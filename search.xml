<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇</title>
    <url>/2021/02/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="你知道ma"><a href="#你知道ma" class="headerlink" title="你知道ma"></a>你知道ma</h1><a id="more"></a>

<h2 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h2><p><a href="https://www.baidu.com/">百度</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组与稀疏数组</title>
    <url>/2021/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组与稀疏数组之间的转变说明（图）"><a href="#二维数组与稀疏数组之间的转变说明（图）" class="headerlink" title="二维数组与稀疏数组之间的转变说明（图）"></a>二维数组与稀疏数组之间的转变说明（图）</h1><a id="more"></a>

<p>​    <a href="https://imgtu.com/i/6EUbLD"><img src="https://s3.ax1x.com/2021/03/03/6EUbLD.png" alt="6EUbLD.png"></a></p>
<p><a href="https://imgtu.com/i/6EdVBD"><img src="https://s3.ax1x.com/2021/03/03/6EdVBD.png" alt="6EdVBD.png"></a></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="二维数组转变成稀疏数组"><a href="#二维数组转变成稀疏数组" class="headerlink" title="二维数组转变成稀疏数组"></a>二维数组转变成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 二维数组</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arrayToSparse(<span class="keyword">int</span> array[][]) &#123;</span><br><span class="line">        <span class="comment">//获取二维数组中值的个数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//稀疏数组的第一行的值分别为 二维数组总行数  二维数组总列数  二维数组中值的个数</span></span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">2</span>] = num;</span><br><span class="line">        <span class="comment">//将二维数组中的值填充到稀疏数组中  二维数组行 二维数组列 二维数组值</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sparse[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparse[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparse[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="稀疏数组转变从二维数组"><a href="#稀疏数组转变从二维数组" class="headerlink" title="稀疏数组转变从二维数组"></a>稀疏数组转变从二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 稀疏数组</span></span><br><span class="line"><span class="comment"> * return : 二维数组</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span> sparse[][]) &#123;</span><br><span class="line">        <span class="comment">//根据稀疏数组的第一行数据创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[sparse[<span class="number">0</span>][<span class="number">0</span>]][sparse[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//将稀疏数组中的值填充到二维数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparse.length;i++)&#123;</span><br><span class="line">            array[sparse[i][<span class="number">0</span>]][sparse[i][<span class="number">1</span>]]=sparse[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="将稀疏数组与本地文件之间在互相转换"><a href="#将稀疏数组与本地文件之间在互相转换" class="headerlink" title="将稀疏数组与本地文件之间在互相转换"></a>将稀疏数组与本地文件之间在互相转换</h1><p> 保存二维数组 ：二维数组 -&gt; 稀疏数组 -&gt; 本地文件</p>
<p> 获取二维数组 :  本地文件 -&gt; 稀疏数组 -&gt; 二维数组</p>
<p>二维数组与稀疏数组之间的转换上面已经写明了，这里主要讲稀疏数组与本地文件的转换，需要用到 java 中的IO操作</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="稀疏数组保存至本地文件"><a href="#稀疏数组保存至本地文件" class="headerlink" title="稀疏数组保存至本地文件"></a>稀疏数组保存至本地文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args1: 稀疏数组  args2: 需要保存文件的地址</span></span><br><span class="line"><span class="comment"> * return : 是否保存成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arraySave</span><span class="params">(<span class="keyword">int</span> sparse[][], String fileName)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter writer = <span class="keyword">new</span> FileWriter(file);<span class="comment">//文件输入流</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparse) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                    writer.write(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="将本地文件转换成稀疏数组"><a href="#将本地文件转换成稀疏数组" class="headerlink" title="将本地文件转换成稀疏数组"></a>将本地文件转换成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 需要读取的文件地址</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getArray(String fileName) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先获取文件的行数</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//根据文件的行数创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse=<span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//再次读取文件，将文件的内容填充到稀疏数组中</span></span><br><span class="line">        reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//获取文件中的每一行数据</span></span><br><span class="line">            String[] temp = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">                sparse[count][i]=Integer.parseInt(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>稀疏数组</tag>
        <tag>io流</tag>
      </tags>
  </entry>
  <entry>
    <title>数组队列与环形队列</title>
    <url>/2021/03/04/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E4%B8%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p> 队列是一个有序列表，可以用数组或是链表来实现。 </p>
<a id="more"></a>

<p> 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 </p>
<p> 示意图：(使用数组模拟队列示意图)</p>
<p><a href="https://imgtu.com/i/6ZdR8s"><img src="https://s3.ax1x.com/2021/03/04/6ZdR8s.png" alt="6ZdR8s.png"></a></p>
<h1 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h1><p>1.队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队 列的最大容量。</p>
<p>2.因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</p>
<p>3.头指针front 指向队列头元素的前一个位置，默认为-1</p>
<p>4.尾指针rear指向队列尾元素， 默认为-1</p>
<p>5.向队列中添加数据时：</p>
<p>​    1). 将尾指针往后移：rear+1</p>
<p>​    2).若尾指针 rear == maxSize - 1  ，表示队列已满，不能再存放数据了</p>
<p>6.向队列弹出一个数据时:</p>
<p>​    1). 将头指针往后移： front+1</p>
<p>​    2).将下标为 front+1 返回即可</p>
<p>​    3).头指针等于尾指针 ，即 front==rear ,则表示该队列为空，不能弹出数据了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//前部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//后部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">this</span>.maxSize=max;</span><br><span class="line">            <span class="keyword">this</span>.rear=-<span class="number">1</span>;<span class="comment">// 指向队列尾部，默认-1</span></span><br><span class="line">            <span class="keyword">this</span>.front=-<span class="number">1</span>;<span class="comment">// 指向队列头部的前一个位置，默认-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            <span class="keyword">this</span>.arr[rear]=data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.front++;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front+<span class="number">1</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;arr[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.arr[front+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析并优化"><a href="#问题分析并优化" class="headerlink" title="问题分析并优化"></a>问题分析并优化</h3><ol>
<li><p>目前数组使用一次就不能用， 没有达到复用的效果 </p>
</li>
<li><p>将这个数组使用算法，改进成一个环形的队列 （取模：%）</p>
</li>
</ol>
<h1 id="环形数组模拟队列"><a href="#环形数组模拟队列" class="headerlink" title="环形数组模拟队列"></a>环形数组模拟队列</h1><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><p>1)对头指针front含义做一个调整：front指向队列的第一个元素，初始值为 0</p>
<p>2)对尾指针rear含义做一个调整：rear指向队列最后一个元素的下一个位置，初始值为 0  ，因为希望空出一个位置作为约定</p>
<p>3)队列满表示为 ：(rear+1)%maxSize==front </p>
<p>4)队列空表示为：rear==front</p>
<p>5)队列中有效的值的个数表示为: (rear+maxSize-front)%maxSize </p>
<p>6)front++   与  rear++   统一写成  (front+1)%maxSize  与  (rear+1)%maxSize  ,因为这是个环形队列，如果front或rear超过数组最大下标则需要从下标0开始添加数据</p>
<p>7)根据原来的队列代码进行修改，就可以得到一个环形队列</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="comment">//指向队列头部 默认为0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">        <span class="comment">//指向队列尾部的后一个位置 默认为0  因为这是一个环形队列，需要预留一个位置作为约定</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            maxSize=max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="comment">//尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为 rear 指向队列尾元素的下一个位置，直接添加，再进行 rear++操作</span></span><br><span class="line">            arr[rear]=data;</span><br><span class="line">            <span class="comment">// 本来这里是 rear++ ，但是这是个环形队列，如果rear超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将队列头元素先保存下来,最后需要返回</span></span><br><span class="line">            <span class="keyword">int</span> result=arr[front];</span><br><span class="line">            <span class="comment">//本来这里是 front++ ，但是这是个环形队列，如果front超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            front=front+<span class="number">1</span>%maxSize;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front;i&lt;front+size();i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;arr[&quot;</span>+i%maxSize+<span class="string">&quot;]=&quot;</span>+arr[i%maxSize]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前队列中的有效个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[front]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试数组队列</span></span><br><span class="line">    	<span class="comment">//Queue queue = new Queue(3);</span></span><br><span class="line">    	<span class="comment">//测试环形数组队列</span></span><br><span class="line">       CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);<span class="comment">//因为需要预留一个位置作为约定, 所以该队列中只能存放3个数据，如需存放4个数据，该算法即可</span></span><br><span class="line">    	</span><br><span class="line">       Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;\na : 添加数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;p : 弹出一个数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;s : 显示队列&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;h : 显示头&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;e : 退出&quot;</span>);</span><br><span class="line">           String key = scanner.next();</span><br><span class="line">           <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                   System.out.println(<span class="string">&quot;请输入值:&quot;</span>);</span><br><span class="line">                   <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">                   queue.add(i);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;p&quot;</span>:</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> pop = queue.pop();</span><br><span class="line">                       System.out.println(<span class="string">&quot;弹出值为:&quot;</span>+pop);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       System.out.println(e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                   queue.showQueue();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;h&quot;</span>:</span><br><span class="line">                   queue.showHead();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       scanner.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题</title>
    <url>/2021/03/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>单向环形链表应用场景：</p>
<p> Josephu(约瑟夫、约瑟夫环) 问题 ：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。</p>
<a id="more"></a> 

<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<h3 id="约瑟夫问题-创建环形链表的思路"><a href="#约瑟夫问题-创建环形链表的思路" class="headerlink" title="约瑟夫问题-创建环形链表的思路:"></a>约瑟夫问题-创建环形链表的思路:</h3><p>1.创建一个节点时，让first节点等于它，并且first.setNext(first)，一个节点也形成环形</p>
<p>2.后面创建新节点时，就把节点加入到环形链表最后，即链表原来最后的节点指向新节点，新节点指向first，又可变成一个环形</p>
<h3 id="约瑟夫问题-小孩出圈的思路分析"><a href="#约瑟夫问题-小孩出圈的思路分析" class="headerlink" title="约瑟夫问题-小孩出圈的思路分析:"></a>约瑟夫问题-小孩出圈的思路分析:</h3><p>用户需要穿入3个数据(startNo:从 startNo 个节点开始数， count:  数 num 下， size: 圈中一共有多少个节点)</p>
<p>1.创建一个辅助指针 helper ，事先指向链表的最后一个节点，即first的前面，因为是单向链表，只能通过遍历来完成，直到 helper.getNext()=first</p>
<p>2.报数之前，先让first与helper移动 startNo -1 次，因为是从startNo开始报数的</p>
<p>3.循环遍历数时，每次报数让 first与helper移动 count-1 次(自己也要报一次数)，这是将first指向的节点出圈</p>
<p>4.出圈为 ： first=first.next      helpser.next=first</p>
<p>5.直到first==helper，循环才可结束，这时链表中只有一个节点，first与helper同时指向它</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码:"></a>实现代码:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环形单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boy first; <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 根据传入的数据创建size个节点的环形单链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoys</span><span class="params">(Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建失败:请传入不小于1的数！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针，指向新添加的节点，即最后的一个节点</span></span><br><span class="line">        boy currBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">            boy boy = <span class="keyword">new</span> boy(i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//第一个节点</span></span><br><span class="line">                first=boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                currBoy=first;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currBoy.setNext(boy); <span class="comment">//原来最后的节点指向新节点</span></span><br><span class="line">                boy.setNext(first);  <span class="comment">//新节点指向first</span></span><br><span class="line">                currBoy=boy;		</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历环形单链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        boy currBoy=first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(currBoy.getId()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currBoy.getNext()==first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currBoy=currBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出圈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从 startNo 个节点开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  数 num 下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 圈中一共有多少个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Integer startNo,Integer count,Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first ==<span class="keyword">null</span> || startNo&lt;<span class="number">1</span> || startNo&gt;size || count&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据有问题，请重试！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个helper指针，指向first之前的位置</span></span><br><span class="line">        boy helper=first;</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext()!=first) &#123;</span><br><span class="line">          helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将helper与first移动到 startNo 位置 ，移动 startNo-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startNo-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备就绪，开始出圈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper==first)&#123; <span class="comment">//表示只有一个数据了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count-<span class="number">1</span>;i++)&#123; <span class="comment">//移动count-1次</span></span><br><span class="line">                first=first.getNext();</span><br><span class="line">                helper=helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(first.getId()+<span class="string">&quot;--》&quot;</span>);</span><br><span class="line">            <span class="comment">//将当前first指向的节点出圈</span></span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后保留的数据:&quot;</span>+first.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">boy</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表与双向链表</title>
    <url>/2021/03/06/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>​     链表是以节点的方式来存储,是链式存储 ， 每个节点包含 data 域， next 域：指向下一个节点.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定,这里主要介绍带头节点的链表</p>
<a id="more"></a>

<h1 id="使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"><a href="#使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作" class="headerlink" title="使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"></a>使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作</h1><ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部 </p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6uwseI"><img src="https://s3.ax1x.com/2021/03/06/6uwseI.png" alt="6uwseI.png"></a></p>
<ol start="3">
<li>修改节点功能, 思路:</li>
</ol>
<p>​                (1) 通过遍历,先找到该节点,直接修改数据即可</p>
<p>​                (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p>
<ol start="4">
<li>删除节点 ，思路分析的示意图</li>
</ol>
<p><a href="https://imgtu.com/i/6uwgFf"><img src="https://s3.ax1x.com/2021/03/06/6uwgFf.png" alt="6uwgFf.png"></a></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer no;  <span class="comment">//序号</span></span><br><span class="line">    String name;    <span class="comment">//名称</span></span><br><span class="line">    String nickName;    <span class="comment">//昵称</span></span><br><span class="line">    Node next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&#x27;&quot;</span> + no + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加  找到最后一个节点，将新节点添加到链表的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照序号进行添加  根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//标记新节点序号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;node.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==node.no)&#123; <span class="comment">//该序号已存在，则无法插入</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该节点序号已存在，添加数据失败！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next=temp.next;</span><br><span class="line">            temp.next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表所有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;<span class="comment">//循环遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改  根据序号进行修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要修改的节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.no==node.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=node.name;</span><br><span class="line">            temp.nickName= node.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功:&quot;</span>+temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+node.no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除 根据序号进行删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该序号</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功序号为‘&quot;</span>+no+<span class="string">&quot;’节点&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="一些单项链表常见面试题"><a href="#一些单项链表常见面试题" class="headerlink" title="一些单项链表常见面试题"></a>一些单项链表常见面试题</h3><ol>
<li>求单链表中有效节点的个数,代码演示(easy):</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;<span class="comment">//循环遍历</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查找单链表中的倒数第 k 个结点  代码演示:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 列表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 倒数第 index 个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第index个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLastIndexNode</span><span class="params">(Node head,Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遍历，获取该链表有效节点</span></span><br><span class="line">        Integer size=getLength(head);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span> || index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历，遍历 (size-index)次</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(size-index);i++)&#123;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>单链表的反转 采用头插法</li>
</ol>
<p>思路分析：1.先创建一个头节点，暂时存放反转节点   Node reverseHead=new Node(0,””,””);</p>
<p>​                   2.循环遍历原来的链表，每遍历一遍，就把当前的节点转移到临时头节点  reverseHead的最前面</p>
<p>​                            curr.next=reverseHead.next;      reverseHead.next=curr;</p>
<p>​                   3.遍历完毕后原来的头节点后的节点全部反转到临时头节点 reverseHead后面，直接将原来头节点指向临时头节点之后的节点即可           head.next=reverseHead.next</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//当链表为空或只有一个节点，无需反转</span></span><br><span class="line">       <span class="keyword">if</span>(head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//暂时存放反转节点的节点头</span></span><br><span class="line">       Node reverseHead=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       Node curr=head.next;<span class="comment">//需要转移到到reverseList头部的节点</span></span><br><span class="line">       Node next=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           next=curr.next;</span><br><span class="line">           <span class="comment">//开始转移</span></span><br><span class="line">           curr.next=reverseHead.next;</span><br><span class="line">           reverseHead.next=curr;</span><br><span class="line">           curr=next;</span><br><span class="line">       &#125;</span><br><span class="line">       head.next=reverseHead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>从尾到头打印单链表 【要求方式 1：反向遍历 。 方式 2：Stack 栈】</li>
</ol>
<p>方法一:先反转链表，再遍历打印 （这样改变了链表原来的结构，不推荐，即使再次反转过来也很浪费时间）<br>方法二:将链表的数据全部放入栈中，再遍历栈取出数据，这样不会改变链表原来的结构（这里暂时使用java中的stack，不手写栈了）</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环遍历将链表的数据放入栈中</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历打印栈的数据</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
</ol>
<p>思路分析: </p>
<p>1.如果两个链表全部空则返回空；如果list1为空，返回list2；如果list2为空，返回list1</p>
<p>2.新建一个链表list用来存放合并list1与list2合并后的数据</p>
<p>3.同时遍历list1与list2，每一次比较list1当前节点与list2当前节点，谁更小就转移到list最后 (转移节点可参考问题三:链表的反转)</p>
<p>4.如果list1为空了，则把list2中的数据全部转移到list最后；如果list2空了，则把list1中的数据全部转移到list最后</p>
<p>注意: 可添加一个新的指针来标识list中新插入的节点位置</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的单链表，合并之后的链表依然有序 ,如果链表中的有两个序号相同，默认先取 list1 中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">merge</span><span class="params">(SingleLinkedList list1,SingleLinkedList list2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span> &amp;&amp; list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        SingleLinkedList list = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//记录当前插入的节点</span></span><br><span class="line">        Node newNode=list.getHead();</span><br><span class="line">        <span class="comment">//标志list1暂时需要转移的节点</span></span><br><span class="line">        Node curr1=list1.getHead().next;</span><br><span class="line">        <span class="comment">//记录curr1的下一个节点</span></span><br><span class="line">        Node next1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//标志list2暂时需要转移的节点</span></span><br><span class="line">        Node curr2=list2.getHead().next;</span><br><span class="line">        <span class="comment">//记录list2的下一个节点</span></span><br><span class="line">        Node next2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr1==<span class="keyword">null</span>)&#123;<span class="comment">//list1合并完毕,可将curr2中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr2==<span class="keyword">null</span>)&#123;<span class="comment">//list2合并完毕，可将curr1中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next1=curr1.next;</span><br><span class="line">            next2=curr2.next;</span><br><span class="line">            <span class="keyword">if</span>(curr1.no&lt;=curr2.no)&#123; <span class="comment">//添加curr1</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr1=next1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//添加curr2</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr2=next2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用带-head-头的双向链表实现-–水浒英雄排行榜"><a href="#使用带-head-头的双向链表实现-–水浒英雄排行榜" class="headerlink" title="使用带 head 头的双向链表实现 –水浒英雄排行榜"></a>使用带 head 头的双向链表实现 –水浒英雄排行榜</h1><p>管理单向链表的缺点分析:</p>
<p>​                 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p>
<p>​                 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，前面我们单链表删除 时节点，总是找到待删除节点的前一个节点.</p>
<p>双向链表的遍历与修改与单链表一样，添加与删除方法略有不同</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点需要新增一个值</span></span><br><span class="line">DoubleNode pre; <span class="comment">//指向前一个结点</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 添加再链表最后位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">        DoubleNode temp = head;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行添加</span></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        newNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序进行添加 根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">            DoubleNode temp=head;</span><br><span class="line">            <span class="comment">//标记新节点是否存在</span></span><br><span class="line">            <span class="keyword">boolean</span> exist=<span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//标记新节点是否插入到最后</span></span><br><span class="line">            <span class="keyword">boolean</span> last=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;<span class="comment">//表示新节点序号最大，需要插入到最后</span></span><br><span class="line">                    last=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no&gt; newNode.no)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no== newNode.no)&#123;<span class="comment">//表示新节点序号已存在</span></span><br><span class="line">                    exist=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入失败:该节点序号‘&quot;</span>+newNode.no+<span class="string">&quot;’已存在！！！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(last)&#123; <span class="comment">//插入到最后</span></span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//表示后一个节点</span></span><br><span class="line">                    DoubleNode rear = temp.next;</span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.next=rear;</span><br><span class="line">                    rear.pre=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 无需像单链表一样找到要删除的前一个节点，直接找到需要删除的节点，就可执行自我删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找序号为no的节点</span></span><br><span class="line">        DoubleNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;<span class="comment">//找到该节点,进行自我删除</span></span><br><span class="line">                temp.pre.next = temp.next;<span class="comment">//让temp前一个节点指向temp的后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next!=<span class="keyword">null</span>) &#123; <span class="comment">//如果temp的后一个节点为空，则会有空控制在异常</span></span><br><span class="line">                    temp.next.pre = temp.pre;<span class="comment">//让temp的后一个节点指向temp的前一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败:没找到序号为‘&quot;</span> + no + <span class="string">&quot;’的节点&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/03/06/%E6%A0%88/</url>
    <content><![CDATA[<p> 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除</p>
<a id="more"></a>

<h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><ol>
<li><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。</p>
</li>
<li><p>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。</p>
</li>
<li><p>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
</li>
<li><p>二叉树的遍历。</p>
</li>
<li><p>图形的深度优先(depth 一 first)搜索法。</p>
</li>
</ol>
<h3 id="用数组模拟栈的使用"><a href="#用数组模拟栈的使用" class="headerlink" title="用数组模拟栈的使用"></a>用数组模拟栈的使用</h3><p>思路 : </p>
<p>1.定义一个top表示栈顶,初始值为-1</p>
<p>2.入栈操作: top++;   stack[top]=data;</p>
<p>3.出栈操作: int val=stack[top];    top–;    return val;</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">int</span> [] stack; <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶，默认-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize=maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        <span class="keyword">this</span>.top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败:栈满~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历显示栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;stack[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+stack[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表模拟栈的使用-采用有头单项链表"><a href="#用链表模拟栈的使用-采用有头单项链表" class="headerlink" title="用链表模拟栈的使用,采用有头单项链表"></a>用链表模拟栈的使用,采用有头单项链表</h3><p>思路:</p>
<p>1.压栈：放入链表的第一个位置     newNode.next=head.next;      head.next=newNode;</p>
<p>2.弹栈：取链表的第一个节点      Node oldFirst = head.next;    head.next=head.next.next;   return oldFirst.data;</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈 采用头差法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        newNode.next=head.next;</span><br><span class="line">        head.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈 头取法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        head.next=head.next.next;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历栈失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器</title>
    <url>/2021/03/07/%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<p>栈实现一个中缀表达式计算器和一个后缀表达式计算器</p>
<a id="more"></a>

<h3 id="中缀表达式计算器"><a href="#中缀表达式计算器" class="headerlink" title="中缀表达式计算器"></a>中缀表达式计算器</h3><h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------再栈中补充以下代码,方便后续操作-------------------------------------	</span></span><br><span class="line"><span class="comment">//瞄一眼栈顶的数据，不是弹栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回运算符的优先级，越大优先级越高  假设只有 加减乘除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&#x27;*&#x27;</span> || oper==<span class="string">&#x27;/&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper==<span class="string">&#x27;+&#x27;</span> || oper==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他无效字符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span> || val==<span class="string">&#x27;-&#x27;</span> || val==<span class="string">&#x27;*&#x27;</span> || val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num2+num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num2*num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(num1==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式实现思路分析"><a href="#中缀表达式实现思路分析" class="headerlink" title="中缀表达式实现思路分析:"></a>中缀表达式实现思路分析:</h4><p>1.创建两个栈，一个用来存放数字numStack，一个用来存放运算符operStack</p>
<p>2.用一个指针index遍历需要计算的表达式，初始值为0</p>
<p>3.遍历如果发现是index指向的是数字就直接存入数栈</p>
<p>4.如果是运算符则需要一下判断:如果符号栈为空或当前运算符的优先级大于栈顶运算符的优先级，则可以直接将当前运算符入栈；</p>
<p>如果当前运算符优先级小于或等于栈顶运算符优先级，则需将符号栈栈顶的运算符弹出，将数栈的前两位数值弹出，进行运算，将结果放入数栈中，当前运算符放入符号栈</p>
<p>5.遍历完毕后继续遍历两个栈中剩下的数据，取出数栈的两个值，符号栈一个符号继续进行运算，将结果放入数栈，直到符号栈空</p>
<p>6.此时数栈只有一个数值，该值就是运算结果</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题:"></a>存在问题:</h5><p>上面思路只能解决一位数的计算，如果要多位数，则需一下改进:</p>
<ol>
<li>创建一个字符串chs，用来拼接多位数</li>
<li>数值压入数栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是就不能入栈，继续扫描，直到下一位是运算符才能入栈</li>
</ol>
<h5 id="实现计算器代码"><a href="#实现计算器代码" class="headerlink" title="实现计算器代码"></a>实现计算器代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算该表达式</span></span><br><span class="line">        String expression = <span class="string">&quot;7*2*2-5+16-5+3-4&quot;</span>; <span class="comment">//33</span></span><br><span class="line">        <span class="comment">//String expression=&quot;10+12*2-10&quot;;</span></span><br><span class="line">        <span class="comment">//用于存放 数字的栈</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于存放运算符的栈</span></span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">//第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">//第二个数字</span></span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;<span class="comment">//运算符</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//运算结果</span></span><br><span class="line">        <span class="keyword">char</span> ch;<span class="comment">//将每次扫描得到 char 保存到 ch</span></span><br><span class="line">        String chs=<span class="string">&quot;&quot;</span>;<span class="comment">//用来拼接多位数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//一个一个字符扫描</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是表达式</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//是表达式</span></span><br><span class="line">                <span class="comment">//判断 operStack 是否空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123; <span class="comment">//不空,不能直接将表达式压栈，需要判断</span></span><br><span class="line">                    <span class="comment">//如果当前表达式优先级小于或等于栈顶的表达式的优先级，则需要将栈顶的表达式取出，还需取出数值栈中的前两个数字，进行运算</span></span><br><span class="line">                    <span class="comment">//运算完毕将结果压入数值栈中，将当前表达式压入表达式栈中</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peekTop()))&#123;</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        <span class="comment">//进行运算</span></span><br><span class="line">                        result = operStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//空，直接将表达式压栈即可</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是表达式,即数字,将数字直接压入数值栈中(注:当前ch是字符,如果ch=&#x27;1&#x27;,转换成数字等于49,如果ch=&#x27;2&#x27;,转换成数字等于50,之间相差48)</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);</span></span><br><span class="line">                <span class="comment">//上面写法只能处理一位数的运算，如果需要多位数的运算，需要改进</span></span><br><span class="line">                <span class="comment">//思路:数值压入数值栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是则不能入栈，继续扫描，直到下一位是运算符才能入栈</span></span><br><span class="line">                chs += ch;<span class="comment">//拼接多位数</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;<span class="comment">//如果已经是最后一位数，可以直接入数栈</span></span><br><span class="line">                    numStack.push(Integer.parseInt(chs));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123; <span class="comment">//下一位是运算符，可以直接入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(chs));</span><br><span class="line">                        <span class="comment">//入栈后需清空chs</span></span><br><span class="line">                        chs=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描完毕,将栈中剩余的值计算掉,计算完毕后运算符栈中没有数据,但是数值栈中还有一个值，就是结果</span></span><br><span class="line">        <span class="keyword">while</span>(!operStack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            <span class="comment">//进行运算</span></span><br><span class="line">            result = operStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;运算结果为:&quot;</span>+numStack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>中缀表达式不利于计算机的计算，所以这里再实现一个后缀表达式计算器</p>
<h3 id="后缀表达式计算器"><a href="#后缀表达式计算器" class="headerlink" title="后缀表达式计算器"></a>后缀表达式计算器</h3><p>因为这里主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算</p>
<p>步骤: 中缀表达式 ==&gt; 中缀表达式list ==&gt; 后缀表达式list ==》 计算后缀表达式list ==》 结果</p>
<h4 id="将中缀表达式中的每一个值放入list集合中（方便后续计算）"><a href="#将中缀表达式中的每一个值放入list集合中（方便后续计算）" class="headerlink" title="将中缀表达式中的每一个值放入list集合中（方便后续计算）"></a>将中缀表达式中的每一个值放入list集合中（方便后续计算）</h4><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个指针index，用来遍历表达式；创建一个list集合，用来存放数据</p>
<p>2.循环遍历如果当前值不是数字，直接放入list集合中    (ch = s.charAt(index)) &lt; 48 || (ch = s.charAt(index)) &gt; 57  （字符0-9的十进制ASCII码为48-57）</p>
<p>3.如果当前值是数字，则需要考虑多位数 </p>
<p>4.遍历结束，直接将list集合返回即可</p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将中缀表达式放入到list中   13+8*6+2*5-(2+1) ==&gt; list[13,+,8,*,6,+,2,*,5,-,(,2,+,1,)]</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixExpressionBeList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//扫描指针</span></span><br><span class="line">       <span class="keyword">char</span> ch;<span class="comment">//表示每一个字符</span></span><br><span class="line">       String chs = <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> ((ch = s.charAt(index)) &lt; <span class="number">48</span> || (ch = s.charAt(index)) &gt; <span class="number">57</span>) &#123; <span class="comment">//表示不是数字，直接放入list中即可</span></span><br><span class="line">               list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//是数字,则需要考虑多位数</span></span><br><span class="line">               chs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; (ch = s.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = s.charAt(index)) &lt;= <span class="number">57</span>) &#123; <span class="comment">//属于0-9</span></span><br><span class="line">                   chs += ch;</span><br><span class="line">                   index++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//循环结束表示当前 s.charAt(index) 不是一个数字，chs中是个单位数或多位数</span></span><br><span class="line">               list.add(chs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (index &lt; s.length());<span class="comment">//表示扫描完毕</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将中缀表达式转换成后缀表达式（重难点）"><a href="#将中缀表达式转换成后缀表达式（重难点）" class="headerlink" title="将中缀表达式转换成后缀表达式（重难点）"></a>将中缀表达式转换成后缀表达式（重难点）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2</p>
<p>2.遍历中缀表达式</p>
<p>3.遇到数字时，将其压 s2</p>
<p>4.遇到运算符时，需要进行以下判断：</p>
<p>​            （1）.如果是左括号”(“,直接将此运算符入栈</p>
<p>​            （2）.如果是右括号”)”,则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，并将左括号弹出，此时这一对括号丢弃</p>
<p>​            （3）.如果 s1 为空，直接将此运算符入栈            </p>
<p>​            （4）.如果当前运算符优先级 &gt; 栈顶运算符优先级，也将运算符压入 s1；</p>
<p>​            （5）.如果当前运算符优先级 &lt;= 栈顶运算符优先级,将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(3)(4)进行比较；</p>
<p>5.遍历结束，将s1剩余的运算符依次弹出并压入到s2中，直到s1为空</p>
<p>6.此时s2中保存的数据就是转换后的后缀表达式的逆序</p>
<p>注:因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list集合代替s2,最后直接返回即可</p>
<h5 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式list转化成后缀表达式list(难点)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">       Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//存放运算符的栈</span></span><br><span class="line">       <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;&gt;();//存放数字以及结果的栈</span></span><br><span class="line">       <span class="comment">//因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list代替s2,最后直接返回即可</span></span><br><span class="line">       List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//遍历中缀表达式list</span></span><br><span class="line">       <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">           <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//数字直接存放到s2</span></span><br><span class="line">               s2.add(item);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123; <span class="comment">//item为符号，需要判断</span></span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;(&quot;</span>.equals(item))&#123; <span class="comment">//item为左括号，直接放入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;)&quot;</span>.equals(item))&#123; <span class="comment">//item为右括号，需要将符号栈中的符号转入到s2集合中，直到找到左括号为止，并将左括号弹出，这样就能消除一对括号</span></span><br><span class="line">                   <span class="keyword">while</span>(!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示s1栈顶是一个左括号，将它弹出即可，右括号也无需保存</span></span><br><span class="line">                   s1.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前运算符优先级小于符号栈栈顶优先级，需要将栈顶符号转入list中，再重新判断，否则可直接入符号栈，</span></span><br><span class="line">                   <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item)) &#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示当前运算符高于栈顶运算符，或符号栈为空，将当前符号直接入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，还需将符号栈剩余的符号全部依次转入list集合中</span></span><br><span class="line">       <span class="keyword">while</span>(s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           s2.add(s1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将后缀表达式进行计算（比中缀表达式计算简单的多）"><a href="#将后缀表达式进行计算（比中缀表达式计算简单的多）" class="headerlink" title="将后缀表达式进行计算（比中缀表达式计算简单的多）"></a>将后缀表达式进行计算（比中缀表达式计算简单的多）</h4><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个栈用来存放数值</p>
<p>2.遍历 list 集合，如果是数值则放入栈中，如果是运算符则从栈中弹出两个数进行运算，将结果压入栈中</p>
<p>3.遍历结束后栈中只有一个值，该值就是运算结果</p>
<h5 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//正则表达式判断是否为数字</span></span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不是数字</span></span><br><span class="line">                num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">switch</span> (s) &#123;  <span class="comment">//进行运算</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = num2 + num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = num2 - num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = num2 * num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (num1 == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:被除数不能为0!!!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = num2 / num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:运算符错误!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果放回栈中</span></span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中只有一个数据，就是运算结果，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>计算器</tag>
        <tag>中缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2021/03/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八皇后问题介绍 ：</p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的</p>
<a id="more"></a>

<p>国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。</p>
<h4 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h4><ol>
<li><p>第一个皇后先放第一行第一列</p>
</li>
<li><p>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 </p>
</li>
<li><p>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 </p>
</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解， 全部得到. </p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
<li><p>示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6lgytg"><img src="https://s3.ax1x.com/2021/03/08/6lgytg.png" alt="6lgytg.png"></a></p>
<p>说明：</p>
<p> 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. （注:下标是从0开始）</p>
<p>map[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 map 下标 表示第几行，即第几个皇后，map[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘 ，一维数组</span></span><br><span class="line">    <span class="comment">//说明:下标表示第几个皇后，也就是第几行，对应的值表示每个皇后所在的列,  例如: map=[0,4,7,5,2,6,1,3]</span></span><br><span class="line">    <span class="comment">//    比如上面的数组表示:第一个皇后在第一行第一列；第二个皇后在第二行第五列，第三个皇后在第三行第八列,第四个皇后在第四行第六列。。。。。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//总共解法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count2=<span class="number">0</span>;<span class="comment">//总共检查了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queen8 queen = <span class="keyword">new</span> Queen8();</span><br><span class="line">        <span class="comment">//从第一个皇后开始</span></span><br><span class="line">        queen.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有’&quot;</span>+queen.count+<span class="string">&quot;‘解法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共检查了’&quot;</span>+queen.count2+<span class="string">&quot;‘次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摆放皇后,从第n个皇后开始摆放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">8</span>)&#123;<span class="comment">//该摆放第9个皇后了，表示第八个皇后已摆放好</span></span><br><span class="line">            print();<span class="comment">//打印结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始放，直到第8列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放皇后 n 到 i 上</span></span><br><span class="line">            map[n]=i;</span><br><span class="line">            <span class="comment">//检查n皇后是否摆放正确</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;<span class="comment">//如果正确，递归，开始摆放下一个皇后</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查当前第n个皇后是否摆放正确</span></span><br><span class="line">    <span class="comment">//从n皇后之前的所有皇后进行遍历检查</span></span><br><span class="line">    <span class="comment">// map[i]==map[n] 表示在同一列</span></span><br><span class="line">    <span class="comment">// Math.abs(n-i)==Math.abs(map[n]-map[i] 表示在同一斜线--- 如果在同一斜线这两个坐标显示为一个等腰三角形，而等腰三角形两边相等，注意要取绝对值再判断~~自行体会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放错误</span></span><br><span class="line">            <span class="keyword">if</span>(map[i]==map[n] || Math.abs(n-i)==Math.abs(map[n]-map[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++)&#123;</span><br><span class="line">            System.out.print(map[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>八皇后</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫回溯</title>
    <url>/2021/03/08/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p>运用递归方法给小球找一条路能让小球到出口</p>
<a id="more"></a>

<p>思路:全在代码里，自行体会</p>
<p><a href="https://imgtu.com/i/6l6JHO"><img src="https://s3.ax1x.com/2021/03/08/6l6JHO.png" alt="6l6JHO.png"></a></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试给地图找路&quot;</span>);</span><br><span class="line">        <span class="comment">//创建地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = MiGong.createMap();</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//给地图找条路,从(1,1)开始出发</span></span><br><span class="line">        <span class="keyword">boolean</span> isOk = MiGong.setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(isOk?<span class="string">&quot;正确通过&quot;</span>:<span class="string">&quot;此路不通&quot;</span>);</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用递归方式给地图找路</span></span><br><span class="line">    <span class="comment">// 约定:1.  0表示还没走的路；1表示墙；2表示通路可以走；3表示该路走过，但走不通</span></span><br><span class="line">    <span class="comment">//     2.   在走迷宫时定义一条策略(方法):下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">    <span class="comment">//     3.   地图入口为 (i,j) ，出口为 (6,5)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;<span class="comment">//出口走过，表示走通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            map[i][j]=<span class="number">2</span>; <span class="comment">//先默认该路可走</span></span><br><span class="line">            <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//表示该路走不通</span></span><br><span class="line">                map[i][j]=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果map[i][j]= 1、2、3 都不继续玩下走</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建小地图   地图为8行7列大小，1表示墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] createMap()&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置个障碍</span></span><br><span class="line"><span class="comment">//        map[1][2]=1;</span></span><br><span class="line"><span class="comment">//        map[2][2]=1;</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span> <span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/03/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<p>排序的分类:  内部排序，指将需要处理的所有数据都加载到内部存储器(内存)中进行排序 ；外部排序法， 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。</p>
<p> 常见的排序算法分类(见右图):</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/68rGTS"><img src="https://s3.ax1x.com/2021/03/09/68rGTS.png" alt="68rGTS.png"></a></p>
<h2 id="冒泡排序（bubble-sorting）"><a href="#冒泡排序（bubble-sorting）" class="headerlink" title="冒泡排序（bubble sorting）"></a>冒泡排序（bubble sorting）</h2><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<p>优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果哪一趟排序没有交换，就代表数组已经有序了，直接退出即可</span></span><br><span class="line">        <span class="keyword">boolean</span> isExchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//用于交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//总共进行 length-1 次排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//将当前数据与下一位数据比较</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isExchange = <span class="keyword">true</span>; <span class="comment">//标记交换了</span></span><br><span class="line">                    <span class="comment">//进行交换</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            <span class="comment">//小小优化</span></span><br><span class="line">            <span class="keyword">if</span> (isExchange) &#123;</span><br><span class="line">                isExchange = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//没有交换，数组已经有序了，直接退出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="选择排序（select-sorting）"><a href="#选择排序（select-sorting）" class="headerlink" title="选择排序（select sorting）"></a>选择排序（select sorting）</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/68s139"><img src="https://s3.ax1x.com/2021/03/09/68s139.png" alt="68s139.png"></a></p>
<p>1.一共排序 （数组大小-1）次</p>
<p>2.每一轮排序，又是一个循环，循环规则:</p>
<p>​    2.1 先假定当前这个数是最小值，并记录下标</p>
<p>​    2.2 然后与后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到该最小数的下标</p>
<p>​    2.3 遍历结束就可以得到最小数以及下标</p>
<p>​    2.4 交换，将最小数放入循环刚开始的位置</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//存放最小值，默认最小值为 arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="comment">//存放最小值下标，默认最小值下标为 i</span></span><br><span class="line">            <span class="keyword">int</span> minIndex=i;</span><br><span class="line">            <span class="comment">//每一次与后一位数比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="comment">//如果min大于后面的数，则在min中放后一位数，minIndex也放后一位数的下标</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;</span><br><span class="line">                    minIndex=j;   <span class="comment">//更换最小值下标</span></span><br><span class="line">                    min=arr[j];   <span class="comment">//更换最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，min存放的值为最小值，minIndex是最小值下标，进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;  <span class="comment">//优化: minIndex==i表示最小值下标没更换，即 arr[i] 已经是最小值，没必要交换</span></span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入排序（insert-sorting）"><a href="#插入排序（insert-sorting）" class="headerlink" title="插入排序（insert sorting）"></a>插入排序（insert sorting）</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本思想：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><a href="https://imgtu.com/i/68yla8"><img src="https://s3.ax1x.com/2021/03/09/68yla8.png" alt="68yla8.png"></a></p>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;<span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">int</span> insertVal=<span class="number">0</span>;  <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">        <span class="keyword">int</span> insertBeforeIndex=<span class="number">0</span>; <span class="comment">//记录当前正在排序的值的前一个下标</span></span><br><span class="line">        <span class="comment">//将数组分成两份，一份为已排好序，默认一个数，一份为没排序，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertVal=arr[i];</span><br><span class="line">            insertBeforeIndex=i-<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//如果insertBeforeIndex指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">            <span class="keyword">while</span>(insertBeforeIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertBeforeIndex])&#123;</span><br><span class="line">                <span class="comment">//将前一个值后移一位</span></span><br><span class="line">                arr[insertBeforeIndex+<span class="number">1</span>]=arr[insertBeforeIndex];</span><br><span class="line">                insertBeforeIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，insertBeforeIndex+1 表示当前正在排序的值该插入的位置</span></span><br><span class="line">            arr[insertBeforeIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+i+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h2><p>简单插入排序存在的问题 </p>
<p>我们看简单的插入排序可能存在的问题. 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), </p>
<p>这样的过程是： </p>
<p>{2,3,4,5,6,6}  ==》 {2,3,4,5,5,6}  ==》  {2,3,4,4,5,6}   ==》 {2,3,3,4,5,6}  ==》  {2,2,3,4,5,6}  ==》  {1,2,3,4,5,6} </p>
<p>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p>希尔排序法的示意图:</p>
<p><a href="https://imgtu.com/i/686Xc9"><img src="https://s3.ax1x.com/2021/03/09/686Xc9.png" alt="686Xc9.png"></a></p>
<p><a href="https://imgtu.com/i/68cS76"><img src="https://s3.ax1x.com/2021/03/09/68cS76.png" alt="68cS76.png"></a></p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用交换法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 : 交换法     （不是说升级版吗？怎么感觉不太行。。。尴尬了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//存放临时变量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123; <span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123; <span class="comment">// 如果当前值大于当前值下标加步长的值，则交换位置</span></span><br><span class="line">                        temp=arr[j+gap];</span><br><span class="line">                        arr[j+gap]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(++count)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用移动法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种排序:移动法（真正的希尔排序，利用插入法原则，每一轮排序调整大小时不需要直接交换，而是向后移位，直到最后的位置才交换）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellPlus</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;<span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">               <span class="keyword">int</span> j=i; <span class="comment">//记录当前正在排序的值需要插入的位置 ，每次循环减步长gap</span></span><br><span class="line">               <span class="keyword">int</span> temp=arr[j]; <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="keyword">while</span>((j-gap)&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-gap])&#123; <span class="comment">//如果(j-gap)指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">                       <span class="comment">//前面的值向后移一位(步长位)</span></span><br><span class="line">                       arr[j]=arr[j-gap];</span><br><span class="line">                       <span class="comment">//j指向的下标向前移一位(步长位)</span></span><br><span class="line">                       j-=gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，j所指向的下标就是当前排序的值需要插入的地方</span></span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//不走if语句说明当前值不小于前一位的值(前一个步长位的值)，没必要继续走下去，否则，还需循环判断下面的值是否还小于</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+(++count)+<span class="string">&quot;趟排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（quick-sort）"><a href="#快速排序（quick-sort）" class="headerlink" title="快速排序（quick sort）"></a>快速排序（quick sort）</h3><p>是对冒泡排序的一种改进。</p>
<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.把数组中的一个数当作基准书,一般会把数组中最左边的数当作基准数</p>
<p>2.从两边开始检索，如果是最左边的数是基准数就从右边开始检索，否则从左边开始检索，</p>
<p>从右边开始检索，如果找到比基准数小的数时，停下，再从右边开始检索，如果找到比基准数大的数时，也停下，交换左右两边指向的数，然后继续检索。。</p>
<p>3.当左右两边指针相遇，就停止检索，交换基准数和当前的位置</p>
<p>4.递归上面代码 继续排序数组左边的元素</p>
<p>5.递归上面代码 继续排序数组右边的元素</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6YAm60"><img src="https://s3.ax1x.com/2021/03/10/6YAm60.png" alt="6YAm60.png"></a></p>
<h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123; <span class="comment">//出口  排序到最后面只有一个值时，就会执行该语句</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> temp=<span class="number">0</span>;  <span class="comment">//存放交换时的临时变量</span></span><br><span class="line">       <span class="keyword">int</span> base=arr[left]; <span class="comment">//基数，默认选每一组数的第一个元素</span></span><br><span class="line">       <span class="keyword">int</span> l=left;  <span class="comment">//左指针，从数组头开始</span></span><br><span class="line">       <span class="keyword">int</span> r=right; <span class="comment">//右指针，从数组尾开始</span></span><br><span class="line">       <span class="comment">//左右指针开始移动进行排序，因为 基数是最左边的元素，所以从右边开始索引，否则从左边开始索引</span></span><br><span class="line">       <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">           <span class="comment">//如果右指针的数据小于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span>(arr[r] &gt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               r--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果左指针的数据大于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两边指针都停止，交换两边指针所指向的值</span></span><br><span class="line">           temp=arr[r];</span><br><span class="line">           arr[r]=arr[l];</span><br><span class="line">           arr[l]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// l==i 时, 退出循环,说明当前指向的位置是基数该放的位置，将当前值与计算交换即可</span></span><br><span class="line">       arr[left]=arr[l];</span><br><span class="line">       arr[l]=base;</span><br><span class="line">       <span class="comment">//继续排序数组左边的元素</span></span><br><span class="line">       quick(arr,left,l-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//继续排序数组右边的元素</span></span><br><span class="line">       quick(arr,r+<span class="number">1</span>,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p>
<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><p>分简单，重点是治(合)</p>
<p>总体思路图:</p>
<p><a href="https://imgtu.com/i/6YA5NQ"><img src="https://s3.ax1x.com/2021/03/10/6YA5NQ.png" alt="6YA5NQ.png"></a></p>
<p>合并相邻有序子序列: </p>
<p>治阶段，我们需要将两个已经有序的子序列合并成一个有序序列</p>
<p>1.创建一个temp数组保存临时排序数据</p>
<p>2.相邻有序子序列都从左到右开始遍历，并进行比较，那个小就 先加入到temp临时数组中</p>
<p>3.当其中一组子序列遍历完毕，就可将另一组子序列全部放入temp中</p>
<p>4.此时temp中存放的数据就是这两个有序子序列中的所有值，并且排好序，只需将temp中的值全部导入到相邻序列中</p>
<p><a href="https://imgtu.com/i/6YEMvt"><img src="https://s3.ax1x.com/2021/03/10/6YEMvt.png" alt="6YEMvt.png"></a></p>
<h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分与和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//先从左开始分</span></span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//再从右开始分</span></span><br><span class="line">            mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//进行合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   最左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid    中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  最右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp   暂时存放排序数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一.将数组左右两边的数依次比较，哪个小就把哪个放入临时数组temp中，直到有一组数据遍历完毕</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;  <span class="comment">// 记录临时数组存放位置的指针</span></span><br><span class="line">        <span class="keyword">int</span> l=left;  <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right)&#123;     <span class="comment">//循环结束就表示有一组数据全部填充完毕</span></span><br><span class="line">            <span class="comment">//进行比较判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l]&lt;=arr[r])&#123;   <span class="comment">//将左边的数据填充到 temp中，并 l++; t++;</span></span><br><span class="line">                temp[t]=arr[l];</span><br><span class="line">                l++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t]=arr[r];  <span class="comment">//将右边的数据填充到 temp中，并 r++; t++;</span></span><br><span class="line">                r++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二.将另一组没有遍历完的数据依次放入临时数组中</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到 temp</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123;</span><br><span class="line">            temp[t]=arr[l];</span><br><span class="line">            t++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[r];</span><br><span class="line">            t++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三.将临时数组中的数据导入到arr数组中 ,arr数组中的位置是 left~~right</span></span><br><span class="line">        <span class="keyword">int</span>  j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            arr[i]=temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 </p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 </p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展 </p>
</li>
<li><p>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。</p>
</li>
</ol>
<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>2.这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
<p><a href="https://imgtu.com/i/6YeBrt"><img src="https://s3.ax1x.com/2021/03/10/6YeBrt.png" alt="6YeBrt.png"></a></p>
<p><a href="https://imgtu.com/i/6YeDqP"><img src="https://s3.ax1x.com/2021/03/10/6YeDqP.png" alt="6YeDqP.png"></a></p>
<p><a href="https://imgtu.com/i/6YesVf"><img src="https://s3.ax1x.com/2021/03/10/6YesVf.png" alt="6YesVf.png"></a></p>
<h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先获取数组中最高位的个数,才能判断排序几轮</span></span><br><span class="line">       <span class="comment">//存放该数组中最大的数，默认第一个数最大</span></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(max&lt;arr[i])&#123;</span><br><span class="line">               max=arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxSize=(max+<span class="string">&quot;&quot;</span>).length();<span class="comment">//获取位数</span></span><br><span class="line">       <span class="comment">//创建一个二维数组，二维数组包含10个一维数组，每个一位数组表示一个桶，一维数组存放的数据就是arr存放的需要排序的数据</span></span><br><span class="line">       <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">       <span class="comment">//创建一个一维数组，表示每个桶里有多少个数据，便于后面将数据放回到arr中</span></span><br><span class="line">       <span class="keyword">int</span>[] bucketCount=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,n=<span class="number">1</span>;j&lt;=maxSize;j++,n*=<span class="number">10</span>)&#123; <span class="comment">//共排序maxSize轮,当前第j轮</span></span><br><span class="line">           <span class="comment">//开始排序,将数据放入桶中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">               <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">               <span class="keyword">int</span> digit = arr[i]/n % <span class="number">10</span>;  <span class="comment">//如果n=1，获取个位；n=10，获取十位；n=100，获取百位。。。。判断当前数该放在哪个桶</span></span><br><span class="line">               bucket[digit][bucketCount[digit]]=arr[i];<span class="comment">//放入第digit个桶中第bucketCount[digit]个位置</span></span><br><span class="line">               bucketCount[digit]++;<span class="comment">//该桶中的数量加一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将10个桶中结果依次放回到arr中</span></span><br><span class="line">           <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//指向放入arr中数据的位置</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bucketCount[i]!=<span class="number">0</span>)&#123;<span class="comment">//如果桶中没数据，则跳过该桶</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;bucketCount[i];m++)&#123;<span class="comment">//根据该桶显示的数据循环获取数据，放入arr中</span></span><br><span class="line">                       arr[index++]=bucket[i][m];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，当前桶 i 中的数据全部放回至arr中，需要当前桶需将bucketCount[i]中的数据改为0，表示桶i中没有了数据，为了下一轮的排序</span></span><br><span class="line">                   bucketCount[i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，全部桶中的数据全部放回到arr中</span></span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+j+<span class="string">&quot;轮排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 基数排序的说明:</p>
<ol>
<li><p>基数排序是对传统桶排序的扩展，速度很快. </p>
</li>
<li><p>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError（内存溢出异常） 。</p>
</li>
<li><p>基数排序时稳定的。</p>
</li>
<li><p>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
</ol>
<h3 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h3><p><a href="https://imgtu.com/i/6Ymrl9"><img src="https://s3.ax1x.com/2021/03/10/6Ymrl9.png" alt="6Ymrl9.png"></a></p>
<h4 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h4><ol>
<li><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</p>
</li>
<li><p>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； </p>
</li>
<li><p>内排序：所有排序操作都在内存中完成；</p>
</li>
<li><p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
</li>
<li><p>时间复杂度： 一个算法执行所耗费的时间。</p>
</li>
<li><p>空间复杂度：运行完一个程序所需内存的大小。</p>
</li>
<li><p>n: 数据规模 </p>
</li>
<li><p>k: “桶”的个数 </p>
</li>
<li><p>In-place: 不占用额外内存</p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ol>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
