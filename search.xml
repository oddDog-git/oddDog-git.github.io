<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇</title>
    <url>/2021/02/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="你知道吗"><a href="#你知道吗" class="headerlink" title="你知道吗"></a>你知道吗</h1><a id="more"></a>

<h2 id="我是怪狗狗"><a href="#我是怪狗狗" class="headerlink" title="我是怪狗狗"></a>我是怪狗狗</h2><p>你绝对不知道</p>
<p>绝对  ， 哎 绝对</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组与稀疏数组</title>
    <url>/2021/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组与稀疏数组之间的转变说明（图）"><a href="#二维数组与稀疏数组之间的转变说明（图）" class="headerlink" title="二维数组与稀疏数组之间的转变说明（图）"></a>二维数组与稀疏数组之间的转变说明（图）</h1><a id="more"></a>

<p>​    <a href="https://imgtu.com/i/6EUbLD"><img src="https://s3.ax1x.com/2021/03/03/6EUbLD.png" alt="6EUbLD.png"></a></p>
<p><a href="https://imgtu.com/i/6EdVBD"><img src="https://s3.ax1x.com/2021/03/03/6EdVBD.png" alt="6EdVBD.png"></a></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="二维数组转变成稀疏数组"><a href="#二维数组转变成稀疏数组" class="headerlink" title="二维数组转变成稀疏数组"></a>二维数组转变成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 二维数组</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arrayToSparse(<span class="keyword">int</span> array[][]) &#123;</span><br><span class="line">        <span class="comment">//获取二维数组中值的个数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//稀疏数组的第一行的值分别为 二维数组总行数  二维数组总列数  二维数组中值的个数</span></span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">2</span>] = num;</span><br><span class="line">        <span class="comment">//将二维数组中的值填充到稀疏数组中  二维数组行 二维数组列 二维数组值</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sparse[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparse[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparse[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="稀疏数组转变从二维数组"><a href="#稀疏数组转变从二维数组" class="headerlink" title="稀疏数组转变从二维数组"></a>稀疏数组转变从二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 稀疏数组</span></span><br><span class="line"><span class="comment"> * return : 二维数组</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span> sparse[][]) &#123;</span><br><span class="line">        <span class="comment">//根据稀疏数组的第一行数据创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[sparse[<span class="number">0</span>][<span class="number">0</span>]][sparse[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//将稀疏数组中的值填充到二维数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparse.length;i++)&#123;</span><br><span class="line">            array[sparse[i][<span class="number">0</span>]][sparse[i][<span class="number">1</span>]]=sparse[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="将稀疏数组与本地文件之间在互相转换"><a href="#将稀疏数组与本地文件之间在互相转换" class="headerlink" title="将稀疏数组与本地文件之间在互相转换"></a>将稀疏数组与本地文件之间在互相转换</h1><p> 保存二维数组 ：二维数组 -&gt; 稀疏数组 -&gt; 本地文件</p>
<p> 获取二维数组 :  本地文件 -&gt; 稀疏数组 -&gt; 二维数组</p>
<p>二维数组与稀疏数组之间的转换上面已经写明了，这里主要讲稀疏数组与本地文件的转换，需要用到 java 中的IO操作</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="稀疏数组保存至本地文件"><a href="#稀疏数组保存至本地文件" class="headerlink" title="稀疏数组保存至本地文件"></a>稀疏数组保存至本地文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args1: 稀疏数组  args2: 需要保存文件的地址</span></span><br><span class="line"><span class="comment"> * return : 是否保存成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arraySave</span><span class="params">(<span class="keyword">int</span> sparse[][], String fileName)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter writer = <span class="keyword">new</span> FileWriter(file);<span class="comment">//文件输入流</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparse) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                    writer.write(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="将本地文件转换成稀疏数组"><a href="#将本地文件转换成稀疏数组" class="headerlink" title="将本地文件转换成稀疏数组"></a>将本地文件转换成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 需要读取的文件地址</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getArray(String fileName) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先获取文件的行数</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//根据文件的行数创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse=<span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//再次读取文件，将文件的内容填充到稀疏数组中</span></span><br><span class="line">        reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//获取文件中的每一行数据</span></span><br><span class="line">            String[] temp = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">                sparse[count][i]=Integer.parseInt(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>稀疏数组</tag>
        <tag>io流</tag>
      </tags>
  </entry>
  <entry>
    <title>数组队列与环形队列</title>
    <url>/2021/03/04/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E4%B8%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p> 队列是一个有序列表，可以用数组或是链表来实现。 </p>
<a id="more"></a>

<p> 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 </p>
<p> 示意图：(使用数组模拟队列示意图)</p>
<p><a href="https://imgtu.com/i/6ZdR8s"><img src="https://s3.ax1x.com/2021/03/04/6ZdR8s.png" alt="6ZdR8s.png"></a></p>
<h1 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h1><p>1.队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队 列的最大容量。</p>
<p>2.因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</p>
<p>3.头指针front 指向队列头元素的前一个位置，默认为-1</p>
<p>4.尾指针rear指向队列尾元素， 默认为-1</p>
<p>5.向队列中添加数据时：</p>
<p>​    1). 将尾指针往后移：rear+1</p>
<p>​    2).若尾指针 rear == maxSize - 1  ，表示队列已满，不能再存放数据了</p>
<p>6.向队列弹出一个数据时:</p>
<p>​    1). 将头指针往后移： front+1</p>
<p>​    2).将下标为 front+1 返回即可</p>
<p>​    3).头指针等于尾指针 ，即 front==rear ,则表示该队列为空，不能弹出数据了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//前部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//后部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">this</span>.maxSize=max;</span><br><span class="line">            <span class="keyword">this</span>.rear=-<span class="number">1</span>;<span class="comment">// 指向队列尾部，默认-1</span></span><br><span class="line">            <span class="keyword">this</span>.front=-<span class="number">1</span>;<span class="comment">// 指向队列头部的前一个位置，默认-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            <span class="keyword">this</span>.arr[rear]=data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.front++;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front+<span class="number">1</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;arr[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.arr[front+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析并优化"><a href="#问题分析并优化" class="headerlink" title="问题分析并优化"></a>问题分析并优化</h3><ol>
<li><p>目前数组使用一次就不能用， 没有达到复用的效果 </p>
</li>
<li><p>将这个数组使用算法，改进成一个环形的队列 （取模：%）</p>
</li>
</ol>
<h1 id="环形数组模拟队列"><a href="#环形数组模拟队列" class="headerlink" title="环形数组模拟队列"></a>环形数组模拟队列</h1><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><p>1)对头指针front含义做一个调整：front指向队列的第一个元素，初始值为 0</p>
<p>2)对尾指针rear含义做一个调整：rear指向队列最后一个元素的下一个位置，初始值为 0  ，因为希望空出一个位置作为约定</p>
<p>3)队列满表示为 ：(rear+1)%maxSize==front </p>
<p>4)队列空表示为：rear==front</p>
<p>5)队列中有效的值的个数表示为: (rear+maxSize-front)%maxSize </p>
<p>6)front++   与  rear++   统一写成  (front+1)%maxSize  与  (rear+1)%maxSize  ,因为这是个环形队列，如果front或rear超过数组最大下标则需要从下标0开始添加数据</p>
<p>7)根据原来的队列代码进行修改，就可以得到一个环形队列</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="comment">//指向队列头部 默认为0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">        <span class="comment">//指向队列尾部的后一个位置 默认为0  因为这是一个环形队列，需要预留一个位置作为约定</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            maxSize=max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="comment">//尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为 rear 指向队列尾元素的下一个位置，直接添加，再进行 rear++操作</span></span><br><span class="line">            arr[rear]=data;</span><br><span class="line">            <span class="comment">// 本来这里是 rear++ ，但是这是个环形队列，如果rear超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将队列头元素先保存下来,最后需要返回</span></span><br><span class="line">            <span class="keyword">int</span> result=arr[front];</span><br><span class="line">            <span class="comment">//本来这里是 front++ ，但是这是个环形队列，如果front超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            front=front+<span class="number">1</span>%maxSize;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front;i&lt;front+size();i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;arr[&quot;</span>+i%maxSize+<span class="string">&quot;]=&quot;</span>+arr[i%maxSize]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前队列中的有效个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[front]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试数组队列</span></span><br><span class="line">    	<span class="comment">//Queue queue = new Queue(3);</span></span><br><span class="line">    	<span class="comment">//测试环形数组队列</span></span><br><span class="line">       CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);<span class="comment">//因为需要预留一个位置作为约定, 所以该队列中只能存放3个数据，如需存放4个数据，该算法即可</span></span><br><span class="line">    	</span><br><span class="line">       Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;\na : 添加数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;p : 弹出一个数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;s : 显示队列&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;h : 显示头&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;e : 退出&quot;</span>);</span><br><span class="line">           String key = scanner.next();</span><br><span class="line">           <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                   System.out.println(<span class="string">&quot;请输入值:&quot;</span>);</span><br><span class="line">                   <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">                   queue.add(i);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;p&quot;</span>:</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> pop = queue.pop();</span><br><span class="line">                       System.out.println(<span class="string">&quot;弹出值为:&quot;</span>+pop);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       System.out.println(e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                   queue.showQueue();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;h&quot;</span>:</span><br><span class="line">                   queue.showHead();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       scanner.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题</title>
    <url>/2021/03/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>单向环形链表应用场景：</p>
<p> Josephu(约瑟夫、约瑟夫环) 问题 ：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。</p>
<a id="more"></a> 

<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<h3 id="约瑟夫问题-创建环形链表的思路"><a href="#约瑟夫问题-创建环形链表的思路" class="headerlink" title="约瑟夫问题-创建环形链表的思路:"></a>约瑟夫问题-创建环形链表的思路:</h3><p>1.创建一个节点时，让first节点等于它，并且first.setNext(first)，一个节点也形成环形</p>
<p>2.后面创建新节点时，就把节点加入到环形链表最后，即链表原来最后的节点指向新节点，新节点指向first，又可变成一个环形</p>
<h3 id="约瑟夫问题-小孩出圈的思路分析"><a href="#约瑟夫问题-小孩出圈的思路分析" class="headerlink" title="约瑟夫问题-小孩出圈的思路分析:"></a>约瑟夫问题-小孩出圈的思路分析:</h3><p>用户需要穿入3个数据(startNo:从 startNo 个节点开始数， count:  数 num 下， size: 圈中一共有多少个节点)</p>
<p>1.创建一个辅助指针 helper ，事先指向链表的最后一个节点，即first的前面，因为是单向链表，只能通过遍历来完成，直到 helper.getNext()=first</p>
<p>2.报数之前，先让first与helper移动 startNo -1 次，因为是从startNo开始报数的</p>
<p>3.循环遍历数时，每次报数让 first与helper移动 count-1 次(自己也要报一次数)，这是将first指向的节点出圈</p>
<p>4.出圈为 ： first=first.next      helpser.next=first</p>
<p>5.直到first==helper，循环才可结束，这时链表中只有一个节点，first与helper同时指向它</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码:"></a>实现代码:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环形单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boy first; <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 根据传入的数据创建size个节点的环形单链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoys</span><span class="params">(Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建失败:请传入不小于1的数！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针，指向新添加的节点，即最后的一个节点</span></span><br><span class="line">        boy currBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">            boy boy = <span class="keyword">new</span> boy(i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//第一个节点</span></span><br><span class="line">                first=boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                currBoy=first;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currBoy.setNext(boy); <span class="comment">//原来最后的节点指向新节点</span></span><br><span class="line">                boy.setNext(first);  <span class="comment">//新节点指向first</span></span><br><span class="line">                currBoy=boy;		</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历环形单链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        boy currBoy=first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(currBoy.getId()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currBoy.getNext()==first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currBoy=currBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出圈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从 startNo 个节点开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  数 num 下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 圈中一共有多少个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Integer startNo,Integer count,Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first ==<span class="keyword">null</span> || startNo&lt;<span class="number">1</span> || startNo&gt;size || count&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据有问题，请重试！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个helper指针，指向first之前的位置</span></span><br><span class="line">        boy helper=first;</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext()!=first) &#123;</span><br><span class="line">          helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将helper与first移动到 startNo 位置 ，移动 startNo-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startNo-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备就绪，开始出圈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper==first)&#123; <span class="comment">//表示只有一个数据了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count-<span class="number">1</span>;i++)&#123; <span class="comment">//移动count-1次</span></span><br><span class="line">                first=first.getNext();</span><br><span class="line">                helper=helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(first.getId()+<span class="string">&quot;--》&quot;</span>);</span><br><span class="line">            <span class="comment">//将当前first指向的节点出圈</span></span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后保留的数据:&quot;</span>+first.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">boy</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表与双向链表</title>
    <url>/2021/03/06/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>​     链表是以节点的方式来存储,是链式存储 ， 每个节点包含 data 域， next 域：指向下一个节点.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定,这里主要介绍带头节点的链表</p>
<a id="more"></a>

<h1 id="使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"><a href="#使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作" class="headerlink" title="使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"></a>使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作</h1><ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部 </p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6uwseI"><img src="https://s3.ax1x.com/2021/03/06/6uwseI.png" alt="6uwseI.png"></a></p>
<ol start="3">
<li>修改节点功能, 思路:</li>
</ol>
<p>​                (1) 通过遍历,先找到该节点,直接修改数据即可</p>
<p>​                (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p>
<ol start="4">
<li>删除节点 ，思路分析的示意图</li>
</ol>
<p><a href="https://imgtu.com/i/6uwgFf"><img src="https://s3.ax1x.com/2021/03/06/6uwgFf.png" alt="6uwgFf.png"></a></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer no;  <span class="comment">//序号</span></span><br><span class="line">    String name;    <span class="comment">//名称</span></span><br><span class="line">    String nickName;    <span class="comment">//昵称</span></span><br><span class="line">    Node next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&#x27;&quot;</span> + no + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加  找到最后一个节点，将新节点添加到链表的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照序号进行添加  根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//标记新节点序号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;node.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==node.no)&#123; <span class="comment">//该序号已存在，则无法插入</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该节点序号已存在，添加数据失败！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next=temp.next;</span><br><span class="line">            temp.next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表所有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;<span class="comment">//循环遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改  根据序号进行修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要修改的节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.no==node.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=node.name;</span><br><span class="line">            temp.nickName= node.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功:&quot;</span>+temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+node.no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除 根据序号进行删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该序号</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功序号为‘&quot;</span>+no+<span class="string">&quot;’节点&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="一些单项链表常见面试题"><a href="#一些单项链表常见面试题" class="headerlink" title="一些单项链表常见面试题"></a>一些单项链表常见面试题</h3><ol>
<li>求单链表中有效节点的个数,代码演示(easy):</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;<span class="comment">//循环遍历</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>查找单链表中的倒数第 k 个结点</p>
<p>代码演示:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 列表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 倒数第 index 个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第index个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLastIndexNode</span><span class="params">(Node head,Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遍历，获取该链表有效节点</span></span><br><span class="line">        Integer size=getLength(head);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span> || index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历，遍历 (size-index)次</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(size-index);i++)&#123;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-快慢指针法"><a href="#方法二-快慢指针法" class="headerlink" title="方法二:快慢指针法"></a>方法二:快慢指针法</h5><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h6><p>1.快指针从头开始走，慢指针从头的前一个地方开始走</p>
<p>2.快指针先走，走n次，然后快指针与慢指针一起走</p>
<p>3.直到快指针走到尾部，这时慢指针指向的下一个节点就是要删除的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//快慢指针法</span></span><br><span class="line">       ListNode temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> temp.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>单链表的反转 采用头插法</li>
</ol>
<p>思路分析：1.先创建一个头节点，暂时存放反转节点   Node reverseHead=new Node(0,””,””);</p>
<p>​                   2.循环遍历原来的链表，每遍历一遍，就把当前的节点转移到临时头节点  reverseHead的最前面</p>
<p>​                            curr.next=reverseHead.next;      reverseHead.next=curr;</p>
<p>​                   3.遍历完毕后原来的头节点后的节点全部反转到临时头节点 reverseHead后面，直接将原来头节点指向临时头节点之后的节点即可           head.next=reverseHead.next</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//当链表为空或只有一个节点，无需反转</span></span><br><span class="line">       <span class="keyword">if</span>(head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//暂时存放反转节点的节点头</span></span><br><span class="line">       Node reverseHead=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       Node curr=head.next;<span class="comment">//需要转移到到reverseList头部的节点</span></span><br><span class="line">       Node next=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           next=curr.next;</span><br><span class="line">           <span class="comment">//开始转移</span></span><br><span class="line">           curr.next=reverseHead.next;</span><br><span class="line">           reverseHead.next=curr;</span><br><span class="line">           curr=next;</span><br><span class="line">       &#125;</span><br><span class="line">       head.next=reverseHead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>从尾到头打印单链表 【要求方式 1：反向遍历 。 方式 2：Stack 栈】</li>
</ol>
<p>方法一:先反转链表，再遍历打印 （这样改变了链表原来的结构，不推荐，即使再次反转过来也很浪费时间）<br>方法二:将链表的数据全部放入栈中，再遍历栈取出数据，这样不会改变链表原来的结构（这里暂时使用java中的stack，不手写栈了）</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环遍历将链表的数据放入栈中</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历打印栈的数据</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
</ol>
<p>思路分析: </p>
<p>1.如果两个链表全部空则返回空；如果list1为空，返回list2；如果list2为空，返回list1</p>
<p>2.新建一个链表list用来存放合并list1与list2合并后的数据</p>
<p>3.同时遍历list1与list2，每一次比较list1当前节点与list2当前节点，谁更小就转移到list最后 (转移节点可参考问题三:链表的反转)</p>
<p>4.如果list1为空了，则把list2中的数据全部转移到list最后；如果list2空了，则把list1中的数据全部转移到list最后</p>
<p>注意: 可添加一个新的指针来标识list中新插入的节点位置</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的单链表，合并之后的链表依然有序 ,如果链表中的有两个序号相同，默认先取 list1 中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">merge</span><span class="params">(SingleLinkedList list1,SingleLinkedList list2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span> &amp;&amp; list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        SingleLinkedList list = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//记录当前插入的节点</span></span><br><span class="line">        Node newNode=list.getHead();</span><br><span class="line">        <span class="comment">//标志list1暂时需要转移的节点</span></span><br><span class="line">        Node curr1=list1.getHead().next;</span><br><span class="line">        <span class="comment">//记录curr1的下一个节点</span></span><br><span class="line">        Node next1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//标志list2暂时需要转移的节点</span></span><br><span class="line">        Node curr2=list2.getHead().next;</span><br><span class="line">        <span class="comment">//记录list2的下一个节点</span></span><br><span class="line">        Node next2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr1==<span class="keyword">null</span>)&#123;<span class="comment">//list1合并完毕,可将curr2中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr2==<span class="keyword">null</span>)&#123;<span class="comment">//list2合并完毕，可将curr1中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next1=curr1.next;</span><br><span class="line">            next2=curr2.next;</span><br><span class="line">            <span class="keyword">if</span>(curr1.no&lt;=curr2.no)&#123; <span class="comment">//添加curr1</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr1=next1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//添加curr2</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr2=next2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用带-head-头的双向链表实现-–水浒英雄排行榜"><a href="#使用带-head-头的双向链表实现-–水浒英雄排行榜" class="headerlink" title="使用带 head 头的双向链表实现 –水浒英雄排行榜"></a>使用带 head 头的双向链表实现 –水浒英雄排行榜</h1><p>管理单向链表的缺点分析:</p>
<p>​                 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p>
<p>​                 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，前面我们单链表删除 时节点，总是找到待删除节点的前一个节点.</p>
<p>双向链表的遍历与修改与单链表一样，添加与删除方法略有不同</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点需要新增一个值</span></span><br><span class="line">DoubleNode pre; <span class="comment">//指向前一个结点</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 添加再链表最后位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">        DoubleNode temp = head;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行添加</span></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        newNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序进行添加 根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">            DoubleNode temp=head;</span><br><span class="line">            <span class="comment">//标记新节点是否存在</span></span><br><span class="line">            <span class="keyword">boolean</span> exist=<span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//标记新节点是否插入到最后</span></span><br><span class="line">            <span class="keyword">boolean</span> last=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;<span class="comment">//表示新节点序号最大，需要插入到最后</span></span><br><span class="line">                    last=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no&gt; newNode.no)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no== newNode.no)&#123;<span class="comment">//表示新节点序号已存在</span></span><br><span class="line">                    exist=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入失败:该节点序号‘&quot;</span>+newNode.no+<span class="string">&quot;’已存在！！！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(last)&#123; <span class="comment">//插入到最后</span></span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//表示后一个节点</span></span><br><span class="line">                    DoubleNode rear = temp.next;</span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.next=rear;</span><br><span class="line">                    rear.pre=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 无需像单链表一样找到要删除的前一个节点，直接找到需要删除的节点，就可执行自我删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找序号为no的节点</span></span><br><span class="line">        DoubleNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;<span class="comment">//找到该节点,进行自我删除</span></span><br><span class="line">                temp.pre.next = temp.next;<span class="comment">//让temp前一个节点指向temp的后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next!=<span class="keyword">null</span>) &#123; <span class="comment">//如果temp的后一个节点为空，则会有空控制在异常</span></span><br><span class="line">                    temp.next.pre = temp.pre;<span class="comment">//让temp的后一个节点指向temp的前一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败:没找到序号为‘&quot;</span> + no + <span class="string">&quot;’的节点&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/03/06/%E6%A0%88/</url>
    <content><![CDATA[<p> 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除</p>
<a id="more"></a>

<h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><ol>
<li><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。</p>
</li>
<li><p>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。</p>
</li>
<li><p>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
</li>
<li><p>二叉树的遍历。</p>
</li>
<li><p>图形的深度优先(depth 一 first)搜索法。</p>
</li>
</ol>
<h3 id="用数组模拟栈的使用"><a href="#用数组模拟栈的使用" class="headerlink" title="用数组模拟栈的使用"></a>用数组模拟栈的使用</h3><p>思路 : </p>
<p>1.定义一个top表示栈顶,初始值为-1</p>
<p>2.入栈操作: top++;   stack[top]=data;</p>
<p>3.出栈操作: int val=stack[top];    top–;    return val;</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">int</span> [] stack; <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶，默认-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize=maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        <span class="keyword">this</span>.top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败:栈满~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历显示栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;stack[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+stack[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表模拟栈的使用-采用有头单项链表"><a href="#用链表模拟栈的使用-采用有头单项链表" class="headerlink" title="用链表模拟栈的使用,采用有头单项链表"></a>用链表模拟栈的使用,采用有头单项链表</h3><p>思路:</p>
<p>1.压栈：放入链表的第一个位置     newNode.next=head.next;      head.next=newNode;</p>
<p>2.弹栈：取链表的第一个节点      Node oldFirst = head.next;    head.next=head.next.next;   return oldFirst.data;</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈 采用头差法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        newNode.next=head.next;</span><br><span class="line">        head.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈 头取法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        head.next=head.next.next;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历栈失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器</title>
    <url>/2021/03/07/%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<p>栈实现一个中缀表达式计算器和一个后缀表达式计算器</p>
<a id="more"></a>

<h3 id="中缀表达式计算器"><a href="#中缀表达式计算器" class="headerlink" title="中缀表达式计算器"></a>中缀表达式计算器</h3><h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------再栈中补充以下代码,方便后续操作-------------------------------------	</span></span><br><span class="line"><span class="comment">//瞄一眼栈顶的数据，不是弹栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回运算符的优先级，越大优先级越高  假设只有 加减乘除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&#x27;*&#x27;</span> || oper==<span class="string">&#x27;/&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper==<span class="string">&#x27;+&#x27;</span> || oper==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他无效字符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span> || val==<span class="string">&#x27;-&#x27;</span> || val==<span class="string">&#x27;*&#x27;</span> || val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num2+num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num2*num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(num1==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式实现思路分析"><a href="#中缀表达式实现思路分析" class="headerlink" title="中缀表达式实现思路分析:"></a>中缀表达式实现思路分析:</h4><p>1.创建两个栈，一个用来存放数字numStack，一个用来存放运算符operStack</p>
<p>2.用一个指针index遍历需要计算的表达式，初始值为0</p>
<p>3.遍历如果发现是index指向的是数字就直接存入数栈</p>
<p>4.如果是运算符则需要一下判断:如果符号栈为空或当前运算符的优先级大于栈顶运算符的优先级，则可以直接将当前运算符入栈；</p>
<p>如果当前运算符优先级小于或等于栈顶运算符优先级，则需将符号栈栈顶的运算符弹出，将数栈的前两位数值弹出，进行运算，将结果放入数栈中，当前运算符放入符号栈</p>
<p>5.遍历完毕后继续遍历两个栈中剩下的数据，取出数栈的两个值，符号栈一个符号继续进行运算，将结果放入数栈，直到符号栈空</p>
<p>6.此时数栈只有一个数值，该值就是运算结果</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题:"></a>存在问题:</h5><p>上面思路只能解决一位数的计算，如果要多位数，则需一下改进:</p>
<ol>
<li>创建一个字符串chs，用来拼接多位数</li>
<li>数值压入数栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是就不能入栈，继续扫描，直到下一位是运算符才能入栈</li>
</ol>
<h5 id="实现计算器代码"><a href="#实现计算器代码" class="headerlink" title="实现计算器代码"></a>实现计算器代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算该表达式</span></span><br><span class="line">        String expression = <span class="string">&quot;7*2*2-5+16-5+3-4&quot;</span>; <span class="comment">//33</span></span><br><span class="line">        <span class="comment">//String expression=&quot;10+12*2-10&quot;;</span></span><br><span class="line">        <span class="comment">//用于存放 数字的栈</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于存放运算符的栈</span></span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">//第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">//第二个数字</span></span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;<span class="comment">//运算符</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//运算结果</span></span><br><span class="line">        <span class="keyword">char</span> ch;<span class="comment">//将每次扫描得到 char 保存到 ch</span></span><br><span class="line">        String chs=<span class="string">&quot;&quot;</span>;<span class="comment">//用来拼接多位数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//一个一个字符扫描</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是表达式</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//是表达式</span></span><br><span class="line">                <span class="comment">//判断 operStack 是否空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123; <span class="comment">//不空,不能直接将表达式压栈，需要判断</span></span><br><span class="line">                    <span class="comment">//如果当前表达式优先级小于或等于栈顶的表达式的优先级，则需要将栈顶的表达式取出，还需取出数值栈中的前两个数字，进行运算</span></span><br><span class="line">                    <span class="comment">//运算完毕将结果压入数值栈中，将当前表达式压入表达式栈中</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peekTop()))&#123;</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        <span class="comment">//进行运算</span></span><br><span class="line">                        result = operStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//空，直接将表达式压栈即可</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是表达式,即数字,将数字直接压入数值栈中(注:当前ch是字符,如果ch=&#x27;1&#x27;,转换成数字等于49,如果ch=&#x27;2&#x27;,转换成数字等于50,之间相差48)</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);</span></span><br><span class="line">                <span class="comment">//上面写法只能处理一位数的运算，如果需要多位数的运算，需要改进</span></span><br><span class="line">                <span class="comment">//思路:数值压入数值栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是则不能入栈，继续扫描，直到下一位是运算符才能入栈</span></span><br><span class="line">                chs += ch;<span class="comment">//拼接多位数</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;<span class="comment">//如果已经是最后一位数，可以直接入数栈</span></span><br><span class="line">                    numStack.push(Integer.parseInt(chs));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123; <span class="comment">//下一位是运算符，可以直接入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(chs));</span><br><span class="line">                        <span class="comment">//入栈后需清空chs</span></span><br><span class="line">                        chs=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描完毕,将栈中剩余的值计算掉,计算完毕后运算符栈中没有数据,但是数值栈中还有一个值，就是结果</span></span><br><span class="line">        <span class="keyword">while</span>(!operStack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            <span class="comment">//进行运算</span></span><br><span class="line">            result = operStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;运算结果为:&quot;</span>+numStack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>中缀表达式不利于计算机的计算，所以这里再实现一个后缀表达式计算器</p>
<h3 id="后缀表达式计算器"><a href="#后缀表达式计算器" class="headerlink" title="后缀表达式计算器"></a>后缀表达式计算器</h3><p>因为这里主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算</p>
<p>步骤: 中缀表达式 ==&gt; 中缀表达式list ==&gt; 后缀表达式list ==》 计算后缀表达式list ==》 结果</p>
<h4 id="将中缀表达式中的每一个值放入list集合中（方便后续计算）"><a href="#将中缀表达式中的每一个值放入list集合中（方便后续计算）" class="headerlink" title="将中缀表达式中的每一个值放入list集合中（方便后续计算）"></a>将中缀表达式中的每一个值放入list集合中（方便后续计算）</h4><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个指针index，用来遍历表达式；创建一个list集合，用来存放数据</p>
<p>2.循环遍历如果当前值不是数字，直接放入list集合中    (ch = s.charAt(index)) &lt; 48 || (ch = s.charAt(index)) &gt; 57  （字符0-9的十进制ASCII码为48-57）</p>
<p>3.如果当前值是数字，则需要考虑多位数 </p>
<p>4.遍历结束，直接将list集合返回即可</p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将中缀表达式放入到list中   13+8*6+2*5-(2+1) ==&gt; list[13,+,8,*,6,+,2,*,5,-,(,2,+,1,)]</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixExpressionBeList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//扫描指针</span></span><br><span class="line">       <span class="keyword">char</span> ch;<span class="comment">//表示每一个字符</span></span><br><span class="line">       String chs = <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> ((ch = s.charAt(index)) &lt; <span class="number">48</span> || (ch = s.charAt(index)) &gt; <span class="number">57</span>) &#123; <span class="comment">//表示不是数字，直接放入list中即可</span></span><br><span class="line">               list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//是数字,则需要考虑多位数</span></span><br><span class="line">               chs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; (ch = s.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = s.charAt(index)) &lt;= <span class="number">57</span>) &#123; <span class="comment">//属于0-9</span></span><br><span class="line">                   chs += ch;</span><br><span class="line">                   index++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//循环结束表示当前 s.charAt(index) 不是一个数字，chs中是个单位数或多位数</span></span><br><span class="line">               list.add(chs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (index &lt; s.length());<span class="comment">//表示扫描完毕</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将中缀表达式转换成后缀表达式（重难点）"><a href="#将中缀表达式转换成后缀表达式（重难点）" class="headerlink" title="将中缀表达式转换成后缀表达式（重难点）"></a>将中缀表达式转换成后缀表达式（重难点）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2</p>
<p>2.遍历中缀表达式</p>
<p>3.遇到数字时，将其压 s2</p>
<p>4.遇到运算符时，需要进行以下判断：</p>
<p>​            （1）.如果是左括号”(“,直接将此运算符入栈</p>
<p>​            （2）.如果是右括号”)”,则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，并将左括号弹出，此时这一对括号丢弃</p>
<p>​            （3）.如果 s1 为空，直接将此运算符入栈            </p>
<p>​            （4）.如果当前运算符优先级 &gt; 栈顶运算符优先级，也将运算符压入 s1；</p>
<p>​            （5）.如果当前运算符优先级 &lt;= 栈顶运算符优先级,将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(3)(4)进行比较；</p>
<p>5.遍历结束，将s1剩余的运算符依次弹出并压入到s2中，直到s1为空</p>
<p>6.此时s2中保存的数据就是转换后的后缀表达式的逆序</p>
<p>注:因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list集合代替s2,最后直接返回即可</p>
<h5 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式list转化成后缀表达式list(难点)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">       Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//存放运算符的栈</span></span><br><span class="line">       <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;&gt;();//存放数字以及结果的栈</span></span><br><span class="line">       <span class="comment">//因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list代替s2,最后直接返回即可</span></span><br><span class="line">       List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//遍历中缀表达式list</span></span><br><span class="line">       <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">           <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//数字直接存放到s2</span></span><br><span class="line">               s2.add(item);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123; <span class="comment">//item为符号，需要判断</span></span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;(&quot;</span>.equals(item))&#123; <span class="comment">//item为左括号，直接放入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;)&quot;</span>.equals(item))&#123; <span class="comment">//item为右括号，需要将符号栈中的符号转入到s2集合中，直到找到左括号为止，并将左括号弹出，这样就能消除一对括号</span></span><br><span class="line">                   <span class="keyword">while</span>(!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示s1栈顶是一个左括号，将它弹出即可，右括号也无需保存</span></span><br><span class="line">                   s1.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前运算符优先级小于符号栈栈顶优先级，需要将栈顶符号转入list中，再重新判断，否则可直接入符号栈，</span></span><br><span class="line">                   <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item)) &#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示当前运算符高于栈顶运算符，或符号栈为空，将当前符号直接入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，还需将符号栈剩余的符号全部依次转入list集合中</span></span><br><span class="line">       <span class="keyword">while</span>(s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           s2.add(s1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将后缀表达式进行计算（比中缀表达式计算简单的多）"><a href="#将后缀表达式进行计算（比中缀表达式计算简单的多）" class="headerlink" title="将后缀表达式进行计算（比中缀表达式计算简单的多）"></a>将后缀表达式进行计算（比中缀表达式计算简单的多）</h4><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个栈用来存放数值</p>
<p>2.遍历 list 集合，如果是数值则放入栈中，如果是运算符则从栈中弹出两个数进行运算，将结果压入栈中</p>
<p>3.遍历结束后栈中只有一个值，该值就是运算结果</p>
<h5 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//正则表达式判断是否为数字</span></span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不是数字</span></span><br><span class="line">                num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">switch</span> (s) &#123;  <span class="comment">//进行运算</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = num2 + num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = num2 - num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = num2 * num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (num1 == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:被除数不能为0!!!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = num2 / num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:运算符错误!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果放回栈中</span></span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中只有一个数据，就是运算结果，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>计算器</tag>
        <tag>中缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2021/03/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八皇后问题介绍 ：</p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的</p>
<a id="more"></a>

<p>国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。</p>
<h4 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h4><ol>
<li><p>第一个皇后先放第一行第一列</p>
</li>
<li><p>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 </p>
</li>
<li><p>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 </p>
</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解， 全部得到. </p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
<li><p>示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6lgytg"><img src="https://s3.ax1x.com/2021/03/08/6lgytg.png" alt="6lgytg.png"></a></p>
<p>说明：</p>
<p> 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. （注:下标是从0开始）</p>
<p>map[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 map 下标 表示第几行，即第几个皇后，map[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘 ，一维数组</span></span><br><span class="line">    <span class="comment">//说明:下标表示第几个皇后，也就是第几行，对应的值表示每个皇后所在的列,  例如: map=[0,4,7,5,2,6,1,3]</span></span><br><span class="line">    <span class="comment">//    比如上面的数组表示:第一个皇后在第一行第一列；第二个皇后在第二行第五列，第三个皇后在第三行第八列,第四个皇后在第四行第六列。。。。。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//总共解法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count2=<span class="number">0</span>;<span class="comment">//总共检查了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queen8 queen = <span class="keyword">new</span> Queen8();</span><br><span class="line">        <span class="comment">//从第一个皇后开始</span></span><br><span class="line">        queen.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有’&quot;</span>+queen.count+<span class="string">&quot;‘解法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共检查了’&quot;</span>+queen.count2+<span class="string">&quot;‘次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摆放皇后,从第n个皇后开始摆放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">8</span>)&#123;<span class="comment">//该摆放第9个皇后了，表示第八个皇后已摆放好</span></span><br><span class="line">            print();<span class="comment">//打印结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始放，直到第8列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放皇后 n 到 i 上</span></span><br><span class="line">            map[n]=i;</span><br><span class="line">            <span class="comment">//检查n皇后是否摆放正确</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;<span class="comment">//如果正确，递归，开始摆放下一个皇后</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查当前第n个皇后是否摆放正确</span></span><br><span class="line">    <span class="comment">//从n皇后之前的所有皇后进行遍历检查</span></span><br><span class="line">    <span class="comment">// map[i]==map[n] 表示在同一列</span></span><br><span class="line">    <span class="comment">// Math.abs(n-i)==Math.abs(map[n]-map[i] 表示在同一斜线--- 如果在同一斜线这两个坐标显示为一个等腰三角形，而等腰三角形两边相等，注意要取绝对值再判断~~自行体会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放错误</span></span><br><span class="line">            <span class="keyword">if</span>(map[i]==map[n] || Math.abs(n-i)==Math.abs(map[n]-map[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++)&#123;</span><br><span class="line">            System.out.print(map[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>八皇后</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫回溯</title>
    <url>/2021/03/08/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p>运用递归方法给小球找一条路能让小球到出口</p>
<a id="more"></a>

<p>思路:全在代码里，自行体会</p>
<p><a href="https://imgtu.com/i/6l6JHO"><img src="https://s3.ax1x.com/2021/03/08/6l6JHO.png" alt="6l6JHO.png"></a></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试给地图找路&quot;</span>);</span><br><span class="line">        <span class="comment">//创建地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = MiGong.createMap();</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//给地图找条路,从(1,1)开始出发</span></span><br><span class="line">        <span class="keyword">boolean</span> isOk = MiGong.setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(isOk?<span class="string">&quot;正确通过&quot;</span>:<span class="string">&quot;此路不通&quot;</span>);</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用递归方式给地图找路</span></span><br><span class="line">    <span class="comment">// 约定:1.  0表示还没走的路；1表示墙；2表示通路可以走；3表示该路走过，但走不通</span></span><br><span class="line">    <span class="comment">//     2.   在走迷宫时定义一条策略(方法):下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">    <span class="comment">//     3.   地图入口为 (i,j) ，出口为 (6,5)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;<span class="comment">//出口走过，表示走通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            map[i][j]=<span class="number">2</span>; <span class="comment">//先默认该路可走</span></span><br><span class="line">            <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//表示该路走不通</span></span><br><span class="line">                map[i][j]=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果map[i][j]= 1、2、3 都不继续玩下走</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建小地图   地图为8行7列大小，1表示墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] createMap()&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置个障碍</span></span><br><span class="line"><span class="comment">//        map[1][2]=1;</span></span><br><span class="line"><span class="comment">//        map[2][2]=1;</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span> <span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/03/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<p>排序的分类:  内部排序，指将需要处理的所有数据都加载到内部存储器(内存)中进行排序 ；外部排序法， 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。</p>
<p> 常见的排序算法分类(见右图):</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/68rGTS"><img src="https://s3.ax1x.com/2021/03/09/68rGTS.png" alt="68rGTS.png"></a></p>
<h2 id="冒泡排序（bubble-sorting）"><a href="#冒泡排序（bubble-sorting）" class="headerlink" title="冒泡排序（bubble sorting）"></a>冒泡排序（bubble sorting）</h2><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<p>优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果哪一趟排序没有交换，就代表数组已经有序了，直接退出即可</span></span><br><span class="line">        <span class="keyword">boolean</span> isExchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//用于交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//总共进行 length-1 次排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//将当前数据与下一位数据比较</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isExchange = <span class="keyword">true</span>; <span class="comment">//标记交换了</span></span><br><span class="line">                    <span class="comment">//进行交换</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            <span class="comment">//小小优化</span></span><br><span class="line">            <span class="keyword">if</span> (isExchange) &#123;</span><br><span class="line">                isExchange = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//没有交换，数组已经有序了，直接退出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="选择排序（select-sorting）"><a href="#选择排序（select-sorting）" class="headerlink" title="选择排序（select sorting）"></a>选择排序（select sorting）</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/68s139"><img src="https://s3.ax1x.com/2021/03/09/68s139.png" alt="68s139.png"></a></p>
<p>1.一共排序 （数组大小-1）次</p>
<p>2.每一轮排序，又是一个循环，循环规则:</p>
<p>​    2.1 先假定当前这个数是最小值，并记录下标</p>
<p>​    2.2 然后与后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到该最小数的下标</p>
<p>​    2.3 遍历结束就可以得到最小数以及下标</p>
<p>​    2.4 交换，将最小数放入循环刚开始的位置</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//存放最小值，默认最小值为 arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="comment">//存放最小值下标，默认最小值下标为 i</span></span><br><span class="line">            <span class="keyword">int</span> minIndex=i;</span><br><span class="line">            <span class="comment">//每一次与后一位数比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="comment">//如果min大于后面的数，则在min中放后一位数，minIndex也放后一位数的下标</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;</span><br><span class="line">                    minIndex=j;   <span class="comment">//更换最小值下标</span></span><br><span class="line">                    min=arr[j];   <span class="comment">//更换最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，min存放的值为最小值，minIndex是最小值下标，进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;  <span class="comment">//优化: minIndex==i表示最小值下标没更换，即 arr[i] 已经是最小值，没必要交换</span></span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入排序（insert-sorting）"><a href="#插入排序（insert-sorting）" class="headerlink" title="插入排序（insert sorting）"></a>插入排序（insert sorting）</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本思想：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><a href="https://imgtu.com/i/68yla8"><img src="https://s3.ax1x.com/2021/03/09/68yla8.png" alt="68yla8.png"></a></p>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;<span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">int</span> insertVal=<span class="number">0</span>;  <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">        <span class="keyword">int</span> insertBeforeIndex=<span class="number">0</span>; <span class="comment">//记录当前正在排序的值的前一个下标</span></span><br><span class="line">        <span class="comment">//将数组分成两份，一份为已排好序，默认一个数，一份为没排序，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertVal=arr[i];</span><br><span class="line">            insertBeforeIndex=i-<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//如果insertBeforeIndex指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">            <span class="keyword">while</span>(insertBeforeIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertBeforeIndex])&#123;</span><br><span class="line">                <span class="comment">//将前一个值后移一位</span></span><br><span class="line">                arr[insertBeforeIndex+<span class="number">1</span>]=arr[insertBeforeIndex];</span><br><span class="line">                insertBeforeIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，insertBeforeIndex+1 表示当前正在排序的值该插入的位置</span></span><br><span class="line">            arr[insertBeforeIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+i+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h2><p>简单插入排序存在的问题 </p>
<p>我们看简单的插入排序可能存在的问题. 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), </p>
<p>这样的过程是： </p>
<p>{2,3,4,5,6,6}  ==》 {2,3,4,5,5,6}  ==》  {2,3,4,4,5,6}   ==》 {2,3,3,4,5,6}  ==》  {2,2,3,4,5,6}  ==》  {1,2,3,4,5,6} </p>
<p>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p>希尔排序法的示意图:</p>
<p><a href="https://imgtu.com/i/686Xc9"><img src="https://s3.ax1x.com/2021/03/09/686Xc9.png" alt="686Xc9.png"></a></p>
<p><a href="https://imgtu.com/i/68cS76"><img src="https://s3.ax1x.com/2021/03/09/68cS76.png" alt="68cS76.png"></a></p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用交换法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 : 交换法     （不是说升级版吗？怎么感觉不太行。。。尴尬了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//存放临时变量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123; <span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123; <span class="comment">// 如果当前值大于当前值下标加步长的值，则交换位置</span></span><br><span class="line">                        temp=arr[j+gap];</span><br><span class="line">                        arr[j+gap]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(++count)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用移动法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种排序:移动法（真正的希尔排序，利用插入法原则，每一轮排序调整大小时不需要直接交换，而是向后移位，直到最后的位置才交换）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellPlus</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;<span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">               <span class="keyword">int</span> j=i; <span class="comment">//记录当前正在排序的值需要插入的位置 ，每次循环减步长gap</span></span><br><span class="line">               <span class="keyword">int</span> temp=arr[j]; <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="keyword">while</span>((j-gap)&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-gap])&#123; <span class="comment">//如果(j-gap)指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">                       <span class="comment">//前面的值向后移一位(步长位)</span></span><br><span class="line">                       arr[j]=arr[j-gap];</span><br><span class="line">                       <span class="comment">//j指向的下标向前移一位(步长位)</span></span><br><span class="line">                       j-=gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，j所指向的下标就是当前排序的值需要插入的地方</span></span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//不走if语句说明当前值不小于前一位的值(前一个步长位的值)，没必要继续走下去，否则，还需循环判断下面的值是否还小于</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+(++count)+<span class="string">&quot;趟排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（quick-sort）"><a href="#快速排序（quick-sort）" class="headerlink" title="快速排序（quick sort）"></a>快速排序（quick sort）</h3><p>是对冒泡排序的一种改进。</p>
<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.把数组中的一个数当作基准书,一般会把数组中最左边的数当作基准数</p>
<p>2.从两边开始检索，如果是最左边的数是基准数就从右边开始检索，否则从左边开始检索，</p>
<p>从右边开始检索，如果找到比基准数小的数时，停下，再从右边开始检索，如果找到比基准数大的数时，也停下，交换左右两边指向的数，然后继续检索。。</p>
<p>3.当左右两边指针相遇，就停止检索，交换基准数和当前的位置</p>
<p>4.递归上面代码 继续排序数组左边的元素</p>
<p>5.递归上面代码 继续排序数组右边的元素</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6YAm60"><img src="https://s3.ax1x.com/2021/03/10/6YAm60.png" alt="6YAm60.png"></a></p>
<h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123; <span class="comment">//出口  排序到最后面只有一个值时，就会执行该语句</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> temp=<span class="number">0</span>;  <span class="comment">//存放交换时的临时变量</span></span><br><span class="line">       <span class="keyword">int</span> base=arr[left]; <span class="comment">//基数，默认选每一组数的第一个元素</span></span><br><span class="line">       <span class="keyword">int</span> l=left;  <span class="comment">//左指针，从数组头开始</span></span><br><span class="line">       <span class="keyword">int</span> r=right; <span class="comment">//右指针，从数组尾开始</span></span><br><span class="line">       <span class="comment">//左右指针开始移动进行排序，因为 基数是最左边的元素，所以从右边开始索引，否则从左边开始索引</span></span><br><span class="line">       <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">           <span class="comment">//如果右指针的数据小于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span>(arr[r] &gt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               r--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果左指针的数据大于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两边指针都停止，交换两边指针所指向的值</span></span><br><span class="line">           temp=arr[r];</span><br><span class="line">           arr[r]=arr[l];</span><br><span class="line">           arr[l]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// l==i 时, 退出循环,说明当前指向的位置是基数该放的位置，将当前值与计算交换即可</span></span><br><span class="line">       arr[left]=arr[l];</span><br><span class="line">       arr[l]=base;</span><br><span class="line">       <span class="comment">//继续排序数组左边的元素</span></span><br><span class="line">       quick(arr,left,l-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//继续排序数组右边的元素</span></span><br><span class="line">       quick(arr,r+<span class="number">1</span>,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p>
<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><p>分简单，重点是治(合)</p>
<p>总体思路图:</p>
<p><a href="https://imgtu.com/i/6YA5NQ"><img src="https://s3.ax1x.com/2021/03/10/6YA5NQ.png" alt="6YA5NQ.png"></a></p>
<p>合并相邻有序子序列: </p>
<p>治阶段，我们需要将两个已经有序的子序列合并成一个有序序列</p>
<p>1.创建一个temp数组保存临时排序数据</p>
<p>2.相邻有序子序列都从左到右开始遍历，并进行比较，那个小就 先加入到temp临时数组中</p>
<p>3.当其中一组子序列遍历完毕，就可将另一组子序列全部放入temp中</p>
<p>4.此时temp中存放的数据就是这两个有序子序列中的所有值，并且排好序，只需将temp中的值全部导入到相邻序列中</p>
<p><a href="https://imgtu.com/i/6YEMvt"><img src="https://s3.ax1x.com/2021/03/10/6YEMvt.png" alt="6YEMvt.png"></a></p>
<h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分与和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//先从左开始分</span></span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//再从右开始分</span></span><br><span class="line">            mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//进行合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   最左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid    中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  最右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp   暂时存放排序数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一.将数组左右两边的数依次比较，哪个小就把哪个放入临时数组temp中，直到有一组数据遍历完毕</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;  <span class="comment">// 记录临时数组存放位置的指针</span></span><br><span class="line">        <span class="keyword">int</span> l=left;  <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right)&#123;     <span class="comment">//循环结束就表示有一组数据全部填充完毕</span></span><br><span class="line">            <span class="comment">//进行比较判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l]&lt;=arr[r])&#123;   <span class="comment">//将左边的数据填充到 temp中，并 l++; t++;</span></span><br><span class="line">                temp[t]=arr[l];</span><br><span class="line">                l++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t]=arr[r];  <span class="comment">//将右边的数据填充到 temp中，并 r++; t++;</span></span><br><span class="line">                r++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二.将另一组没有遍历完的数据依次放入临时数组中</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到 temp</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123;</span><br><span class="line">            temp[t]=arr[l];</span><br><span class="line">            t++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[r];</span><br><span class="line">            t++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三.将临时数组中的数据导入到arr数组中 ,arr数组中的位置是 left~~right</span></span><br><span class="line">        <span class="keyword">int</span>  j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            arr[i]=temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 </p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 </p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展 </p>
</li>
<li><p>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。</p>
</li>
</ol>
<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>2.这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
<p><a href="https://imgtu.com/i/6YeBrt"><img src="https://s3.ax1x.com/2021/03/10/6YeBrt.png" alt="6YeBrt.png"></a></p>
<p><a href="https://imgtu.com/i/6YeDqP"><img src="https://s3.ax1x.com/2021/03/10/6YeDqP.png" alt="6YeDqP.png"></a></p>
<p><a href="https://imgtu.com/i/6YesVf"><img src="https://s3.ax1x.com/2021/03/10/6YesVf.png" alt="6YesVf.png"></a></p>
<h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先获取数组中最高位的个数,才能判断排序几轮</span></span><br><span class="line">       <span class="comment">//存放该数组中最大的数，默认第一个数最大</span></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(max&lt;arr[i])&#123;</span><br><span class="line">               max=arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxSize=(max+<span class="string">&quot;&quot;</span>).length();<span class="comment">//获取位数</span></span><br><span class="line">       <span class="comment">//创建一个二维数组，二维数组包含10个一维数组，每个一位数组表示一个桶，一维数组存放的数据就是arr存放的需要排序的数据</span></span><br><span class="line">       <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">       <span class="comment">//创建一个一维数组，表示每个桶里有多少个数据，便于后面将数据放回到arr中</span></span><br><span class="line">       <span class="keyword">int</span>[] bucketCount=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,n=<span class="number">1</span>;j&lt;=maxSize;j++,n*=<span class="number">10</span>)&#123; <span class="comment">//共排序maxSize轮,当前第j轮</span></span><br><span class="line">           <span class="comment">//开始排序,将数据放入桶中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">               <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">               <span class="keyword">int</span> digit = arr[i]/n % <span class="number">10</span>;  <span class="comment">//如果n=1，获取个位；n=10，获取十位；n=100，获取百位。。。。判断当前数该放在哪个桶</span></span><br><span class="line">               bucket[digit][bucketCount[digit]]=arr[i];<span class="comment">//放入第digit个桶中第bucketCount[digit]个位置</span></span><br><span class="line">               bucketCount[digit]++;<span class="comment">//该桶中的数量加一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将10个桶中结果依次放回到arr中</span></span><br><span class="line">           <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//指向放入arr中数据的位置</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bucketCount[i]!=<span class="number">0</span>)&#123;<span class="comment">//如果桶中没数据，则跳过该桶</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;bucketCount[i];m++)&#123;<span class="comment">//根据该桶显示的数据循环获取数据，放入arr中</span></span><br><span class="line">                       arr[index++]=bucket[i][m];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，当前桶 i 中的数据全部放回至arr中，需要当前桶需将bucketCount[i]中的数据改为0，表示桶i中没有了数据，为了下一轮的排序</span></span><br><span class="line">                   bucketCount[i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，全部桶中的数据全部放回到arr中</span></span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+j+<span class="string">&quot;轮排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 基数排序的说明:</p>
<ol>
<li><p>基数排序是对传统桶排序的扩展，速度很快. </p>
</li>
<li><p>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError（内存溢出异常） 。</p>
</li>
<li><p>基数排序时稳定的。</p>
</li>
<li><p>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。 </p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。 </p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 </p>
</li>
<li><p>大顶堆举例说明</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6B9M1H"><img src="https://s3.ax1x.com/2021/03/14/6B9M1H.png" alt="6B9M1H.png"></a></p>
<ol start="5">
<li>小顶堆举例说明</li>
</ol>
<p><a href="https://imgtu.com/i/6B93nI"><img src="https://s3.ax1x.com/2021/03/14/6B93nI.png" alt="6B93nI.png"></a></p>
<ol start="6">
<li>一般升序采用大顶堆，降序采用小顶堆</li>
</ol>
<h4 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h4><p>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，这里是大顶堆，此时，整个序列的最大值就是堆顶的根节点</p>
<p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; </p>
<ol start="3">
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次大值,如此反复执行，便能得到一个有序 序列了</li>
</ol>
<p>​        可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p>提示:最后一个非叶子节点:(arr.length/2-1) , 左子树:(n<em>2+1) , 右子树:(n</em>2+2) , 父节点:(n+1)/2</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//堆排序，从小到大</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//将数组变成大顶堆</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           adjust(arr,i,arr.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//循环遍历，将最大值依次放到数组最后</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="comment">//将根节点（最大值）与最后一个节点的数据交换位置</span></span><br><span class="line">           <span class="keyword">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">           arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">           <span class="comment">//再调整位置</span></span><br><span class="line">           adjust(arr,<span class="number">0</span>,i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;	</span><br><span class="line"><span class="comment">//------------------------------核心代码-------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr 要排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i   将当前树的 i 节点与左右子树比较，将大的排在前面</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length 排序的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//调整当前数组i位置的值，将该值要大于子树的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="comment">//保存当前值</span></span><br><span class="line">       <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">       <span class="comment">//如果存在子节点，循环遍历左子树</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=(i*<span class="number">2</span>+<span class="number">1</span>);k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果存在右子树，且大于左子树，将大的子树提出来</span></span><br><span class="line">           <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k+<span class="number">1</span>]&gt;arr[k])&#123;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断 k 指向的子树是否大于当前节点,如果大则将子节点放入到当前节点位置</span></span><br><span class="line">           <span class="keyword">if</span>(arr[k]&gt;temp)&#123;</span><br><span class="line">               arr[i]=arr[k];</span><br><span class="line">               i=k;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，最大值已经放入到当前树的根节点处</span></span><br><span class="line">       <span class="comment">//如果当前值被替换了，需将 temp 值放到调整后的位置</span></span><br><span class="line">       <span class="keyword">if</span>(temp!=arr[i])&#123;</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h3><p><a href="https://imgtu.com/i/6Ymrl9"><img src="https://s3.ax1x.com/2021/03/10/6Ymrl9.png" alt="6Ymrl9.png"></a></p>
<h4 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h4><ol>
<li><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</p>
</li>
<li><p>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； </p>
</li>
<li><p>内排序：所有排序操作都在内存中完成；</p>
</li>
<li><p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
</li>
<li><p>时间复杂度： 一个算法执行所耗费的时间。</p>
</li>
<li><p>空间复杂度：运行完一个程序所需内存的大小。</p>
</li>
<li><p>n: 数据规模 </p>
</li>
<li><p>k: “桶”的个数 </p>
</li>
<li><p>In-place: 不占用额外内存</p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ol>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/03/11/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 java 中，我们常用的查找有四种:  顺序(线性)查找 ；二分查找/折半查找 ； 插值查找 ； 斐波那契查找</p>
<a id="more"></a>

<h3 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h3><p>就是通过遍历数组，每次判断，如果当前值等于要查找的值，就返回下标即可，相当的easy啦，这里就不演示了</p>
<h3 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找/折半查找"></a>二分查找/折半查找</h3><p>只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.获取该数组中间下标 midIndex=(left+right)/2</p>
<p>2.如果查找的值是否小于中间值mid，则向左继续递归查找</p>
<p>3.如果查找的值是否大于中间值mid，则向右继续递归查找</p>
<p>3.如果等于，则将中间下标返回即可</p>
<p>4.如果遍历完毕还没找到需要查找的值，即 left&gt;right，就反回-1 </p>
<p>问题:上面方法只能找到一个值,如需找到所有该值的下标，需要改进步骤 3 </p>
<p>优化 ： 如果等于，不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只查找一个匹配的下标，并返回该下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchOne</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接返回-1即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">            <span class="keyword">return</span> midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找所有匹配的值，将下标放入集合中，并返回该集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">searchList</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//改进</span></span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到</span></span><br><span class="line">            <span class="comment">//但是不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//向左遍历，将左边一样的值放入list</span></span><br><span class="line">            <span class="keyword">int</span> temp=midIndex-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;<span class="number">0</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将中间值放入list</span></span><br><span class="line">            list.add(midIndex);</span><br><span class="line">            <span class="comment">//向右遍历，将右边一样的值放入list</span></span><br><span class="line">            temp=midIndex+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码（非递归形式查找）"><a href="#补充代码（非递归形式查找）" class="headerlink" title="补充代码（非递归形式查找）"></a>补充代码（非递归形式查找）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归形式查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchPlus</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">           mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="comment">//向左查找</span></span><br><span class="line">           <span class="keyword">if</span>(target&lt;arr[mid])&#123;</span><br><span class="line">               right=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;arr[mid])&#123;</span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h3><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>将折半查找中的求 mid 索引的公式进行改进 , low 表示左边索引 left, high 表示右边索引 right. key 就是我们需要查找的值</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6Nl0pV"><img src="https://s3.ax1x.com/2021/03/11/6Nl0pV.png" alt="6Nl0pV.png"></a></p>
<p>二分查找时，中间值下标  midIndex = (left+right)/2 = left+(right-left)*(1/2)</p>
<p>插值查找将上面的 1/2 做了改进，变成 (data-arr[left])/(arr[right]-arr[left])，让midIndex自适应</p>
<p>midIndex  = left+(right-left)*(data-arr[left])/(arr[right]-arr[left])    通过当前查找的值在最大值与最小值之间的比例来获得中间值</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><p>1.退出条件还需添加  data&lt;arr[left] 与  data&gt;arr[right]，查找的数不小于最小值，不大于最大值，这两个条件不仅是为了优化，还必须存在 （如果查找的数是个特别大或小的数，会造成下标越界异常）</p>
<p>2.插值查找适合在大量数据，且数据分布均匀的条件下使用，如果数据分布相当不均匀，不如用二分查找</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值查找，只查一个值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;插值查找~~&quot;</span>);</span><br><span class="line">       <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">       <span class="comment">// data&lt;arr[left] 与 data&gt;arr[right] 查找的数不小于最小值，不大于最大值，这两个条件不仅时为了优化，必须存在 （如果查找的数是个相当大或小的数，会造成下标越界异常）</span></span><br><span class="line">       <span class="keyword">if</span>(left&gt;right || data&lt;arr[left] || data&gt;arr[right])&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//中间值下标，自适应，(该算法的核心)</span></span><br><span class="line">       <span class="keyword">int</span> midIndex=left+(right-left)*(data-arr[left])/(arr[right]-arr[left]);</span><br><span class="line">       <span class="keyword">int</span> mid=arr[midIndex];</span><br><span class="line">       <span class="keyword">if</span>(data&lt;mid)&#123;<span class="comment">//查找值小于中间值，继续向左递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;<span class="comment">//查找值大于中间值，继续向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">           <span class="keyword">return</span> midIndex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契（黄金分割法）查找算法"><a href="#斐波那契（黄金分割法）查找算法" class="headerlink" title="斐波那契（黄金分割法）查找算法"></a>斐波那契（黄金分割法）查找算法</h3><ol>
<li><p>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神 奇的数字，会带来意向不大的效果。</p>
</li>
<li><p>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ，当前数等于两个数相加，并且斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
</li>
</ol>
<p>本人一直不知道该算法有何意义，真的是玄学算法，好玩倒是真的</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p>
<p><a href="https://imgtu.com/i/6N1UDe"><img src="https://s3.ax1x.com/2021/03/11/6N1UDe.png" alt="6N1UDe.png"></a></p>
<h6 id="对-F-k-1-1-的理解"><a href="#对-F-k-1-1-的理解" class="headerlink" title="对 F(k-1)-1 的理解"></a>对 F(k-1)-1 的理解</h6><p>1.由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段,再加上mid这个位置，即如上图所示。从而中间位置为 mid=low+F[k-1]-1</p>
<p>2.类似的，每一子段也可以用相同的方式分割</p>
<p>3.但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使 得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。</p>
<p> while(n&gt;fib[k]-1) {</p>
<p>​        k++;</p>
<p>}</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认斐波那契数组大小为20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize=<span class="number">20</span>;</span><br><span class="line">   <span class="comment">//创建一个斐波那契数组  &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55 , 89  ...... &#125;</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">       <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">       fib[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">           fib[i]=fib[i-<span class="number">1</span>]+fib[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fib;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//斐波那契算法，不用递归  mid=low+fib[k-1]-1</span></span><br><span class="line">   <span class="comment">// fib[k] = fib[k-1] + fib[k-2]</span></span><br><span class="line">   <span class="comment">// fib[k]-1 = (fib[k-1]-1) +(fib[k-2]-1) + 1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> low=<span class="number">0</span>;  <span class="comment">//最低点</span></span><br><span class="line">       <span class="keyword">int</span> high=arr.length-<span class="number">1</span>;  <span class="comment">//最高点</span></span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//斐波那契中k的值</span></span><br><span class="line">       <span class="keyword">int</span> mid=<span class="number">0</span>; <span class="comment">//中间值</span></span><br><span class="line">       <span class="keyword">int</span>[] fib = fib(); <span class="comment">//获取斐波那契数组</span></span><br><span class="line">       <span class="comment">//通过最大下标，获取k, fib[k]-1 要大于或等于 high</span></span><br><span class="line">       <span class="keyword">while</span> (high&gt;fib[k]-<span class="number">1</span>) &#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，获取到k值，这时arr的长度可能小于fib的长度，这时需要复制通过数组temp</span></span><br><span class="line">       <span class="keyword">int</span>[] temp= Arrays.copyOf(arr,fib[k]);</span><br><span class="line">       <span class="comment">//默认后面填充的值是0，需将0全部变成最后一个数</span></span><br><span class="line">       <span class="comment">//&#123;1,8, 10, 89, 1000, 1234, 0, 0, 0&#125; ==》 &#123;1,8, 10, 89, 1000, 1234, 1234, 1234, 1234&#125;</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=high+<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">           temp[i]=arr[high];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始循环，获取data下标</span></span><br><span class="line">       <span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">           mid=low+fib[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">           System.out.println(mid);</span><br><span class="line">           <span class="keyword">if</span>(data&lt;temp[mid])&#123;<span class="comment">//小于，向左继续查找</span></span><br><span class="line">               high=mid-<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//fib[k]=fib[k-1]+fib[k-2]</span></span><br><span class="line">               <span class="comment">//在前一部分的值中继续查找，前一部分也就是 fib[k-1]</span></span><br><span class="line">               k-=<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;temp[mid])&#123;<span class="comment">//大于，向右继续查找</span></span><br><span class="line">               low=mid+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//在后一部分的值中继续查找,后一部分也就是 fib[k-2]</span></span><br><span class="line">               k-=<span class="number">2</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//等于 ，</span></span><br><span class="line">               <span class="keyword">if</span>(mid&lt;=high)&#123;</span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> high;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/03/13/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/6waRI0"><img src="https://s3.ax1x.com/2021/03/13/6waRI0.png" alt="6waRI0.png"></a></p>
<p>哈希表中存放 链表数组，每一条链表都存放了雇员信息，如图</p>
<p><a href="https://imgtu.com/i/6w05z8"><img src="https://s3.ax1x.com/2021/03/13/6w05z8.png" alt="6w05z8.png"></a></p>
<h4 id="代码实现（暂时不包含相应的方法）"><a href="#代码实现（暂时不包含相应的方法）" class="headerlink" title="代码实现（暂时不包含相应的方法）"></a>代码实现（暂时不包含相应的方法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span> </span>&#123;</span><br><span class="line">    <span class="comment">//哈希表中的链表条数,默认8条（注:后期不能修改）</span></span><br><span class="line">    <span class="keyword">private</span> Integer size = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">private</span> LinkUser[] hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数，根据用户id判断该用户应该在哪一条链表中(这里根据链表条数进行取模计算)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个节点，默认为空</span></span><br><span class="line">    User head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一个用户（节点）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    User next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码实现-实现添加，遍历，查找，删除"><a href="#代码实现-实现添加，遍历，查找，删除" class="headerlink" title="代码实现(实现添加，遍历，查找，删除)"></a>代码实现(实现添加，遍历，查找，删除)</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].add(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].addByOrder(user);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line">	<span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不为空，找到最后一个节点，添加到最后</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,temp为最后一个节点</span></span><br><span class="line">       temp.next = user;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果等于头节点，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(head.id==user.id)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果新节点小于头节点，直接换头节点</span></span><br><span class="line">       <span class="keyword">if</span>(user.id&lt;head.id)&#123;</span><br><span class="line">           user.next=head;</span><br><span class="line">           head=user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果上面条件都不满足，找到需要添加位置的前一个节点</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="comment">//标记temp节点是否是最后一个节点</span></span><br><span class="line">       <span class="keyword">boolean</span> isLast=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(user.id&lt;temp.next.id)&#123;</span><br><span class="line">               isLast=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，要么找到了需要插入的位置，要么遍历到了最后</span></span><br><span class="line">       <span class="keyword">if</span>(isLast)&#123;</span><br><span class="line">           temp.next = user;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           user.next=temp.next;</span><br><span class="line">           temp.next=user;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//遍历哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;链表&quot;</span> + i + <span class="string">&quot;为\t&quot;</span>);</span><br><span class="line">            hash[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot; ==&gt; id=&quot;</span> + temp.id + <span class="string">&quot;,name=&quot;</span> + temp.name);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        User user = hash[i].find(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123; <span class="comment">//存在</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"> <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        <span class="keyword">return</span> hash[i].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.id==id)&#123;<span class="comment">//如果该用户是头节点，直接自我删除即可</span></span><br><span class="line">            head=head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//指向当前要删除的节点的前一个节点</span></span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h5 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h5><h6 id="1-数组存储方式的分析"><a href="#1-数组存储方式的分析" class="headerlink" title="1) 数组存储方式的分析"></a>1) 数组存储方式的分析</h6><a id="more"></a>

<p> 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</p>
<h6 id="2-链式存储方式的分析"><a href="#2-链式存储方式的分析" class="headerlink" title="2) 链式存储方式的分析"></a>2) 链式存储方式的分析</h6><p> 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<h6 id="3-树存储方式的分析"><a href="#3-树存储方式的分析" class="headerlink" title="3) 树存储方式的分析"></a>3) 树存储方式的分析</h6><p> 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度</p>
<p>数示意图:</p>
<p><a href="https://imgtu.com/i/6wsnyT"><img src="https://s3.ax1x.com/2021/03/13/6wsnyT.png" alt="6wsnyT.png"></a></p>
<p>树的常用术语(结合示意图理解): </p>
<ol>
<li><p>节点</p>
</li>
<li><p>根节点</p>
</li>
<li><p>父节点</p>
</li>
<li><p>子节点 </p>
</li>
<li><p>叶子节点 (没有子节点的节点) </p>
</li>
<li><p>节点的权(节点值)</p>
</li>
<li><p>路径(从 root 节点找到该节点的路线)</p>
</li>
<li><p>层 </p>
</li>
<li><p>子树 </p>
</li>
<li><p>树的高度(最大层数) </p>
</li>
<li><p>森林 :多颗子树构成森林</p>
</li>
</ol>
<h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><ol>
<li><p>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 </p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6wsw0e"><img src="https://s3.ax1x.com/2021/03/13/6wsw0e.png" alt="6wsw0e.png"></a></p>
<ol start="4">
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树</li>
</ol>
<p><a href="https://imgtu.com/i/6wsrtA"><img src="https://s3.ax1x.com/2021/03/13/6wsrtA.png" alt="6wsrtA.png"></a></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>使用前序，中序和后序对下面的二叉树进行遍历</p>
<ol>
<li><p>前序遍历: 先输出父节点，再递归遍历左子树，最后递归遍历右子树 </p>
</li>
<li><p>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</p>
</li>
<li><p>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 </p>
</li>
</ol>
<p>小结: 看输出父节点的顺序，就确定是前序，中序还是后序</p>
<h5 id="实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加"><a href="#实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加" class="headerlink" title="实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)"></a>实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历  父节点==》左节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历  左节点==》父节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历  左节点==》右节点==》父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-查找指定节点"><a href="#二叉树-查找指定节点" class="headerlink" title="二叉树-查找指定节点"></a>二叉树-查找指定节点</h4><p>使用前序查找，中序查找和后序查找</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><h6 id="前序查找"><a href="#前序查找" class="headerlink" title="前序查找"></a>前序查找</h6><p>1.先判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>2.如果不等，则判断当前节点左子树是否为空，如果不为空,则向左子树递归前序查找</p>
<p>3.如果左子树找到节点，直接返回，否则判断当前节点右子树是否为空，如果不空，则继续向右子树递归前序查找</p>
<h6 id="中序查找"><a href="#中序查找" class="headerlink" title="中序查找"></a>中序查找</h6><p>1.判断当前节点左子树是否为空，如果不为空,则向左子树递归中序查找</p>
<p>2.如果左子树找到节点，直接返回，否则判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>3.如果不是，则向右子树中序递归查找，找到就返回，没有就返回null</p>
<h6 id="后序查找"><a href="#后序查找" class="headerlink" title="后序查找"></a>后序查找</h6><p>1.先左，再右，后当前节点。。。。。与上面基本一样的套路</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是前序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//先判断当前节点,如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//没找到就向左子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//左子树没找到，就向右子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是中序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//如果左子树没找到，就判单当前节点，如果是，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当前节点没找到，就向右子树递归调用中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不管找到没找到，直接返回即可</span></span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当左子树没找到，就向右子树递归调用后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是后续查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">// 如果左子树没找到，就判断当前节点，如果是就返回当前</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果都没找到，就返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-删除节点（不考虑是否有子树，统一删除）"><a href="#二叉树-删除节点（不考虑是否有子树，统一删除）" class="headerlink" title="二叉树-删除节点（不考虑是否有子树，统一删除）"></a>二叉树-删除节点（不考虑是否有子树，统一删除）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先考虑:</p>
<p>改树是否为空树；根节点是否是要删除的节点；</p>
<p>然后进行以下步骤:</p>
<p>1.因为二叉树是单项的，所以我们需要判断当前节点的子树是否要删除的节点</p>
<p>2.如果当前节点的左子树不为空，并且左子树就是要删除节点，就将 this.left=null; 并返回（结束递归删除）</p>
<p>3.如果当前节点的右子树不为空，并且右子树就是要删除节点，就将 this.right=null; 并返回（结束递归删除）</p>
<p>4.如果第2步与第3步没有删除节点，则需要向左子树递归删除节点</p>
<p>5.如果第4步也没有删除节点，则需要向右子树递归删除</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;删除失败:该数为空！！！&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果要删除的节点是根节点，直接自我删除即可</span></span><br><span class="line">           <span class="keyword">if</span>(root.getNo()==no)&#123;</span><br><span class="line">               root=<span class="keyword">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果不是，就调用树节点的方法</span></span><br><span class="line">               root.deleteNode(no);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码--------------------------------- </span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先判断删除的节点是不是左子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//再判断删除的节点是不是右子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.right=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不是左右子树,则先向左子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树递归没找都，就再向右子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.right.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>数</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/2021/03/14/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>先看一个问题， 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. （ n+1=7 个空指针 )</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<a id="more"></a>

<p>问题分析: </p>
<ol>
<li><p>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } </p>
</li>
<li><p>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</p>
</li>
<li><p>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? </p>
</li>
<li><p>解决方案-线索二叉树</p>
</li>
</ol>
<h4 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h4><ol>
<li><p>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） </p>
</li>
<li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 </p>
</li>
<li><p>一个结点的前一个结点，称为前驱结点</p>
</li>
<li><p>一个结点的后一个结点，称为后继结点</p>
</li>
</ol>
<h4 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h4><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h5><p>中序遍历的结果：{8, 3, 10, 1, 14, 6}，如图</p>
<p><a href="https://imgtu.com/i/6ywk4J"><img src="https://s3.ax1x.com/2021/03/16/6ywk4J.png" alt="6ywk4J.png"></a></p>
<p>节点8，10。。没有左右子树，安装中序遍历结果，8的前驱节点为null，后继节点为3；10的前驱节点为3，后继节点为1。。。</p>
<p>1.我们可以定义一个前驱节点pre，默认为null</p>
<p>2.线索化左节点时，判断当前节点node是否有左子树，如果没有则让当前节点的左指针指向pre</p>
<p>3.线索化右节点时，判断前驱节点pre是否为null，是否有右子树，如果不为null，并且没有右子树，则让pre的右指针指向当前节点</p>
<p>4.每次线索化后，都让pre后移，即 pre=node</p>
<h6 id="说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况"><a href="#说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况" class="headerlink" title="说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:"></a>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</h6><ol>
<li><p>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. </p>
</li>
<li><p>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//用来表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> Node pre=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先向左递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化左指针</span></span><br><span class="line">        <span class="comment">//如果左子树为空，则将左指针指向前驱节点,并改变左指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化右指针</span></span><br><span class="line">        <span class="comment">//如果当前前驱节点不为空，且前驱节点没有右子树，则让他右指针指向它的后继节点（即当前节点），并改变右指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">        pre=node;</span><br><span class="line">        <span class="comment">//最高向右递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法</span></span><br><span class="line">        infixThreaded(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line">    <span class="comment">// 表示左指针指向的类型是什么，0表示左子树，1表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示右指针指向的类型是什么，0表示右子树，1表示后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历中序线索化二叉树"><a href="#遍历中序线索化二叉树" class="headerlink" title="遍历中序线索化二叉树"></a>遍历中序线索化二叉树</h4><p>对前面的中序线索化的二叉树， 进行遍历 </p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历 线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次 序应当和中序遍历保持一致。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       root.infixList();<span class="comment">//从根节点开始</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的(核心)==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前节点，从根节点开始</span></span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//先找到最左边的节点，也就是第一个有前驱的节点，注:即使前驱节点为空，leftType 也等于 1</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到第一个,直接打印</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//如果有后继节点，也直接打印</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getRightType()==<span class="number">1</span>)&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//最后将它变成右子树</span></span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//--------------创建线索化二叉树--------------------</span></span><br><span class="line">       Node root=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">       Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">       Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">       Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">       Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">       root.setLeft(node1);</span><br><span class="line">       root.setRight(node2);</span><br><span class="line">       node1.setLeft(node3);</span><br><span class="line">       node1.setRight(node4);</span><br><span class="line">       node2.setLeft(node5);</span><br><span class="line">       <span class="comment">//这里手动创建</span></span><br><span class="line">       ThreadedBinaryTree tree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">       tree.setRoot(root);</span><br><span class="line">       <span class="comment">//-------------------中序线索化 和 遍历  测试------------------</span></span><br><span class="line">       <span class="comment">//中序线索化</span></span><br><span class="line">       <span class="comment">//中序遍历后是 :  3, 1, 4, 0, 5, 2</span></span><br><span class="line">       <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">       <span class="comment">//但是在线索化后，节点3的前驱为null,后继为1; 节点4的前驱为1，后继为0; 节点5的前驱为0，后继为2</span></span><br><span class="line">       tree.infixThreaded();</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">     	<span class="comment">//中序线索化后遍历</span></span><br><span class="line">       System.out.println(<span class="string">&quot;中序线索化后的遍历:&quot;</span>);  <span class="comment">// 3, 1, 4, 0, 5, 2</span></span><br><span class="line">       tree.infixList();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>根据上面的思路，接下来我将实现前序线索化二叉树及遍历 与 后续线索化二叉树及遍历</p>
<p>注: 向左子树递归与向右子树递归还需加一个条件node.getLeftType()==0与node.getRightType()==0</p>
<p>不加会出现死循环，可自己画个图看看叶节点的前驱与后继是指向哪里</p>
<h4 id="前序线索化二叉树及其遍历"><a href="#前序线索化二叉树及其遍历" class="headerlink" title="前序线索化二叉树及其遍历"></a>前序线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">       pre=node;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           preThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">           preThreaded(node.getRight());</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       preThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.preList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//直接打印当前</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//先向左遍历</span></span><br><span class="line">           <span class="keyword">while</span> (temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示向左遍历完毕,继续获取的后继节点</span></span><br><span class="line">           <span class="keyword">if</span> (temp.getRightType()==<span class="number">1</span> )&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line">      <span class="comment">//前序遍历 : 0, 1, 3, 4, 2, 5</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为1，后继节点为4; 节点4的前驱为3，后继为2; 节点5的前驱为2，后继为null</span></span><br><span class="line">      tree.preThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.preList();</span><br></pre></td></tr></table></figure>
<h4 id="后续线索化二叉树及其遍历"><a href="#后续线索化二叉树及其遍历" class="headerlink" title="后续线索化二叉树及其遍历"></a>后续线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的======================</span></span><br><span class="line"> <span class="comment">//后序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//前驱指针向后移</span></span><br><span class="line">       pre=node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       postThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.postList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//这里本人写不出来，字节用递归的笨方法。。。。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(node);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//后序线索化后的的遍历，重构上面遍历方法，方便调用</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       postList(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line"><span class="comment">//前序遍历 : 3, 4, 1, 5, 2, 0</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为null，后继节点为4; 节点4的前驱为3，后继为1; 节点5的前驱为1，后继为2</span></span><br><span class="line">      tree.postThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.postList();</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼编码</title>
    <url>/2021/03/15/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="赫夫曼树基本介绍"><a href="#赫夫曼树基本介绍" class="headerlink" title="赫夫曼树基本介绍"></a>赫夫曼树基本介绍</h2><ol>
<li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 </li>
</ol>
<a id="more"></a>

<ol start="2">
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h5 id="赫夫曼树几个重要概念和举例说明"><a href="#赫夫曼树几个重要概念和举例说明" class="headerlink" title="赫夫曼树几个重要概念和举例说明"></a>赫夫曼树几个重要概念和举例说明</h5><ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 </p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结 点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 </p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 </p>
</li>
<li><p>WPL 最小的就是赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rMxqx"><img src="https://s3.ax1x.com/2021/03/15/6rMxqx.png" alt="6rMxqx.png"></a></p>
<h3 id="构成赫夫曼树："><a href="#构成赫夫曼树：" class="headerlink" title="构成赫夫曼树："></a>构成赫夫曼树：</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>将每一个数据变成一个节点，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树 </p>
</li>
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将该数字变成一颗霍夫曼树</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HufNode tree = createHuffmanTree(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;霍夫曼树为:&quot;</span>);</span><br><span class="line">        tree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入一个数组，将数组变成一颗赫夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HufNode <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组的每一个元素都组成一个节点，然后放入到list集合中</span></span><br><span class="line">        List&lt;HufNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HufNode(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历，直到list中只有一个值</span></span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先排好序</span></span><br><span class="line">        	Collections.sort(list);</span><br><span class="line">            <span class="comment">// 取出前两个节点(即最小值与次小值)，组成一颗新树</span></span><br><span class="line">            HufNode leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            HufNode rightNode = list.get(<span class="number">1</span>);</span><br><span class="line">            HufNode newNode = <span class="keyword">new</span> HufNode(leftNode.value+ rightNode.value,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//将之前的两个节点删除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新树放入到list集合中，再次排序</span></span><br><span class="line">            list.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时list中只有一个节点，该节点就是一颗完整的赫夫曼树，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HufNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HufNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    HufNode left;</span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    HufNode right;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HufNode o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value-o.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HufNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value, HufNode left, HufNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼编码基本介绍"><a href="#赫夫曼编码基本介绍" class="headerlink" title="赫夫曼编码基本介绍"></a>赫夫曼编码基本介绍</h2><ol>
<li><p>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 </p>
</li>
<li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 </p>
</li>
<li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 </p>
</li>
<li><p>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</p>
</li>
</ol>
<h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><h5 id="通信领域中信息的处理方式-1-定长编码"><a href="#通信领域中信息的处理方式-1-定长编码" class="headerlink" title="通信领域中信息的处理方式 1-定长编码"></a>通信领域中信息的处理方式 1-定长编码</h5><p><a href="https://imgtu.com/i/6rlKn1"><img src="https://s3.ax1x.com/2021/03/15/6rlKn1.png" alt="6rlKn1.png"></a></p>
<h5 id="通信领域中信息的处理方式-2-变长编码"><a href="#通信领域中信息的处理方式-2-变长编码" class="headerlink" title="通信领域中信息的处理方式 2-变长编码"></a>通信领域中信息的处理方式 2-变长编码</h5><p><a href="https://imgtu.com/i/6rlQ76"><img src="https://s3.ax1x.com/2021/03/15/6rlQ76.png" alt="6rlQ76.png"></a></p>
<h5 id="通信领域中信息的处理方式-3-赫夫曼编码"><a href="#通信领域中信息的处理方式-3-赫夫曼编码" class="headerlink" title="通信领域中信息的处理方式 3-赫夫曼编码"></a>通信领域中信息的处理方式 3-赫夫曼编码</h5><h5 id="传输的-字符串"><a href="#传输的-字符串" class="headerlink" title="传输的 字符串"></a>传输的 字符串</h5><ol>
<li><p>i like like like java do you like a java </p>
</li>
<li><p>d:1  y:1  u:1  j:2  v:2  o:2  l:4  k:4  e:4  i:5  a:5  &lt;空格&gt;:9 // 各个字符对应出现的次数 </p>
</li>
<li><p>按照上面字符出现的次数构建一颗赫夫曼树, 字符出现的次数作为权值  </p>
</li>
</ol>
<h5 id="构成赫夫曼树的步骤"><a href="#构成赫夫曼树的步骤" class="headerlink" title="构成赫夫曼树的步骤"></a>构成赫夫曼树的步骤</h5><p>1)将每一个数据变成一个节点 , 将上面的字符变成节点的值，字符出现的次数变成节点的权重，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树</p>
<ol start="2">
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rltcd"><img src="https://s3.ax1x.com/2021/03/15/6rltcd.png" alt="6rltcd.png"></a></p>
<ol start="4">
<li><p>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ，</p>
<p>编码 如下: o: 1000   u: 10010   d: 100110   y: 100111   i: 101   a : 110   k: 1110   e: 1111   j: 0000   v: 0001   l: 001  &lt;空格&gt;: 01 </p>
</li>
<li><p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注 意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110 </p>
</li>
</ol>
<p>通过赫夫曼编码处理 长度为 133 </p>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h6><p> 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% , 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 ,赫夫曼编码是无损处理方案</p>
<h4 id="压缩代码实现"><a href="#压缩代码实现" class="headerlink" title="压缩代码实现"></a>压缩代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================简单封装了下边的所有方法,方便调用 =========================</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   压缩后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(String s)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodeList(s);    <span class="comment">//根据数据获取节点，并放入list集合中</span></span><br><span class="line">        Node tree = createHuffmanTree(nodes); <span class="comment">// 根据所有的节点获取霍夫曼树</span></span><br><span class="line">        Map&lt;Byte, String&gt; table = createHuffmanTable(tree); <span class="comment">// 根据霍夫曼树或取霍夫曼编码表</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = huffmanZip(table, s); <span class="comment">//根据编码表将数据压缩，并返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//===========将字符串中的每一个字符及其出现的频率保存到 List&lt;Node&gt; 集合中=============</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodeList</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="comment">//转换成字符数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">//遍历该字符数组,将数据放入map集合中，key为字符，value为当前字符出现频率</span></span><br><span class="line">        Map&lt;Byte,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = map.get(b);</span><br><span class="line">            <span class="comment">//如果不存在，就直接存入</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(b,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//存在就频率+1</span></span><br><span class="line">                map.put(b,count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历map,将map中的数据全部转换成 Node ，并保存到list中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================创建根据List&lt;Node&gt;集合创建赫夫曼树==================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出最小与次小的两个节点，组成新树，并加入到list中</span></span><br><span class="line">            Node leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode=list.get(<span class="number">1</span>);</span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight, leftNode, rightNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">            <span class="comment">//删除之前的两个最小值</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面循环结束，list中只有一个node节点，该节点就是一颗完整的 赫夫曼树</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================根据霍夫曼树，创建霍夫曼编码表==================</span></span><br><span class="line">	<span class="comment">//霍夫曼编码表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanTable=<span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">    <span class="comment">//用来拼接编码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node   节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code   编码, 0表示左子树，1表示右子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用来拼接编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="comment">//如果不是叶节点，则递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node.data==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123; <span class="comment">//向左递归,0表示</span></span><br><span class="line">                createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;<span class="comment">//向右递归,1表示</span></span><br><span class="line">                createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是叶节点，就直接将编码保存到huffmanTable中</span></span><br><span class="line">            huffmanTable.put(node.data,stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//为了简便调用，重构上面方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//===========根据霍夫曼编码表将字符串进行压缩，得到压缩后的byte数组=============</span></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanTable  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text          需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              压缩完后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(Map&lt;Byte,String&gt; huffmanTable, String text)&#123;</span><br><span class="line">        <span class="comment">//将文本变成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">// 用来保存字节数组根据编码表转换后的内容</span></span><br><span class="line">        <span class="comment">// 如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">        StringBuilder codes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历字节数组，根据编码表将值替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            codes.append(huffmanTable.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时codes保存了译码后的内容，还需将codes内容8位为一体，转变成字节放入压缩后的字节数组zip中</span></span><br><span class="line">        <span class="comment">//根据codes判断zip数组大小，也可以这样写: len=(builder.length()+7)/8</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(codes.length()%<span class="number">8</span>==<span class="number">0</span>)&#123; <span class="comment">//刚好除8没有余数</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果有余数，长度+1即可</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放压缩后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] zip=<span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//标记zip的下标</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历builder，每次获取8位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;codes.length();i+=<span class="number">8</span>)&#123;</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span>&gt;=codes.length())&#123;</span><br><span class="line">                <span class="comment">//如果超过长度，字节截取到最后即可</span></span><br><span class="line">                data=codes.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                data=codes.substring(i,i+<span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为builder是字符串类型，需要先转换成二进制类型，再变成字节类型</span></span><br><span class="line">            zip[index]=(<span class="keyword">byte</span>)Integer.parseInt(data,<span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 字符</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">// 权重（字符出现的频率）</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight-o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">byte</span> data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据解压-使用赫夫曼编码解码"><a href="#数据解压-使用赫夫曼编码解码" class="headerlink" title="数据解压(使用赫夫曼编码解码)"></a>数据解压(使用赫夫曼编码解码)</h3><ol>
<li><p>前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77 , -57, 6, -24, -14, -117, -4, -60, -90, 28] </p>
</li>
<li><p>现在要求使用赫夫曼编码， 进行解码，又 重新得到原来的字符串”i like like like java do you like a java”</p>
</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> flag  标记是否需要补高位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b     需要转换的字节</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>      转换后的二进制字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//将一个字节变成二进制字符串形式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byteToBinaryString</span><span class="params">(<span class="keyword">boolean</span> flag,<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先将字节转换成整数</span></span><br><span class="line">       <span class="keyword">int</span> temp=b;</span><br><span class="line">       <span class="comment">//需要补高位</span></span><br><span class="line">       <span class="comment">//如果temp=1，他的二进制为0000 0001，但是Integer.toBinaryString()方法输出会省略前面的0，直接输出 1，但是前面的0我们也是需要的</span></span><br><span class="line">       <span class="comment">//256=》 1 0000 0000 ， 1 =》 0000 0001， 1|256 =》 1 0000 0001 ，后面再截取最后8位，这样就能补齐高位</span></span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           temp =temp | <span class="number">256</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String str = Integer.toBinaryString(temp);</span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           <span class="comment">//如果补了高位，就截取最后 8 位</span></span><br><span class="line">           <span class="keyword">return</span> str.substring(str.length()-<span class="number">8</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没有补高位就直接返回</span></span><br><span class="line">           <span class="keyword">return</span> str;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> huffmanTable   赫夫曼编码表</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bytes          需要解压的字节数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>               解压后的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//开始解压</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] unzip(Map&lt;Byte,String&gt; huffmanTable,<span class="keyword">byte</span>[] bytes)&#123;</span><br><span class="line">       <span class="comment">//遍历字节数组，将每一个字节转换成二进制字符串，添加到stringBuilder</span></span><br><span class="line">       <span class="comment">//如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">       StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果是最后一位，则不需要补高位</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = i==bytes.length-<span class="number">1</span>;</span><br><span class="line">           stringBuilder.append(byteToBinaryString(!flag, bytes[i]));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//根据哈夫曼编码表将二进制字符串解码</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//先转换一下哈夫曼编码表</span></span><br><span class="line">       HashMap&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;Byte,String&gt; table:huffmanTable.entrySet())&#123;</span><br><span class="line">           map.put(table.getValue(),table.getKey());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始解码</span></span><br><span class="line">       List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 扫描 二进制字符串</span></span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (index&lt;stringBuilder.length())&#123;</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">1</span>;        <span class="comment">//用于计数</span></span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;  <span class="comment">//标记是否计数</span></span><br><span class="line">           String str;         <span class="comment">//用于拼接</span></span><br><span class="line">           Byte value = <span class="keyword">null</span>;         <span class="comment">//用于存放解码后的字节</span></span><br><span class="line">           <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">               str=stringBuilder.substring(index,index+count);</span><br><span class="line">               value=map.get(str);</span><br><span class="line">               <span class="keyword">if</span>(value==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//当前没有找到，继续查找，计数器+1</span></span><br><span class="line">                   count++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//找到，可以结束当前</span></span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到，将value放入list中，并且index指针向后移count次</span></span><br><span class="line">           list.add(value);</span><br><span class="line">           index+=count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将list中的数据全部放入一个字节数组中，返回</span></span><br><span class="line">       <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">           result[i]=list.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩 </p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> srcFile   希望压缩的文件路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dstFile   压缩后文件的路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileZip</span><span class="params">(String srcFile,String dstFile)</span></span>&#123;</span><br><span class="line">      <span class="comment">//文件输入流</span></span><br><span class="line">      InputStream in = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件输出流</span></span><br><span class="line">      OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件对象输出流</span></span><br><span class="line">      ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// ===============写入================</span></span><br><span class="line">          in=<span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">          <span class="comment">//用来存放文件数据</span></span><br><span class="line">          <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">          <span class="comment">//开始写入</span></span><br><span class="line">          in.read(bytes);</span><br><span class="line">          <span class="comment">//================压缩================</span></span><br><span class="line">          <span class="keyword">byte</span>[] zip = HuffmanCoding.zip(bytes);</span><br><span class="line">          <span class="comment">//================输出===============</span></span><br><span class="line">          os=<span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">          oos=<span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">          <span class="comment">//将数据写入</span></span><br><span class="line">          oos.writeObject(zip);</span><br><span class="line">          <span class="comment">//还需将赫夫曼编码表写入</span></span><br><span class="line">          oos.writeObject(HuffmanCoding.huffmanTable);</span><br><span class="line">          System.out.println(<span class="string">&quot;压缩成功~~~&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          System.out.println(e.getMessage());</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//关闭流</span></span><br><span class="line">              in.close();</span><br><span class="line">              os.close();</span><br><span class="line">              oos.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">              System.out.println((ex.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> zipFile  需要解压的文件路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile   解压后的文件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileUnzip</span><span class="params">(String zipFile,String srcFile)</span></span>&#123;</span><br><span class="line">       <span class="comment">//文件输入流</span></span><br><span class="line">       InputStream is=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件对象输入流</span></span><br><span class="line">       ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件输出流</span></span><br><span class="line">       OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//=================输入==============</span></span><br><span class="line">           is=<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">           ois=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">           <span class="comment">//读取数据</span></span><br><span class="line">           <span class="keyword">byte</span>[] bytes =(<span class="keyword">byte</span>[]) ois.readObject();</span><br><span class="line">           <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">           Map&lt;Byte,String&gt; huffmanCodes=(Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line">           <span class="comment">//=================解压==============</span></span><br><span class="line">           <span class="keyword">byte</span>[] result = HuffmanCoding.unzip(huffmanCodes, bytes);</span><br><span class="line">           <span class="comment">//=================输出==============</span></span><br><span class="line">           os=<span class="keyword">new</span> FileOutputStream(srcFile);</span><br><span class="line">           os.write(result);</span><br><span class="line">           System.out.println(<span class="string">&quot;解压成功~~~&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//关闭流</span></span><br><span class="line">               is.close();</span><br><span class="line">               ois.close();</span><br><span class="line">               os.close();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               System.out.println(e.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//因为是对二进制进行压缩，所以可以压缩视频即图片</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要压缩的文件</span></span><br><span class="line">       String srcFile=<span class="string">&quot;c://test.png&quot;</span>;</span><br><span class="line">        <span class="comment">//压缩后的地址</span></span><br><span class="line">       String dstFile=<span class="string">&quot;c://test.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//解压后的地址</span></span><br><span class="line">       String srcFile2=<span class="string">&quot;c://test2.png&quot;</span>;</span><br><span class="line">       <span class="comment">//压缩</span></span><br><span class="line">       fileZip(srcFile,dstFile);</span><br><span class="line">       <span class="comment">//解压</span></span><br><span class="line">       fileUnzip(dstFile,srcFile2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>赫夫曼树</tag>
        <tag>压缩</tag>
        <tag>解压</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树与平衡二叉树</title>
    <url>/2021/03/17/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树：BST (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。 </p>
<p>特别说明：<a id="more"></a>如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><a href="https://imgtu.com/i/6cOefO"><img src="https://s3.ax1x.com/2021/03/17/6cOefO.png" alt="6cOefO.png"></a></p>
<h3 id="二叉排序树创建和遍历"><a href="#二叉排序树创建和遍历" class="headerlink" title="二叉排序树创建和遍历"></a>二叉排序树创建和遍历</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   Node left;</span><br><span class="line">   Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//小的添加到左边</span></span><br><span class="line">        <span class="keyword">if</span>(node.value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点有左子树，则递归左子树进行添加</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.left=node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.value&gt;<span class="keyword">this</span>.value)&#123; <span class="comment">//大的添加到右边</span></span><br><span class="line">            <span class="comment">//如果当前节点有右子树，则递归右子树进行添加</span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">this</span>.right.add(node);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.right=node;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>1.需求先去找到要删除的结点 targetNode </p>
<p>2.找到 targetNode 的 父结点 parent </p>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 </p>
<ol>
<li><p>删除叶子节点  </p>
</li>
<li><p>删除只有一颗子树的节点  </p>
</li>
<li><p>删除有两颗子树的节点. </p>
</li>
</ol>
<h5 id="情况一-删除叶子节点"><a href="#情况一-删除叶子节点" class="headerlink" title="情况一: 删除叶子节点"></a>情况一: 删除叶子节点</h5><p>1.确定 targetNode 是 parent 的左子结点 还是右子结点 </p>
<p>2.根据前面的情况来对应删除 </p>
<p>左子结点 parent.left = null </p>
<p>右子结点 parent.right = null;</p>
<h5 id="情况二-删除只有一颗子树的节点"><a href="#情况二-删除只有一颗子树的节点" class="headerlink" title="情况二: 删除只有一颗子树的节点"></a>情况二: 删除只有一颗子树的节点</h5><p>1.确定 targetNode 的子结点是左子结点还是右子结点 </p>
<p>2.确定targetNode 是 parent 的左子结点还是右子结点</p>
<p>3.根据上面的判断让parent直接指向targetNode 的子节点</p>
<h5 id="情况三-：-删除有两颗子树的节点"><a href="#情况三-：-删除有两颗子树的节点" class="headerlink" title="情况三 ： 删除有两颗子树的节点"></a>情况三 ： 删除有两颗子树的节点</h5><p>1.从 targetNode 的右子树找到最小的结点  (从左子树中找最大值也一样)</p>
<p>2.用一个临时变量temp，将 最小结点的值</p>
<p>3.删除该最小结点 </p>
<p>4.将当前节点的值指向临时变量  ，  targetNode.value = temp</p>
<h4 id="代码实现（前提）"><a href="#代码实现（前提）" class="headerlink" title="代码实现（前提）"></a>代码实现（前提）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line"><span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMaxNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node     当作一棵树的根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>          最小值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMinNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> root.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"> <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(value==<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&gt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没找到就返回空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点的父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果value等于当前节点的左子树的值 或 右子树的值  就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value==value))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; value&gt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没找到就返回空</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代码实现-和兴"><a href="#代码实现-和兴" class="headerlink" title="代码实现 (和兴)"></a>代码实现 (和兴)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要删除的节点是根节点，并且当前树只有该根节点，直接自我删除即可</span></span><br><span class="line">        <span class="keyword">if</span>(value==root.value &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到要删除的节点</span></span><br><span class="line">        Node target = <span class="keyword">this</span>.search(value);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:没有value值为:&quot;</span>+value+<span class="string">&quot;的节点&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除节点的父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.searchParent(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况一:当前要删除的节点是叶节点</span></span><br><span class="line">        <span class="keyword">if</span>(target.right==<span class="keyword">null</span> &amp;&amp; target.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断target是parent的左子树还是右子树</span></span><br><span class="line">            <span class="keyword">if</span>(parent.left!=<span class="keyword">null</span> &amp;&amp; parent.left.value== target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.left=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right!=<span class="keyword">null</span> &amp;&amp; parent.right.value==target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.right=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target.right!=<span class="keyword">null</span> &amp;&amp; target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//情况二:删除有两个子树的节点</span></span><br><span class="line">            <span class="comment">//思路:将左子树中的最大值或右子树中的最小值删除，再填充到当前节点</span></span><br><span class="line">            <span class="comment">//获取右子树中的最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = getAndDeleteMinNode(target.right);</span><br><span class="line">            <span class="comment">//将最小值填充到target中</span></span><br><span class="line">            target.value=min;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取左子树中最大的值(两种方法随便选一个即可)</span></span><br><span class="line"><span class="comment">//            int max =getAndDeleteMaxNode(target.left);</span></span><br><span class="line">            <span class="comment">//将最大值填充到target中</span></span><br><span class="line"><span class="comment">//            target.value=max;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况三:删除只有一个子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//删除的节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//删除的节点有右子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><p>看一个案例(说明二叉排序树可能的问题) </p>
<p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在</p>
<p><a href="https://imgtu.com/i/6cx1xS"><img src="https://s3.ax1x.com/2021/03/17/6cx1xS.png" alt="6cx1xS.png"></a></p>
<ol>
<li><p>左子树全部为空，从形式上看，更像一个单链表. </p>
</li>
<li><p>插入速度没有影响 </p>
</li>
<li><p>查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 </p>
</li>
<li><p>解决方案-平衡二叉树(AVL)</p>
</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 </p>
</li>
<li><p>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 </p>
</li>
<li><p>举例说明, 看看下面哪些 AVL 树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6cx2I1"><img src="https://s3.ax1x.com/2021/03/17/6cx2I1.png" alt="6cx2I1.png"></a></p>
<h3 id="单旋转-左旋转"><a href="#单旋转-左旋转" class="headerlink" title="单旋转(左旋转)"></a>单旋转(左旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p>
<p><a href="https://imgtu.com/i/6czfTs"><img src="https://s3.ax1x.com/2021/03/17/6czfTs.png" alt="6czfTs.png"></a></p>
<h4 id="代码实现-核心"><a href="#代码实现-核心" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><h6 id="注-下面的代码全是在上面的二叉查找树的基础上完成的"><a href="#注-下面的代码全是在上面的二叉查找树的基础上完成的" class="headerlink" title="注:下面的代码全是在上面的二叉查找树的基础上完成的"></a>注:下面的代码全是在上面的二叉查找树的基础上完成的</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//左旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//复制当前节点</span></span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       <span class="comment">//将新节点的左子树变成当前节点的左子树</span></span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">       <span class="comment">//将新节点的右子树变成当前节点的右子树的左子树</span></span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">       <span class="comment">//将当前节点的右子树的值覆盖当前节点（即将右子树代替当前节点）</span></span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line">       <span class="comment">//将当前节点的左子树变成新节点</span></span><br><span class="line">       <span class="keyword">this</span>.left = newNode;</span><br><span class="line">       <span class="comment">//将当前节点的右子树变成当前节点的右子树的右子树</span></span><br><span class="line">       <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="单旋转-右旋转"><a href="#单旋转-右旋转" class="headerlink" title="单旋转(右旋转)"></a>单旋转(右旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p>
<p><a href="https://imgtu.com/i/6gSg9x"><img src="https://s3.ax1x.com/2021/03/17/6gSg9x.png" alt="6gSg9x.png"></a></p>
<h4 id="代码实现-核心-1"><a href="#代码实现-核心-1" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//右旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">       <span class="keyword">this</span>.right = newNode;</span><br><span class="line">       <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================	</span></span><br><span class="line"><span class="comment">//获取当前树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Math.max(node.left == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left), node.right == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取左子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取右子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><p>在之前二叉查找树的节点类的新增方法上添加以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">     <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) </span><br><span class="line">         leftRotate();</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         rightRotate();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。例如: </p>
<p>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.</p>
<p>int[] arr = {2,1,6,5,7,3};   运行原来的代码可以看到，并没有转成 AVL 树</p>
<h5 id="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"><a href="#解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）" class="headerlink" title="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"></a>解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）</h5><p>1.当符合右旋转的条件时 (左子树长)</p>
<p>2.如果它的左子树的右子树高度大于它的左子树的高度</p>
<p>3.先对当前这个结点的左节点进行左旋转</p>
<p>4.再对当前结点进行右旋转的操作即可</p>
<h4 id="改进代码-1"><a href="#改进代码-1" class="headerlink" title="改进代码"></a>改进代码</h4><p>在上面的改进代码中再次改进（有点绕，自己画个图就能理解了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">      <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果右子树的左子树高于右子树，需要先将右子树进行右旋</span></span><br><span class="line">          <span class="keyword">if</span>(right.leftHeight()&gt;right.rightHeight())&#123;</span><br><span class="line">              right.rightRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          leftRotate();</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果左子树的右子树高于左子树，需要先将左子树进行左旋</span></span><br><span class="line">          <span class="keyword">if</span>(left.rightHeight()&gt;left.leftHeight())&#123;</span><br><span class="line">              left.leftRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          rightRotate();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2021/03/19/%E5%9B%BE/</url>
    <content><![CDATA[<p>为什么要有图 </p>
<ol>
<li><p>前面我们学了线性表和树 </p>
</li>
<li><p>线性表局限于一个直接前驱和一个直接后继的关系 </p>
</li>
<li><p>树也只能有一个直接前驱也就是父节点 </p>
</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>当我们需要表示多对多的关系时， 这里我们就用到了图。</li>
</ol>
<h3 id="图的举例说明"><a href="#图的举例说明" class="headerlink" title="图的举例说明"></a>图的举例说明</h3><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图：</p>
<p><a href="https://imgtu.com/i/6feD5q"><img src="https://s4.ax1x.com/2021/03/19/6feD5q.png" alt="6feD5q.png"></a></p>
<h4 id="图的常用概念"><a href="#图的常用概念" class="headerlink" title="图的常用概念"></a>图的常用概念</h4><ol>
<li><p>顶点(vertex) </p>
</li>
<li><p>边(edge) </p>
</li>
<li><p>路径 </p>
</li>
<li><p>无向图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feoPx"><img src="https://s4.ax1x.com/2021/03/19/6feoPx.png" alt="6feoPx.png"></a></p>
<ol start="5">
<li><p>有向图 </p>
</li>
<li><p>带权图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feHxO"><img src="https://s4.ax1x.com/2021/03/19/6feHxO.png" alt="6feHxO.png"></a></p>
<h3 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h3><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。</p>
<p><a href="https://imgtu.com/i/6fm9Rf"><img src="https://s4.ax1x.com/2021/03/19/6fm9Rf.png" alt="6fm9Rf.png"></a></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ol>
<li><p>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. </p>
</li>
<li><p>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6fmiQS"><img src="https://s4.ax1x.com/2021/03/19/6fmiQS.png" alt="6fmiQS.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放各顶点之间关系的二维数组，权重1表示有链接，0表示无连接(矩阵图)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//存放所有的顶点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeCount;</span><br><span class="line">    <span class="comment">//是否已访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edgeCount=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1      边的一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2      边的另一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  权重 (这里1表示链接，0表示不连接)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2]=<span class="number">1</span>;</span><br><span class="line">        edges[v2][v1]=<span class="number">1</span>;</span><br><span class="line">        edgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===============其他常用方法==============</span></span><br><span class="line">    <span class="comment">//获取顶点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgesCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edgeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取v1与v2的权重(是否链接)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isClose</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回下标 i 对应的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印edges</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arr=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>&#125;;</span><br><span class="line">    	<span class="comment">//创建图，并添加顶点</span></span><br><span class="line">       Graph graph = <span class="keyword">new</span> Graph(arr.length);</span><br><span class="line">       <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">           graph.addVertex(s);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加边</span></span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       graph.showEdges();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先遍历介绍"><a href="#图的深度优先遍历介绍" class="headerlink" title="图的深度优先遍历介绍"></a>图的深度优先遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 访问策略: </p>
<p>(1)深度优先遍历 </p>
<p>(2)广度优先遍历</p>
<h4 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h4><p>图的深度优先搜索(Depth First Search) 。 </p>
<ol>
<li><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 </p>
</li>
<li><p>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 </p>
</li>
<li><p>显然，深度优先搜索是一个递归的过程</p>
</li>
</ol>
<h5 id="深度优先遍历算法步骤"><a href="#深度优先遍历算法步骤" class="headerlink" title="深度优先遍历算法步骤"></a>深度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v，并标记结点 v 为已访问。</p>
</li>
<li><p>查找结点 v 的第一个邻接结点 w。</p>
</li>
<li><p>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 </p>
</li>
<li><p>若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 </p>
</li>
<li><p>查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 </p>
</li>
</ol>
<h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前顶点第一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前顶点当前邻接点的下一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=w+<span class="number">1</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度遍历(DFS)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">       <span class="comment">//没有访问过</span></span><br><span class="line">       <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">           System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">           <span class="comment">//标识已访问</span></span><br><span class="line">           isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取第一个邻接点</span></span><br><span class="line">       <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">       <span class="comment">//如果有邻接点，循环遍历</span></span><br><span class="line">       <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果没有被访问，就访问，并标识</span></span><br><span class="line">           <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">              DFS(w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续访问下一个</span></span><br><span class="line">           w=getNextNeighbor(v,w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//重构深度遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">       isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; vertexList.size();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">               DFS(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历基本思想"><a href="#广度优先遍历基本思想" class="headerlink" title="广度优先遍历基本思想"></a>广度优先遍历基本思想</h4><ol>
<li><p>图的广度优先搜索(Broad First Search) 。</p>
</li>
<li><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 访问这些结点的邻接结点 </p>
</li>
</ol>
<h5 id="广度优先遍历算法步骤"><a href="#广度优先遍历算法步骤" class="headerlink" title="广度优先遍历算法步骤"></a>广度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v 并标记结点 v 为已访问。 </p>
</li>
<li><p>结点 v 入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。 </p>
</li>
<li><p>出队列，取得队头结点 u。 </p>
</li>
<li><p>查找结点 u 的第一个邻接结点 w。 </p>
</li>
<li><p>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： </p>
</li>
</ol>
<p>​    6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 </p>
<p>​    6.2 结点 w 入队列 </p>
<p>​    6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度遍历(BFS)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="comment">//用LinkedList模拟一个队列，输出一个数据就将它放入队尾</span></span><br><span class="line">      LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">//没有被访问</span></span><br><span class="line">      <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">          System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">          isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">          queue.addLast(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//获取队列头</span></span><br><span class="line">          v = (<span class="keyword">int</span>)queue.removeFirst();</span><br><span class="line">          <span class="comment">//获取第一个邻接点</span></span><br><span class="line">          <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">          <span class="comment">//如果有邻接点</span></span><br><span class="line">          <span class="keyword">while</span> (w!=-<span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">                  System.out.print(vertexList.get(w)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">                  isVisited[w]=<span class="keyword">true</span>;</span><br><span class="line">                  queue.addLast(w);</span><br><span class="line">              &#125;</span><br><span class="line">              w=getNextNeighbor(v,w);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重构广度遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">      isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">              BFS(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2021/03/19/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<p>汉诺塔的传说 </p>
<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度<a id="more"></a>一个古老传说的益智玩具。大梵天创造世界的时候做了三根金 刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小 顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p> 假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百 亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 </p>
<h3 id="汉诺塔游戏的演示和思路分析"><a href="#汉诺塔游戏的演示和思路分析" class="headerlink" title="汉诺塔游戏的演示和思路分析:"></a>汉诺塔游戏的演示和思路分析:</h3><p>分治算法解决汉诺塔问题<br>1.如果只有一个盘就直接从a移动到c<br>2.如果个数大&gt;=2,就将盘分成最下面一个盘与上面的所有盘<br>3.将上面的所有盘从a移动到b，最下面一个盘从a移动到c，最后把上面的所有盘从b移动到c，依次递归执行</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num    盘的个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a      柱子 1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b      柱子 2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c      柱子 3</span></span><br><span class="line"><span class="comment">    */</span> 	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果只有一个盘</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;盘 1 :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//将上面的所有盘从a移动到b</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">           <span class="comment">//最下面一个盘从a移动到c</span></span><br><span class="line">           System.out.println(<span class="string">&quot;盘 &quot;</span>+num+<span class="string">&quot; :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">           <span class="comment">//最后把上面的所有盘从b移动到c</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试汉诺塔</span></span><br><span class="line">       hanoi(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2021/03/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>最小生成树(Minimum Cost Spanning Tree)，简称 MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树</p>
<a id="more"></a>

<h2 id="普里姆（prim）算法"><a href="#普里姆（prim）算法" class="headerlink" title="普里姆（prim）算法"></a>普里姆（prim）算法</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的 连通子图，也就是所谓的极小连通子图</p>
<h3 id="修路问题"><a href="#修路问题" class="headerlink" title="修路问题"></a>修路问题</h3><p><a href="https://imgtu.com/i/6xhH2D"><img src="https://z3.ax1x.com/2021/03/27/6xhH2D.png" alt="6xhH2D.png"></a></p>
<ol>
<li><p>有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通 </p>
</li>
<li><p>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 </p>
</li>
<li><p>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h4><p>有n个顶点，则需要获取n-1条边</p>
<p>每一次获取边一条边的步骤:</p>
<p>1.假如从A开始，将A设为已访问，获取所有已访问与未访问相连的边 如 &lt;A,C&gt;=7   &lt;A,B&gt;=5    &lt;A,G&gt;=2</p>
<p>2.上面三条边中取权值最小的一条边:&lt;A,G&gt;=2,并将G设为已访问</p>
<p>接下来获取第二条边时，A   G  已经是访问过的点了</p>
<p>可以获取 &lt;A,C&gt;=7   &lt;A,B&gt;=5   &lt;G,B&gt;=3   &lt;G,E&gt;=4   &lt;G,F&gt;=6   这5条边，选择最小的一条边: &lt;G,B&gt;=3,并将B设为已访问</p>
<p>循环 n-1次上面的操作</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  需要生产最小数的图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v      从哪个顶点下标开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(Graph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.vertexNum];</span><br><span class="line">        <span class="comment">//标记当前被访问过</span></span><br><span class="line">        isVisited[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记当前生产边的两个点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存放最小值，初始值可以用无穷大代替</span></span><br><span class="line">        <span class="keyword">int</span> minWeight=<span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为普利姆算法最后产生顶点个数x-1条边，每循环一次添加一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt; graph.vertexNum-<span class="number">1</span>;n++)&#123;</span><br><span class="line">            <span class="comment">// i 表示被访问过的顶点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; graph.vertexNum;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示没有被访问过的顶点下标</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph.vertexNum;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVisited[i]==<span class="number">1</span> &amp;&amp; isVisited[j]==<span class="number">0</span> &amp;&amp; graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        <span class="comment">//替换最小值 与顶点</span></span><br><span class="line">                        minWeight=graph.weight[i][j];</span><br><span class="line">                        h1=i;</span><br><span class="line">                        h2=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结束上面两个循环，就生产了一条边</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span>+graph.data[h1]+<span class="string">&quot;,&quot;</span>+graph.data[h2]+<span class="string">&quot;&gt;,&quot;</span>+minWeight);</span><br><span class="line">            <span class="comment">//标记当前点已访问</span></span><br><span class="line">            isVisited[h2]=<span class="number">1</span>;</span><br><span class="line">            minWeight=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexNum  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight     矩阵图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Graph <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum,<span class="keyword">char</span>[] data,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertexNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            graph.data[i]=data[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;</span><br><span class="line">                graph.weight[i][j]=weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> vertexNum;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] data;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexNum = vertexNum;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">        <span class="keyword">this</span>.weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顶点</span></span><br><span class="line">        <span class="keyword">char</span>[] data=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 矩阵图</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight=&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Graph graph = minTree.createGraph(data.length,data,weight);</span><br><span class="line">        <span class="comment">//生产最小数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最段路:&quot;</span>);</span><br><span class="line">        minTree.prim(graph,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h2><ol>
<li><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 </p>
</li>
<li><p>基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 </p>
</li>
<li><p>具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森 林中不产生回路，直至森林变成一棵树为止</p>
</li>
</ol>
<h3 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h3><p><a href="https://imgtu.com/i/6xoaWV"><img src="https://z3.ax1x.com/2021/03/27/6xoaWV.png" alt="6xoaWV.png"></a></p>
<ol>
<li><p>有北京有新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 </p>
</li>
<li><p>各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 </p>
</li>
<li><p>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第 1 步：将边加入 R 中。 边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbSmD"><img src="https://z3.ax1x.com/2021/03/27/6xbSmD.png" alt="6xbSmD.png"></a></p>
<p>第 2 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。</p>
<p><a href="https://imgtu.com/i/6xb9TH"><img src="https://z3.ax1x.com/2021/03/27/6xb9TH.png" alt="6xb9TH.png"></a></p>
<p>第 3 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbitA"><img src="https://z3.ax1x.com/2021/03/27/6xbitA.png" alt="6xbitA.png"></a></p>
<p>第 4 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbFfI"><img src="https://z3.ax1x.com/2021/03/27/6xbFfI.png" alt="6xbFfI.png"></a></p>
<p>第 5 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbApt"><img src="https://z3.ax1x.com/2021/03/27/6xbApt.png" alt="6xbApt.png"></a></p>
<p>第 6 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbE1P"><img src="https://z3.ax1x.com/2021/03/27/6xbE1P.png" alt="6xbE1P.png"></a></p>
<p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt;  &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;     </p>
<h5 id="克鲁斯卡尔算法重点需要解决的以下两个问-题："><a href="#克鲁斯卡尔算法重点需要解决的以下两个问-题：" class="headerlink" title="克鲁斯卡尔算法重点需要解决的以下两个问 题："></a>克鲁斯卡尔算法重点需要解决的以下两个问 题：</h5><h6 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h6><p>对图的所有边按照权值大小进行排序。很好解决，采用排序算法进行排序即可。</p>
<h6 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h6><p>将边添加到最小生成树中时，怎么样判断是否形成了回路。 </p>
<p>记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。 然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123; </span><br><span class="line">    <span class="comment">//用无穷大表示不存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line">    <span class="comment">//所有顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里全部采用复制拷贝的方式初始化，而不是直接赋值，是为了不改变原来传进来vertex，weight的值</span></span><br><span class="line">        <span class="keyword">int</span> len = vertex.length;</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="keyword">this</span>.vertex = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertex[i] = vertex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化矩阵图 与 边的个数</span></span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.weight[i][j] = weight[i][j];</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF &amp;&amp; weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edgeNum /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心算法(生产最小树)</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] kruskal() &#123;</span><br><span class="line">        <span class="comment">//存放最终结果</span></span><br><span class="line">        Edge[] result = <span class="keyword">new</span> Edge[vertex.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存放各个顶点的终点，该数组是不断变化的</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length];</span><br><span class="line">        <span class="comment">//获取所有边</span></span><br><span class="line">        Edge[] edges = getAllEdge();</span><br><span class="line">        <span class="comment">//将边从小到大排序</span></span><br><span class="line">        sort(edges);</span><br><span class="line">        <span class="comment">//遍历排序后的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取边的两个点的下标</span></span><br><span class="line">            <span class="keyword">char</span> v1 = edges[i].from;</span><br><span class="line">            <span class="keyword">int</span> p1 = getIndexOfVertex(v1);</span><br><span class="line">            <span class="keyword">char</span> v2 = edges[i].to;</span><br><span class="line">            <span class="keyword">int</span> p2 = getIndexOfVertex(v2);</span><br><span class="line">            <span class="comment">//然后获取两个点的终点,如果终点的值为0，返回的就是它的自己下标</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p1);</span><br><span class="line">            <span class="keyword">int</span> m =getEnd(ends,p2);</span><br><span class="line">            <span class="comment">//如果两个点的终点不一样就加入到树中,并且标记终点</span></span><br><span class="line">            <span class="keyword">if</span> (n != m) &#123;</span><br><span class="line">                result[index++] = edges[i];</span><br><span class="line">                ends[n] = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============其他补充的重要方法======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 存放每个顶点对应的终点，如果下标是0，则表示终点是自己</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需要查找终点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下标 i 对应的终点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取下标 i 的终点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据顶点获取该顶点所在的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndexOfVertex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex[i] == v) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边排序(从小到大,冒泡)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Edge[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    Edge temp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有边,如果边为INT 或 0（本身）则不显示</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] getAllEdge() &#123;</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> Edge[edgeNum];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF) &#123;</span><br><span class="line">                    Edge edge = <span class="keyword">new</span> Edge(vertex[i], vertex[j], weight[i][j]);</span><br><span class="line">                    edges[index++] = edge;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%13d&quot;</span>, weight[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> from;</span><br><span class="line">    <span class="keyword">char</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">char</span> from, <span class="keyword">char</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span> + from + <span class="string">&quot;,&quot;</span></span><br><span class="line">                + to +</span><br><span class="line">                <span class="string">&quot;&gt;=&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span>[][] weight = &#123;</span><br><span class="line">               <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">               <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">               <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">               <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">               <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">               <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//创建</span></span><br><span class="line">       Kruskal kruskal = <span class="keyword">new</span> Kruskal(vertex, weight);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       kruskal.show();</span><br><span class="line">       <span class="comment">//开始生产最小树</span></span><br><span class="line">       Edge[] result = kruskal.kruskal();</span><br><span class="line">       System.out.println(<span class="string">&quot;最小树为:&quot;</span>);</span><br><span class="line">       System.out.println(Arrays.toString(result));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>prim</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2021/03/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以 起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<p><a href="https://imgtu.com/i/6xz77V"><img src="https://z3.ax1x.com/2021/03/27/6xz77V.png" alt="6xz77V.png"></a></p>
<p>如何计算出 G 到 其它各个点的最短距离?</p>
<a id="more"></a>

<h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><ol>
<li><p>设置出发顶点为 G，顶点集合 V{v1,v2,vi…}，G 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis 集合记录着 G 到图中各顶点的距离(到自身可以看作 0，G 到 vi 距离对应为 di) </p>
</li>
<li><p>从 Dis 中选择值最小且没有访问的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 G 到 vi 即为最短路径</p>
</li>
<li><p>更新 Dis 集合，更新规则为：比较 G 到 V 集合中顶点的距离值，与 G 通过 vi 到 V 集合中顶点的距离值，保留 值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) </p>
</li>
<li><p>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dgraph</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line">    VisitedVertex vv;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 从哪个顶点开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//迪杰斯特拉算法，生产最短路径，结果在vv中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        vv=<span class="keyword">new</span> VisitedVertex(vertex.length,index);</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        vv.update(index,weight);</span><br><span class="line">        <span class="comment">//每循环一次，获取下一个位还没有访问的最小距离的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            index = vv.getNextVertex();</span><br><span class="line">            <span class="comment">//标记该顶点已访问</span></span><br><span class="line">            vv.visited[index]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//根据下一个顶点进行更新</span></span><br><span class="line">            vv.update(index,weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dgraph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showVV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vv.show(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints:weight)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取具体某个顶点路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        vv.getLoad(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放算法所需要的数组及方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span></span>&#123;</span><br><span class="line">    <span class="comment">//标记是顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">//标记出发点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] dis;</span><br><span class="line">    <span class="comment">//标记到该顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] pre_visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  从哪个顶点开始出发，寻找最短路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        dis=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        pre_visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="comment">//将其他顶点的距离设为最大值</span></span><br><span class="line">        Arrays.fill(dis,<span class="number">65532</span>);</span><br><span class="line">        <span class="comment">//本身的距离设置为0</span></span><br><span class="line">        dis[index]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记本身访问过</span></span><br><span class="line">        visited[index]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//前驱就是本身</span></span><br><span class="line">        pre_visited[index]=index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据index顶点与矩阵图更新VisitedVertex中的各个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="comment">//起点到index的距离加index到j的距离</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//遍历当前顶点的邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight[index].length;j++)&#123;</span><br><span class="line">            len=dis[index]+weight[index][j];</span><br><span class="line">            <span class="comment">//如果j点没有被访问，并且len小于起点到j的距离，则替换距离，并标记前驱</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; len&lt;dis[j])&#123;</span><br><span class="line">                dis[j]=len;</span><br><span class="line">                pre_visited[j]=index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取下一个顶点，如果当前顶点没有被访问，并且起点到该点的距离最小，就返回该点下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">65532</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dis.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; dis[j]&lt;min)&#123;</span><br><span class="line">                min=dis[j];</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径(dis)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span>[] vertex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">            System.out.print(vertex[i]+<span class="string">&quot;(&quot;</span>+dis[i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据某一个终点获取具体路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pre_visited[end]!=end) &#123;</span><br><span class="line">            System.out.print(end+<span class="string">&quot;&lt;=&quot;</span>);</span><br><span class="line">            end=pre_visited[end];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//表示该路不存在</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">65532</span>;</span><br><span class="line">        weight[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        weight[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        weight[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        weight[<span class="number">3</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        weight[<span class="number">4</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        weight[<span class="number">5</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        weight[<span class="number">6</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Dgraph graph = <span class="keyword">new</span> Dgraph(vertex, weight);</span><br><span class="line">        <span class="comment">//查看图的矩阵图</span></span><br><span class="line">        graph.show();</span><br><span class="line">        <span class="comment">//生产最短路径(从C开始)</span></span><br><span class="line">        graph.dijkstra(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最短路径:&quot;</span>);</span><br><span class="line">        graph.showVV();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n从C到D的路劲为:&quot;</span>);</span><br><span class="line">        graph.getLoad(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h2><ol>
<li><p>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法 名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 </p>
</li>
<li><p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p>
</li>
<li><p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 </p>
</li>
<li><p>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点 的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每 一个顶点到其他顶点的最短路径。</p>
</li>
</ol>
<h4 id="弗洛伊德-Floyd-算法图解分析"><a href="#弗洛伊德-Floyd-算法图解分析" class="headerlink" title="弗洛伊德(Floyd)算法图解分析"></a>弗洛伊德(Floyd)算法图解分析</h4><p><a href="https://imgtu.com/i/6zpMrR"><img src="https://z3.ax1x.com/2021/03/27/6zpMrR.png" alt="6zpMrR.png"></a></p>
<p>第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为：</p>
<ol>
<li>以 A 顶点作为中间顶点是，B-&gt;A-&gt;C = 12，C-&gt;A-&gt;G = 9 , B-&gt;A-&gt;G = 7 </li>
</ol>
<p>这里只需变换 B-&gt;C   与 C-&gt;G 的中间点，因为B-&gt;A-&gt;G = 7 路线更长，不需要变换</p>
<ol start="2">
<li>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li>
</ol>
<p><a href="https://imgtu.com/i/6zpOy9"><img src="https://z3.ax1x.com/2021/03/27/6zpOy9.png" alt="6zpOy9.png"></a></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fgraph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图(距离)</span></span><br><span class="line">    <span class="keyword">int</span>[][] dis;</span><br><span class="line">    <span class="comment">//中间顶点图（前驱）</span></span><br><span class="line">    <span class="keyword">int</span>[][] pre;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fgraph</span><span class="params">(<span class="keyword">char</span>[] vertex,<span class="keyword">int</span>[][] dis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex=vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis=dis;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            Arrays.fill(pre[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弗洛伊德算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// k 表示中间点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="comment">// i 表示起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示终点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertex.length;j++)&#123;</span><br><span class="line">                    len=dis[i][k]+dis[k][j]; <span class="comment">//表示起点 i 经过中间点 m ，再到终点 j 的距离</span></span><br><span class="line">                    <span class="comment">//如果 len 小于 起点直接到终点的距离，就替换距离与前驱点</span></span><br><span class="line">                    <span class="keyword">if</span>(len&lt;dis[i][j])&#123;</span><br><span class="line">                        dis[i][j]=len;</span><br><span class="line">                        <span class="comment">//替换前驱点(中间点)</span></span><br><span class="line">                        pre[i][j]=pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出pre与dis</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]]+<span class="string">&quot;\t\t\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span>+vertex[k]+<span class="string">&quot;-&gt;&quot;</span>+vertex[i]+<span class="string">&quot;=&quot;</span>+dis[k][i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">        dis[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">        dis[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">        dis[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        dis[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        dis[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Fgraph graph = <span class="keyword">new</span> Fgraph(vertex,dis);</span><br><span class="line">        System.out.println(<span class="string">&quot;距离图与前驱图:&quot;</span>);</span><br><span class="line">        graph.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n弗洛伊德计算后:&quot;</span>);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/03/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题：有一个背包，容量为 4 磅 ， 现有如下物品</p>
<p><a href="https://imgtu.com/i/6xs1Ag"><img src="https://z3.ax1x.com/2021/03/27/6xs1Ag.png" alt="6xs1Ag.png"></a></p>
<ol>
<li><p>要求达到的目标为装入的背包的<a id="more"></a>总价值最大，并且重量不超出 </p>
</li>
<li><p>要求装入的物品不能重复</p>
</li>
</ol>
<p>这里属于01背包问题，即每件物品只能放一次</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>算法的主要思想，利用动态规划来解决</p>
<p>1.定义物品的价格： p ，重量 w ，再定义一张表（列表示包能装的重量，行表示每一个物品）</p>
<p>2.遍历每一个物品，如果当前物品重量大于当前背包能装的重量，就采取前一个策列来装物品</p>
<p>3.如果包能装的重量大于或等于当前物品的重量，就需要判断— 上一个策略的价格 与 当前物品价格加剩余空间物品的价格，</p>
<p>哪个大，就把大的转入背包</p>
<p><a href="https://imgtu.com/i/6xsr4J"><img src="https://z3.ax1x.com/2021/03/27/6xsr4J.png" alt="6xsr4J.png"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的价格</span></span><br><span class="line">        <span class="keyword">int</span>[] p = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包容量</span></span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//物品个数</span></span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="comment">//表（列表示包能装的重量，行表示每一个物品）</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//标记当前物品路径</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//遍历整个表（因为表的大小是n+1，all+1，所以要从1开始遍历，将0出省略）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;        <span class="comment">// i表示第几个物品，j表示第几个重量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果包能装的重量小于当前物品重量，则采取向上的策略</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//包能装的重量大于或等于当前物品的重量，</span></span><br><span class="line">                    <span class="comment">//上一个策略的价格 与 当前物品价格加剩余空间物品的价格</span></span><br><span class="line">                    <span class="comment">//v[i-1][j]表示上一个策略的价格</span></span><br><span class="line">                    <span class="comment">//p[i-1]表示当前物品价格，v[i-1][all-w[i-1]]表示总重量减去当前物品重量在上一个策略中的价格</span></span><br><span class="line"><span class="comment">//                    v[i][j]=Math.max(v[i-1][j],p[i-1]+v[i-1][all-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//注:当加入的path之后，不能像上面一样直接填写价格高的，这里还需分开，如果当前物品加上一个策略剩余物品价格要高，就在path中添加当前物品标记</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j]=p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]];</span><br><span class="line">                        path[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        v[i][j]=v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将添加的物品表示出来</span></span><br><span class="line">        <span class="comment">//反向遍历，如果该物品标记了，就输出，并且将当前背包的重量减去当前物品重量</span></span><br><span class="line">        <span class="keyword">int</span> i=path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加了&quot;</span>+i+<span class="string">&quot;号物品&quot;</span>);</span><br><span class="line">                j-= w[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;填表过程:&quot;</span>);</span><br><span class="line">        show(v);</span><br><span class="line">        System.out.println(<span class="string">&quot;path标记:&quot;</span>);</span><br><span class="line">        show(path);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[][] v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>马踏棋盘算法</title>
    <url>/2021/03/27/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>马踏棋盘算法也被称为骑士周游问题 </p>
</li>
<li><p>将马随机放在国际象棋的 8×8 棋盘的某个方格中，马按走棋规则(马走日字)进行移动。要求 每个方格只进入一次，走遍棋盘上全部 64 个方格</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6zFtu4"><img src="https://z3.ax1x.com/2021/03/27/6zFtu4.png" alt="6zFtu4.png"></a></p>
<a id="more"></a>

<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发 现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……</p>
<p>1.假设当前位置可以走，设置当前已访问，并标记步数</p>
<p>1.获取马儿当前位置可以走的所有位置</p>
<p>2.遍历所有位置，如果该位置没走就递归走</p>
<p>3.一旦步数达到了棋盘总数，就标记  finished</p>
<p>3.如果遍历完毕，马儿走的步数没达到棋盘总数，或则没有完成，就表示当前位置走不了，清空当前位置的步数，且标记为未访问</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋盘的总列数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> X ;</span><br><span class="line">   <span class="comment">//棋盘的中行数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> Y;</span><br><span class="line">   <span class="comment">//马儿是否走过的位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">   <span class="comment">//开始走</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> row  当前马儿所在的 行 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> col  当前马儿所在的 列 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> step  当前的步数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>[][] chessBoard,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前步数</span></span><br><span class="line">       chessBoard[row][col]=step;</span><br><span class="line">       <span class="comment">//标记当前走过,当前位置在一位数组中表示: 当前行*总列数+当前列</span></span><br><span class="line">       visited[row*X+col]=<span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//获取当前位置可以走的位置</span></span><br><span class="line">       List&lt;Point&gt; nextList = getNext(<span class="keyword">new</span> Point(col, row));</span><br><span class="line">       <span class="comment">//遍历所有的下一步</span></span><br><span class="line">       <span class="keyword">while</span> (!nextList.isEmpty()) &#123;</span><br><span class="line">           Point next = nextList.remove(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//如果下一步没走，就走该位置</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[next.y*X+next.x])&#123;</span><br><span class="line">               go(chessBoard,next.y,next.x,step+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断马儿是否完成了任务</span></span><br><span class="line">       <span class="comment">// 如果上面的循环结束，step没有走到X*Y步，并且还没完成，就将当前位置设置成未访问，并且清空当前位置的步数</span></span><br><span class="line">       <span class="comment">// 如果 step==X*Y ,表示走完，将finished=true; 之后回溯的过程中就不需要清空当前位置的步数了</span></span><br><span class="line">       <span class="keyword">if</span>(step&lt;X*Y &amp;&amp; !finished )&#123;</span><br><span class="line">           chessBoard[row][col]=<span class="number">0</span>;</span><br><span class="line">           visited[row*X+col]=<span class="keyword">false</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           finished=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//获取当前马儿可以走的路线</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point&gt; <span class="title">getNext</span><span class="params">(Point curr)</span></span>&#123;</span><br><span class="line">       List&lt;Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Point p = <span class="keyword">new</span> Point();</span><br><span class="line">       <span class="comment">// 5</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 7</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 0</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 1</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X=<span class="number">6</span>;</span><br><span class="line">        Y=<span class="number">6</span>;</span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span> [][] chessBoard=<span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[X*Y];</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始走</span></span><br><span class="line">        go(chessBoard,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;消耗&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">//输出棋盘</span></span><br><span class="line">        System.out.println(<span class="string">&quot;棋盘为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] ints:chessBoard)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i:ints)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用贪心算法进行优化"><a href="#使用贪心算法进行优化" class="headerlink" title="使用贪心算法进行优化"></a>使用贪心算法进行优化</h4><p>基本思路: 遍历所有下一步可走的位置时，不直接遍历，先对该结果进行排序</p>
<p>排序规则: 当前位置的下一次可走位置次数越大，就排在越前面</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>再上面的遍历nextList的代码上加上  sort(nextList)   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序  point下一次可以走的次数递增排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Point&gt; list)</span></span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取下一步可以走的步数</span></span><br><span class="line">                <span class="keyword">int</span> count1=getNext(o1).size();</span><br><span class="line">                <span class="keyword">int</span> count2=getNext(o2).size();</span><br><span class="line">                <span class="keyword">if</span>(count1-count2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1-count2==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>贪心算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2021/03/27/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配问题：</p>
<ol>
<li><p>有一个字符串 str1= “我是我是怪狗 我是我是怪狗狗”，和一个子串 str2=”我是怪狗狗” </p>
</li>
<li><p>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
</li>
</ol>
<a id="more"></a>

<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><p>并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: </p>
<ol>
<li><p>如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 </p>
</li>
<li><p>如果失配（即 str1[i]! = str2[j]），令 i = i - j + 1，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 </p>
</li>
<li><p>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量 的时间。(不可行!)</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violence</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] s1=str1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2=str2.toCharArray();</span><br><span class="line">       <span class="comment">//指向s1的指针</span></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//指向s2的指针</span></span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;s1.length &amp;&amp; j&lt;s2.length)&#123;</span><br><span class="line">           <span class="comment">//如果匹配</span></span><br><span class="line">           <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//不匹配</span></span><br><span class="line">               <span class="comment">//i 回退到之前的位置，并且向前移动一位</span></span><br><span class="line">               i=i-j+<span class="number">1</span>;</span><br><span class="line">               j=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,</span></span><br><span class="line">       <span class="keyword">if</span>(j==s2.length)&#123;</span><br><span class="line">           <span class="keyword">return</span> i-j;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>介绍《部分匹配表》怎么产生的 </p>
<p>先介绍前缀，后缀是什么</p>
<p><a href="https://imgtu.com/i/6x2JOI"><img src="https://z3.ax1x.com/2021/03/27/6x2JOI.png" alt="6x2JOI.png"></a></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度,例如</p>
<p>”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1；</p>
<p>”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2；</p>
<h5 id="”部分匹配”的实质是"><a href="#”部分匹配”的实质是" class="headerlink" title="”部分匹配”的实质是:"></a>”部分匹配”的实质是:</h5><p>字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么 它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候如果发现 最后一个D不匹配，这时第二个”AB”向前移动 4 位（字符串长度   减去   部分匹配值），就可以来到第一个”AB”的位置。再继续匹配</p>
<p><a href="https://imgtu.com/i/6x2yXn"><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></a></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”</p>
<p><a href="https://imgtu.com/i/6xRQH0"><img src="https://z3.ax1x.com/2021/03/27/6xRQH0.png" alt="6xRQH0.png"></a></p>
<p><a href="https://imgtu.com/i/6xRBE6"><img src="https://z3.ax1x.com/2021/03/27/6xRBE6.png" alt="6xRBE6.png"></a></p>
<p>6.这个时候，如果是暴力算法，就会将继续遍历第三步中 Str1 的下一个字符与str2的第一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这 样就提高了效率）</p>
<p>7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》</p>
<p><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></p>
<p>8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数： </p>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值 </p>
<p>因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p>
<p><a href="https://imgtu.com/i/6xWDLn"><img src="https://z3.ax1x.com/2021/03/27/6xWDLn.png" alt="6xWDLn.png"></a></p>
<p><a href="https://imgtu.com/i/6xWhQJ"><img src="https://z3.ax1x.com/2021/03/27/6xWhQJ.png" alt="6xWhQJ.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str1  所有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str2  需要查找的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> next  str2的部分匹配表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>      需要查找的值的下标，没找到就返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">      <span class="comment">//  i扫描，j扫描str2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ========核心代码===========</span></span><br><span class="line">          <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; str1.charAt(i)!=str2.charAt(j))&#123;</span><br><span class="line">              j=next[j-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果j扫描完毕，就返回下标（因为上面 j++ 了，而 i 没来得及 ++ ，所以后面要 +1 ）</span></span><br><span class="line">          <span class="keyword">if</span>(j==str2.length())&#123;</span><br><span class="line">              <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取一个字符串的部分匹配表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String str)&#123;</span><br><span class="line">      <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">      <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line">      <span class="comment">//第一个数据默认为0（没有前缀与后缀）</span></span><br><span class="line">      next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">          <span class="comment">//如果不匹配，不能直接让len=0，要让len变成匹配表中上一位的匹配值指向的位置</span></span><br><span class="line">          <span class="keyword">while</span>(len&gt;<span class="number">0</span> &amp;&amp; chars[i]!=chars[len])&#123;</span><br><span class="line">              len=next[len-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// i表示当前截取的字符最后一位，如果char[i]==char[len],表示匹配了，匹配值就在上一次的基础上+1,len也要向后移动一位，为了下一次的匹配</span></span><br><span class="line">          <span class="keyword">if</span>(chars[i]==chars[len])&#123;</span><br><span class="line">              len++;</span><br><span class="line">              next[i]=len;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符匹配</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/03/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。<a id="more"></a></p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h4><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>双重for循环，暴力求解</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] ints=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>( (nums[i]+nums[j]) == target)&#123;</span><br><span class="line">                   ints[<span class="number">0</span>]=i;</span><br><span class="line">                   ints[<span class="number">1</span>]=j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ints;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>1.创建一个map集合，key为数组中的值，value为数组当前值的下标</p>
<p>2.循环遍历数组,查询map中是否存在 target 减去 当前值这个key </p>
<p>3.不存在就将当前值为key，下标为value ，存入map中</p>
<p>4.如果存在就直接返回</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>合并有序链表</title>
    <url>/2021/03/28/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/cpVCqO"><img src="https://z3.ax1x.com/2021/03/28/cpVCqO.png" alt="cpVCqO.png" style="zoom: 80%;" /></a></p>
<h3 id="思路一-迭代"><a href="#思路一-迭代" class="headerlink" title="思路一:迭代"></a>思路一:迭代</h3><p>1.创建一个头节点head，用来存放结果，curr指向当前插入的位置</p>
<p>2.循环比较 l1.val 与 l2.val , 哪个小就添加到 curr .next ,并后移,直到一个链表全部遍历完毕</p>
<p>3.将另一个链表中剩余的值 直接添加到curr.next</p>
<p>4.返回 head.next</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放返回的结果</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="comment">//遍历两个链表，依次加入到 head中</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next= (l1!=<span class="keyword">null</span>? l1:l2);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-递归"><a href="#思路二-递归" class="headerlink" title="思路二:递归"></a>思路二:递归</h3><p>l1.val 与 l2.val 比较，哪个小就递归该节点的下一个节点与较大的节点，并返回该小的节点</p>
<p>思路都差不多，看代码理解吧~~</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出口，哪个链表先结束就获取另一个链表</span></span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//哪个小就返回哪个，并且再返回前还需将当前较小的节点递归调用获取下一个节点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">           l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="提升"><a href="#提升" class="headerlink" title="提升:"></a>提升:</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="思路一-暴力求解（不推荐）"><a href="#思路一-暴力求解（不推荐）" class="headerlink" title="思路一:暴力求解（不推荐）"></a>思路一:暴力求解（不推荐）</h3><p>遍历数组中所有的链表，全部添加到一个新的链表，再对新链表排序，简单粗暴</p>
<h3 id="思路二-逐一合并"><a href="#思路二-逐一合并" class="headerlink" title="思路二:逐一合并"></a>思路二:逐一合并</h3><p>创建一条新链表，再遍历链表数组，将每一条链表与新链表合并，而合并两条链表再上面已讲解</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//逐一合并</span></span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            res=mergeTwoLists(res,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路三-两两合并-分治思想"><a href="#思路三-两两合并-分治思想" class="headerlink" title="思路三:两两合并(分治思想)"></a>思路三:两两合并(分治思想)</h3><p>根据下标将链表数组分成左右两部分，再递归将左右两部分继续分，直到分不了为止</p>
<p>依次将最小的两链表合并，并返回</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//两两合并,分治思想</span></span><br><span class="line">       <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">           <span class="keyword">return</span> lists[left];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取中间下标</span></span><br><span class="line">       <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//向左递归分</span></span><br><span class="line">       ListNode list1 = merge(lists, left, mid);</span><br><span class="line">       <span class="comment">//向右递归分</span></span><br><span class="line">       ListNode list2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">       <span class="comment">//将上面递归出来的两条链表合并，并返回</span></span><br><span class="line">       <span class="keyword">return</span> mergeTwoLists(list1,list2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路四-两两合并-迭代思想"><a href="#思路四-两两合并-迭代思想" class="headerlink" title="思路四:两两合并(迭代思想)"></a>思路四:两两合并(迭代思想)</h3><p>与上面实录差不多，只不过这里没有用递归而已</p>
<p> 将数组中相邻的两个链表进行合并，并依次添加到数组左边，数组大小依次压缩2倍，直到大小为1，并这最后的一个链表返回即可</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两两合并,迭代思想</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标志数组长度，依次 /2</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//如果只剩一个，直接添加就行</span></span><br><span class="line">                <span class="keyword">if</span>(i==k-<span class="number">1</span>)&#123;</span><br><span class="line">                    lists[index++]=lists[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lists[index++]=mergeTwoLists(lists[i],lists[i+<span class="number">1</span>]);<span class="comment">//合并</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压缩后更新数组大小</span></span><br><span class="line">            k=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>分治</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2021/03/28/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<a id="more"></a>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cpkusU"><img src="https://z3.ax1x.com/2021/03/28/cpkusU.png" alt="cpkusU.png"></a></p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p><a href="https://imgtu.com/i/cpkQZ4"><img src="https://z3.ax1x.com/2021/03/28/cpkQZ4.png" alt="cpkQZ4.png"></a></p>
<p>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：matrix = [[1]]<br>输出：[[1]]</p>
<h3 id="思路一-暴力求解"><a href="#思路一-暴力求解" class="headerlink" title="思路一:暴力求解"></a>思路一:暴力求解</h3><p>通过一个辅助数组完成</p>
<p>对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：</p>
<p><a href="https://imgtu.com/i/cpk0dH"><img src="https://z3.ax1x.com/2021/03/28/cpk0dH.png" alt="cpk0dH.png"></a></p>
<p>并且，第一行的第 x<em>x</em> 个元素在旋转后恰好是倒数第一列的第 x<em>x</em> 个元素。</p>
<p>对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：</p>
<p><a href="https://imgtu.com/i/cpkrFA"><img src="https://z3.ax1x.com/2021/03/28/cpkrFA.png" alt="cpkrFA.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，通过一个辅助数组完成</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                temp[j][temp.length-<span class="number">1</span>-i]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                matrix[i][j]=temp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-自身旋转"><a href="#思路二-自身旋转" class="headerlink" title="思路二: 自身旋转"></a>思路二: 自身旋转</h3><p>采用分层来进行平移的方式，将矩阵的每一层都分开进行旋转，比如5*5的矩阵可以分为3层</p>
<p><a href="https://imgtu.com/i/cpkjw4"><img src="https://z3.ax1x.com/2021/03/28/cpkjw4.png" alt="cpkjw4.png" style="zoom: 50%;" /></a></p>
<p>旋转的时候，每四个矩阵块作为一组进行相应的旋转，将这4个位置的值交换</p>
<p>​    <a href="https://imgtu.com/i/cpAi6K"><img src="https://z3.ax1x.com/2021/03/28/cpAi6K.png" alt="cpAi6K.png" style="zoom:33%;" /></a><img src="https://z3.ax1x.com/2021/03/28/cpA3nS.png" alt="cpA3nS.png" style="zoom:67%;" /></p>
<p>首先不考虑偏移量的时候写出左上角的坐标为(pos1,pos1),右上角的坐标为(pos1,pos2),左下角的坐标为(pos2,pos1),右下角的坐标为(pos2,pos2)。  可以看出，第二次旋转的时候比第一次旋转偏移了一格，这里我们使用add变量来记录矩阵块的偏移量，则能够写出偏移之后对应的坐标</p>
<p>每次计算完一层之后，矩阵向内收缩一层，让 post1++ ，post2– ,条件是  post1&lt;post2</p>
<p><a href="https://imgtu.com/i/cpAfc6"><img src="https://z3.ax1x.com/2021/03/28/cpAfc6.png" alt="cpAfc6.png" style="zoom: 33%;" /></a></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，自身旋转</span></span><br><span class="line">        <span class="keyword">int</span> post1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> post2=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//偏移量</span></span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次循环都将旋转最外圈的值</span></span><br><span class="line">        <span class="keyword">while</span> (post1&lt;post2)&#123;</span><br><span class="line">             add=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//开始循环替换 4 个为一组的值</span></span><br><span class="line">            <span class="comment">// post1,post1+len   post1+len,post2   post2,post2-len   post2-len,post1</span></span><br><span class="line">            <span class="keyword">while</span>(add&lt;post2-post1)&#123;</span><br><span class="line">                temp=matrix[post1][post1+add];</span><br><span class="line">                matrix[post1][post1+add]=matrix[post2-add][post1];</span><br><span class="line">                matrix[post2-add][post1]=matrix[post2][post2-add];</span><br><span class="line">                matrix[post2][post2-add]=matrix[post1+add][post2];</span><br><span class="line">                matrix[post1+add][post2]=temp;</span><br><span class="line">                add++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向内缩小</span></span><br><span class="line">            post1++;</span><br><span class="line">            post2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/03/28/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
<h3 id="思路一-递归跳跃-超时"><a href="#思路一-递归跳跃-超时" class="headerlink" title="思路一:递归跳跃(超时)"></a>思路一:递归跳跃(超时)</h3><p>1.判断当前步数有没有超过数组长度，如果超过就返回 true</p>
<p>2.如果没超过就获取当前位置的值，遍历当前位置能跳的所有情况，每次遍历就递归条越</p>
<p>3.如果遍历完毕还没有跳出，就返回false</p>
<p>4.这种方法严重超时，不推荐</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归跳跃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前值可以跳跃的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[n];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jump(nums,n+i))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-直推法"><a href="#思路二-直推法" class="headerlink" title="思路二:直推法"></a>思路二:直推法</h3><p>1.直接遍历当前数组，如果遇到0就停下，从当前0所在的位置向前遍历</p>
<p>2.判断前方是否存在:  (下标 + 值)  &gt;  0所在位置的下标，如果存在则说明这个0是可以跳过的，继续上面的遍历</p>
<p>3.如果不存在，就表示当前0是条不过去的，直接返回false</p>
<p>4.遍历结束，返回true</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果找到0，并且不是最后一个数，就向前遍历</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; i!=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                   <span class="comment">//说明前方有一个值可以跳过当前的0</span></span><br><span class="line">                   <span class="keyword">if</span>(nums[j]+j&gt;i)&#123;</span><br><span class="line">                       flag=<span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没找到可以跳跃的数，就返回 false</span></span><br><span class="line">               <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-覆盖法"><a href="#思路三-覆盖法" class="headerlink" title="思路三:覆盖法"></a>思路三:覆盖法</h3><p>1.用一个值can，表示当前最大可达下标</p>
<p>2.遍历数组，如果当前下标小于或等于最大可达下标，说明可以继续跳越，并且不断更新 can == 》Math.max(can ,  i+nums[i])</p>
<p>3.一旦发现当前下标大于最大可达下标，就返回false</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//表示最大可达的下标</span></span><br><span class="line">       <span class="keyword">int</span> can=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果最大可达下标大于当前下标，就不断更新最大可达下标，否则就返回 false</span></span><br><span class="line">           <span class="keyword">if</span>(can&gt;=i)&#123;</span><br><span class="line">               can=Math.max(can,i+nums[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>进阶</p>
<h3 id="跳跃游戏-二"><a href="#跳跃游戏-二" class="headerlink" title="跳跃游戏 二"></a>跳跃游戏 二</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<h3 id="思路一-递归（还是超时）"><a href="#思路一-递归（还是超时）" class="headerlink" title="思路一:递归（还是超时）"></a>思路一:递归（还是超时）</h3><p>遍历每一次跳跃能跳的所有次数, 哪个跳的次数小就返回哪个</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> jump(nums,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">1</span> &lt;&lt; <span class="number">31</span>-<span class="number">1</span>; <span class="comment">//默认最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i&lt;=nums[index]+index;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = jump(nums, i)+<span class="number">1</span>;</span><br><span class="line">            step=Math.min(step,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-反向查找出发位置"><a href="#思路二-反向查找出发位置" class="headerlink" title="思路二:(反向查找出发位置)"></a>思路二:(反向查找出发位置)</h3><p>从后向前遍历，可获取到达当前下标的所有位置，这时找一个离当前下标最远的位置即可，再更新当前下标为最远位置</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>; <span class="comment">//步数</span></span><br><span class="line">        <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isChange=<span class="keyword">false</span>;<span class="comment">//标记是否可以跳出当前</span></span><br><span class="line">            <span class="comment">//循环遍历，判断最左边是否有值可以跳过当前位置，如果可以跳过就更行 右指针</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+nums[i]&gt;=j)&#123;</span><br><span class="line">                    step++;</span><br><span class="line">                    j=i;</span><br><span class="line">                    isChange=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isChange)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-正向查找可到达的最大位置"><a href="#思路三-正向查找可到达的最大位置" class="headerlink" title="思路三:(正向查找可到达的最大位置)"></a>思路三:(正向查找可到达的最大位置)</h3><p>看官网解释方法二，这里我也不是很懂</p>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</a></p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">int</span> maxJump=<span class="number">0</span>;<span class="comment">//当前最大可跳的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//根据当前位置更新最大可达下标</span></span><br><span class="line">            maxJump=Math.max(maxJump,i+nums[i]);</span><br><span class="line">            <span class="comment">//更新边界</span></span><br><span class="line">            <span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">                end=maxJump;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>续。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2021/03/29/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cPSVeJ"><img src="https://z3.ax1x.com/2021/03/29/cPSVeJ.png" alt="cPSVeJ.png"></a></p>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，<a id="more"></a>在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p>
<h3 id="思路一-动态编程"><a href="#思路一-动态编程" class="headerlink" title="思路一:动态编程"></a>思路一:动态编程</h3><p><a href="https://imgtu.com/i/cPSB6S"><img src="https://z3.ax1x.com/2021/03/29/cPSB6S.png" alt="cPSB6S.png" style="zoom: 67%;" /></a></p>
<p>1.从左向右遍历，获取数组 leftMax , 存放左边最大值</p>
<p>2.从右向左遍历，获取数组 rightMax，存放右边最大值</p>
<p>3.遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差，将差累加起来，最后返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//存放左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差</span></span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span>(min&gt;height[i])&#123;</span><br><span class="line">                num+=(min-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>1.获取数组中的最高值</p>
<p>2.从将最高值看作山顶，最左边向山顶走是大概是递增函数，最右边向山顶走大概是递减函数</p>
<p>3.从左边遍历获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</p>
<p>4.从右边遍历获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//获取最高值</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;max)&#123;</span><br><span class="line">                max=height[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从左边获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=leftMax)&#123;</span><br><span class="line">                leftMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(leftMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右边获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=rightMax)&#123;</span><br><span class="line">                rightMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(rightMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>困难</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和、四数之和</title>
    <url>/2021/03/31/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>三数之和: 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = []<br>输出：[]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：nums = [0]<br>输出：[]</p>
<h3 id="方法一-双指针"><a href="#方法一-双指针" class="headerlink" title="方法一(双指针)"></a>方法一(双指针)</h3><h5 id="一二指针不动，第三指针移动"><a href="#一二指针不动，第三指针移动" class="headerlink" title="一二指针不动，第三指针移动"></a>一二指针不动，第三指针移动</h5><p>先对当前数组从小到大排序,这里定义三个指针</p>
<p>让第一个指针从头循环遍历该数组，每一次遍历先让第二指针指向第一指针的下一个位置，再让第二个指针循环遍历数组</p>
<p>第二指针遍历时让第三指针从最后开始走，如果三个指针的值相加大于0，就让第三指针左移，直到等于0，</p>
<p>将结果添加到集合，并最后返回该集合</p>
<h6 id="注意-指针要去重"><a href="#注意-指针要去重" class="headerlink" title="注意: 指针要去重"></a>注意: 指针要去重</h6><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//首先循环第一个指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span> &amp;&amp; nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> third=n-<span class="number">1</span>; <span class="comment">//第三个指针</span></span><br><span class="line">            <span class="keyword">int</span> target= -nums[first];<span class="comment">// 0 减去 头指针的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="comment">//第二个指针去重</span></span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span> &amp;&amp; nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//保证第二指针在第三指针的左边情况下，如果两数相加要大于target，就让第三个指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(second&lt;third &amp;&amp; nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(second==third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;<span class="comment">//条件成立,添加到list中</span></span><br><span class="line">                    List&lt;Integer&gt; add = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    add.add(nums[first]);</span><br><span class="line">                    add.add(nums[second]);</span><br><span class="line">                    add.add(nums[third]);</span><br><span class="line">                    list.add(add);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对上面的方法该进"><a href="#对上面的方法该进" class="headerlink" title="对上面的方法该进"></a>对上面的方法该进</h3><h5 id="一指针不动，二三指针同时移动"><a href="#一指针不动，二三指针同时移动" class="headerlink" title="一指针不动，二三指针同时移动"></a>一指针不动，二三指针同时移动</h5><p>二三指针这里变成左右指针，左指针一定要小于右指针</p>
<p>如果三个数相加小于0，左指针移动，大于0，右指针移动，等于0就将三个数添加到list集合，并同时移动左右指针</p>
<p>最后将集合返回</p>
<h6 id="注意-指针都要去重"><a href="#注意-指针都要去重" class="headerlink" title="注意:指针都要去重"></a>注意:指针都要去重</h6><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">int</span> left= i+<span class="number">1</span>;<span class="comment">//左指针</span></span><br><span class="line">            <span class="keyword">int</span> right=n-<span class="number">1</span>;<span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//添加到list</span></span><br><span class="line">                    list.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//左边去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>] )&#123; left++; &#125;</span><br><span class="line">                    <span class="comment">//右边去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) &#123; right--; &#125;</span><br><span class="line">                    <span class="comment">//指针同移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;  <span class="comment">//如果小了，就左指针移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果大了，就右指针移动</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h6><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [], target = 0<br>输出：[]</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>方法与三数之和相同，再三数之和的基础上再包一个for循环，看作是第四个数</p>
<p>定义四个指针 a ，b ，c ，d，   </p>
<p>a在最外层，从头遍历数组，b为下一层，从a的下一个数开始遍历数组，c与d为第三层，看作左右指针同时移动。。。。。。(参考两数之和改进后的方法)</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// -2,-1,0,0,1,2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n-<span class="number">3</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; nums[a]==nums[a-<span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]+nums[a+<span class="number">1</span>]+nums[a+<span class="number">2</span>]+nums[a+<span class="number">3</span>]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;n-<span class="number">2</span>;b++)&#123;</span><br><span class="line">                <span class="comment">//去重 b</span></span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span> &amp;&amp; nums[b]==nums[b-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[a]+nums[b]+nums[b+<span class="number">1</span>]+nums[b+<span class="number">2</span>]&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c=b+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> d=n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[a]+nums[b]+nums[c]+nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[c]==nums[c+<span class="number">1</span>]) &#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[d]==nums[d-<span class="number">1</span>]) &#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib与requests库的基本使用</title>
    <url>/2021/04/04/urllib%E4%B8%8Erequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-urllib库-—内置"><a href="#1-urllib库-—内置" class="headerlink" title="1.urllib库   —内置"></a>1.urllib库   —内置</h2><h3 id="urlopen函数："><a href="#urlopen函数：" class="headerlink" title="urlopen函数："></a>urlopen函数：</h3><p>创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。</p>
<p>url：请求的url。<a id="more"></a><br>data：请求的data，如果设置了这个值，那么将变成post请求。<br>返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。</p>
<h3 id="urlretrieve函数："><a href="#urlretrieve函数：" class="headerlink" title="urlretrieve函数："></a>urlretrieve函数：</h3><p>这个函数可以方便的将网页上的一个文件保存到本地。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request.urlretrieve(url,文件名)</span><br></pre></td></tr></table></figure>
<h3 id="urlencode函数：编码"><a href="#urlencode函数：编码" class="headerlink" title="urlencode函数：编码"></a>urlencode函数：编码</h3><p>urlencode可以把字典数据转换为URL编码的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;老王&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line">print(qs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#name=%E8%80%81%E7%8E%8B&amp;age=18&amp;greet=hello+world</span></span><br></pre></td></tr></table></figure>


<h3 id="parse-qs函数：解码"><a href="#parse-qs函数：解码" class="headerlink" title="parse_qs函数：解码"></a>parse_qs函数：解码</h3><p>可以将经过编码后的url参数进行解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(parse.parse_qs(qs))</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: [&#x27;老王&#x27;], &#x27;age&#x27;: [&#x27;18&#x27;], &#x27;greet&#x27;: [&#x27;hello world&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="urlparse和urlsplit函数：解析url"><a href="#urlparse和urlsplit函数：解析url" class="headerlink" title="urlparse和urlsplit函数：解析url"></a>urlparse和urlsplit函数：解析url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/index.html;user?id=S#comment&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"><span class="comment"># result = parse.urlsplit(url)</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line">print(result.scheme)</span><br><span class="line">print(result.netloc)</span><br><span class="line">print(result.path)</span><br><span class="line"><span class="comment">#urlparse里有params属性，而urlsplit没有这个params属性。</span></span><br><span class="line">print(result.params)</span><br></pre></td></tr></table></figure>




<h3 id="request-Request类：网络请求-可以增加请求头"><a href="#request-Request类：网络请求-可以增加请求头" class="headerlink" title="request.Request类：网络请求  可以增加请求头"></a>request.Request类：网络请求  可以增加请求头</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 			(KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rq = request.Request(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(rq)</span><br><span class="line"></span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


<h3 id="ProxyHandler处理器（代理设置）：封ip问题"><a href="#ProxyHandler处理器（代理设置）：封ip问题" class="headerlink" title="ProxyHandler处理器（代理设置）：封ip问题"></a>ProxyHandler处理器（代理设置）：封ip问题</h3><ol>
<li><p>代理原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，代理服务器拿到目的网站的数据后，再转发给我们的代码。</p>
</li>
<li><p><a href="http://httpbin.org：这个网站可以方便的查看http请求的一些参数。">http://httpbin.org：这个网站可以方便的查看http请求的一些参数。</a></p>
</li>
<li><p>在代码中使用代理  示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用代理</span></span><br><span class="line"><span class="comment"># 步骤</span></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/ip&#x27;</span></span><br><span class="line"><span class="comment">#1. 使用ProxyHandler,传入代理构建一个handler</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;122.193.244.243:9999&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#2. 使用上面创建的handler构建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#3. 使用opener去发送一个请求</span></span><br><span class="line">resp = opener.<span class="built_in">open</span>(url)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="cookie-登录"><a href="#cookie-登录" class="headerlink" title="cookie:           登录"></a>cookie:           登录</h3><ol>
<li><p>什么是cookie：指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据</p>
</li>
<li><p>cookie的格式：<br>Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；         Domain=DOMAIN_NAME；SECURE<br>参数意义：<br>NAME：cookie的名字。<br>VALUE：cookie的值。<br>Expires：cookie的过期时间。<br>Path：cookie作用的路径。<br>Domain：cookie作用的域名。<br>SECURE：是否只在https协议下起作用。</p>
</li>
</ol>
<h3 id="http-cookiejar模块：提供用于存储cookie的对象"><a href="#http-cookiejar模块：提供用于存储cookie的对象" class="headerlink" title="http.cookiejar模块：提供用于存储cookie的对象"></a>http.cookiejar模块：提供用于存储cookie的对象</h3><ol>
<li><p>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</p>
</li>
<li><p>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</p>
</li>
<li><p>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</p>
</li>
<li><p>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</p>
</li>
</ol>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span>  CookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录：https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F</span></span><br><span class="line"><span class="comment">#个人网页https://i.meishi.cc/cook.php?id=13686422</span></span><br><span class="line"></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.登录</span></span><br><span class="line"><span class="comment">#1.1 创建cookiejar对象</span></span><br><span class="line">cookiejar = CookieJar()</span><br><span class="line"><span class="comment">#1.2 使用cookiejar创建一个HTTPCookieProcess对象</span></span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line"><span class="comment">#1.3 使用上一步的创建的handler创建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#1.4 使用opener发送登录请求  (账号和密码)</span></span><br><span class="line"></span><br><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">post_data = parse.urlencode(&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">req = request.Request(post_url,data=post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">opener.<span class="built_in">open</span>(req)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.访问个人网页</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">rq = request.Request(url,headers=headers)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(rq)</span><br><span class="line">print(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>cookie加载与保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="comment"># cookiejar = MozillaCookieJar(&#x27;cookie.txt&#x27;)</span></span><br><span class="line"><span class="comment"># handler = request.HTTPCookieProcessor(cookiejar)</span></span><br><span class="line"><span class="comment"># opener = request.build_opener(handler)</span></span><br><span class="line"><span class="comment"># resp = opener.open(&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cookiejar.save(ignore_discard=True,ignore_expires=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore_discard=True  即使cookies即将被丢弃也要保存下来</span></span><br><span class="line"><span class="comment"># ignore_expires=True  如果cookies已经过期也将它保存并且文件已存在时将覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookie.txt&#x27;</span>)</span><br><span class="line">cookiejar.load()</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure>


<h2 id="2-requests库-—第三方库"><a href="#2-requests库-—第三方库" class="headerlink" title="2.requests库   —第三方库"></a>2.requests库   —第三方库</h2><p>Requests：让HTTP服务人类</p>
<h3 id="安装和文档地址："><a href="#安装和文档地址：" class="headerlink" title="安装和文档地址："></a>安装和文档地址：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>


<h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加headers和查询参数</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">kw = &#123;<span class="string">&#x27;wd&#x27;</span>:<span class="string">&#x27;中国&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com/s&#x27;</span>,headers=headers,params=kw)</span><br><span class="line">print(response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性</span></span><br><span class="line"><span class="comment"># 查询响应内容</span></span><br><span class="line">print(response.text)  <span class="comment">#返回unicode格式的数据</span></span><br><span class="line">print(response.content) <span class="comment">#返回字节流数据</span></span><br><span class="line">print(response.url)  <span class="comment">#查看完整url地址</span></span><br><span class="line">print(response.encoding) <span class="comment"># 查看响应头部字符编码</span></span><br></pre></td></tr></table></figure>


<h4 id="response-text和response-content的区别："><a href="#response-text和response-content的区别：" class="headerlink" title="response.text和response.content的区别："></a>response.text和response.content的区别：</h4><ol>
<li><code>response.content</code> ：这个是直接从网络上抓取的数据，没有经过任何的编码，所以是一个bytes类型，其实在硬盘上和网络上传输的字符串都是bytes类型</li>
<li><code>response.text</code>：这个是str的数据类型，是requests库将response.content进行解码的字符串，解码需要指定一个编码方式，requests会根据自己的猜测来判断编码的方式，所以有时候可能会猜测错误，就会导致解码产生乱码，这时候就应该进行手动解码，比如使用<code>response.content.decode(&#39;utf-8&#39;)</code></li>
</ol>
<h3 id="发送POST请求："><a href="#发送POST请求：" class="headerlink" title="发送POST请求："></a>发送POST请求：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>,data=data)</span><br></pre></td></tr></table></figure>
<p>POST请求方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;https://www.meishij.net/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.post(url,headers=headers,data=data)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="使用代理："><a href="#使用代理：" class="headerlink" title="使用代理："></a>使用代理：</h3><p>只要在请求的方法中（比如get或者post）传递proxies参数就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;111.77.197.127:9999&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://www.httpbin.org/ip&#x27;</span></span><br><span class="line">resp = requests.get(url,proxies=proxy)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h3><p>基本使用：模拟登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://www.zhihu.com/hot&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_zap=59cde9c3-c5c0-4baa-b756-fa16b5e72b10; d_c0=&quot;APDi1NJcuQ6PTvP9qa1EKY6nlhVHc_zYWGM=|1545737641&quot;; __gads=ID=237616e597ec37ad:T=1546339385:S=ALNI_Mbo2JturZesh38v7GzEeKjlADtQ5Q; _xsrf=pOd30ApWQ2jihUIfq94gn2UXxc0zEeay; q_c1=1767e338c3ab416692e624763646fc07|1554209209000|1545743740000; tst=h; __utma=51854390.247721793.1554359436.1554359436.1554359436.1; __utmc=51854390; __utmz=51854390.1554359436.1.1.utmcsr=zhihu.com|utmccn=(referral)|utmcmd=referral|utmcct=/hot; __utmv=51854390.100-1|2=registration_date=20180515=1^3=entry_date=20180515=1; l_n_c=1; l_cap_id=&quot;OWRiYjI0NzJhYzYwNDM3MmE2ZmIxMGIzYmQwYzgzN2I=|1554365239|875ac141458a2ebc478680d99b9219c461947071&quot;; r_cap_id=&quot;MmZmNDFkYmIyM2YwNDAxZmJhNWU1NmFjOGRkNDNjYjc=|1554365239|54372ab1797cba8c4dd224ba1845dd7d3f851802&quot;; cap_id=&quot;YzQwNGFlYWNmNjY3NDFhNGI4MGMyYjZjYjRhMzQ1ZmE=|1554365239|385cc25e3c4e3b0b68ad5747f623cf3ad2955c9f&quot;; n_c=1; capsion_ticket=&quot;2|1:0|10:1554366287|14:capsion_ticket|44:MmE5YzNkYjgzODAyNDgzNzg5MTdjNmE3NjQyODllOGE=|40d3498bedab1b7ba1a247d9fc70dc0e4f9a4f394d095b0992a4c85e32fd29be&quot;; z_c0=&quot;2|1:0|10:1554366318|4:z_c0|92:Mi4xOWpCeUNRQUFBQUFBOE9MVTBseTVEaVlBQUFCZ0FsVk5iZzJUWFFEWi1JMkxnQXlVUXh2SlhYb3NmWks3d1VwMXRB|81b45e01da4bc235c2e7e535d580a8cc07679b50dac9e02de2711e66c65460c6&quot;; tgw_l7_route=578107ff0d4b4f191be329db6089ff48&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(url,headers=headers)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h4 id="session：共享cookie"><a href="#session：共享cookie" class="headerlink" title="session：共享cookie"></a>session：共享cookie</h4><p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line"></span><br><span class="line">post_data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(post_url,headers=headers,data=post_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问个人页面</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">resp = session.get(url)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="处理不信任的SSL证书："><a href="#处理不信任的SSL证书：" class="headerlink" title="处理不信任的SSL证书："></a>处理不信任的SSL证书：</h3><p>对于那些已经被信任的SSL证书的网站，比如<a href="https://www.baidu.com/%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%BF%E7%94%A8requests%E7%9B%B4%E6%8E%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E3%80%82%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = requests.get(<span class="string">&#x27;https://inv-veri.chinatax.gov.cn/&#x27;</span>,verify=<span class="literal">False</span>)</span><br><span class="line">print(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫数据提取基础</title>
    <url>/2021/04/05/%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="XPath语法和lxml模块"><a href="#XPath语法和lxml模块" class="headerlink" title="XPath语法和lxml模块"></a>XPath语法和lxml模块</h1><p>xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p>
<h2 id="XPath节点"><a href="#XPath节点" class="headerlink" title="XPath节点"></a>XPath节点</h2><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p>
<a id="more"></a>

<h2 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h2><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>使用//获取整个页面当中的元素，然后写标签名，然后在写谓语进行提取，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[@lang=<span class="string">&#x27;en&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="需要注意的知识点："><a href="#需要注意的知识点：" class="headerlink" title="需要注意的知识点："></a>需要注意的知识点：</h3><ol>
<li><p>/和//的区别：/代表只获取子节点，//获取子孙节点，一般//用的比较多，当然也要视情况而定</p>
</li>
<li><p>contains：有时候某个属性中包含了多个值，那么可以使用contains函数，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[contains(@lang,<span class="string">&#x27;en&#x27;</span>)]</span><br></pre></td></tr></table></figure></li>
<li><p>谓词中下标是从1开始的，不是从0开始的</p>
</li>
</ol>
<h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 将字符串解析为html文档</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">print(html)</span><br><span class="line"><span class="comment"># 按字符串序列化html</span></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="从文件中读取html代码："><a href="#从文件中读取html代码：" class="headerlink" title="从文件中读取html代码："></a>从文件中读取html代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="在lxml中使用xpath语法"><a href="#在lxml中使用xpath语法" class="headerlink" title="在lxml中使用xpath语法"></a>在lxml中使用xpath语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法练习</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取所有li标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># for i in result:</span></span><br><span class="line"><span class="comment">#     print(etree.tostring(i))</span></span><br><span class="line"><span class="comment"># 获取所有li元素下的所有class属性的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下href为www.baidu.com的a标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a[@href=&quot;www.baidu.com&quot;]&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下所有span标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li//span&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下的a标签里的所有class：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a//@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取最后一个li的a的href属性对应的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()]/a/@href&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()-1]/a&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result[0].text)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容的第二种方式：</span></span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="实战（瓜子二手车）"><a href="#实战（瓜子二手车）" class="headerlink" title="实战（瓜子二手车）"></a>实战（瓜子二手车）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;...&#x27;</span> <span class="comment">#自己网页查找</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 根据首页获取所有详情页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHrefs</span>(<span class="params">indexUrl</span>):</span></span><br><span class="line">    <span class="comment"># 获取首页内容</span></span><br><span class="line">    index_url = indexUrl</span><br><span class="line">    res = requests.get(index_url, headers=head)</span><br><span class="line">    text = res.content.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 解析首页内容</span></span><br><span class="line">    html = etree.HTML(text)</span><br><span class="line">    ul = html.xpath(<span class="string">&#x27;//ul[@class=&quot;carlist clearfix js-top&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    hrefs = ul.xpath(<span class="string">&#x27;./li/a/@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取详细页面所需内容，保存到字典中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDetail</span>(<span class="params">detail_url</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.guazi.com&#x27;</span> + detail_url</span><br><span class="line">    detail = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    html = etree.HTML(detail)</span><br><span class="line">    title = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    title = title.replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip()</span><br><span class="line">    info = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/ul/li/span/text()&#x27;</span>)</span><br><span class="line">    price_now = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/span/text()&#x27;</span>)</span><br><span class="line">    price_origin = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/div/text()&#x27;</span>)</span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    res[<span class="string">&#x27;标题&#x27;</span>] = title</span><br><span class="line">    res[<span class="string">&#x27;里程表&#x27;</span>] = info[<span class="number">2</span>]</span><br><span class="line">    res[<span class="string">&#x27;排量&#x27;</span>] = info[<span class="number">3</span>]</span><br><span class="line">    res[<span class="string">&#x27;变速箱&#x27;</span>] = info[<span class="number">4</span>]</span><br><span class="line">    res[<span class="string">&#x27;价格&#x27;</span>] = price_now</span><br><span class="line">    res[<span class="string">&#x27;原价&#x27;</span>] = price_origin</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guazhi.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入文件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 遍历一到六页</span></span><br><span class="line">            hrefs = getHrefs(url.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">                detail = getDetail(href)</span><br><span class="line">                <span class="comment"># 开始文件写入</span></span><br><span class="line">                f.write(</span><br><span class="line">                    <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(detail[<span class="string">&#x27;标题&#x27;</span>], detail[<span class="string">&#x27;里程表&#x27;</span>], detail[<span class="string">&#x27;排量&#x27;</span>], detail[<span class="string">&#x27;变速箱&#x27;</span>], detail[<span class="string">&#x27;价格&#x27;</span>],</span><br><span class="line">                                                 detail[<span class="string">&#x27;原价&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url=<span class="string">&#x27;https://www.guazi.com/nc/buy/o&#123;&#125;/#bread&#x27;</span></span><br><span class="line">    main(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="BeautifulSoup4库"><a href="#BeautifulSoup4库" class="headerlink" title="BeautifulSoup4库"></a>BeautifulSoup4库</h1><p>和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。</p>
<h2 id="安装和文档："><a href="#安装和文档：" class="headerlink" title="安装和文档："></a>安装和文档：</h2><p>安装：<br>pip install bs4</p>
<p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>
<h2 id="常见的四种对象："><a href="#常见的四种对象：" class="headerlink" title="常见的四种对象："></a>常见的四种对象：</h2><ol>
<li>Tag：BeautifulSoup中所有的标签都是Tag类型，并且BeautifulSoup的对象其实本质上也是一个Tag类型。所以其实一些方法比如find、find_all并不是BeautifulSoup的，而是Tag的。</li>
<li>NavigableString：继承自python中的str，用起来就跟使用python的str是一样的。</li>
<li>BeautifulSoup：继承自Tag。用来生成BeaufifulSoup树的。对于一些查找方法，比如find、select这些，其实还是Tag的。</li>
<li>Comment：这个也没什么好说，就是继承自NavigableString。</li>
</ol>
<h2 id="contents和children："><a href="#contents和children：" class="headerlink" title="contents和children："></a>contents和children：</h2><p>返回某个标签下的直接子元素，其中也包括字符串。他们两的区别是：contents返回来的是一个列表，children返回的是一个迭代器。</p>
<h2 id="string和strings、stripped-strings属性以及get-text方法"><a href="#string和strings、stripped-strings属性以及get-text方法" class="headerlink" title="string和strings、stripped_strings属性以及get_text方法"></a>string和strings、stripped_strings属性以及get_text方法</h2><ol>
<li>string：获取某个标签下的非标签字符串。返回来的是个字符串。如果这个标签下有多行字符，那么就不能获取到了。</li>
<li>strings：获取某个标签下的子孙非标签字符串。返回来的是个生成器。</li>
<li>stripped_strings：获取某个标签下的子孙非标签字符串，会去掉空白字符。返回来的是个生成器。</li>
<li>get_text：获取某个标签下的子孙非标签字符串，以普通字符串形式返回</li>
</ol>
<h2 id="find-all的使用："><a href="#find-all的使用：" class="headerlink" title="find_all的使用："></a>find_all的使用：</h2><ol>
<li>在提取标签的时候，第一个参数是标签的名字。然后如果在提取标签的时候想要使用标签属性进行过滤，那么可以在这个方法中通过关键字参数的形式，将属性的名字以及对应的值传进去。或者是使用<code>attrs</code>属性，将所有的属性以及对应的值放在一个字典中传给<code>attrs</code>属性。</li>
<li>有些时候，在提取标签的时候，不想提取那么多，那么可以使用<code>limit</code>参数。限制提取多少个。</li>
</ol>
<h2 id="find与find-all的区别："><a href="#find与find-all的区别：" class="headerlink" title="find与find_all的区别："></a>find与find_all的区别：</h2><ol>
<li>find：找到第一个满足条件的标签就返回。说白了，就是只会返回一个元素。</li>
<li>find_all:将所有满足条件的标签都返回。说白了，会返回很多标签（以列表的形式）。</li>
</ol>
<h2 id="使用find和find-all的过滤条件："><a href="#使用find和find-all的过滤条件：" class="headerlink" title="使用find和find_all的过滤条件："></a>使用find和find_all的过滤条件：</h2><ol>
<li>关键字参数：将属性的名字作为关键字参数的名字，以及属性的值作为关键字参数的值进行过滤。</li>
<li>attrs参数：将属性条件放到一个字典中，传给attrs参数。</li>
</ol>
<h2 id="获取标签的属性："><a href="#获取标签的属性：" class="headerlink" title="获取标签的属性："></a>获取标签的属性：</h2><ol>
<li><p>通过下标获取：通过标签的下标的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>通过attrs属性获取：示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a.attrs[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="CSS选择器："><a href="#CSS选择器：" class="headerlink" title="CSS选择器："></a>CSS选择器：</h2><h3 id="select方法："><a href="#select方法：" class="headerlink" title="select方法："></a>select方法：</h3><p>使用以上方法可以方便的找出元素。但有时候使用<code>css</code>选择器的方式可以更加的方便。使用<code>css</code>选择器的语法，应该使用<code>select</code>方法。以下列出几种常用的<code>css</code>选择器方法：</p>
<h4 id="（1）通过标签名查找："><a href="#（1）通过标签名查找：" class="headerlink" title="（1）通过标签名查找："></a>（1）通过标签名查找：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（2）通过类名查找："><a href="#（2）通过类名查找：" class="headerlink" title="（2）通过类名查找："></a>（2）通过类名查找：</h4><p>通过类名，则应该在类的前面加一个<code>.</code>。比如要查找<code>class=sister</code>的标签。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（3）通过id查找："><a href="#（3）通过id查找：" class="headerlink" title="（3）通过id查找："></a>（3）通过id查找：</h4><p>通过id查找，应该在id的名字前面加一个＃号。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;#link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（4）组合查找："><a href="#（4）组合查找：" class="headerlink" title="（4）组合查找："></a>（4）组合查找：</h4><p>组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;p #link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>直接子标签查找，则使用 &gt; 分隔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（5）通过属性查找："><a href="#（5）通过属性查找：" class="headerlink" title="（5）通过属性查找："></a>（5）通过属性查找：</h4><p>查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（6）获取内容"><a href="#（6）获取内容" class="headerlink" title="（6）获取内容"></a>（6）获取内容</h4><p>以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.select(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    print(title.get_text())</span><br></pre></td></tr></table></figure>
<h3 id="实战（豆瓣top250）"><a href="#实战（豆瓣top250）" class="headerlink" title="实战（豆瓣top250）"></a>实战（豆瓣top250）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据首页获取所有详细页的网址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    lis = soup.find(<span class="string">&#x27;ol&#x27;</span>, class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    hrefs = []</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">        href = li.find(<span class="string">&#x27;a&#x27;</span>)[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">        hrefs.append(href)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据详情页获取相关信息并写入文件f中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_detail</span>(<span class="params">url, f</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    div = soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">    <span class="comment"># 电影名</span></span><br><span class="line">    name = <span class="built_in">list</span>(div.find(<span class="string">&#x27;h1&#x27;</span>).stripped_strings)</span><br><span class="line">    div = div.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;subjectwrap clearfix&#x27;</span>)</span><br><span class="line">    info = div.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;info&#x27;</span>).find_all(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;attrs&#x27;</span>)</span><br><span class="line">    <span class="comment"># 导演</span></span><br><span class="line">    direct = <span class="built_in">list</span>(info[<span class="number">0</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 编剧</span></span><br><span class="line">    production = <span class="built_in">list</span>(info[<span class="number">1</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 演员</span></span><br><span class="line">    actor = <span class="built_in">list</span>(info[<span class="number">2</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    score = div.find(<span class="string">&#x27;strong&#x27;</span>, class_=<span class="string">&#x27;ll rating_num&#x27;</span>).string</span><br><span class="line">    f.write(</span><br><span class="line">        <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>.join(name), <span class="string">&#x27;&#x27;</span>.join(direct), <span class="string">&#x27;&#x27;</span>.join(production), <span class="string">&#x27;&#x27;</span>.join(actor), <span class="string">&#x27;&#x27;</span>.join(score)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(name) + <span class="string">&#x27;写入完毕&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>, <span class="number">25</span>): <span class="comment"># 获取所有页数</span></span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        hrefs = get_detail_url(url) <span class="comment"># 获取所有详情页的url</span></span><br><span class="line">        <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                res = write_detail(href, f)</span><br><span class="line">                print(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><h2 id="单字符匹配："><a href="#单字符匹配：" class="headerlink" title="单字符匹配："></a>单字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配某个字符串：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;b&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点（.）：匹配任意的字符(除了&#x27;\n&#x27;)：</span></span><br><span class="line"><span class="comment"># text = &quot;\nabc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;.&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \d：匹配任意的数字：</span></span><br><span class="line"><span class="comment"># text = &quot;aab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\d&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \D：匹配任意的非数字：</span></span><br><span class="line"><span class="comment"># text = &quot;cab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\D&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \s：匹配的是空白字符（包括：\n，\t，\r和空格）：</span></span><br><span class="line"><span class="comment"># text = &quot; ab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\s&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \S：非空白字符：</span></span><br><span class="line"><span class="comment"># text = &quot;\nab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\S&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \w：匹配的是a-z和A-Z以及数字和下划线：</span></span><br><span class="line"><span class="comment"># text = &quot;+bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\w&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \W：匹配的是和\w相反的：</span></span><br><span class="line"><span class="comment"># text = &quot;1bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\W&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []组合的方式，只要满足中括号中的某一项都算匹配成功：</span></span><br><span class="line"><span class="comment"># text = &quot;bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[1b]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式[0-9]\d：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[^0-9]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式实现\w：</span></span><br><span class="line">text = <span class="string">&quot;+bc&quot;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;[^a-zA-Z0-9_]&#x27;</span>,text)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多字符匹配："><a href="#多字符匹配：" class="headerlink" title="多字符匹配："></a>多字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *：匹配0个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\D*&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># +：匹配1个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ?：匹配前一个字符0个或者1个：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w?&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m&#125;：匹配m个字符:</span></span><br><span class="line"><span class="comment"># text = &quot;+1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w&#123;2&#125;&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m,n&#125;：匹配m-n之间的个数的字符：</span></span><br><span class="line">text = <span class="string">&quot;1abc+&quot;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;\w&#123;1,3&#125;&#x27;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="开始-结束-贪婪和非贪婪："><a href="#开始-结束-贪婪和非贪婪：" class="headerlink" title="开始/结束/贪婪和非贪婪："></a>开始/结束/贪婪和非贪婪：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ^：以...开头：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;world&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $：以...结尾：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;hello$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"><span class="comment"># text = &quot;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;^$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># |：匹配多个字符串或者表达式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪婪和非贪婪：在后面加 ?</span></span><br><span class="line"><span class="comment"># text = &quot;12345&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;\d+?&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：提取html标签名称：</span></span><br><span class="line"><span class="comment"># text = &quot;&lt;h1&gt;这是标题&lt;/h1&gt;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;&lt;.+?&gt;&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：验证一个字符是不是0-100之间的数字：</span></span><br><span class="line"><span class="comment"># 0,1,99,100</span></span><br><span class="line"><span class="comment"># 01</span></span><br><span class="line">text = <span class="string">&quot;101&quot;</span></span><br><span class="line">result = re.match(<span class="string">&quot;0$|[1-9]\d?$|100$&quot;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<h2 id="转义字符和原生字符串："><a href="#转义字符和原生字符串：" class="headerlink" title="转义字符和原生字符串："></a>转义字符和原生字符串：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的转义字符：</span></span><br><span class="line"><span class="comment"># raw</span></span><br><span class="line"><span class="comment"># text = r&quot;hello\nworld&quot;</span></span><br><span class="line"><span class="comment"># print(text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式中的转义字符：</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,range price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(&quot;\$\d+&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生字符串和正则表达式：</span></span><br><span class="line"><span class="comment"># 正则表达式的字符串解析规则：</span></span><br><span class="line"><span class="comment"># 1. 先把这个字符串放在Python语言层面进行解析。</span></span><br><span class="line"><span class="comment"># 2. 把Python语言层面解析的结果再放到正则表达式层间进行解析。</span></span><br><span class="line">text = <span class="string">&quot;\cba c&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&quot;\\\\c&quot;,text) # \\\\c =(Python语言层面)&gt; \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">result = re.match(<span class="string">r&quot;\\c&quot;</span>,text) <span class="comment"># \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line">result = re.search(<span class="string">&#x27;.+(\$\d+).+(\$\d+)&#x27;</span>,text)</span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># group()/group(0)：匹配整个分组</span></span><br><span class="line"><span class="comment"># group(1)：匹配第一个分组</span></span><br><span class="line"><span class="comment"># group(2)：匹配第二个分组</span></span><br><span class="line"><span class="comment"># groups()：获取所有的分组</span></span><br></pre></td></tr></table></figure>

<h2 id="re中常用的函数："><a href="#re中常用的函数：" class="headerlink" title="re中常用的函数："></a>re中常用的函数：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># findall：查找所有满足条件的</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(r&#x27;\$\d+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub：根据规则替换其他字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># new_text = text.replace(&quot; &quot;,&quot;\n&quot;)</span></span><br><span class="line"><span class="comment"># new_text = re.sub(r&#x27; |,&#x27;,&#x27;\n&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(new_text)</span></span><br><span class="line"><span class="comment"># html = &quot;&lt;p&gt;4、有机会转为招商银行内部员工；&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="comment"># new_html = re.sub(r&#x27;&lt;.+?&gt;&#x27;,&quot;&quot;,html)</span></span><br><span class="line"><span class="comment"># print(new_html)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split：根据规则分割字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.split(r&#x27; |,&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile：编译正则表达式</span></span><br><span class="line">text = <span class="string">&quot;apple price is 34.56&quot;</span></span><br><span class="line"><span class="comment"># r = re.compile(r&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># \d+ # 整数部分</span></span><br><span class="line"><span class="comment"># \.? # 小数点</span></span><br><span class="line"><span class="comment"># \d* # 小数部分</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;,re.VERBOSE)</span></span><br><span class="line"><span class="comment"># result = re.search(r,text)</span></span><br><span class="line">result = re.search(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">\d+ # 整数部分</span></span><br><span class="line"><span class="string">\.? # 小数点</span></span><br><span class="line"><span class="string">\d* # 小数部分</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>,text,re.VERBOSE)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<p>如果想要在正则表达式中加注释，那么需要在正则表达式的函数最后加一个<code>re.VERBOSE</code>。</p>
<h3 id="实战-糗事百科"><a href="#实战-糗事百科" class="headerlink" title="实战(糗事百科)"></a>实战(糗事百科)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>&#125;</span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使用正则表达式直接切割</span></span><br><span class="line">    texts = re.findall(<span class="string">&#x27;&lt;div\sclass=&quot;content&quot;&gt;.+?&lt;span&gt;(.+?)&lt;/span&gt;&#x27;</span>, html, re.DOTALL)</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># 去除多余标签</span></span><br><span class="line">        text = re.sub(<span class="string">&#x27;&lt;br/&gt;+?&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        print(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.qiushibaike.com/text/page/&#123;&#125;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>):</span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        get_detail(url)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据提取</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储基础</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JSON字符串处理："><a href="#JSON字符串处理：" class="headerlink" title="JSON字符串处理："></a>JSON字符串处理：</h1><h2 id="将Python对象dump成JSON字符串："><a href="#将Python对象dump成JSON字符串：" class="headerlink" title="将Python对象dump成JSON字符串："></a>将Python对象dump成JSON字符串：</h2><ol>
<li>dumps：把Python对象转换成JSON格式的字符串。</li>
<li>dump：把Python对象转换成JSON格式的字符串，并且还可以接收一个文件指针fp参数，可以写入到文件中。</li>
<li><a id="more"></a>这两个方法都有一个`ensure_ascii`参数，默认情况下这个参数的值是True，也就是说转换后的JSON字符串是只能存储ascii格式的，不能存储中文，如果想要存储成中文，那么可以将他设置为False。


</li>
</ol>
<h2 id="将JSON字符串load成Python对象："><a href="#将JSON字符串load成Python对象：" class="headerlink" title="将JSON字符串load成Python对象："></a>将JSON字符串load成Python对象：</h2><ol>
<li>loads：将JSON字符串转换成Python对象。</li>
<li>load：将JSON字符串转换成Python对象，并且是直接从文件中获取JSON字符串。</li>
</ol>
<h1 id="CSV文件处理："><a href="#CSV文件处理：" class="headerlink" title="CSV文件处理："></a>CSV文件处理：</h1><h2 id="CSV文件读取的两种方式："><a href="#CSV文件读取的两种方式：" class="headerlink" title="CSV文件读取的两种方式："></a>CSV文件读取的两种方式：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式读取到的每一条数据是一个列表，所以需要通过下标的方式获取具体某一个值</span></span><br><span class="line"><span class="comment"># with open(&quot;stock.csv&quot;,&#x27;r&#x27;,encoding=&#x27;gbk&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     reader = csv.reader(fp)</span></span><br><span class="line"><span class="comment">#     for x in reader:</span></span><br><span class="line"><span class="comment">#         print(x[3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式读取到的每一条数据是一个字典，所以可以通过列名获取数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stock.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    reader = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> reader:</span><br><span class="line">        print(x[<span class="string">&#x27;secShortName&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="CSV文件的写入的两种方式："><a href="#CSV文件的写入的两种方式：" class="headerlink" title="CSV文件的写入的两种方式："></a>CSV文件的写入的两种方式：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">headers = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;height&#x27;</span>)</span><br><span class="line"><span class="comment"># students = [</span></span><br><span class="line"><span class="comment">#     (&quot;张三&quot;,18,180),</span></span><br><span class="line"><span class="comment">#     (&quot;李四&quot;,19,190),</span></span><br><span class="line"><span class="comment">#     (&quot;王五&quot;,20,170)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;height&quot;</span>:<span class="number">180</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;height&quot;</span>:<span class="number">190</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;height&quot;</span>:<span class="number">170</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&quot;students.csv&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;,newline=&#x27;&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     writer = csv.writer(fp)</span></span><br><span class="line"><span class="comment">#     writer.writerow(headers) # 写入一行</span></span><br><span class="line"><span class="comment">#     writer.writerows(students) # 写入多行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;students.csv&quot;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    writer = csv.DictWriter(fp,headers) <span class="comment"># 需要指定头</span></span><br><span class="line">    <span class="comment"># 虽然DictWriter创建的时候有一个headers，但是想要写入数据进去</span></span><br><span class="line">    <span class="comment"># 还是需要调用writer.writeheader()方法，否则，表头数据写入不进去</span></span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerows(students)</span><br></pre></td></tr></table></figure>
<h1 id="Excel文件处理："><a href="#Excel文件处理：" class="headerlink" title="Excel文件处理："></a>Excel文件处理：</h1><h2 id="读取Sheet相关的操作："><a href="#读取Sheet相关的操作：" class="headerlink" title="读取Sheet相关的操作："></a>读取Sheet相关的操作：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workbook = xlrd.open_workbook(<span class="string">&quot;成绩表.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的sheet名字</span></span><br><span class="line">print(workbook.sheet_names())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引获取指定的sheet对象</span></span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据名称获取指定的sheet对象</span></span><br><span class="line">sheet = workbook.sheet_by_name(<span class="string">&quot;2班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的sheet对象</span></span><br><span class="line">sheets = workbook.sheets()</span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">    print(sheet.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定sheet的行数和列数</span></span><br><span class="line">rows= sheet.nrows</span><br><span class="line">cols= sheet.ncols</span><br></pre></td></tr></table></figure>
<h2 id="Cell相关的操作："><a href="#Cell相关的操作：" class="headerlink" title="Cell相关的操作："></a>Cell相关的操作：</h2><p>每个Cell代表的是表格中的一格。以下方法可以方便获取想要的cell： </p>
<ol>
<li>sheet.cell(row,col)：获取指定行和列的cell对象。 </li>
<li> sheet.row_slice(row,start_col,end_col)：获取指定行的某几列的cell对象。 </li>
<li>sheet.col_slice(col,start_row,end_row)：获取指定列的某几行的cell对象。 </li>
<li>sheet.cell_value(row,col)：获取指定行和列的值。 </li>
<li>sheet.row_values(row,start_col,end_col)：获取指定行的某几列的值。 </li>
<li>sheet.col_values(col,start_row,end_row)：获取指定列的某几行的值。</li>
</ol>
<h2 id="Cell中常用的数据类型："><a href="#Cell中常用的数据类型：" class="headerlink" title="Cell中常用的数据类型："></a>Cell中常用的数据类型：</h2><ol>
<li><p>xlrd.XL_CELL_TEXT（Text）：文本类型,表示1</p>
</li>
<li><p>xlrd.XL_CELL_NUMBER（Number）：数值类型,表示2</p>
</li>
<li><p> xlrd.XL_CELL_DATE（Date）：日期时间类型,表示3</p>
</li>
<li><p>  xlrd.XL_CELL_BOOLEAN（Bool）：布尔类型,表示4</p>
</li>
<li><p> xlrd.XL_CELL_EMPTY：空白数据类型,表示0</p>
</li>
</ol>
<h2 id="写入Excel"><a href="#写入Excel" class="headerlink" title="写入Excel"></a>写入Excel</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet = workbook.add_sheet(<span class="string">&quot;sheet1&quot;</span>) <span class="comment"># 添加一个sheet</span></span><br><span class="line"><span class="comment"># 在(1,1)处写入&#x27;tom&#x27; </span></span><br><span class="line">sheet.write(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存到&quot;成绩2.xls&quot;</span></span><br><span class="line">workbook.save(<span class="string">&quot;成绩2.xls&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实战-计算一个Excel文件中的总分与平均分"><a href="#实战-计算一个Excel文件中的总分与平均分" class="headerlink" title="实战(计算一个Excel文件中的总分与平均分)"></a>实战(计算一个Excel文件中的总分与平均分)</h3><p>1 .  先将当前文件编辑</p>
<p>2 . 将当前文件中的值全都复制到另一个文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">rbook = xlrd.open_workbook(<span class="string">&#x27;成绩.xls&#x27;</span>)</span><br><span class="line">rsheet = rbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算总分</span></span><br><span class="line">rsheet.put_cell(<span class="number">0</span>, rsheet.ncols, xlrd.XL_CELL_TEXT, <span class="string">&#x27;总分&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rsheet.nrows):</span><br><span class="line">    values = rsheet.row_values(row, <span class="number">1</span>, rsheet.ncols - <span class="number">1</span>)</span><br><span class="line">    sums = <span class="built_in">sum</span>(values)</span><br><span class="line">    print(<span class="built_in">type</span>(sums))</span><br><span class="line">    rsheet.put_cell(row, <span class="number">4</span>, xlrd.XL_CELL_NUMBER, sums, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 计算平均分</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    grades = rsheet.col_values(col, <span class="number">1</span>, rsheet.nrows)</span><br><span class="line">    avg = <span class="built_in">sum</span>(grades) / <span class="built_in">len</span>(grades)</span><br><span class="line">    rsheet.put_cell(rsheet.nrows, col, xlrd.XL_CELL_NUMBER, avg, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># copy</span></span><br><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet = workbook.add_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, rsheet.nrows):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        sheet.write(row, col, rsheet.cell_value(row, col))</span><br><span class="line">workbook.save(<span class="string">&quot;成绩2.xls&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="MySQL处理"><a href="#MySQL处理" class="headerlink" title="MySQL处理"></a>MySQL处理</h1><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db=pymysql.connect(</span><br><span class="line">    host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">3306</span>, user=<span class="string">&quot;root&quot;</span>, password=<span class="string">&quot;nofuck&quot;</span>, database=<span class="string">&quot;py_hui&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取游标，通过该游标操作</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM USER&quot;</span>)</span><br><span class="line">result = cursor.fetchmany(<span class="number">2</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>cursor.fetchone()    # 获取第一条数据</p>
<p>cursor.fetchall()       # 获取所有数据</p>
<p>cursor.fetchmany(2)   # 获取前两条数据</p>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p>sql语句中可用 %s 占一个位置，后面用原组填充进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;怪狗狗&#x27;</span></span><br><span class="line">gender = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">age = <span class="number">2</span></span><br><span class="line">sql = <span class="string">&#x27;insert into user (id,name,gender,age) values (null,%s,%s,%s)&#x27;</span></span><br><span class="line">cursor.execute(sql, (name, gender, age))</span><br><span class="line">db.commit() <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure>
<p>注意: 执行完sql语句后记得要 db.close() 关闭链接！！！</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
        <tag>Excel</tag>
        <tag>CSV</tag>
        <tag>JSON</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程爬虫</title>
    <url>/2021/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="如何创建一个基本的多线程："><a href="#如何创建一个基本的多线程：" class="headerlink" title="如何创建一个基本的多线程："></a>如何创建一个基本的多线程：</h2><p>使用<code>threading</code>模块下的<code>Thread</code>类即可创建一个线程。这个类有一个<code>target</code>参数，需要指定一个函数，那么以后这个线程执行的时候，就会执行这个函数的代码。示例代码如下：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">code</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=code, name=<span class="string">&quot;胖虎&quot;</span>)</span><br><span class="line">    t2 = threading.Thread(target=dance, name=<span class="string">&quot;静香&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    multi_thread() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="查看当前线程："><a href="#查看当前线程：" class="headerlink" title="查看当前线程："></a>查看当前线程：</h2><ol>
<li>threading.current_thread：在线程中执行这个函数，会返回当前线程的对象,如上面例子可以给线程取名。</li>
<li>threading.enumerate：获取整个程序中所有的线程。</li>
</ol>
<h2 id="继承自threading-Thread类："><a href="#继承自threading-Thread类：" class="headerlink" title="继承自threading.Thread类："></a>继承自threading.Thread类：</h2><ol>
<li><p>自己写的类继承自<code>threading.Thread</code>类。</p>
</li>
<li><p>线程代码需要放在run方法中执行。</p>
</li>
<li><p>以后创建线程的时候，直接使用我们自己创建的类来创建线程就可以了。</p>
</li>
<li><p>为什么要使用类的方式创建线程呢？原因是因为类可以更加方便的管理我们的代码，可以让我们使用面向对象的方式进行编程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dance</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread_plus</span>():</span></span><br><span class="line">    t1 = Code()</span><br><span class="line">    t2 = Dance()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="全局变量共享的问题："><a href="#全局变量共享的问题：" class="headerlink" title="全局变量共享的问题："></a>全局变量共享的问题：</h2><p>在多线程中，如果需要修改全局变量，那么需要在修改全局变量的地方使用锁锁起来，执行完成后再把锁释放掉。<br>使用锁的原则：</p>
<ol>
<li><strong>把尽量少的和不耗时的代码放到锁中执行。</strong></li>
<li><strong>代码执行完成后要记得释放锁。</strong><br>在Python中，可以使用<code>threading.Lock</code>来创建锁，<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作。</li>
</ol>
<h2 id="生产者和消费者模式："><a href="#生产者和消费者模式：" class="headerlink" title="生产者和消费者模式："></a>生产者和消费者模式：</h2><p>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。通过生产者和消费者模式，可以让代码达到高内聚低耦合的目标，程序分工更加明确，线程更加方便管理。</p>
<h3 id="Lock版本的生产者和消费者模式："><a href="#Lock版本的生产者和消费者模式：" class="headerlink" title="Lock版本的生产者和消费者模式："></a>Lock版本的生产者和消费者模式：</h3><p>通过<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作</p>
<h2 id="Condition版本的生产者和消费者模式："><a href="#Condition版本的生产者和消费者模式：" class="headerlink" title="Condition版本的生产者和消费者模式："></a>Condition版本的生产者和消费者模式：</h2><p>Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下是一些常用的函数：</p>
<ol>
<li>acquire：上锁。</li>
<li>release：解锁。</li>
<li>wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li>
<li>notify：通知某个正在等待的线程，默认是第1个等待的线程。</li>
<li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li>
</ol>
<h2 id="线程安全的队列Queue："><a href="#线程安全的队列Queue：" class="headerlink" title="线程安全的队列Queue："></a>线程安全的队列Queue：</h2><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：<br>初始化Queue(maxsize)：创建一个先进先出的队列。</p>
<ol>
<li>qsize()：返回队列的大小。</li>
<li>empty()：判断队列是否为空。</li>
<li>full()：判断队列是否满了。</li>
<li>get()：从队列中取最后一个数据。默认情况下是阻塞的，也就是说如果队列已经空了，那么再调用就会一直阻塞，直到有新的数据添加进来。也可以使用<code>block=False</code>，来关掉阻塞。如果关掉了阻塞，在队列为空的情况获取就会抛出异常。</li>
<li>put()：将一个数据放到队列中。跟get一样，在队列满了的时候也会一直阻塞，并且也可以通过block=False来关掉阻塞，同样也会抛出异常。</li>
</ol>
<h3 id="实战（下载王者荣耀壁纸）"><a href="#实战（下载王者荣耀壁纸）" class="headerlink" title="实战（下载王者荣耀壁纸）"></a>实战（下载王者荣耀壁纸）</h3><h4 id="版本一-不加线程"><a href="#版本一-不加线程" class="headerlink" title="版本一: 不加线程"></a>版本一: 不加线程</h4><p>壁纸的内容是通过后台数据渲染上去的，这些数据是通过</p>
<p>“workList_inc.cgi?activityId=2735&amp;sVerifyCode=ABCD&amp;…267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1618065287348”</p>
<p>该请求获取的，获取该请求的url，就可以获取json数据，json数据中有图片的地址及其他详细信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据主页获取所有详细照片的内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://pvp.qq.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;....&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将获取到的数据变成json格式，即dict个数</span></span><br><span class="line">    datas = requests.get(url, headers=head).json()</span><br><span class="line">    <span class="keyword">return</span> datas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析json详细照片内容,将照片的真实递增返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        url = parse.unquote(data[<span class="string">&#x27;sProdImgNo_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)])</span><br><span class="line">        url = url.replace(<span class="string">&quot;/200&quot;</span>, <span class="string">&quot;/0&quot;</span>)</span><br><span class="line">        urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=0&amp;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>): <span class="comment"># 获取25页全部内容</span></span><br><span class="line">        page_url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        datas = get_detail(page_url)</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">            urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">            name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">            <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">            dir_name = os.path.join(<span class="string">&#x27;image01&#x27;</span>, name)</span><br><span class="line">            os.mkdir(dir_name)  <span class="comment"># 创建该文件</span></span><br><span class="line">            print(name)</span><br><span class="line">            <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                print(url)</span><br><span class="line">                <span class="comment"># 开始下载</span></span><br><span class="line">                request.urlretrieve(url, os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(index))))</span><br><span class="line">                print(dir_name + <span class="string">&quot;\\&quot;</span> + <span class="built_in">str</span>(index + <span class="number">1</span>) + <span class="string">&quot;保存完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="版本二：-加线程"><a href="#版本二：-加线程" class="headerlink" title="版本二： 加线程"></a>版本二： 加线程</h4><p>get_detail 与 get_data 两个后去数据的方法不变，其他的进行优化</p>
<p>1.把所有page页的url放入page_queen队列中，让多个生产者根据队列中url生产图片的地址，并保存到image_queen队列中；</p>
<p>2.多个消费者根据page_queen队列中的内容消费，即根据对应图片url下载图片</p>
<p>注: 继承threading.Thread类如果要传参数，就需要重写初始化（init） 方法 , 还需调用父类的init方法</p>
<p>super(Product, self).<strong>init</strong>(*args, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产图片地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, page_queen, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Product, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queen = page_queen</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.page_queen.empty():</span><br><span class="line">            datas = get_detail(self.page_queen.get())</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">                name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">                print(name)</span><br><span class="line">                <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">                dir_name = os.path.join(<span class="string">&#x27;image02&#x27;</span>, name)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):  <span class="comment"># 创建该文件</span></span><br><span class="line">                    os.mkdir(dir_name)</span><br><span class="line">                urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">                <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                    image_detail = &#123;<span class="string">&#x27;image_url&#x27;</span>: url,</span><br><span class="line">                                    <span class="string">&#x27;image_path&#x27;</span>: os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(index+<span class="number">1</span>))&#125;</span><br><span class="line">                    self.image_queen.put(image_detail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费图片地址，下载到本地</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                image_detail = self.image_queen.get(timeout=<span class="number">10</span>)  <span class="comment"># 10秒超时就会报错</span></span><br><span class="line">                url = image_detail.get(<span class="string">&#x27;image_url&#x27;</span>)</span><br><span class="line">                path = image_detail.get(<span class="string">&#x27;image_path&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(url, path)</span><br><span class="line">                    print(path + <span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(path + <span class="string">&quot;下载失败&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=&#123;&#125;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    page_queen = queue.Queue(<span class="number">25</span>)  <span class="comment"># 保存基本页的安全队列</span></span><br><span class="line">    image_queen = queue.Queue(<span class="number">1000</span>)  <span class="comment"># 保存图片地址的安全队列</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):  <span class="comment"># 获取25页地址</span></span><br><span class="line">        page_queen.put(base_url.<span class="built_in">format</span>(page))</span><br><span class="line">        print(page_queen.get())</span><br><span class="line">    <span class="comment"># 3个生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        product = Product(page_queen, image_queen, name=<span class="string">&#x27;生产者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        product.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5个消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        consumer = Consumer(image_queen, name=<span class="string">&#x27;消费者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        consumer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/2021/04/07/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><a href="https://imgtu.com/i/cG2ODP"><img src="https://z3.ax1x.com/2021/04/07/cG2ODP.png" alt="cG2ODP.png"></a></p>
<a id="more"></a>

<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：m = 3, n = 7<br>输出：28</p>
<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>
<h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一: 动态规划"></a>方法一: 动态规划</h3><p>对于(0,0)这个点来说，它只能往右走、或者往下走。<br>那么反过来看，哪个点可以到达(2,2)呢？</p>
<p>1.只能是它的上方(1,2)这个点<br>2.或者是它的左方(2,1)这个点</p>
<p><a href="https://imgtu.com/i/cGzbB6"><img src="https://z3.ax1x.com/2021/04/08/cGzbB6.png" alt="cGzbB6.png" style="zoom:50%;" /></a></p>
<p>搞清楚这个关系，动态规划的转移方程就可以很容易写出来了，第一一个二维数组，用来存放途中每一个点的路径数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure>
<p>这里还需要额外处理第一行与第一列，将他们的值只设置成1即可</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">      ints[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 第一列</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          ints[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第一行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          ints[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">              ints[i][j] = ints[i - <span class="number">1</span>][j] + ints[i][j - <span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ints[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>我们在二维数组推导的时发现,  dp(i)(j) 的值来自于 dp(i-1)(j)和 dp(i)(j-1)。<br>也就是只需要上一行的值就可以了，上上一行的并不需要了，所以这里可以用滚动数组的方式优化一下空间。</p>
<p>将原先<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code><br>改为：<br><code>dp[j] = dp[j] + dp[j - 1]</code></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       <span class="comment">// 默认全都填充为 1</span></span><br><span class="line">       Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">              dp[j]=dp[j]+dp[j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>


<h3 id="方法二-递归"><a href="#方法二-递归" class="headerlink" title="方法二: 递归"></a>方法二: 递归</h3><p><a href="https://imgtu.com/i/cGWyO1"><img src="https://z3.ax1x.com/2021/04/07/cGWyO1.png" alt="cGWyO1.png" style="zoom:50%;" /></a></p>
<p>从(0,0)出发，走到(m,n)的所有路径，应该是由两条路线加起来的：</p>
<p>1.从(0,0)为起点，往右的所有路径<br>2.从(0,0)为起点，往下的所有路径<br>把上面的(1)和(2)加起来即为总路径了。<br>所以递归的核心逻辑就是:</p>
<p>result = dfs(i + 1, j) + dfs(i, j + 1)</p>
<p>就是到达边界时，会触发递归终止，然后返回</p>
<p>也就是当<code>i == m - 1</code>时，或者<code>j == n - 1</code>时，递归返回</p>
<p><a href="https://imgtu.com/i/cGWXtS"><img src="https://z3.ax1x.com/2021/04/07/cGWXtS.png" alt="cGWXtS.png" style="zoom:50%;" /></a></p>
<p>有大量的重复调用会导致超时，如起点为<code>(0,0)</code>时，会有大量重复调用。<br>这里用纯递归是不行的，需要加个缓存</p>
<p><a href="https://imgtu.com/i/cGfI4U"><img src="https://z3.ax1x.com/2021/04/07/cGfI4U.png" alt="cGfI4U.png" style="zoom:50%;" /></a></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dfs(<span class="keyword">new</span> HashMap&lt;Pair, Integer&gt;(), <span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归不同路径</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;Pair, Integer&gt; cache, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      Pair p = <span class="keyword">new</span> Pair(i, j);</span><br><span class="line">      <span class="comment">// 如果存在就直接返回，节省时间</span></span><br><span class="line">      <span class="keyword">if</span> (cache.containsKey(p)) &#123;</span><br><span class="line">          <span class="keyword">return</span> cache.get(p);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到了边界就返回</span></span><br><span class="line">      <span class="keyword">if</span> (i == m - <span class="number">1</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 加入缓存，key为当前p，value为向左递归 + 向右的递归值</span></span><br><span class="line">      cache.put(p, dfs(cache, i + <span class="number">1</span>, j, m, n) + dfs(cache, i, j + <span class="number">1</span>, m, n));</span><br><span class="line">      <span class="keyword">return</span> cache.get(p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同路径二"><a href="#不同路径二" class="headerlink" title="不同路径二"></a>不同路径二</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<h3 id="方法一-动态规划-1"><a href="#方法一-动态规划-1" class="headerlink" title="方法一:动态规划"></a>方法一:动态规划</h3><p>在上面的基础上添加条件即可,如果 obstacleGrid(i)(j)== 1 就跳过该点，不添加</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">       ints[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">               <span class="comment">// 只添加可走的值，障碍物默认为0</span></span><br><span class="line">               <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       ints[i][j] = ints[i - <span class="number">1</span>][j] + ints[i][j - <span class="number">1</span>];</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;  <span class="comment">//  第一列,添加上一个的值</span></span><br><span class="line">                       ints[i][j] = ints[i - <span class="number">1</span>][j];</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;  <span class="comment">// 第一行，添加左边的值</span></span><br><span class="line">                       ints[i][j] = ints[i][j - <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回最后一个值</span></span><br><span class="line">       <span class="keyword">return</span> ints[ints.length - <span class="number">1</span>][ints[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>动态爬虫</title>
    <url>/2021/04/10/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="动态网页爬虫的解决方案："><a href="#动态网页爬虫的解决方案：" class="headerlink" title="动态网页爬虫的解决方案："></a>动态网页爬虫的解决方案：</h2><ol>
<li>直接分析ajax调用的接口。然后通过代码请求这个接口。</li>
<li>使用Selenium+chromedriver模拟浏览器行为获取数据。</li>
</ol>
<a id="more"></a>

<h2 id="selenium和chromedriver："><a href="#selenium和chromedriver：" class="headerlink" title="selenium和chromedriver："></a>selenium和chromedriver：</h2><p>基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># chromedriver在本地的地址</span></span><br><span class="line">path = <span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span></span><br><span class="line">driver = webdriver.Chrome(path)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用selenium关闭浏览器："><a href="#使用selenium关闭浏览器：" class="headerlink" title="使用selenium关闭浏览器："></a>使用selenium关闭浏览器：</h3><ol>
<li>driver.close():关闭当前的页面。</li>
<li>driver.quit()：关闭整个浏览器。</li>
</ol>
<h3 id="selenium定位元素："><a href="#selenium定位元素：" class="headerlink" title="selenium定位元素："></a>selenium定位元素：</h3><ol>
<li>find_element_by_id：根据id来查找某个元素。</li>
<li>find_element_by_class_name：根据类名查找元素。</li>
<li>find_element_by_name：根据name属性的值来查找元素。</li>
<li>find_element_by_tag_name：根据标签名来查找元素。</li>
<li>find_element_by_xpath：根据xpath语法来获取元素。</li>
<li>find_element_by_css_selector：根据css选择器选择元素。</li>
<li>find_element_by_link_text: 根据超链接的文本选中元素</li>
</ol>
<p>要注意，find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素，find_element_by_id除外</p>
<h3 id="selenium表单操作："><a href="#selenium表单操作：" class="headerlink" title="selenium表单操作："></a>selenium表单操作：</h3><ol>
<li><p>webelement.send_keys：给输入框填充内容。</p>
</li>
<li><p>webelement.click：点击。</p>
</li>
<li><p>操作select标签：需要首先用<code>from selenium.webdriver.support.ui import Select</code>来包装一下选中的对象，才能进行<code>select</code>选择：</p>
<ul>
<li>select_by_index：按索引进行选择。</li>
<li>select_by_value：按值进行选择。</li>
<li>select_by_visible_text：按照可见文本进行选择。</li>
</ul>
<h5 id="登入知乎小案例"><a href="#登入知乎小案例" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line">login = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">login.click()</span><br><span class="line">username = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">username.send_keys(<span class="string">&#x27;17379621235&#x27;</span>)</span><br><span class="line">password.send_keys(<span class="string">&#x27;12313&#x27;</span>)</span><br><span class="line">do_login = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line">do_login.click()</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="selenium行为链："><a href="#selenium行为链：" class="headerlink" title="selenium行为链："></a>selenium行为链：</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类selenium.webdriver.common.action_chains.ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。</p>
<h4 id="登入知乎小案例-1"><a href="#登入知乎小案例-1" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line"><span class="comment"># 激活行为链</span></span><br><span class="line">chains = ActionChains(driver)</span><br><span class="line"><span class="comment"># 移动到密码登入，再单击,进入到密码登入</span></span><br><span class="line">loginTag = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">chains.move_to_element(loginTag)</span><br><span class="line">chains.click()</span><br><span class="line">chains.perform()</span><br><span class="line">usernameTag = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">passwordTag = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">doLoginTag = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line"><span class="comment"># 移动到用户名表单，再输入</span></span><br><span class="line">chains.move_to_element(usernameTag)</span><br><span class="line">chains.send_keys_to_element(usernameTag,<span class="string">&quot;17379621235&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到密码表单，再输入</span></span><br><span class="line">chains.move_to_element(passwordTag)</span><br><span class="line">chains.send_keys_to_element(passwordTag,<span class="string">&quot;xxxxxxxx&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到登入按钮，再单击</span></span><br><span class="line">chains.move_to_element(doLoginTag)</span><br><span class="line">chains.click()</span><br><span class="line"><span class="comment"># 执行上面操作</span></span><br><span class="line">chains.perform()</span><br></pre></td></tr></table></figure>
<p>还有更多的鼠标相关的操作。<br>click_and_hold(element)：点击但不松开鼠标。<br>context_click(element)：右键点击。<br>double_click(element)：双击。 </p>
<p>更多方法请参考：<a href="http://selenium-python.readthedocs.io/api.html">http://selenium-python.readthedocs.io/api.html</a></p>
<p><strong>为什么需要行为链条？</strong><br>因为有些网站可能会在浏览器端做一些验证行为是否符合人类的行为来做反爬虫。这时候我们就可以使用行为链来模拟人的操作。行为链有更多的复杂操作，比如双击，右键等，在自动化测试中非常有用。</p>
<h3 id="操作cookie："><a href="#操作cookie：" class="headerlink" title="操作cookie："></a>操作cookie：</h3><ol>
<li><p>获取所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure></li>
<li><p>根据cookie的key获取value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>删除所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure></li>
<li><p>删除某个cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>添加cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.add_cookie(&#123;“name”:”username”,”value”:”abc”&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="隐式等待和显式等待："><a href="#隐式等待和显式等待：" class="headerlink" title="隐式等待和显式等待："></a>隐式等待和显式等待：</h3></li>
<li><p>隐式等待：指定一个时间，在这个时间内一直会处于等待状态。隐式等待需要使用<code>driver.implicitly_wait</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"><span class="comment"># 隐式等待</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># 等待10秒</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;ksdjflksd&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>显式等待：指定在某个时间内，如果某个条件满足了，那么就不会再等待，如果在指定的时间内条件都不满足，那么就不会再等待了。显式等待用的方法是<code>from selenium.webdriver.support.ui import WebDriverWait</code>。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait  <span class="comment"># 显示等待</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC  <span class="comment"># 条件</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示等待(12306小案例)</span></span><br><span class="line">driver.get(<span class="string">&quot;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&quot;</span>)</span><br><span class="line"><span class="comment"># 满足以下两个条件或则等待10秒再向下执行</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">   	</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;fromStationText&#x27;</span>), <span class="string">&#x27;长沙&#x27;</span>),</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;toStationText&#x27;</span>), <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">print(<span class="string">&quot;skdjflfhgjklksdjflk&quot;</span>)</span><br><span class="line">search = driver.find_element_by_id(<span class="string">&#x27;query_ticket&#x27;</span>)</span><br><span class="line">search.click()</span><br></pre></td></tr></table></figure>
<h3 id="打开新窗口和切换页面："><a href="#打开新窗口和切换页面：" class="headerlink" title="打开新窗口和切换页面："></a>打开新窗口和切换页面：</h3></li>
<li><p>selenium中没有专门的打开新窗口的方法，是通过<code>window.execute_script()</code>来执行<code>js</code>脚本的形式来打开新窗口的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.execute_script(<span class="string">&quot;window.open(&#x27;https://www.douban.com/&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>打开新的窗口后<code>driver</code>当前的页面依然还是之前的，如果想要获取新的窗口的源代码，那么就必须先切换过去。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.switch_to.window(driver.window_handlers[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3></li>
</ol>
<p>设置代理通过<code>ChromeOptions</code>来设置，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://110.52.235.176:9999&quot;</span>)</span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&quot;D:\ProgramApp\chromedriver\chromedriver73.exe&quot;</span>,chrome_options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;http://httpbin.org/ip&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li>webelement.get_property：获取html标签中官方写好的属性。</li>
<li>webelement.get_attribute：获取html标签中官方和非官方的属性。</li>
<li>driver.save_screenshoot（”curr.png”）：获取当前页面的截图，有时候请求失败了，那么可以把当前网页的截图保存下来，方便后期进行分析。</li>
<li>print(driver.page_source) ： 获取网页源代码</li>
</ol>
<h3 id="12306抢票实战"><a href="#12306抢票实战" class="headerlink" title="12306抢票实战"></a>12306抢票实战</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9：商务座 ，M：一等座，O：二等座，3：硬卧，4：软卧，1：硬座 ....</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    login_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/resources/login.html&#x27;</span></span><br><span class="line">    person_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/view/index.html&#x27;</span></span><br><span class="line">    select_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&#x27;</span></span><br><span class="line">    sure_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/confirmPassenger/initDc&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trains:&#123;&quot;G67&quot;: [&#x27;M&#x27;, &#x27;O&#x27;],&quot;G533&quot;: [&#x27;9&#x27;, &#x27;M&#x27;, &#x27;O&#x27;]&#125;   表示可以接受的列车与座位</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, from_station, to_station, date, trains, users</span>):</span></span><br><span class="line">        self.from_station = from_station</span><br><span class="line">        self.to_station = to_station</span><br><span class="line">        self.date = date</span><br><span class="line">        self.trains = trains</span><br><span class="line">        self.users = users</span><br><span class="line">        self.station_code = &#123;&#125;</span><br><span class="line">        self.initCode()</span><br><span class="line">        self.train_number = <span class="literal">None</span></span><br><span class="line">        self.train_place = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据地名获取该地名相关代号,文件内容在stations.csv中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initCode</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stations.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.DictReader(f)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">                name = line.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                code = line.get(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">                self.station_code[name] = code</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.login_url)</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.person_url)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选票</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.select_url)</span><br><span class="line">        <span class="comment"># 关闭提示弹框</span></span><br><span class="line">        sure = driver.find_element_by_id(<span class="string">&quot;qd_closeDefaultWarningWindowDialog_id&quot;</span>)</span><br><span class="line">        sure.click()</span><br><span class="line">        <span class="comment"># 起始地 , 通过js脚本给隐藏的input标签赋值</span></span><br><span class="line">        from_input = driver.find_element_by_id(<span class="string">&quot;fromStation&quot;</span>)</span><br><span class="line">        from_code = self.station_code[self.from_station]  <span class="comment"># &#x27;BOP&#x27;, &#x27;北京&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % from_code, from_input)</span><br><span class="line">        <span class="comment"># 目的地</span></span><br><span class="line">        to_input = driver.find_element_by_id(<span class="string">&quot;toStation&quot;</span>)</span><br><span class="line">        to_code = self.station_code[self.to_station]  <span class="comment"># &#x27;长沙&#x27;: &#x27;CSQ&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % to_code, to_input)</span><br><span class="line">        <span class="comment"># 时间</span></span><br><span class="line">        date_input = driver.find_element_by_id(<span class="string">&quot;train_date&quot;</span>)</span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % self.date, date_input)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        search = driver.find_element_by_id(<span class="string">&quot;query_ticket&quot;</span>)</span><br><span class="line">        search.click()</span><br><span class="line">        <span class="comment"># 等待加载完毕，再预定合适的票</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 获取所有列车信息，并遍历</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 一直循环查询，直到选中票</span></span><br><span class="line">            trains = driver.find_elements_by_xpath(<span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr[not(@datatran)]&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> train <span class="keyword">in</span> trains:</span><br><span class="line">                train_list = train.text.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                print(train_list)</span><br><span class="line">                number = train_list[<span class="number">0</span>]  <span class="comment"># 车次</span></span><br><span class="line">                <span class="comment"># 如果当前列车是自己可以接受的列车，就进行选座位</span></span><br><span class="line">                <span class="keyword">if</span> number <span class="keyword">in</span> self.trains:</span><br><span class="line">                    is_selected = <span class="literal">False</span>  <span class="comment"># 标记是否选中了座位</span></span><br><span class="line">                    select_place = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 标记选中的座位</span></span><br><span class="line">                    places = self.trains[number]  <span class="comment"># 获取该车次可以接受的座位</span></span><br><span class="line">                    <span class="keyword">for</span> place <span class="keyword">in</span> places:</span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;9&quot;</span>:  <span class="comment"># 商务坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">7</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">7</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;M&quot;</span>:  <span class="comment"># 一等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">8</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">8</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;M&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;O&quot;</span>:  <span class="comment"># 二等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">9</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">9</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                    <span class="comment"># 如果选中了座位，就结束循环，并预定</span></span><br><span class="line">                    <span class="keyword">if</span> is_selected:</span><br><span class="line">                        pre = train.find_element_by_xpath(<span class="string">&quot;.//a[@class=&#x27;btn72&#x27;]&quot;</span>)</span><br><span class="line">                        pre.click()</span><br><span class="line">                        self.train_number = number</span><br><span class="line">                        self.train_place = select_place</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确认乘客与座位，正式预定</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sure_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.sure_url)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 选中乘车人</span></span><br><span class="line">        users = driver.find_elements_by_xpath(<span class="string">&quot;//ul[@id=&#x27;normal_passenger_id&#x27;]/li/label&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">            <span class="keyword">if</span> user.text <span class="keyword">in</span> self.users:</span><br><span class="line">                user.click()</span><br><span class="line">        <span class="comment"># 选中座位类型</span></span><br><span class="line">        place_select = Select(driver.find_element_by_id(<span class="string">&quot;seatType_1&quot;</span>))</span><br><span class="line">        place_select.select_by_value(self.train_place)</span><br><span class="line">        <span class="comment"># 提交订单</span></span><br><span class="line">        sure_btn = driver.find_element_by_id(<span class="string">&quot;submitOrder_id&quot;</span>)</span><br><span class="line">        sure_btn.click()</span><br><span class="line">        <span class="comment"># 等待加载核对信息对话框,与确定按钮</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//div[@id=&#x27;content_checkticketinfo_id&#x27;]&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">&quot;qr_submit_id&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 单击确定按钮，正式生产订单,这里确定按钮不生效，一直循环暴力点击确定按钮，直到获取不到该按钮</span></span><br><span class="line">        sure_btn_final = driver.find_element_by_id(<span class="string">&quot;qr_submit_id&quot;</span>)</span><br><span class="line">        sure_btn_final.click()</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     try:</span></span><br><span class="line">        <span class="comment">#         sure_btn_final.click()</span></span><br><span class="line">        <span class="comment">#         # sure_btn_final = driver.find_element_by_id(&quot;qr_submit_id&quot;)</span></span><br><span class="line">        <span class="comment">#         sure_btn_final = driver.find_element_by_id(&quot;back_edit_id&quot;)</span></span><br><span class="line">        <span class="comment">#     except ElementNotInteractableException:</span></span><br><span class="line">        <span class="comment">#         print(&quot;抢票成功,车次:&quot; + self.train_number + &quot;,席位:&quot; + self.train_place)</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行该代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.select_ticket()</span><br><span class="line">        self.sure_ticket()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    spider = Spider(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;长沙&quot;</span>, <span class="string">&quot;2021-04-17&quot;</span>, &#123;<span class="string">&quot;K21&quot;</span>: [<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], <span class="string">&quot;G529&quot;</span>: [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]&#125;, [<span class="string">&#x27;李昭辉&#x27;</span>])</span><br><span class="line">    spider.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















































]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Selenium</tag>
        <tag>chromedriver</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬虫</title>
    <url>/2021/04/12/%E5%8F%8D%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h3 id="图片验证码识别"><a href="#图片验证码识别" class="headerlink" title="图片验证码识别"></a>图片验证码识别</h3><p>平台</p>
<p>1.云打码     2.斐斐打码 <a id="more"></a></p>
<p>这里主要介绍斐斐打码</p>
<p>官网 <a href="http://www.fateadm.com/login.html%E4%B8%AD%E6%89%BE%E5%88%B0python3">http://www.fateadm.com/login.html中找到python3</a> demo的下载链接</p>
<p><a href="http://www.fateadm.com/download/demo/python3.zip">http://www.fateadm.com/download/demo/python3.zip</a></p>
<p>下载该文件</p>
<p>该文件的使用案例在TestFunc方法中，可以复制该方法，模仿着写，并识别验证码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fateadm_api <span class="keyword">import</span> FateadmApi</span><br><span class="line"></span><br><span class="line">pd_id = <span class="string">&quot;129281&quot;</span>  <span class="comment"># 用户中心页可以查询到pd信息</span></span><br><span class="line">pd_key = <span class="string">&quot;GmNxNIU5XL4N+A49UFNtC7G0nsn456yQ&quot;</span></span><br><span class="line">app_id = <span class="string">&quot;329281&quot;</span>  <span class="comment"># 开发者分成用的账号，在开发者中心可以查询到</span></span><br><span class="line">app_key = <span class="string">&quot;Cawup44zVSJTGukiJaT3MysZs4ITe3xQ&quot;</span></span><br><span class="line">api = FateadmApi(app_id, app_key, pd_id, pd_key)</span><br><span class="line"><span class="comment"># 识别类型，</span></span><br><span class="line">pred_type = <span class="string">&quot;20500&quot;</span></span><br><span class="line"><span class="comment"># 通过文件形式识别：</span></span><br><span class="line">file_name = <span class="string">&quot;img.png&quot;</span></span><br><span class="line">res = api.PredictFromFileExtend(pred_type, file_name)</span><br><span class="line">print(<span class="string">&quot;识别后的内容为:&quot;</span>+res)</span><br></pre></td></tr></table></figure>
<h3 id="字体识别"><a href="#字体识别" class="headerlink" title="字体识别"></a>字体识别</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.网页开发者自己创造一种字体，因为在字体中每个文字都有其代号，那么以后在网页中不会 直接显示这个文字的最终的效果，而是显示他的代号，因此即使获取到了网页中的文本内 容，也只是获取到文字的代号，而不是文字本身。 </p>
<p>2.因为创造字体费时费力，并且如果把中国3000多常用汉字都实现，那么这个字体将达到几十 兆，也会影响网页的加载。一般情况下为了反爬虫，仅会针对0-9以及少数汉字进行自己单独 创建，其他的还是使用用户系统中自带的字体。</p>
<h4 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h4><p>1.一般情况下为了考虑网页渲染性能，通常网页开发者会把字体编码成base64的方式，因此我 们可以到网页中找到@font-face属性，然后获取里面的base64代码，再用Python代码进行 解码，然后再保存本地。</p>
<p>2.如果没有使用base64，还有另外一种方式，就是直接把字体文件放到服务器上，然后前端通 过@font-face中的url函数进行加载。</p>
<h4 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h4><p>1.分析字体需要将字体转换成xml文件，然后查看其中的cmap和glyf中的属性。其中cmap存储 的是code和name的映射，而glyf下存储的是每个name下的字体绘制规则。 </p>
<p>2.从第1步中我们知道了name对应的字体的绘制规则，但是还是不知道字体是长什么样子，那 么可以通过一款叫做FontCreator的软件来打开.tff的字体文件，这样就可以看到每个name对 应的字体最终的呈现效果。</p>
<p>3.在网页中，直接显示的是字体的code，而不是name。并且网页开发者为了增加爬虫的难 度，有可能在多次请求之间</p>
<p>code-&gt;name-&gt;最终字体的映射    会发生改变。但是最终字体的形 状是不会改变的，因此我们可以通过形状对比来进行判断。</p>
<p>4.我们可以通过分析字体，得出每个字体形状对应的文字，然后保存到一个字典中。以后再请 求网页的时候，就进行反向解析，先获取字体的形状，再通过字体形状反向获取代号所对应 的具体文字内容</p>
<p><a href="https://imgtu.com/i/cD7ZDA"><img src="https://z3.ax1x.com/2021/04/12/cD7ZDA.png" alt="cD7ZDA.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实习僧小案例 ，只爬取一个详情页的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================获取xml文件和ttf文件，先分析name与形状之间的关系，保存到base_font_map中=============================</span></span><br><span class="line"><span class="comment"># 保存font-face</span></span><br><span class="line">font_face = <span class="string">&#x27;。。。&#x27;</span></span><br><span class="line">binary = base64.b64decode(font_face)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 ttf 文件，以便后面的分析</span></span><br><span class="line"><span class="comment"># with open(&quot;实习僧.ttf&quot;, &#x27;wb&#x27;) as fb:</span></span><br><span class="line"><span class="comment">#     fb.write(binary)</span></span><br><span class="line">base_font = TTFont(<span class="string">&quot;实习僧.ttf&quot;</span>)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 xml 文件，以便后面的分析保存为xml文件</span></span><br><span class="line"><span class="comment"># base_font.saveXML(&quot;实习僧.xml&quot;)</span></span><br><span class="line"><span class="comment"># 获取形状映射关系</span></span><br><span class="line">glyf = base_font[<span class="string">&#x27;glyf&#x27;</span>]</span><br><span class="line"><span class="comment"># 存放正确字体与形状</span></span><br><span class="line">shape_name_map = &#123;</span><br><span class="line">    <span class="number">0</span>: glyf[<span class="string">&quot;uni30&quot;</span>],</span><br><span class="line">    <span class="number">1</span>: glyf[<span class="string">&quot;uni31&quot;</span>],</span><br><span class="line">    <span class="number">2</span>: glyf[<span class="string">&quot;uni32&quot;</span>],</span><br><span class="line">    <span class="number">3</span>: glyf[<span class="string">&quot;uni33&quot;</span>],</span><br><span class="line">    <span class="number">4</span>: glyf[<span class="string">&quot;uni34&quot;</span>],</span><br><span class="line">    <span class="number">5</span>: glyf[<span class="string">&quot;uni35&quot;</span>],</span><br><span class="line">    <span class="number">6</span>: glyf[<span class="string">&quot;uni36&quot;</span>],</span><br><span class="line">    <span class="number">7</span>: glyf[<span class="string">&quot;uni37&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">9</span>: glyf[<span class="string">&quot;uni39&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================开始爬取网页，目的:将网页的源代码中乱的字体替换成正确字体:=================================</span></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">text = requests.get(<span class="string">&quot;https://m.shixiseng.com/intern/inn_sxjh0abyyqxf&quot;</span>, headers=head).text</span><br><span class="line"><span class="comment"># 获取font-face</span></span><br><span class="line">fontFace = re.search(<span class="string">r&#x27;font-family:myFont; src: url\(&quot;data:application/octet-stream;base64,(.+?)&quot;\)&#x27;</span>, text).group(<span class="number">1</span>)</span><br><span class="line">b = base64.b64decode(fontFace)</span><br><span class="line"><span class="comment"># 这里直接放入到管道内，不动用磁盘空间</span></span><br><span class="line">baseFont = TTFont(io.BytesIO(b))</span><br><span class="line">shapes = baseFont[<span class="string">&#x27;glyf&#x27;</span>]  <span class="comment"># 所有形状</span></span><br><span class="line">cmap = baseFont.getBestCmap()  <span class="comment"># code 与 name 的映射</span></span><br><span class="line"><span class="keyword">for</span> code, name <span class="keyword">in</span> cmap.items():  <span class="comment"># code == 0xe06e</span></span><br><span class="line">    <span class="comment"># 通过名字获取形状</span></span><br><span class="line">    shape = shapes[name]</span><br><span class="line">    <span class="comment"># 遍历之前获取的shape_name_map，如果形状相等，就将code替换成正确的字体 k</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> shape_name_map.items():</span><br><span class="line">        <span class="keyword">if</span> shape == v:</span><br><span class="line">            code = <span class="built_in">hex</span>(code)  <span class="comment"># 先把code替换成16进制  57454 ==》 0xe06e</span></span><br><span class="line">            <span class="comment"># 把code替换成网页的code形式  0xe06e ==》 &amp;#xe06e</span></span><br><span class="line">            webCode = <span class="built_in">str</span>(code).replace(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;&amp;#&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 把网页的code替换成正确的字体</span></span><br><span class="line">            text = re.sub(webCode, <span class="built_in">str</span>(k),text)</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>图片验证码识别</tag>
        <tag>字体识别</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架</title>
    <url>/2021/04/16/scrapy%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Scrapy框架："><a href="#Scrapy框架：" class="headerlink" title="Scrapy框架："></a>Scrapy框架：</h1><p>写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此Scrapy把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用Scrapy框架来解决。</p>
<a id="more"></a>


<h2 id="安装Scrapy框架："><a href="#安装Scrapy框架：" class="headerlink" title="安装Scrapy框架："></a>安装Scrapy框架：</h2><ol>
<li>pip install scrapy</li>
</ol>
<h2 id="Scrapy框架架构："><a href="#Scrapy框架架构：" class="headerlink" title="Scrapy框架架构："></a>Scrapy框架架构：</h2><ol>
<li><p>Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。</p>
</li>
<li><p>Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是需要的，都是由程序员自己决定。</p>
</li>
<li><p>Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。</p>
</li>
<li><p>Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。</p>
</li>
<li><p>Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。</p>
</li>
<li><p>Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。</p>
</li>
<li><p>Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。</p>
<p><a href="https://imgtu.com/i/cRzQ1S"><img src="https://z3.ax1x.com/2021/04/16/cRzQ1S.png" alt="cRzQ1S.png" style="zoom:50%;" /></a></p>
</li>
</ol>
<h2 id="创建Scrapy项目："><a href="#创建Scrapy项目：" class="headerlink" title="创建Scrapy项目："></a>创建Scrapy项目：</h2><ol>
<li>创建项目：<code>scrapy startproject [项目名称]</code>.</li>
<li>创建爬虫：<code>cd到项目中-&gt;scrapy genspider [爬虫名称] [域名]</code>.</li>
</ol>
<h2 id="项目文件作用："><a href="#项目文件作用：" class="headerlink" title="项目文件作用："></a>项目文件作用：</h2><ol>
<li><code>settings.py</code>：用来配置爬虫的。</li>
<li><code>middlewares.py</code>：用来定义中间件。</li>
<li><code>items.py</code>：用来提前定义好需要下载的数据字段。</li>
<li><code>pipelines.py</code>：用来保存数据。</li>
<li><code>scrapy.cfg</code>：用来配置项目的。</li>
</ol>
<h2 id="CrawlSpider爬虫："><a href="#CrawlSpider爬虫：" class="headerlink" title="CrawlSpider爬虫："></a>CrawlSpider爬虫：</h2><ol>
<li>作用：可以定义规则，让Scrapy自动的去爬取我们想要的链接。而不必跟Spider类一样，手动的yield Request。</li>
<li>创建：scrapy genspider -t crawl [爬虫名] [域名]</li>
<li>提取的两个类：<ul>
<li>LinkExtrator：用来定义需要爬取的url规则。</li>
<li>Rule：用来定义这个url爬取后的处理方式，比如是否需要跟进，是否需要执行回调函数等。</li>
</ul>
</li>
</ol>
<h2 id="Scrapy-Shell："><a href="#Scrapy-Shell：" class="headerlink" title="Scrapy Shell："></a>Scrapy Shell：</h2><p>在命令行中，进入到项目所在的路径。然后：<br><code>scrapy shell 链接</code><br>在这个里面，可以先去写提取的规则，没有问题后，就可以把代码拷贝到项目中。方便写代码。</p>
<h2 id="使用twisted异步保存mysql数据：（猎云网案例）"><a href="#使用twisted异步保存mysql数据：（猎云网案例）" class="headerlink" title="使用twisted异步保存mysql数据：（猎云网案例）"></a>使用twisted异步保存mysql数据：（猎云网案例）</h2><p>在Lspider中获取网页信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> LieyunItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunSpiderSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;lieyun_spider&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;lieyunwang.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://lieyunwang.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/latest/p\d+\.html&#x27;</span>), follow=<span class="literal">True</span>),</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/archives/\d+&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">False</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        title_list = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/text()&quot;</span>).getall()</span><br><span class="line">        title = <span class="string">&quot;&quot;</span>.join(title_list).strip()</span><br><span class="line">        pub_time = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/span/text()&quot;</span>).get()</span><br><span class="line">        author = response.xpath(<span class="string">&quot;//a[contains(@class,&#x27;author-name&#x27;)]/text()&quot;</span>).get()</span><br><span class="line">        context = response.xpath(<span class="string">&quot;//div[@id=&#x27;main-text-id&#x27;]&quot;</span>).getall()</span><br><span class="line">        item = LieyunItem(title=title, pub_time=pub_time, author=author, context=context, detail_url=response.url)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>在pipeline中，使用twisted.enterprise.adbapi来创建一个连接对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunPipeline</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,mysql_config</span>):</span></span><br><span class="line">    self.dbpool = adbapi.ConnectionPool(</span><br><span class="line">        mysql_config[<span class="string">&#x27;DRIVER&#x27;</span>],</span><br><span class="line">        host=mysql_config[<span class="string">&#x27;HOST&#x27;</span>],</span><br><span class="line">        port=mysql_config[<span class="string">&#x27;PORT&#x27;</span>],</span><br><span class="line">        user=mysql_config[<span class="string">&#x27;USER&#x27;</span>],</span><br><span class="line">        password=mysql_config[<span class="string">&#x27;PASSWORD&#x27;</span>],</span><br><span class="line">        db=mysql_config[<span class="string">&#x27;DATABASE&#x27;</span>],</span><br><span class="line">        charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 重写该方法,获取配置文件中的MYSQL_CONFIG信息，再调用构造器</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">    mysql_config = crawler.settings[<span class="string">&#x27;MYSQL_CONFIG&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> cls(mysql_config)</span><br></pre></td></tr></table></figure>
<p>在插入数据的函数中，使用<code>runInteraction</code>来运行真正执行sql语句的函数。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">      <span class="comment"># 执行插入操作</span></span><br><span class="line">      result = self.dbpool.runInteraction(self.item_insert, item)</span><br><span class="line">      <span class="comment"># 失败调用</span></span><br><span class="line">      result.addErrback(self.insert_error)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 插入数据，通过游标cursor插入item中的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">item_insert</span>(<span class="params">self, cursor, item</span>):</span></span><br><span class="line">      sql = <span class="string">&quot;insert into lieyun values(null,%s,%s,%s,%s,%s)&quot;</span></span><br><span class="line">      args = (item[<span class="string">&#x27;title&#x27;</span>], item[<span class="string">&#x27;author&#x27;</span>], item[<span class="string">&#x27;detail_url&#x27;</span>], item[<span class="string">&#x27;pub_time&#x27;</span>], item[<span class="string">&#x27;context&#x27;</span>])</span><br><span class="line">      cursor.execute(sql, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出报错信息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_error</span>(<span class="params">self,fail</span>):</span></span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line">      print(fail)</span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Scrapy下载图片："><a href="#Scrapy下载图片：" class="headerlink" title="Scrapy下载图片："></a>Scrapy下载图片：</h2><ol>
<li>根据网页解析图片的链接。</li>
<li>定义一个item，上面有一定要有两个字段，一个是image_urls，一个是images。其中image_urls是用来存储图片的链接，由开发者把数据爬取下来后添加的，images时存放相关信息的，我们不需要管他</li>
<li>使用scrapy.pipelines.images.ImagesPipeline来作为数据保存的pipeline。</li>
<li>在settings.py中设置IMAGES_SOTRE来定义图片下载的路径。</li>
</ol>
<h4 id="在settings-py这样定义"><a href="#在settings-py这样定义" class="headerlink" title="在settings.py这样定义"></a>在settings.py这样定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="comment"># &#x27;zcool.pipelines.ZcoolPipeline&#x27;: 300,</span></span><br><span class="line">    <span class="comment"># 不用自己的pipeline，用scrapy自带的图片pipeline</span></span><br><span class="line">    <span class="string">&#x27;scrapy.pipelines.images.ImagesPipeline&#x27;</span>: <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 图片保存路径</span></span><br><span class="line">IMAGES_STORE = os.path.join(os.path.dirname(os.path.dirname(__file__)), <span class="string">&#x27;images&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果上面这样写的换，图片路径全在images/full中</p>
<p>如果想要有更复杂的图片保存的路径需求，可以在pipeline中重写ImagePipeline的file_path方法，这个方法用来返回每个图片的保存路径。而<code>file_path</code>方法没有<code>item</code>对象，所以我们还需要重写<code>get_media_requests</code>方法，来把<code>item</code>绑定到<code>request</code>上。注:settings.py中要改回自定义的pipeline</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> zcool <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZcoolPipeline</span>(<span class="params">ImagesPipeline</span>):</span></span><br><span class="line">    <span class="comment"># 将item数据挂载到request中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span>(<span class="params">self, item, info</span>):</span></span><br><span class="line">        requests = <span class="built_in">super</span>(ZcoolPipeline, self).get_media_requests(item, info)</span><br><span class="line">        <span class="keyword">for</span> request <span class="keyword">in</span> requests:</span><br><span class="line">            request.item = item</span><br><span class="line">        <span class="keyword">return</span> requests</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 获取原来的图片路径</span></span><br><span class="line">        origin_path = <span class="built_in">super</span>(ZcoolPipeline, self).file_path(request, response, info)</span><br><span class="line">        <span class="comment"># 获取标题，并将不合法字符删除</span></span><br><span class="line">        title = request.item[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        title = re.sub(<span class="string">r&#x27;\\/:\*\?\|&lt;&gt;&quot;&#x27;</span>, title)</span><br><span class="line">        <span class="comment"># 根据图片的标题创建文件夹</span></span><br><span class="line">        dir_path = os.path.join(settings.IMAGES_STORE, title)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_path):</span><br><span class="line">            os.mkdir(dir_path)</span><br><span class="line"></span><br><span class="line">        curr_path = origin_path.replace(<span class="string">&quot;/full&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> os.path.join(dir_path,curr_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="下载器中间件："><a href="#下载器中间件：" class="headerlink" title="下载器中间件："></a>下载器中间件：</h2><p>下载器中间件是引擎和下载器之间通信的中间件。在这个中间件中我们可以设置代理、更换请求头等来达到反反爬虫的目的。要写下载器中间件，可以在下载器中实现两个方法。</p>
<ol>
<li>process_request(self,request,spider)：  请求发送之前会执行</li>
<li>process_response(self,request,response,spider)：数据下载到引擎之前执行</li>
</ol>
<p><a href="https://imgtu.com/i/cRzl6g"><img src="https://z3.ax1x.com/2021/04/16/cRzl6g.png" alt="cRzl6g.png" style="zoom:50%;" /></a></p>
<h4 id="Scrapy中更换请求头：使用fake-useragent-动态更换"><a href="#Scrapy中更换请求头：使用fake-useragent-动态更换" class="headerlink" title="Scrapy中更换请求头：使用fake_useragent 动态更换"></a>Scrapy中更换请求头：使用fake_useragent 动态更换</h4><p>pip install fake_useragent</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 自定义跟换请求头中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        <span class="comment"># 更换请求头</span></span><br><span class="line">        request.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = ua.random</span><br></pre></td></tr></table></figure>
<h4 id="Scrapy中设置代理："><a href="#Scrapy中设置代理：" class="headerlink" title="Scrapy中设置代理："></a>Scrapy中设置代理：</h4><ol>
<li><p>设置普通代理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义更换代理中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    proxies = &#123;<span class="string">&quot;code&quot;</span>: <span class="number">0</span>, <span class="string">&quot;data&quot;</span>: [&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;36.6.146.163&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4225</span>&#125;, &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;119.54.15.185&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4258</span>&#125;],<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;success&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        <span class="comment"># 任意选中一个代理对象</span></span><br><span class="line">        proxy = random.choice(self.proxies[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">        <span class="comment"># 更换代理</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = <span class="string">&#x27;http://&#x27;</span> + proxy[<span class="string">&#x27;ip&#x27;</span>]+<span class="string">&quot;:&quot;</span>+<span class="built_in">str</span>(proxy[<span class="string">&#x27;port&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>设置独享代理：需要提供密钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPProxyDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request,spider</span>):</span></span><br><span class="line">        proxy = <span class="string">&#x27;121.199.6.124:16816&#x27;</span></span><br><span class="line">        user_password = <span class="string">&quot;970138074:rcdj35xx&quot;</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = proxy</span><br><span class="line">        <span class="comment"># bytes</span></span><br><span class="line">        b64_user_password = base64.b64encode(user_password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        request.headers[<span class="string">&#x27;Proxy-Authorization&#x27;</span>] = <span class="string">&#x27;Basic &#x27;</span> + b64_user_password.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>代理服务商：</p>
<ul>
<li>芝麻代理：<a href="http://http.zhimaruanjian.com/">http://http.zhimaruanjian.com/</a></li>
<li>太阳代理：<a href="http://http.taiyangruanjian.com/">http://http.taiyangruanjian.com/</a></li>
<li>快代理：<a href="http://www.kuaidaili.com/">http://www.kuaidaili.com/</a></li>
<li>讯代理：<a href="http://www.xdaili.cn/">http://www.xdaili.cn/</a></li>
<li>蚂蚁代理：<a href="http://www.mayidaili.com/">http://www.mayidaili.com/</a></li>
<li>极光代理：<a href="http://www.jiguangdaili.com/">http://www.jiguangdaili.com/</a></li>
</ul>
</li>
</ol>
<h3 id="猎聘网动态更换ip代理案例"><a href="#猎聘网动态更换ip代理案例" class="headerlink" title="猎聘网动态更换ip代理案例"></a>猎聘网动态更换ip代理案例</h3><h5 id="定义一个模型，根据代理ip的json数据，解析里面的代理ip"><a href="#定义一个模型，根据代理ip的json数据，解析里面的代理ip" class="headerlink" title="定义一个模型，根据代理ip的json数据，解析里面的代理ip"></a>定义一个模型，根据代理ip的json数据，解析里面的代理ip</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, proxy_dict</span>):</span></span><br><span class="line">        proxy_data = proxy_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        self.proxy_url = <span class="string">&quot;https://&quot;</span> + proxy_data[<span class="string">&#x27;ip&#x27;</span>] + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(proxy_data[<span class="string">&#x27;port&#x27;</span>])</span><br><span class="line">        self.expire_time = datetime.datetime.strptime(proxy_data[<span class="string">&#x27;expire_time&#x27;</span>], <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        self.is_backed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 时间是否过去</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_expire</span>(<span class="params">self</span>):</span></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        <span class="comment"># 如果超时或还剩5秒就返回True</span></span><br><span class="line">        <span class="keyword">if</span> (self.expire_time - now) &lt; datetime.timedelta(seconds=<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="在中间件中定义代理ip的动态更换"><a href="#在中间件中定义代理ip的动态更换" class="headerlink" title="在中间件中定义代理ip的动态更换"></a>在中间件中定义代理ip的动态更换</h5><p>process_request : 更换 ip </p>
<p>process_response: 判断返回的网页是否有问题，如果有就标记  is_backed 为True，表示当前ip加入了黑名单</p>
<p>update_proxy：调用模型更新代理ip，将ip信息赋给 self.proxy_model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> proxy_model <span class="keyword">import</span> model</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiepinDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LiepinDownloaderMiddleware, self).__init__()</span><br><span class="line">        <span class="comment"># 存放代理ip的相关数据</span></span><br><span class="line">        self.proxy_model = <span class="literal">None</span></span><br><span class="line">        self.proxy_url = <span class="string">&#x27;通过代理服务商获取ip地址&#x27;</span></span><br><span class="line">        self.head = &#123; 。。。 &#125;</span><br><span class="line">        self.update_proxy()  <span class="comment"># 一开始就用代理ip</span></span><br><span class="line">        self.lock = threading.Lock() <span class="comment"># 锁</span></span><br><span class="line">        <span class="comment"># 另外开启一条线程管理ip代理</span></span><br><span class="line">        threading.Thread(target=self.update_proxy_in_thread).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = self.proxy_model.proxy_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response, spider</span>):</span></span><br><span class="line">        <span class="comment"># 如果状态码步数200，说明该代理ip加入黑名单了，需要标记一下,并直接返回request对象，下次继续加载该请求</span></span><br><span class="line">        <span class="keyword">if</span> response.status != <span class="number">200</span>:</span><br><span class="line">            self.lock.locked()  <span class="comment"># 加锁</span></span><br><span class="line">            self.proxy_model.is_backed = <span class="literal">True</span></span><br><span class="line">            self.lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line">            <span class="keyword">return</span> request</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新代理ip，将ip信息赋给self.proxy_model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy</span>(<span class="params">self</span>):</span></span><br><span class="line">        proxy_dict = requests.get(self.proxy_url, headers=self.head).json()</span><br><span class="line">        proxy_model = model(proxy_dict)</span><br><span class="line">        self.proxy_model = proxy_model</span><br><span class="line">        print(<span class="string">&quot;更换了代理&quot;</span>)</span><br><span class="line">        print(self.proxy_model.proxy_url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程的方式更新代理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy_in_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="comment"># 每过5秒检查一次，如果代理 运行了60秒或 加入黑名单或 超时，就更换代理</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">60</span> <span class="keyword">or</span> self.proxy_model.is_backed <span class="keyword">or</span> self.proxy_model.is_expire:</span><br><span class="line">                self.update_proxy()</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count + <span class="number">5</span></span><br><span class="line">                print(<span class="string">&quot;代理运行了&quot;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;秒&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Scrapy中使用selenium动态爬虫"><a href="#Scrapy中使用selenium动态爬虫" class="headerlink" title="Scrapy中使用selenium动态爬虫"></a>Scrapy中使用selenium动态爬虫</h2><p>在中间件的request中使用selenium获取网页数据，直接返回给爬虫进行解析数据</p>
<h3 id="简书案例-获取加载更多中的全部数据"><a href="#简书案例-获取加载更多中的全部数据" class="headerlink" title="简书案例,获取加载更多中的全部数据"></a>简书案例,获取加载更多中的全部数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> scrapy.http.response.html <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianshuDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="comment"># 初始化dirver</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(JianshuDownloaderMiddleware, self).__init__()</span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拦截请求，自定义发送动态爬虫，直接返回response对象给爬虫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        self.driver.get(request.url)</span><br><span class="line">        <span class="comment"># 等待加载</span></span><br><span class="line">        WebDriverWait(self.driver, <span class="number">8</span>).until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, <span class="string">&quot;//section[position()=2]/h3&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 循环点击加载更多，直到加载完毕即可</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                add_more = self.driver.find_element_by_xpath(<span class="string">&quot;//section[position()=2]/div/div[@role=&#x27;button&#x27;]&quot;</span>)</span><br><span class="line">                print(add_more)</span><br><span class="line">                self.driver.execute_script(<span class="string">&quot;arguments[0].click();&quot;</span>, add_more)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        response = HtmlResponse(request.url, request=request, body=self.driver.page_source,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>此时爬虫spider中获取的response是从上面这个方法中传过来的，可以根据自己的需求获取相关数据</p>
<h6 id="更多的介绍请参考API：https-scrapyd-readthedocs-io-en-stable-api-html"><a href="#更多的介绍请参考API：https-scrapyd-readthedocs-io-en-stable-api-html" class="headerlink" title="更多的介绍请参考API：https://scrapyd.readthedocs.io/en/stable/api.html"></a>更多的介绍请参考API：<a href="https://scrapyd.readthedocs.io/en/stable/api.html">https://scrapyd.readthedocs.io/en/stable/api.html</a></h6><p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas库</title>
    <url>/2021/04/18/pandas%E5%BA%93/</url>
    <content><![CDATA[<p>pandas的基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pandas.Series(</span><br><span class="line"> data = <span class="literal">None</span>,</span><br><span class="line"> index = <span class="literal">None</span>,</span><br><span class="line"> dtype = <span class="literal">None</span>,</span><br><span class="line"> name = <span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Serires的dtype"><a href="#Serires的dtype" class="headerlink" title="Serires的dtype"></a>Serires的dtype</h3><p>• int8/int16/int32/int64(默认): 整型 </p>
<p>• float16/float32/float64(默认): 浮点型 </p>
<p>• str/string: 字符串 • bool: 布尔 </p>
<p>• category: 分类 • datetime64[ns]: 时间戳(纳秒) </p>
<p>• period[Y/M/D]: 时间周期(年/月/日) </p>
<p>• object: python对象混合类型</p>
<h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><h4 id="通过2维的list-like创建"><a href="#通过2维的list-like创建" class="headerlink" title="通过2维的list-like创建"></a>通过2维的list-like创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]], columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="通过字典创建"><a href="#通过字典创建" class="headerlink" title="通过字典创建"></a>通过字典创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">6</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">2</span>, <span class="number">8</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="通过读取Excel表-最常用"><a href="#通过读取Excel表-最常用" class="headerlink" title="通过读取Excel表(最常用)"></a>通过读取Excel表(最常用)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(<span class="string">&quot;xxx.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas读excel文件-pandas-read-excel-的参数"><a href="#pandas读excel文件-pandas-read-excel-的参数" class="headerlink" title="pandas读excel文件:pandas.read_excel()的参数"></a>pandas读excel文件:pandas.read_excel()的参数</h2><h4 id="io-路径-StringIO-URL"><a href="#io-路径-StringIO-URL" class="headerlink" title="io    路径, StringIO, URL"></a>io    路径, StringIO, URL</h4><p>可以使用os.chdir(“….”)来切换当前路径</p>
<h4 id="sheet-name-0-选择子表-sheet"><a href="#sheet-name-0-选择子表-sheet" class="headerlink" title="sheet_name=0    选择子表(sheet)"></a>sheet_name=0    选择子表(sheet)</h4><p>• int: 选第几个sheet, 下标从0开始    • str: sheet名字     • list: [0, “2月”], 返回字典    • None: 全部sheet, 返回字典</p>
<h4 id="nrows-None-要解析的行数"><a href="#nrows-None-要解析的行数" class="headerlink" title="nrows=None    要解析的行数"></a>nrows=None    要解析的行数</h4><p>norws=3   只解析当前表格的前3行，不包括表头</p>
<h4 id="sheet-header-0-指定作为’列索引’的行"><a href="#sheet-header-0-指定作为’列索引’的行" class="headerlink" title="sheet_header=0    指定作为’列索引’的行"></a>sheet_header=0    指定作为’列索引’的行</h4><p>header=[0, 1]   将第一行与第二行作为列索引，也可以   header=[‘姓名’,’年龄’]模式</p>
<h4 id="index-col-None-指定作为’行索引’的列"><a href="#index-col-None-指定作为’行索引’的列" class="headerlink" title="index_col=None     指定作为’行索引’的列"></a>index_col=None     指定作为’行索引’的列</h4><p>index_col=[0, 1]    将第一列与第二列作为行索引，注意不可以  index_col=[‘姓名’,’年龄’]   模式</p>
<h4 id="usecols-None-指定只使用哪些列"><a href="#usecols-None-指定只使用哪些列" class="headerlink" title="usecols=None    指定只使用哪些列"></a>usecols=None    指定只使用哪些列</h4><p>• int-list: [0, 2]    •str-list: [‘AAA’, ‘CCC’]   • str: ‘A,C’, ‘A,C:E’     • 函数: lambda x: x == ‘CCC’ </p>
<h4 id="skiprows-None-跳过⾏"><a href="#skiprows-None-跳过⾏" class="headerlink" title="skiprows=None  跳过⾏"></a>skiprows=None  跳过⾏</h4><p>skiprows=1  跳过第一行   ；   skiprows=[0, 2]  跳过0和2行</p>
<h4 id="dtype-None-设置列的类型"><a href="#dtype-None-设置列的类型" class="headerlink" title="dtype=None   设置列的类型"></a>dtype=None   设置列的类型</h4><p>dtype = {‘a’: ‘float64’, ‘b’: ‘int32’}</p>
<h4 id="names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。"><a href="#names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。" class="headerlink" title="names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。"></a>names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。</h4><p>header=None    </p>
<p>names=[‘⽉份’ , ‘销量’ , ‘销售额’]</p>
<h4 id="parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12"><a href="#parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12" class="headerlink" title="parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12"></a>parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12</h4><p>• True -&gt; 尝试解析index的格式</p>
<p>• [0, 1] 或 [‘a’, ‘b’] -&gt; 尝试解析指定列作为一个单独的日期列 </p>
<p>• [[0, 1, 2]] -&gt; 结合多列解析为单个日期列 ，如果年月日不在一起，可以这样使用将他们结合</p>
<p>• {‘日期’: [0, 1, 2]} -&gt; 同上, 结果的列名改为’日期’ •</p>
<h4 id="date-parser-None-function-解析日期格式的函数"><a href="#date-parser-None-function-解析日期格式的函数" class="headerlink" title="date_parser=None    function, 解析日期格式的函数"></a>date_parser=None    function, 解析日期格式的函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date_parser=<span class="keyword">lambda</span> x: pd.to_datetime(x, <span class="built_in">format</span>=<span class="string">&quot;%Y年%m月%d日&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="na-values-None-识别为-NaN-缺失值-的其他字符串"><a href="#na-values-None-识别为-NaN-缺失值-的其他字符串" class="headerlink" title="na_values=None    识别为 NaN(缺失值) 的其他字符串"></a>na_values=None    识别为 NaN(缺失值) 的其他字符串</h4><p>missing data (缺失值) (NaN)    Not a Number </p>
<p>默认情况下，以下值被解析为NaN</p>
<p> ‘-1.#IND’     ‘1.#IND’      ‘NA’     ‘#N/A’   ‘-1.#QNAN’     ‘1.#QNAN’     ‘NULL’     ‘#NA’     ‘-NaN’     ‘NaN’     ‘#N/A N/A’     ‘-nan’     ‘N/A’     ‘n/a’</p>
<p>na_values=[‘空值’, 0]   将’空值‘字符串和0变成NaN</p>
<p>na_values={1: [‘空值’, 0]}    将第二列中的’空值‘字符串和0变成NaN</p>
<h4 id="converters-None-值转换函数，注意传递的是dict"><a href="#converters-None-值转换函数，注意传递的是dict" class="headerlink" title="converters=None      值转换函数，注意传递的是dict"></a>converters=None      值转换函数，注意传递的是dict</h4><p>converters={ </p>
<p>“a”: lambda x: x +1, # 将 列’a‘中的值 + 1 </p>
<p>“b”: lambda x: x * 2, #  将列’b‘中的值 * 2</p>
<p>}</p>
<h4 id="true-values-None-变成-True-的值"><a href="#true-values-None-变成-True-的值" class="headerlink" title="true_values=None    变成 True 的值"></a>true_values=None    变成 True 的值</h4><p>true_values=[‘a’, ‘b’]     将’a‘与’b‘变成布尔类型TRUE</p>
<h4 id="false-values-None-变成-False-的值"><a href="#false-values-None-变成-False-的值" class="headerlink" title="false_values=None   变成 False 的值"></a>false_values=None   变成 False 的值</h4><p> false_values=[‘c’, ‘d’]     将’c‘与’d‘变成布尔类型FALSE</p>
<p>注意:上面的两个参数只对字符串起作⽤，并要一整列要么全部变要么全部不变</p>
<h4 id="mangle-dupe-cols-True-列名是否重复"><a href="#mangle-dupe-cols-True-列名是否重复" class="headerlink" title="mangle_dupe_cols=True   列名是否重复"></a>mangle_dupe_cols=True   列名是否重复</h4><p>如果重复命名,会自动修改 :   a    b     b   -&gt;  a   b    b.1</p>
<p>mangle_dupe_cols=False  如果出现重复命名将会报错:</p>
<p>ValueError: Setting mangle_dupe_cols=False is not supported yet</p>
<h2 id="pandas写excel文件"><a href="#pandas写excel文件" class="headerlink" title="pandas写excel文件:"></a>pandas写excel文件:</h2><h4 id="DataFrame写入excel"><a href="#DataFrame写入excel" class="headerlink" title="DataFrame写入excel"></a>DataFrame写入excel</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(</span><br><span class="line"> self,</span><br><span class="line"> excel_writer, <span class="comment"># ⽂件路径/ExcelWriter</span></span><br><span class="line"> sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, <span class="comment"># sheet名字</span></span><br><span class="line"> index=<span class="literal">True</span>, <span class="comment"># 是否输出index</span></span><br><span class="line"> float_format=<span class="literal">None</span>, <span class="comment"># 浮点数输出格式, 如: &quot;%.2f&quot;</span></span><br><span class="line"> na_rep=<span class="string">&#x27;&#x27;</span> <span class="comment"># 缺失值输出的表示形式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="用pandas-ExcelWriter类写入"><a href="#用pandas-ExcelWriter类写入" class="headerlink" title="用pandas.ExcelWriter类写入"></a>用pandas.ExcelWriter类写入</h4><p>1: 设置datatime输出格式       2: 输出多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">&#x27;tb.xlsx&#x27;</span>,datetime_format=<span class="string">&quot;YYYY-MM-DD&quot;</span>) <span class="keyword">as</span> writer:</span><br><span class="line"> df1.to_excel(writer, sheet_name=<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line"> df2.to_excel(writer, sheet_name=<span class="string">&#x27;BBB&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas写-读csv"><a href="#pandas写-读csv" class="headerlink" title="pandas写/读csv"></a>pandas写/读csv</h2><h4 id="read-csv"><a href="#read-csv" class="headerlink" title="read_csv()"></a>read_csv()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(</span><br><span class="line"> filepath, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,    <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="to-csv"><a href="#to-csv" class="headerlink" title="to_csv()"></a>to_csv()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(</span><br><span class="line"> path_or_buf, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,   <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据表处理"><a href="#pandas数据表处理" class="headerlink" title="pandas数据表处理"></a>pandas数据表处理</h2><h3 id="一-数据常用筛选方法"><a href="#一-数据常用筛选方法" class="headerlink" title="一.数据常用筛选方法"></a>一.数据常用筛选方法</h3><p>1.基础索引方式,就是直接引用 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic[[<span class="string">&#x27;户主姓名&#x27;</span>,<span class="string">&#x27;农户生产经营类型&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>2.loc [行索引名称或者条件,列索引名称或者标签]   # 左闭右闭</p>
<p>可以接多个条件(&amp; , | )：（basic[‘age’]&gt;10）&amp; (basic[‘age’]&lt;2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.loc[<span class="number">0</span>:<span class="number">2</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>]] </span><br><span class="line">basic.loc[basic[<span class="string">&#x27;健康状况&#x27;</span>]== <span class="string">&#x27;良好&#x27;</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>,<span class="string">&#x27;健康状况&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>3.iloc [行索引位置,列索引位置]   # 左闭右开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.iloc[<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">order.iloc[:,[<span class="number">0</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="二-数据增加和删除"><a href="#二-数据增加和删除" class="headerlink" title="二.数据增加和删除"></a>二.数据增加和删除</h3><h5 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h5><p>df.insert(loc, column, value)   添加一列,loc添加位置,column字段名,value添加的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.insert(<span class="number">0</span>, <span class="string">&#x27;出生年月&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h5><p>del  df[column]   # 删除一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> basic[<span class="string">&#x27;数据&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>df.drop(labels,axis,inplace=True)    </p>
<p>labels表示删除的数据, axis表示作用轴，inplace=True表示是否对原数据生效</p>
<p>axis=0按行操作, axis=1按列操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.drop(labels = [<span class="string">&#x27;日期&#x27;</span>, <span class="string">&#x27;销量&#x27;</span>],axis = <span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">basic.drop(labels= <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">11</span>),axis=<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="三-数据修改和查找"><a href="#三-数据修改和查找" class="headerlink" title="三.数据修改和查找"></a>三.数据修改和查找</h3><p>db.rename()     修改列名称或者行索引名称   ，  inplace = True表示生效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.rename(columns = &#123;<span class="string">&#x27;出生年月&#x27;</span>:<span class="string">&#x27;出生日期&#x27;</span>,<span class="string">&#x27;文化程度&#x27;</span>:<span class="string">&#x27;受教育水平&#x27;</span> &#125;,inplace = <span class="literal">True</span>) <span class="comment">#修改列</span></span><br><span class="line">basic.rename(index = &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;10&#x27;</span>:<span class="string">&#x27;ten&#x27;</span> &#125;,inplace = <span class="literal">True</span>)  <span class="comment">#修改行</span></span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>)   <span class="comment">#  重置索引，从0开始</span></span><br></pre></td></tr></table></figure>
<p>使用loc方法修改数据，查询到数据后直接赋值即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[ df[<span class="string">&#x27;性别&#x27;</span>]== <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;女‘  # 将性别为0的变成女</span></span><br></pre></td></tr></table></figure>
<p>条件与条件之间用 &amp; ， |  连接，分别代表‘且’和‘或’ ，也可以使用between和isin选择满足条件的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].between(<span class="number">18</span>,<span class="number">20</span>,inclusive=<span class="literal">True</span>)]   <span class="comment"># 获取age在18到20的行，inclusive=True表示是左右包含，False为不包含</span></span><br><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].isin([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])]  <span class="comment"># 获取age为10，20，30的行</span></span><br></pre></td></tr></table></figure>
<h3 id="四-数据整理"><a href="#四-数据整理" class="headerlink" title="四.数据整理"></a>四.数据整理</h3><p>pd.concat(objs,axis,join,ignore_index)  </p>
<p>连接多张表，objs: 表的集合, axis =1用于横向，0代表纵向,join=’inner’表示交集,等于’outer’表示并集，ignore_index=True表示重构索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([order1,order2,order3],axis=<span class="number">0</span>,ignore_index=<span class="literal">False</span>)  </span><br><span class="line"><span class="comment"># 纵向连接3张表，不重构索引，可以在后面使用df.reset_index(inplace=True),默认并集</span></span><br></pre></td></tr></table></figure>
<p>pd.merge(left,right,how,left_on,right_on)      # 很想MySQL数据库中的内连接</p>
<p>合并left与right两张表，how是链接方式，默认inner（内连接），left_on与right_on表示采用左右表的哪个字段链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp.merge(left=df1,right=df2,how=<span class="string">&#x27;inner&#x27;</span>,left_on=<span class="string">&#x27;user_id&#x27;</span>,right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="五-层次化索引"><a href="#五-层次化索引" class="headerlink" title="五.层次化索引"></a>五.层次化索引</h3><p>在一个轴上拥有两个或者两个以上的索引 </p>
<p> 使用loc语句进行访问 , loc里面接受tuple,   如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[(<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;江西&#x27;</span>),<span class="string">&#x27;name&#x27;</span>]  <span class="comment"># 获取&#x27;中国&#x27;索引中的&#x27;江西&#x27;索引的行里面的name列</span></span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">10</span>,(<span class="string">&#x27;第一季&#x27;</span>,[<span class="string">&#x27;销量&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>])]   <span class="comment"># 获取0到10行中&#x27;第一季&#x27;索引下的&#x27;销量&#x27;与&#x27;利润&#x27;列表</span></span><br></pre></td></tr></table></figure>
<h2 id="pandas数据转换"><a href="#pandas数据转换" class="headerlink" title="pandas数据转换"></a>pandas数据转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将列的数据类型变成最接近的类型</span></span><br><span class="line">df.convert_dtypes()</span><br><span class="line"><span class="comment"># 选中string类型的列</span></span><br><span class="line">df.select_dtypes(include=<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="comment"># 转换类型</span></span><br><span class="line">df[<span class="string">&#x27;销量&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一-日期格式数据处理"><a href="#一-日期格式数据处理" class="headerlink" title="一.日期格式数据处理"></a>一.日期格式数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成时间格式 datetime64</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>] = pd.to_datetime(d1[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 时间格式可以使用dt提取年月日时分秒</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>].dt.year</span><br></pre></td></tr></table></figure>
<h3 id="二-高阶函数数据处理"><a href="#二-高阶函数数据处理" class="headerlink" title="二.高阶函数数据处理"></a>二.高阶函数数据处理</h3><p>apply函数，axis=0表示对行进行操作,axis=1表示对列进行操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;贷款余额&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x).strip() )</span><br></pre></td></tr></table></figure>
<p>map函数，将dict中出现的键全部替换成值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;gender&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="三-字符串数据处理"><a href="#三-字符串数据处理" class="headerlink" title="三.字符串数据处理"></a>三.字符串数据处理</h3><p>通过 df[col].str 属性访问下列方法，例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;姓名&#x27;</span>].<span class="built_in">str</span>.srip()  <span class="comment"># 去除空白字符</span></span><br></pre></td></tr></table></figure>
<p>contains()      返回表示各str是否含有指定模式的字符串 </p>
<p>replace() 替换字符串。 </p>
<p>lower() 返回字符串的副本，其中所有字母都转换为小写。 </p>
<p>upper() 返回字符串的副本，其中所有字母都转换为大写。 </p>
<p>split() 返回字符串中的单词列表。 </p>
<p>strip() 删除前导和后置空格。 </p>
<p>join() 返回一个字符串，该字符串是给定序列中所有字符串的连接</p>
<h2 id="pandas数据统计"><a href="#pandas数据统计" class="headerlink" title="pandas数据统计"></a>pandas数据统计</h2><h3 id="一-数据分组运算"><a href="#一-数据分组运算" class="headerlink" title="一.数据分组运算"></a>一.数据分组运算</h3><p>使用 df.groupby方法进行分组计算，得到分组对象GroupBy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g1 = df.groupby(by = <span class="string">&#x27;product’)</span></span><br><span class="line"><span class="string">g2 = df.groupby(by = [&#x27;</span>product<span class="string">&#x27;,&#x27;</span>jgmc’]) </span><br></pre></td></tr></table></figure>
<p>分组对象GroupBy可以运用描述性统计方法, 如count、mean 、 median 、 max和min等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Group.mean() </span><br><span class="line">Group.<span class="built_in">sum</span>()</span><br><span class="line">Group.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<h3 id="二-聚合函数使用"><a href="#二-聚合函数使用" class="headerlink" title="二.聚合函数使用"></a>二.聚合函数使用</h3><p>象使用agg聚合函数   (np=numpy)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped.agg([np.mean,np.<span class="built_in">max</span>]).head(<span class="number">20</span>)</span><br><span class="line">grouped.agg(&#123;<span class="string">&#x27;ye&#x27;</span>:np.mean,<span class="string">&#x27;dkje&#x27;</span>:np.<span class="built_in">max</span>&#125;)</span><br><span class="line">df[[<span class="string">&#x27;销售额&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>]].agg([np.<span class="built_in">sum</span>,np.mean])</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据预处理"><a href="#pandas数据预处理" class="headerlink" title="pandas数据预处理"></a>pandas数据预处理</h2><h3 id="一-重复值处理"><a href="#一-重复值处理" class="headerlink" title="一.重复值处理"></a>一.重复值处理</h3><p>df.duplicated()   判断是否有重复值,返回掩码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.dumplicated()]  <span class="comment"># 获取重复值</span></span><br><span class="line">np.<span class="built_in">sum</span>(df.duplicated())   <span class="comment"># 获取重复的行数</span></span><br></pre></td></tr></table></figure>
<p>df.drop_duplicates()  删除重复值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>)  </span><br><span class="line"><span class="comment"># 如果[&#x27;appname&#x27;,&#x27;size&#x27;]中的值重复就表示为重复着</span></span><br><span class="line">df.drop_duplicates(subset= [<span class="string">&#x27;appname&#x27;</span>,<span class="string">&#x27;size&#x27;</span>],inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二-缺失值处理"><a href="#二-缺失值处理" class="headerlink" title="二.缺失值处理"></a>二.缺失值处理</h3><p>直接删除法 </p>
<p>df.dropna()        how=’any’ 表示只要一个是缺失值就删除，how=’all’表示全部是缺失值才删除，subset指定要判断的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(how=<span class="string">&#x27;any&#x27;</span>,subset=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])  </span><br></pre></td></tr></table></figure>
<p>均值替换、常数替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>,inplace=<span class="literal">True</span>)   <span class="comment"># 将所有缺省值替换成0,并在原表格中改变</span></span><br><span class="line">df.age.fillna(df.age.mean())     <span class="comment"># 在age中将缺失值替换成该字段的中位数</span></span><br><span class="line">df.fillna(value=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)   <span class="comment"># 根据不同情况填充不同的值</span></span><br></pre></td></tr></table></figure>
<p>前向、后向替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;age&#x27;</span>].fillna(method=<span class="string">&#x27;ffill&#x27;</span>)  <span class="comment"># 使用前一个值替换缺失值</span></span><br><span class="line">df[<span class="string">&#x27;name&#x27;</span>].fillna(method=<span class="string">&#x27;bfill&#x27;</span>)	<span class="comment"># 使用后一个值替换缺失值</span></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据清洗</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/05/07/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>git命令行操作</p>
<h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git<a id="more"></a></h4><p>git init</p>
<h4 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h4><h5 id="项目级别-仓库级别：仅在当前本地库范围内有效"><a href="#项目级别-仓库级别：仅在当前本地库范围内有效" class="headerlink" title="项目级别/仓库级别：仅在当前本地库范围内有效"></a>项目级别/仓库级别：仅在当前本地库范围内有效</h5><p>git config user.name hui</p>
<p>git config user.email <a href="mailto:&#x31;&#x37;&#54;&#x34;&#53;&#x30;&#49;&#x35;&#x36;&#55;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#x31;&#x37;&#54;&#x34;&#53;&#x30;&#49;&#x35;&#x36;&#55;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a> </p>
<p>信息保存位置：./.git/config 文件</p>
<h5 id="系统用户级别：登录当前操作系统的用户范围"><a href="#系统用户级别：登录当前操作系统的用户范围" class="headerlink" title="系统用户级别：登录当前操作系统的用户范围"></a>系统用户级别：登录当前操作系统的用户范围</h5><p>git config –global user.name hui </p>
<p>git config –global <a href="mailto:&#49;&#x37;&#54;&#52;&#53;&#48;&#x31;&#x35;&#x36;&#x37;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#49;&#x37;&#54;&#52;&#53;&#48;&#x31;&#x35;&#x36;&#x37;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d;</a> </p>
<p>信息保存位置：~/.gitconfig 文件 </p>
<h5 id="注-就近原则-项目级别优先于系统用户级别"><a href="#注-就近原则-项目级别优先于系统用户级别" class="headerlink" title="注: 就近原则,项目级别优先于系统用户级别"></a>注: 就近原则,项目级别优先于系统用户级别</h5><h4 id="其他常规操作"><a href="#其他常规操作" class="headerlink" title="其他常规操作"></a>其他常规操作</h4><p><font size='4'>状态查看   git status </font></p>
<p><font size='4'>添加  git add[file name] </font></p>
<p><font size='4'>提交 git commit -m’提交日志’ [file name] </font></p>
<h4 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h4><p><font size='4'>git log</font></p>
<p><font size='4'>git reflog  ( 最常用 )</font></p>
<p><font size='4'>git log –pretty=oneline </font></p>
<p><font size='4'>git log –oneline </font></p>
<p>多屏显示控制方式： 空格向下翻页 , b 向上翻页 , q 退出</p>
<h4 id="前进后退版本"><a href="#前进后退版本" class="headerlink" title="前进后退版本"></a>前进后退版本</h4><p>git reset –hard [局部索引值]</p>
<p>git reset –hard HEAD^</p>
<p>注：一个^表示后退一步，n 个表示后退 n 步</p>
<p>git reset –hard HEAD~n</p>
<p>注：表示后退 n 步</p>
<h4 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h4><p>–soft</p>
<p>​        仅仅在本地库移动 HEAD 指针</p>
<p>–mixed</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区</p>
<p>–hard</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区 </p>
<p>​        重置工作区</p>
<h4 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h4><p>git diff [文件名] </p>
<p>将工作区中的文件和暂存区进行比较 </p>
<p>git diff [本地库中历史版本] [文件名] </p>
<p>将工作区中的文件和本地库历史记录比较 ，如果不带文件名则比较多个文件</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>查看分支  git branch -v</p>
<p>创建分支  git branch [分支名]</p>
<p>切换分支  git checkout [分支名]</p>
<p>合并分支  git merge [有新内容分支名]</p>
<p>解决合并分支的冲突</p>
<p>​    第一步：编辑文件，删除特殊字符 </p>
<p>​    第二步：把文件修改到满意的程度，保存退出 </p>
<p>​    第三步：git add [文件名] </p>
<p>​    第四步：git commit -m “日志信息” </p>
<p>​    注意：此时 commit 一定不能带具体文件名</p>
<h4 id="github基本命令"><a href="#github基本命令" class="headerlink" title="github基本命令"></a>github基本命令</h4><p>git clone [远程地址]     克隆项目</p>
<p>git remote -v     查看当前所有远程地址别名</p>
<p>git remote add [别名] [远程地址]     添加远程地址</p>
<p>git push [别名] [分支名]     推送</p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>pull=fetch+merge </p>
<p>git fetch [远程库地址别名] [远程分支名] </p>
<p>git merge [远程库地址别名/远程分支名] </p>
<p>git pull [远程库地址别名] [远程分支名]</p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>如果不是基于GitHub远程库的最新版本所做的修改，不能推送，必须先拉取</p>
<p>拉取下来后如果进入冲突状态，则安装“分支冲突解决”操作解决即可</p>
<p>续。。。</p>
]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX笔记</title>
    <url>/2021/05/09/AJAX%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。<a id="more"></a></p>
<h3 id="前提-服务器用express测试"><a href="#前提-服务器用express测试" class="headerlink" title="前提 : 服务器用express测试"></a>前提 : 服务器用express测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> express();</span><br><span class="line"><span class="comment">// 开启一个接口，all可替换成get 、 post</span></span><br><span class="line">app.all(<span class="string">&#x27;/server&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 请求头设置跨域 </span></span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="string">&quot;res&quot;</span>:<span class="string">&quot;ajax&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">    response.send(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动8000端口监听</span></span><br><span class="line">app.listen(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器已启动，8000 端口监听中...&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="原生AJAX"><a href="#原生AJAX" class="headerlink" title="原生AJAX"></a>原生AJAX</h3><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr =<span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure>
<h5 id="初始化-open-requestType-url"><a href="#初始化-open-requestType-url" class="headerlink" title="初始化    open( requestType , url)"></a>初始化    open( requestType , url)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&quot;http://127.0.0.1:8000/server_post?page=1&amp;count=10&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-rulencoded&quot;</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;odd-dog&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="发送-参数是post请求体，如果是get请求则不用传参数"><a href="#发送-参数是post请求体，如果是get请求则不用传参数" class="headerlink" title="发送       参数是post请求体，如果是get请求则不用传参数"></a>发送       参数是post请求体，如果是get请求则不用传参数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="string">&#x27;username=admin&amp;pwd=123&#x27;</span>) </span><br><span class="line"><span class="comment">// xhr.send(&#x27;username:admin&amp;pwd:123&#x27;)</span></span><br></pre></td></tr></table></figure>
<h5 id="事件绑定，处理服务器返回结果"><a href="#事件绑定，处理服务器返回结果" class="headerlink" title="事件绑定，处理服务器返回结果"></a>事件绑定，处理服务器返回结果</h5><p>onreadystatechange : 当readystata属性被改变时调用</p>
<p>readystata 表示xhr中状态的属性 : 0 ，1 ，2 ，3：返回部分响应 ，4：返回全部响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> )&#123;</span><br><span class="line">        <span class="comment">// 如果状态码为 200 </span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status === <span class="number">200</span> )&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status)   <span class="comment">// 状态码</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText)  <span class="comment">//  状态码提示文字</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.getAllResponseHeaders())  <span class="comment">// 打印所有响应头</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response) <span class="comment">//  响应数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理返回的JSON数据"><a href="#处理返回的JSON数据" class="headerlink" title="处理返回的JSON数据"></a>处理返回的JSON数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接转换</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(xhr.response)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.responseType=<span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过该时间就取消请求</span></span><br><span class="line">xhr.timeout = <span class="number">2000</span> </span><br><span class="line"><span class="comment">// 时间超时回调函数</span></span><br><span class="line">xhr.ontimeout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">&quot;网络延迟，请稍后重试！！！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure>
<h6 id="可以解决重复发送请求问题"><a href="#可以解决重复发送请求问题" class="headerlink" title="可以解决重复发送请求问题"></a>可以解决重复发送请求问题</h6><p>先定义一个全局变量  let isSending = false </p>
<p>发送请求前先判断，如果当前正在发送，就取消该次的请求，再标识当前正在发送 ，重新发送</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSending)&#123;</span><br><span class="line">    xhr.abort()</span><br><span class="line">&#125;</span><br><span class="line">isSending = <span class="literal">true</span> </span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>发送完毕就标记 isSending = false</p>
<h3 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h3><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>$.get(url, [data], [callback], [type])</p>
<p>type:设置返回内容格式，xml, html, script, json, text, _default。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;http://127.0.0.1:8000/server_get&quot;</span>,&#123;<span class="string">&#x27;page&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;num&#x27;</span>:<span class="number">10</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><p>$.post(url, [data], [callback], [type]) </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">&quot;http://127.0.0.1:8000/server_post&quot;</span>,&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jerry&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">13</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="注：get中的data参数是设置params，而post是设置请求体"><a href="#注：get中的data参数是设置params，而post是设置请求体" class="headerlink" title="注：get中的data参数是设置params，而post是设置请求体"></a>注：get中的data参数是设置params，而post是设置请求体</h6><h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://127.0.0.1:8000/server&quot;</span>,</span><br><span class="line">    data : &#123;<span class="string">&quot;username&quot;</span> : <span class="string">&quot;admin&quot;</span> , <span class="string">&quot;gender&quot;</span> : <span class="string">&quot;man&quot;</span> &#125;,</span><br><span class="line">    type : <span class="string">&quot;POST&quot;</span>,  	<span class="comment">// 请求类型</span></span><br><span class="line">    dataType : <span class="string">&quot;json&quot;</span>,  <span class="comment">// 数据类型</span></span><br><span class="line">    timeout : <span class="number">2000</span> , 	<span class="comment">// 超时时间</span></span><br><span class="line">    <span class="comment">// 成功调用</span></span><br><span class="line">    success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败调用</span></span><br><span class="line">    error : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求失败，请重试！！！&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    headers : &#123;</span><br><span class="line">        name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        age : <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>设置通用地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL= <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h5><p>axios.get(url  [, config])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;server&quot;</span>,&#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">1</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><p>axios#post(url[, data [, config]])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;server&quot;</span>,&#123;<span class="attr">username</span> : <span class="string">&#x27;tom&#x27;</span>,<span class="attr">pwd</span> : <span class="string">&#x27;123&#x27;</span>&#125;, &#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">10</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;jerry&#x27;</span>,<span class="attr">age</span>:<span class="number">3</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h5><p>axios( {config} )</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;server&#x27;</span>,</span><br><span class="line">    method : <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    params : &#123;<span class="attr">width</span>:<span class="number">100</span>,<span class="attr">height</span>:<span class="number">200</span>&#125;,</span><br><span class="line">    data : &#123;<span class="attr">name</span>:<span class="string">&#x27;kyrie&#x27;</span>,<span class="attr">job</span>:<span class="string">&#x27;ball&#x27;</span>&#125;,</span><br><span class="line">    headers:&#123;<span class="attr">sure</span>:<span class="string">&#x27;yes&#x27;</span>&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。</p>
<p>同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。</p>
<h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><ol>
<li><p>JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 </p>
</li>
<li><p>在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p>
</li>
<li><p>JSONP 的使用</p>
</li>
</ol>
<p>通过script.src来访问需跨域的服务器，但是script返回的不能是单纯数据，需要返回一个函数的调用，这里事先定义一个函数 fn，让script返回 fn 函数的调用，在函数调用里面传入数据</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端:"></a>前端:</h5><p>动态创建script标签，设置src值，url参数设为回调函数名，然后讲scripy添加到body中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数中的data就是跨域后获取的数据，需要依靠script返回的结果来调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	alert(data.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端:"></a>后端:</h5><p>获取回调函数名，用拼接的方式返回该函数的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;/testAJAX&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 获取回调函数名</span></span><br><span class="line">   	<span class="keyword">var</span> callback = request.query.callback </span><br><span class="line">   	<span class="comment">// 获取数据(随便定义一下，一般这里是从数据库中获取)</span></span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;怪狗狗&#x27;</span>&#125;</span><br><span class="line">  	<span class="comment">// 返回函数的调用</span></span><br><span class="line">    response.send(callback+<span class="string">&quot;(&quot;</span>+ <span class="built_in">JSON</span>.stringify(data) +<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ol>
<li><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p>
</li>
<li><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 </p>
</li>
<li><p>CORS 的使用</p>
</li>
</ol>
<p>主要是服务器端来设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)   <span class="comment">// 允许任意源访问</span></span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)  <span class="comment">// 允许设置自定义请求头</span></span><br></pre></td></tr></table></figure>
<p>了解更多CORS，请参考   <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
      </tags>
  </entry>
</search>
