<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇</title>
    <url>/2021/02/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="你知道吗"><a href="#你知道吗" class="headerlink" title="你知道吗"></a>你知道吗</h1><a id="more"></a>

<h2 id="我是怪狗狗"><a href="#我是怪狗狗" class="headerlink" title="我是怪狗狗"></a>我是怪狗狗</h2><p>你绝对不知道</p>
<p>绝对  ， 哎 绝对</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组与稀疏数组</title>
    <url>/2021/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组与稀疏数组之间的转变说明（图）"><a href="#二维数组与稀疏数组之间的转变说明（图）" class="headerlink" title="二维数组与稀疏数组之间的转变说明（图）"></a>二维数组与稀疏数组之间的转变说明（图）</h1><a id="more"></a>

<p>​    <a href="https://imgtu.com/i/6EUbLD"><img src="https://s3.ax1x.com/2021/03/03/6EUbLD.png" alt="6EUbLD.png"></a></p>
<p><a href="https://imgtu.com/i/6EdVBD"><img src="https://s3.ax1x.com/2021/03/03/6EdVBD.png" alt="6EdVBD.png"></a></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="二维数组转变成稀疏数组"><a href="#二维数组转变成稀疏数组" class="headerlink" title="二维数组转变成稀疏数组"></a>二维数组转变成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 二维数组</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arrayToSparse(<span class="keyword">int</span> array[][]) &#123;</span><br><span class="line">        <span class="comment">//获取二维数组中值的个数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//稀疏数组的第一行的值分别为 二维数组总行数  二维数组总列数  二维数组中值的个数</span></span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">2</span>] = num;</span><br><span class="line">        <span class="comment">//将二维数组中的值填充到稀疏数组中  二维数组行 二维数组列 二维数组值</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sparse[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparse[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparse[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="稀疏数组转变从二维数组"><a href="#稀疏数组转变从二维数组" class="headerlink" title="稀疏数组转变从二维数组"></a>稀疏数组转变从二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 稀疏数组</span></span><br><span class="line"><span class="comment"> * return : 二维数组</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span> sparse[][]) &#123;</span><br><span class="line">        <span class="comment">//根据稀疏数组的第一行数据创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[sparse[<span class="number">0</span>][<span class="number">0</span>]][sparse[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//将稀疏数组中的值填充到二维数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparse.length;i++)&#123;</span><br><span class="line">            array[sparse[i][<span class="number">0</span>]][sparse[i][<span class="number">1</span>]]=sparse[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="将稀疏数组与本地文件之间在互相转换"><a href="#将稀疏数组与本地文件之间在互相转换" class="headerlink" title="将稀疏数组与本地文件之间在互相转换"></a>将稀疏数组与本地文件之间在互相转换</h1><p> 保存二维数组 ：二维数组 -&gt; 稀疏数组 -&gt; 本地文件</p>
<p> 获取二维数组 :  本地文件 -&gt; 稀疏数组 -&gt; 二维数组</p>
<p>二维数组与稀疏数组之间的转换上面已经写明了，这里主要讲稀疏数组与本地文件的转换，需要用到 java 中的IO操作</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="稀疏数组保存至本地文件"><a href="#稀疏数组保存至本地文件" class="headerlink" title="稀疏数组保存至本地文件"></a>稀疏数组保存至本地文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args1: 稀疏数组  args2: 需要保存文件的地址</span></span><br><span class="line"><span class="comment"> * return : 是否保存成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arraySave</span><span class="params">(<span class="keyword">int</span> sparse[][], String fileName)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter writer = <span class="keyword">new</span> FileWriter(file);<span class="comment">//文件输入流</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparse) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                    writer.write(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="将本地文件转换成稀疏数组"><a href="#将本地文件转换成稀疏数组" class="headerlink" title="将本地文件转换成稀疏数组"></a>将本地文件转换成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 需要读取的文件地址</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getArray(String fileName) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先获取文件的行数</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//根据文件的行数创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse=<span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//再次读取文件，将文件的内容填充到稀疏数组中</span></span><br><span class="line">        reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//获取文件中的每一行数据</span></span><br><span class="line">            String[] temp = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">                sparse[count][i]=Integer.parseInt(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>稀疏数组</tag>
        <tag>io流</tag>
      </tags>
  </entry>
  <entry>
    <title>数组队列与环形队列</title>
    <url>/2021/03/04/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E4%B8%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p> 队列是一个有序列表，可以用数组或是链表来实现。 </p>
<a id="more"></a>

<p> 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 </p>
<p> 示意图：(使用数组模拟队列示意图)</p>
<p><a href="https://imgtu.com/i/6ZdR8s"><img src="https://s3.ax1x.com/2021/03/04/6ZdR8s.png" alt="6ZdR8s.png"></a></p>
<h1 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h1><p>1.队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队 列的最大容量。</p>
<p>2.因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</p>
<p>3.头指针front 指向队列头元素的前一个位置，默认为-1</p>
<p>4.尾指针rear指向队列尾元素， 默认为-1</p>
<p>5.向队列中添加数据时：</p>
<p>​    1). 将尾指针往后移：rear+1</p>
<p>​    2).若尾指针 rear == maxSize - 1  ，表示队列已满，不能再存放数据了</p>
<p>6.向队列弹出一个数据时:</p>
<p>​    1). 将头指针往后移： front+1</p>
<p>​    2).将下标为 front+1 返回即可</p>
<p>​    3).头指针等于尾指针 ，即 front==rear ,则表示该队列为空，不能弹出数据了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//前部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//后部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">this</span>.maxSize=max;</span><br><span class="line">            <span class="keyword">this</span>.rear=-<span class="number">1</span>;<span class="comment">// 指向队列尾部，默认-1</span></span><br><span class="line">            <span class="keyword">this</span>.front=-<span class="number">1</span>;<span class="comment">// 指向队列头部的前一个位置，默认-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            <span class="keyword">this</span>.arr[rear]=data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.front++;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front+<span class="number">1</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;arr[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.arr[front+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析并优化"><a href="#问题分析并优化" class="headerlink" title="问题分析并优化"></a>问题分析并优化</h3><ol>
<li><p>目前数组使用一次就不能用， 没有达到复用的效果 </p>
</li>
<li><p>将这个数组使用算法，改进成一个环形的队列 （取模：%）</p>
</li>
</ol>
<h1 id="环形数组模拟队列"><a href="#环形数组模拟队列" class="headerlink" title="环形数组模拟队列"></a>环形数组模拟队列</h1><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><p>1)对头指针front含义做一个调整：front指向队列的第一个元素，初始值为 0</p>
<p>2)对尾指针rear含义做一个调整：rear指向队列最后一个元素的下一个位置，初始值为 0  ，因为希望空出一个位置作为约定</p>
<p>3)队列满表示为 ：(rear+1)%maxSize==front </p>
<p>4)队列空表示为：rear==front</p>
<p>5)队列中有效的值的个数表示为: (rear+maxSize-front)%maxSize </p>
<p>6)front++   与  rear++   统一写成  (front+1)%maxSize  与  (rear+1)%maxSize  ,因为这是个环形队列，如果front或rear超过数组最大下标则需要从下标0开始添加数据</p>
<p>7)根据原来的队列代码进行修改，就可以得到一个环形队列</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="comment">//指向队列头部 默认为0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">        <span class="comment">//指向队列尾部的后一个位置 默认为0  因为这是一个环形队列，需要预留一个位置作为约定</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            maxSize=max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="comment">//尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为 rear 指向队列尾元素的下一个位置，直接添加，再进行 rear++操作</span></span><br><span class="line">            arr[rear]=data;</span><br><span class="line">            <span class="comment">// 本来这里是 rear++ ，但是这是个环形队列，如果rear超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将队列头元素先保存下来,最后需要返回</span></span><br><span class="line">            <span class="keyword">int</span> result=arr[front];</span><br><span class="line">            <span class="comment">//本来这里是 front++ ，但是这是个环形队列，如果front超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            front=front+<span class="number">1</span>%maxSize;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front;i&lt;front+size();i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;arr[&quot;</span>+i%maxSize+<span class="string">&quot;]=&quot;</span>+arr[i%maxSize]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前队列中的有效个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[front]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试数组队列</span></span><br><span class="line">    	<span class="comment">//Queue queue = new Queue(3);</span></span><br><span class="line">    	<span class="comment">//测试环形数组队列</span></span><br><span class="line">       CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);<span class="comment">//因为需要预留一个位置作为约定, 所以该队列中只能存放3个数据，如需存放4个数据，该算法即可</span></span><br><span class="line">    	</span><br><span class="line">       Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;\na : 添加数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;p : 弹出一个数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;s : 显示队列&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;h : 显示头&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;e : 退出&quot;</span>);</span><br><span class="line">           String key = scanner.next();</span><br><span class="line">           <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                   System.out.println(<span class="string">&quot;请输入值:&quot;</span>);</span><br><span class="line">                   <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">                   queue.add(i);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;p&quot;</span>:</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> pop = queue.pop();</span><br><span class="line">                       System.out.println(<span class="string">&quot;弹出值为:&quot;</span>+pop);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       System.out.println(e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                   queue.showQueue();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;h&quot;</span>:</span><br><span class="line">                   queue.showHead();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       scanner.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题</title>
    <url>/2021/03/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>单向环形链表应用场景：</p>
<p> Josephu(约瑟夫、约瑟夫环) 问题 ：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。</p>
<a id="more"></a> 

<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<h3 id="约瑟夫问题-创建环形链表的思路"><a href="#约瑟夫问题-创建环形链表的思路" class="headerlink" title="约瑟夫问题-创建环形链表的思路:"></a>约瑟夫问题-创建环形链表的思路:</h3><p>1.创建一个节点时，让first节点等于它，并且first.setNext(first)，一个节点也形成环形</p>
<p>2.后面创建新节点时，就把节点加入到环形链表最后，即链表原来最后的节点指向新节点，新节点指向first，又可变成一个环形</p>
<h3 id="约瑟夫问题-小孩出圈的思路分析"><a href="#约瑟夫问题-小孩出圈的思路分析" class="headerlink" title="约瑟夫问题-小孩出圈的思路分析:"></a>约瑟夫问题-小孩出圈的思路分析:</h3><p>用户需要穿入3个数据(startNo:从 startNo 个节点开始数， count:  数 num 下， size: 圈中一共有多少个节点)</p>
<p>1.创建一个辅助指针 helper ，事先指向链表的最后一个节点，即first的前面，因为是单向链表，只能通过遍历来完成，直到 helper.getNext()=first</p>
<p>2.报数之前，先让first与helper移动 startNo -1 次，因为是从startNo开始报数的</p>
<p>3.循环遍历数时，每次报数让 first与helper移动 count-1 次(自己也要报一次数)，这是将first指向的节点出圈</p>
<p>4.出圈为 ： first=first.next      helpser.next=first</p>
<p>5.直到first==helper，循环才可结束，这时链表中只有一个节点，first与helper同时指向它</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码:"></a>实现代码:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环形单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boy first; <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 根据传入的数据创建size个节点的环形单链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoys</span><span class="params">(Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建失败:请传入不小于1的数！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针，指向新添加的节点，即最后的一个节点</span></span><br><span class="line">        boy currBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">            boy boy = <span class="keyword">new</span> boy(i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//第一个节点</span></span><br><span class="line">                first=boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                currBoy=first;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currBoy.setNext(boy); <span class="comment">//原来最后的节点指向新节点</span></span><br><span class="line">                boy.setNext(first);  <span class="comment">//新节点指向first</span></span><br><span class="line">                currBoy=boy;		</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历环形单链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        boy currBoy=first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(currBoy.getId()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currBoy.getNext()==first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currBoy=currBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出圈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从 startNo 个节点开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  数 num 下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 圈中一共有多少个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Integer startNo,Integer count,Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first ==<span class="keyword">null</span> || startNo&lt;<span class="number">1</span> || startNo&gt;size || count&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据有问题，请重试！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个helper指针，指向first之前的位置</span></span><br><span class="line">        boy helper=first;</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext()!=first) &#123;</span><br><span class="line">          helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将helper与first移动到 startNo 位置 ，移动 startNo-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startNo-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备就绪，开始出圈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper==first)&#123; <span class="comment">//表示只有一个数据了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count-<span class="number">1</span>;i++)&#123; <span class="comment">//移动count-1次</span></span><br><span class="line">                first=first.getNext();</span><br><span class="line">                helper=helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(first.getId()+<span class="string">&quot;--》&quot;</span>);</span><br><span class="line">            <span class="comment">//将当前first指向的节点出圈</span></span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后保留的数据:&quot;</span>+first.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">boy</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表与双向链表</title>
    <url>/2021/03/06/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>​     链表是以节点的方式来存储,是链式存储 ， 每个节点包含 data 域， next 域：指向下一个节点.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定,这里主要介绍带头节点的链表</p>
<a id="more"></a>

<h1 id="使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"><a href="#使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作" class="headerlink" title="使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"></a>使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作</h1><ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部 </p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6uwseI"><img src="https://s3.ax1x.com/2021/03/06/6uwseI.png" alt="6uwseI.png"></a></p>
<ol start="3">
<li>修改节点功能, 思路:</li>
</ol>
<p>​                (1) 通过遍历,先找到该节点,直接修改数据即可</p>
<p>​                (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p>
<ol start="4">
<li>删除节点 ，思路分析的示意图</li>
</ol>
<p><a href="https://imgtu.com/i/6uwgFf"><img src="https://s3.ax1x.com/2021/03/06/6uwgFf.png" alt="6uwgFf.png"></a></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer no;  <span class="comment">//序号</span></span><br><span class="line">    String name;    <span class="comment">//名称</span></span><br><span class="line">    String nickName;    <span class="comment">//昵称</span></span><br><span class="line">    Node next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&#x27;&quot;</span> + no + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加  找到最后一个节点，将新节点添加到链表的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照序号进行添加  根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//标记新节点序号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;node.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==node.no)&#123; <span class="comment">//该序号已存在，则无法插入</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该节点序号已存在，添加数据失败！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next=temp.next;</span><br><span class="line">            temp.next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表所有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;<span class="comment">//循环遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改  根据序号进行修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要修改的节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.no==node.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=node.name;</span><br><span class="line">            temp.nickName= node.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功:&quot;</span>+temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+node.no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除 根据序号进行删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该序号</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功序号为‘&quot;</span>+no+<span class="string">&quot;’节点&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="一些单项链表常见面试题"><a href="#一些单项链表常见面试题" class="headerlink" title="一些单项链表常见面试题"></a>一些单项链表常见面试题</h3><ol>
<li>求单链表中有效节点的个数,代码演示(easy):</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;<span class="comment">//循环遍历</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>查找单链表中的倒数第 k 个结点</p>
<p>代码演示:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 列表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 倒数第 index 个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第index个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLastIndexNode</span><span class="params">(Node head,Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遍历，获取该链表有效节点</span></span><br><span class="line">        Integer size=getLength(head);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span> || index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历，遍历 (size-index)次</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(size-index);i++)&#123;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-快慢指针法"><a href="#方法二-快慢指针法" class="headerlink" title="方法二:快慢指针法"></a>方法二:快慢指针法</h5><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h6><p>1.快指针从头开始走，慢指针从头的前一个地方开始走</p>
<p>2.快指针先走，走n次，然后快指针与慢指针一起走</p>
<p>3.直到快指针走到尾部，这时慢指针指向的下一个节点就是要删除的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//快慢指针法</span></span><br><span class="line">       ListNode temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> temp.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>单链表的反转 采用头插法</li>
</ol>
<p>思路分析：1.先创建一个头节点，暂时存放反转节点   Node reverseHead=new Node(0,””,””);</p>
<p>​                   2.循环遍历原来的链表，每遍历一遍，就把当前的节点转移到临时头节点  reverseHead的最前面</p>
<p>​                            curr.next=reverseHead.next;      reverseHead.next=curr;</p>
<p>​                   3.遍历完毕后原来的头节点后的节点全部反转到临时头节点 reverseHead后面，直接将原来头节点指向临时头节点之后的节点即可           head.next=reverseHead.next</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//当链表为空或只有一个节点，无需反转</span></span><br><span class="line">       <span class="keyword">if</span>(head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//暂时存放反转节点的节点头</span></span><br><span class="line">       Node reverseHead=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       Node curr=head.next;<span class="comment">//需要转移到到reverseList头部的节点</span></span><br><span class="line">       Node next=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           next=curr.next;</span><br><span class="line">           <span class="comment">//开始转移</span></span><br><span class="line">           curr.next=reverseHead.next;</span><br><span class="line">           reverseHead.next=curr;</span><br><span class="line">           curr=next;</span><br><span class="line">       &#125;</span><br><span class="line">       head.next=reverseHead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>从尾到头打印单链表 【要求方式 1：反向遍历 。 方式 2：Stack 栈】</li>
</ol>
<p>方法一:先反转链表，再遍历打印 （这样改变了链表原来的结构，不推荐，即使再次反转过来也很浪费时间）<br>方法二:将链表的数据全部放入栈中，再遍历栈取出数据，这样不会改变链表原来的结构（这里暂时使用java中的stack，不手写栈了）</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环遍历将链表的数据放入栈中</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历打印栈的数据</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
</ol>
<p>思路分析: </p>
<p>1.如果两个链表全部空则返回空；如果list1为空，返回list2；如果list2为空，返回list1</p>
<p>2.新建一个链表list用来存放合并list1与list2合并后的数据</p>
<p>3.同时遍历list1与list2，每一次比较list1当前节点与list2当前节点，谁更小就转移到list最后 (转移节点可参考问题三:链表的反转)</p>
<p>4.如果list1为空了，则把list2中的数据全部转移到list最后；如果list2空了，则把list1中的数据全部转移到list最后</p>
<p>注意: 可添加一个新的指针来标识list中新插入的节点位置</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的单链表，合并之后的链表依然有序 ,如果链表中的有两个序号相同，默认先取 list1 中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">merge</span><span class="params">(SingleLinkedList list1,SingleLinkedList list2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span> &amp;&amp; list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        SingleLinkedList list = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//记录当前插入的节点</span></span><br><span class="line">        Node newNode=list.getHead();</span><br><span class="line">        <span class="comment">//标志list1暂时需要转移的节点</span></span><br><span class="line">        Node curr1=list1.getHead().next;</span><br><span class="line">        <span class="comment">//记录curr1的下一个节点</span></span><br><span class="line">        Node next1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//标志list2暂时需要转移的节点</span></span><br><span class="line">        Node curr2=list2.getHead().next;</span><br><span class="line">        <span class="comment">//记录list2的下一个节点</span></span><br><span class="line">        Node next2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr1==<span class="keyword">null</span>)&#123;<span class="comment">//list1合并完毕,可将curr2中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr2==<span class="keyword">null</span>)&#123;<span class="comment">//list2合并完毕，可将curr1中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next1=curr1.next;</span><br><span class="line">            next2=curr2.next;</span><br><span class="line">            <span class="keyword">if</span>(curr1.no&lt;=curr2.no)&#123; <span class="comment">//添加curr1</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr1=next1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//添加curr2</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr2=next2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用带-head-头的双向链表实现-–水浒英雄排行榜"><a href="#使用带-head-头的双向链表实现-–水浒英雄排行榜" class="headerlink" title="使用带 head 头的双向链表实现 –水浒英雄排行榜"></a>使用带 head 头的双向链表实现 –水浒英雄排行榜</h1><p>管理单向链表的缺点分析:</p>
<p>​                 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p>
<p>​                 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，前面我们单链表删除 时节点，总是找到待删除节点的前一个节点.</p>
<p>双向链表的遍历与修改与单链表一样，添加与删除方法略有不同</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点需要新增一个值</span></span><br><span class="line">DoubleNode pre; <span class="comment">//指向前一个结点</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 添加再链表最后位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">        DoubleNode temp = head;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行添加</span></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        newNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序进行添加 根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">            DoubleNode temp=head;</span><br><span class="line">            <span class="comment">//标记新节点是否存在</span></span><br><span class="line">            <span class="keyword">boolean</span> exist=<span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//标记新节点是否插入到最后</span></span><br><span class="line">            <span class="keyword">boolean</span> last=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;<span class="comment">//表示新节点序号最大，需要插入到最后</span></span><br><span class="line">                    last=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no&gt; newNode.no)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no== newNode.no)&#123;<span class="comment">//表示新节点序号已存在</span></span><br><span class="line">                    exist=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入失败:该节点序号‘&quot;</span>+newNode.no+<span class="string">&quot;’已存在！！！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(last)&#123; <span class="comment">//插入到最后</span></span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//表示后一个节点</span></span><br><span class="line">                    DoubleNode rear = temp.next;</span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.next=rear;</span><br><span class="line">                    rear.pre=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 无需像单链表一样找到要删除的前一个节点，直接找到需要删除的节点，就可执行自我删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找序号为no的节点</span></span><br><span class="line">        DoubleNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;<span class="comment">//找到该节点,进行自我删除</span></span><br><span class="line">                temp.pre.next = temp.next;<span class="comment">//让temp前一个节点指向temp的后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next!=<span class="keyword">null</span>) &#123; <span class="comment">//如果temp的后一个节点为空，则会有空控制在异常</span></span><br><span class="line">                    temp.next.pre = temp.pre;<span class="comment">//让temp的后一个节点指向temp的前一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败:没找到序号为‘&quot;</span> + no + <span class="string">&quot;’的节点&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/03/06/%E6%A0%88/</url>
    <content><![CDATA[<p> 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除</p>
<a id="more"></a>

<h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><ol>
<li><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。</p>
</li>
<li><p>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。</p>
</li>
<li><p>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
</li>
<li><p>二叉树的遍历。</p>
</li>
<li><p>图形的深度优先(depth 一 first)搜索法。</p>
</li>
</ol>
<h3 id="用数组模拟栈的使用"><a href="#用数组模拟栈的使用" class="headerlink" title="用数组模拟栈的使用"></a>用数组模拟栈的使用</h3><p>思路 : </p>
<p>1.定义一个top表示栈顶,初始值为-1</p>
<p>2.入栈操作: top++;   stack[top]=data;</p>
<p>3.出栈操作: int val=stack[top];    top–;    return val;</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">int</span> [] stack; <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶，默认-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize=maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        <span class="keyword">this</span>.top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败:栈满~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历显示栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;stack[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+stack[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表模拟栈的使用-采用有头单项链表"><a href="#用链表模拟栈的使用-采用有头单项链表" class="headerlink" title="用链表模拟栈的使用,采用有头单项链表"></a>用链表模拟栈的使用,采用有头单项链表</h3><p>思路:</p>
<p>1.压栈：放入链表的第一个位置     newNode.next=head.next;      head.next=newNode;</p>
<p>2.弹栈：取链表的第一个节点      Node oldFirst = head.next;    head.next=head.next.next;   return oldFirst.data;</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈 采用头差法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        newNode.next=head.next;</span><br><span class="line">        head.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈 头取法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        head.next=head.next.next;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历栈失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器</title>
    <url>/2021/03/07/%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<p>栈实现一个中缀表达式计算器和一个后缀表达式计算器</p>
<a id="more"></a>

<h3 id="中缀表达式计算器"><a href="#中缀表达式计算器" class="headerlink" title="中缀表达式计算器"></a>中缀表达式计算器</h3><h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------再栈中补充以下代码,方便后续操作-------------------------------------	</span></span><br><span class="line"><span class="comment">//瞄一眼栈顶的数据，不是弹栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回运算符的优先级，越大优先级越高  假设只有 加减乘除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&#x27;*&#x27;</span> || oper==<span class="string">&#x27;/&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper==<span class="string">&#x27;+&#x27;</span> || oper==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他无效字符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span> || val==<span class="string">&#x27;-&#x27;</span> || val==<span class="string">&#x27;*&#x27;</span> || val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num2+num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num2*num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(num1==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式实现思路分析"><a href="#中缀表达式实现思路分析" class="headerlink" title="中缀表达式实现思路分析:"></a>中缀表达式实现思路分析:</h4><p>1.创建两个栈，一个用来存放数字numStack，一个用来存放运算符operStack</p>
<p>2.用一个指针index遍历需要计算的表达式，初始值为0</p>
<p>3.遍历如果发现是index指向的是数字就直接存入数栈</p>
<p>4.如果是运算符则需要一下判断:如果符号栈为空或当前运算符的优先级大于栈顶运算符的优先级，则可以直接将当前运算符入栈；</p>
<p>如果当前运算符优先级小于或等于栈顶运算符优先级，则需将符号栈栈顶的运算符弹出，将数栈的前两位数值弹出，进行运算，将结果放入数栈中，当前运算符放入符号栈</p>
<p>5.遍历完毕后继续遍历两个栈中剩下的数据，取出数栈的两个值，符号栈一个符号继续进行运算，将结果放入数栈，直到符号栈空</p>
<p>6.此时数栈只有一个数值，该值就是运算结果</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题:"></a>存在问题:</h5><p>上面思路只能解决一位数的计算，如果要多位数，则需一下改进:</p>
<ol>
<li>创建一个字符串chs，用来拼接多位数</li>
<li>数值压入数栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是就不能入栈，继续扫描，直到下一位是运算符才能入栈</li>
</ol>
<h5 id="实现计算器代码"><a href="#实现计算器代码" class="headerlink" title="实现计算器代码"></a>实现计算器代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算该表达式</span></span><br><span class="line">        String expression = <span class="string">&quot;7*2*2-5+16-5+3-4&quot;</span>; <span class="comment">//33</span></span><br><span class="line">        <span class="comment">//String expression=&quot;10+12*2-10&quot;;</span></span><br><span class="line">        <span class="comment">//用于存放 数字的栈</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于存放运算符的栈</span></span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">//第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">//第二个数字</span></span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;<span class="comment">//运算符</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//运算结果</span></span><br><span class="line">        <span class="keyword">char</span> ch;<span class="comment">//将每次扫描得到 char 保存到 ch</span></span><br><span class="line">        String chs=<span class="string">&quot;&quot;</span>;<span class="comment">//用来拼接多位数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//一个一个字符扫描</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是表达式</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//是表达式</span></span><br><span class="line">                <span class="comment">//判断 operStack 是否空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123; <span class="comment">//不空,不能直接将表达式压栈，需要判断</span></span><br><span class="line">                    <span class="comment">//如果当前表达式优先级小于或等于栈顶的表达式的优先级，则需要将栈顶的表达式取出，还需取出数值栈中的前两个数字，进行运算</span></span><br><span class="line">                    <span class="comment">//运算完毕将结果压入数值栈中，将当前表达式压入表达式栈中</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peekTop()))&#123;</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        <span class="comment">//进行运算</span></span><br><span class="line">                        result = operStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//空，直接将表达式压栈即可</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是表达式,即数字,将数字直接压入数值栈中(注:当前ch是字符,如果ch=&#x27;1&#x27;,转换成数字等于49,如果ch=&#x27;2&#x27;,转换成数字等于50,之间相差48)</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);</span></span><br><span class="line">                <span class="comment">//上面写法只能处理一位数的运算，如果需要多位数的运算，需要改进</span></span><br><span class="line">                <span class="comment">//思路:数值压入数值栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是则不能入栈，继续扫描，直到下一位是运算符才能入栈</span></span><br><span class="line">                chs += ch;<span class="comment">//拼接多位数</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;<span class="comment">//如果已经是最后一位数，可以直接入数栈</span></span><br><span class="line">                    numStack.push(Integer.parseInt(chs));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123; <span class="comment">//下一位是运算符，可以直接入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(chs));</span><br><span class="line">                        <span class="comment">//入栈后需清空chs</span></span><br><span class="line">                        chs=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描完毕,将栈中剩余的值计算掉,计算完毕后运算符栈中没有数据,但是数值栈中还有一个值，就是结果</span></span><br><span class="line">        <span class="keyword">while</span>(!operStack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            <span class="comment">//进行运算</span></span><br><span class="line">            result = operStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;运算结果为:&quot;</span>+numStack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>中缀表达式不利于计算机的计算，所以这里再实现一个后缀表达式计算器</p>
<h3 id="后缀表达式计算器"><a href="#后缀表达式计算器" class="headerlink" title="后缀表达式计算器"></a>后缀表达式计算器</h3><p>因为这里主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算</p>
<p>步骤: 中缀表达式 ==&gt; 中缀表达式list ==&gt; 后缀表达式list ==》 计算后缀表达式list ==》 结果</p>
<h4 id="将中缀表达式中的每一个值放入list集合中（方便后续计算）"><a href="#将中缀表达式中的每一个值放入list集合中（方便后续计算）" class="headerlink" title="将中缀表达式中的每一个值放入list集合中（方便后续计算）"></a>将中缀表达式中的每一个值放入list集合中（方便后续计算）</h4><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个指针index，用来遍历表达式；创建一个list集合，用来存放数据</p>
<p>2.循环遍历如果当前值不是数字，直接放入list集合中    (ch = s.charAt(index)) &lt; 48 || (ch = s.charAt(index)) &gt; 57  （字符0-9的十进制ASCII码为48-57）</p>
<p>3.如果当前值是数字，则需要考虑多位数 </p>
<p>4.遍历结束，直接将list集合返回即可</p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将中缀表达式放入到list中   13+8*6+2*5-(2+1) ==&gt; list[13,+,8,*,6,+,2,*,5,-,(,2,+,1,)]</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixExpressionBeList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//扫描指针</span></span><br><span class="line">       <span class="keyword">char</span> ch;<span class="comment">//表示每一个字符</span></span><br><span class="line">       String chs = <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> ((ch = s.charAt(index)) &lt; <span class="number">48</span> || (ch = s.charAt(index)) &gt; <span class="number">57</span>) &#123; <span class="comment">//表示不是数字，直接放入list中即可</span></span><br><span class="line">               list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//是数字,则需要考虑多位数</span></span><br><span class="line">               chs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; (ch = s.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = s.charAt(index)) &lt;= <span class="number">57</span>) &#123; <span class="comment">//属于0-9</span></span><br><span class="line">                   chs += ch;</span><br><span class="line">                   index++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//循环结束表示当前 s.charAt(index) 不是一个数字，chs中是个单位数或多位数</span></span><br><span class="line">               list.add(chs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (index &lt; s.length());<span class="comment">//表示扫描完毕</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将中缀表达式转换成后缀表达式（重难点）"><a href="#将中缀表达式转换成后缀表达式（重难点）" class="headerlink" title="将中缀表达式转换成后缀表达式（重难点）"></a>将中缀表达式转换成后缀表达式（重难点）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2</p>
<p>2.遍历中缀表达式</p>
<p>3.遇到数字时，将其压 s2</p>
<p>4.遇到运算符时，需要进行以下判断：</p>
<p>​            （1）.如果是左括号”(“,直接将此运算符入栈</p>
<p>​            （2）.如果是右括号”)”,则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，并将左括号弹出，此时这一对括号丢弃</p>
<p>​            （3）.如果 s1 为空，直接将此运算符入栈            </p>
<p>​            （4）.如果当前运算符优先级 &gt; 栈顶运算符优先级，也将运算符压入 s1；</p>
<p>​            （5）.如果当前运算符优先级 &lt;= 栈顶运算符优先级,将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(3)(4)进行比较；</p>
<p>5.遍历结束，将s1剩余的运算符依次弹出并压入到s2中，直到s1为空</p>
<p>6.此时s2中保存的数据就是转换后的后缀表达式的逆序</p>
<p>注:因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list集合代替s2,最后直接返回即可</p>
<h5 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式list转化成后缀表达式list(难点)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">       Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//存放运算符的栈</span></span><br><span class="line">       <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;&gt;();//存放数字以及结果的栈</span></span><br><span class="line">       <span class="comment">//因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list代替s2,最后直接返回即可</span></span><br><span class="line">       List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//遍历中缀表达式list</span></span><br><span class="line">       <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">           <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//数字直接存放到s2</span></span><br><span class="line">               s2.add(item);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123; <span class="comment">//item为符号，需要判断</span></span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;(&quot;</span>.equals(item))&#123; <span class="comment">//item为左括号，直接放入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;)&quot;</span>.equals(item))&#123; <span class="comment">//item为右括号，需要将符号栈中的符号转入到s2集合中，直到找到左括号为止，并将左括号弹出，这样就能消除一对括号</span></span><br><span class="line">                   <span class="keyword">while</span>(!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示s1栈顶是一个左括号，将它弹出即可，右括号也无需保存</span></span><br><span class="line">                   s1.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前运算符优先级小于符号栈栈顶优先级，需要将栈顶符号转入list中，再重新判断，否则可直接入符号栈，</span></span><br><span class="line">                   <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item)) &#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示当前运算符高于栈顶运算符，或符号栈为空，将当前符号直接入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，还需将符号栈剩余的符号全部依次转入list集合中</span></span><br><span class="line">       <span class="keyword">while</span>(s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           s2.add(s1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将后缀表达式进行计算（比中缀表达式计算简单的多）"><a href="#将后缀表达式进行计算（比中缀表达式计算简单的多）" class="headerlink" title="将后缀表达式进行计算（比中缀表达式计算简单的多）"></a>将后缀表达式进行计算（比中缀表达式计算简单的多）</h4><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个栈用来存放数值</p>
<p>2.遍历 list 集合，如果是数值则放入栈中，如果是运算符则从栈中弹出两个数进行运算，将结果压入栈中</p>
<p>3.遍历结束后栈中只有一个值，该值就是运算结果</p>
<h5 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//正则表达式判断是否为数字</span></span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不是数字</span></span><br><span class="line">                num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">switch</span> (s) &#123;  <span class="comment">//进行运算</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = num2 + num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = num2 - num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = num2 * num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (num1 == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:被除数不能为0!!!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = num2 / num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:运算符错误!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果放回栈中</span></span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中只有一个数据，就是运算结果，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>计算器</tag>
        <tag>中缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2021/03/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八皇后问题介绍 ：</p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的</p>
<a id="more"></a>

<p>国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。</p>
<h4 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h4><ol>
<li><p>第一个皇后先放第一行第一列</p>
</li>
<li><p>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 </p>
</li>
<li><p>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 </p>
</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解， 全部得到. </p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
<li><p>示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6lgytg"><img src="https://s3.ax1x.com/2021/03/08/6lgytg.png" alt="6lgytg.png"></a></p>
<p>说明：</p>
<p> 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. （注:下标是从0开始）</p>
<p>map[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 map 下标 表示第几行，即第几个皇后，map[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘 ，一维数组</span></span><br><span class="line">    <span class="comment">//说明:下标表示第几个皇后，也就是第几行，对应的值表示每个皇后所在的列,  例如: map=[0,4,7,5,2,6,1,3]</span></span><br><span class="line">    <span class="comment">//    比如上面的数组表示:第一个皇后在第一行第一列；第二个皇后在第二行第五列，第三个皇后在第三行第八列,第四个皇后在第四行第六列。。。。。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//总共解法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count2=<span class="number">0</span>;<span class="comment">//总共检查了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queen8 queen = <span class="keyword">new</span> Queen8();</span><br><span class="line">        <span class="comment">//从第一个皇后开始</span></span><br><span class="line">        queen.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有’&quot;</span>+queen.count+<span class="string">&quot;‘解法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共检查了’&quot;</span>+queen.count2+<span class="string">&quot;‘次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摆放皇后,从第n个皇后开始摆放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">8</span>)&#123;<span class="comment">//该摆放第9个皇后了，表示第八个皇后已摆放好</span></span><br><span class="line">            print();<span class="comment">//打印结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始放，直到第8列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放皇后 n 到 i 上</span></span><br><span class="line">            map[n]=i;</span><br><span class="line">            <span class="comment">//检查n皇后是否摆放正确</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;<span class="comment">//如果正确，递归，开始摆放下一个皇后</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查当前第n个皇后是否摆放正确</span></span><br><span class="line">    <span class="comment">//从n皇后之前的所有皇后进行遍历检查</span></span><br><span class="line">    <span class="comment">// map[i]==map[n] 表示在同一列</span></span><br><span class="line">    <span class="comment">// Math.abs(n-i)==Math.abs(map[n]-map[i] 表示在同一斜线--- 如果在同一斜线这两个坐标显示为一个等腰三角形，而等腰三角形两边相等，注意要取绝对值再判断~~自行体会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放错误</span></span><br><span class="line">            <span class="keyword">if</span>(map[i]==map[n] || Math.abs(n-i)==Math.abs(map[n]-map[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++)&#123;</span><br><span class="line">            System.out.print(map[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>八皇后</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫回溯</title>
    <url>/2021/03/08/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p>运用递归方法给小球找一条路能让小球到出口</p>
<a id="more"></a>

<p>思路:全在代码里，自行体会</p>
<p><a href="https://imgtu.com/i/6l6JHO"><img src="https://s3.ax1x.com/2021/03/08/6l6JHO.png" alt="6l6JHO.png"></a></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试给地图找路&quot;</span>);</span><br><span class="line">        <span class="comment">//创建地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = MiGong.createMap();</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//给地图找条路,从(1,1)开始出发</span></span><br><span class="line">        <span class="keyword">boolean</span> isOk = MiGong.setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(isOk?<span class="string">&quot;正确通过&quot;</span>:<span class="string">&quot;此路不通&quot;</span>);</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用递归方式给地图找路</span></span><br><span class="line">    <span class="comment">// 约定:1.  0表示还没走的路；1表示墙；2表示通路可以走；3表示该路走过，但走不通</span></span><br><span class="line">    <span class="comment">//     2.   在走迷宫时定义一条策略(方法):下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">    <span class="comment">//     3.   地图入口为 (i,j) ，出口为 (6,5)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;<span class="comment">//出口走过，表示走通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            map[i][j]=<span class="number">2</span>; <span class="comment">//先默认该路可走</span></span><br><span class="line">            <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//表示该路走不通</span></span><br><span class="line">                map[i][j]=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果map[i][j]= 1、2、3 都不继续玩下走</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建小地图   地图为8行7列大小，1表示墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] createMap()&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置个障碍</span></span><br><span class="line"><span class="comment">//        map[1][2]=1;</span></span><br><span class="line"><span class="comment">//        map[2][2]=1;</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span> <span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/03/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<p>排序的分类:  内部排序，指将需要处理的所有数据都加载到内部存储器(内存)中进行排序 ；外部排序法， 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。</p>
<p> 常见的排序算法分类(见右图):</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/68rGTS"><img src="https://s3.ax1x.com/2021/03/09/68rGTS.png" alt="68rGTS.png"></a></p>
<h2 id="冒泡排序（bubble-sorting）"><a href="#冒泡排序（bubble-sorting）" class="headerlink" title="冒泡排序（bubble sorting）"></a>冒泡排序（bubble sorting）</h2><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<p>优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果哪一趟排序没有交换，就代表数组已经有序了，直接退出即可</span></span><br><span class="line">        <span class="keyword">boolean</span> isExchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//用于交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//总共进行 length-1 次排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//将当前数据与下一位数据比较</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isExchange = <span class="keyword">true</span>; <span class="comment">//标记交换了</span></span><br><span class="line">                    <span class="comment">//进行交换</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            <span class="comment">//小小优化</span></span><br><span class="line">            <span class="keyword">if</span> (isExchange) &#123;</span><br><span class="line">                isExchange = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//没有交换，数组已经有序了，直接退出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="选择排序（select-sorting）"><a href="#选择排序（select-sorting）" class="headerlink" title="选择排序（select sorting）"></a>选择排序（select sorting）</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/68s139"><img src="https://s3.ax1x.com/2021/03/09/68s139.png" alt="68s139.png"></a></p>
<p>1.一共排序 （数组大小-1）次</p>
<p>2.每一轮排序，又是一个循环，循环规则:</p>
<p>​    2.1 先假定当前这个数是最小值，并记录下标</p>
<p>​    2.2 然后与后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到该最小数的下标</p>
<p>​    2.3 遍历结束就可以得到最小数以及下标</p>
<p>​    2.4 交换，将最小数放入循环刚开始的位置</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//存放最小值，默认最小值为 arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="comment">//存放最小值下标，默认最小值下标为 i</span></span><br><span class="line">            <span class="keyword">int</span> minIndex=i;</span><br><span class="line">            <span class="comment">//每一次与后一位数比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="comment">//如果min大于后面的数，则在min中放后一位数，minIndex也放后一位数的下标</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;</span><br><span class="line">                    minIndex=j;   <span class="comment">//更换最小值下标</span></span><br><span class="line">                    min=arr[j];   <span class="comment">//更换最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，min存放的值为最小值，minIndex是最小值下标，进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;  <span class="comment">//优化: minIndex==i表示最小值下标没更换，即 arr[i] 已经是最小值，没必要交换</span></span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入排序（insert-sorting）"><a href="#插入排序（insert-sorting）" class="headerlink" title="插入排序（insert sorting）"></a>插入排序（insert sorting）</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本思想：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><a href="https://imgtu.com/i/68yla8"><img src="https://s3.ax1x.com/2021/03/09/68yla8.png" alt="68yla8.png"></a></p>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;<span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">int</span> insertVal=<span class="number">0</span>;  <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">        <span class="keyword">int</span> insertBeforeIndex=<span class="number">0</span>; <span class="comment">//记录当前正在排序的值的前一个下标</span></span><br><span class="line">        <span class="comment">//将数组分成两份，一份为已排好序，默认一个数，一份为没排序，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertVal=arr[i];</span><br><span class="line">            insertBeforeIndex=i-<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//如果insertBeforeIndex指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">            <span class="keyword">while</span>(insertBeforeIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertBeforeIndex])&#123;</span><br><span class="line">                <span class="comment">//将前一个值后移一位</span></span><br><span class="line">                arr[insertBeforeIndex+<span class="number">1</span>]=arr[insertBeforeIndex];</span><br><span class="line">                insertBeforeIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，insertBeforeIndex+1 表示当前正在排序的值该插入的位置</span></span><br><span class="line">            arr[insertBeforeIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+i+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h2><p>简单插入排序存在的问题 </p>
<p>我们看简单的插入排序可能存在的问题. 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), </p>
<p>这样的过程是： </p>
<p>{2,3,4,5,6,6}  ==》 {2,3,4,5,5,6}  ==》  {2,3,4,4,5,6}   ==》 {2,3,3,4,5,6}  ==》  {2,2,3,4,5,6}  ==》  {1,2,3,4,5,6} </p>
<p>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p>希尔排序法的示意图:</p>
<p><a href="https://imgtu.com/i/686Xc9"><img src="https://s3.ax1x.com/2021/03/09/686Xc9.png" alt="686Xc9.png"></a></p>
<p><a href="https://imgtu.com/i/68cS76"><img src="https://s3.ax1x.com/2021/03/09/68cS76.png" alt="68cS76.png"></a></p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用交换法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 : 交换法     （不是说升级版吗？怎么感觉不太行。。。尴尬了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//存放临时变量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123; <span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123; <span class="comment">// 如果当前值大于当前值下标加步长的值，则交换位置</span></span><br><span class="line">                        temp=arr[j+gap];</span><br><span class="line">                        arr[j+gap]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(++count)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用移动法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种排序:移动法（真正的希尔排序，利用插入法原则，每一轮排序调整大小时不需要直接交换，而是向后移位，直到最后的位置才交换）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellPlus</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;<span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">               <span class="keyword">int</span> j=i; <span class="comment">//记录当前正在排序的值需要插入的位置 ，每次循环减步长gap</span></span><br><span class="line">               <span class="keyword">int</span> temp=arr[j]; <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="keyword">while</span>((j-gap)&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-gap])&#123; <span class="comment">//如果(j-gap)指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">                       <span class="comment">//前面的值向后移一位(步长位)</span></span><br><span class="line">                       arr[j]=arr[j-gap];</span><br><span class="line">                       <span class="comment">//j指向的下标向前移一位(步长位)</span></span><br><span class="line">                       j-=gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，j所指向的下标就是当前排序的值需要插入的地方</span></span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//不走if语句说明当前值不小于前一位的值(前一个步长位的值)，没必要继续走下去，否则，还需循环判断下面的值是否还小于</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+(++count)+<span class="string">&quot;趟排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（quick-sort）"><a href="#快速排序（quick-sort）" class="headerlink" title="快速排序（quick sort）"></a>快速排序（quick sort）</h3><p>是对冒泡排序的一种改进。</p>
<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.把数组中的一个数当作基准书,一般会把数组中最左边的数当作基准数</p>
<p>2.从两边开始检索，如果是最左边的数是基准数就从右边开始检索，否则从左边开始检索，</p>
<p>从右边开始检索，如果找到比基准数小的数时，停下，再从右边开始检索，如果找到比基准数大的数时，也停下，交换左右两边指向的数，然后继续检索。。</p>
<p>3.当左右两边指针相遇，就停止检索，交换基准数和当前的位置</p>
<p>4.递归上面代码 继续排序数组左边的元素</p>
<p>5.递归上面代码 继续排序数组右边的元素</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6YAm60"><img src="https://s3.ax1x.com/2021/03/10/6YAm60.png" alt="6YAm60.png"></a></p>
<h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123; <span class="comment">//出口  排序到最后面只有一个值时，就会执行该语句</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> temp=<span class="number">0</span>;  <span class="comment">//存放交换时的临时变量</span></span><br><span class="line">       <span class="keyword">int</span> base=arr[left]; <span class="comment">//基数，默认选每一组数的第一个元素</span></span><br><span class="line">       <span class="keyword">int</span> l=left;  <span class="comment">//左指针，从数组头开始</span></span><br><span class="line">       <span class="keyword">int</span> r=right; <span class="comment">//右指针，从数组尾开始</span></span><br><span class="line">       <span class="comment">//左右指针开始移动进行排序，因为 基数是最左边的元素，所以从右边开始索引，否则从左边开始索引</span></span><br><span class="line">       <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">           <span class="comment">//如果右指针的数据小于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span>(arr[r] &gt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               r--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果左指针的数据大于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两边指针都停止，交换两边指针所指向的值</span></span><br><span class="line">           temp=arr[r];</span><br><span class="line">           arr[r]=arr[l];</span><br><span class="line">           arr[l]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// l==i 时, 退出循环,说明当前指向的位置是基数该放的位置，将当前值与计算交换即可</span></span><br><span class="line">       arr[left]=arr[l];</span><br><span class="line">       arr[l]=base;</span><br><span class="line">       <span class="comment">//继续排序数组左边的元素</span></span><br><span class="line">       quick(arr,left,l-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//继续排序数组右边的元素</span></span><br><span class="line">       quick(arr,r+<span class="number">1</span>,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p>
<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><p>分简单，重点是治(合)</p>
<p>总体思路图:</p>
<p><a href="https://imgtu.com/i/6YA5NQ"><img src="https://s3.ax1x.com/2021/03/10/6YA5NQ.png" alt="6YA5NQ.png"></a></p>
<p>合并相邻有序子序列: </p>
<p>治阶段，我们需要将两个已经有序的子序列合并成一个有序序列</p>
<p>1.创建一个temp数组保存临时排序数据</p>
<p>2.相邻有序子序列都从左到右开始遍历，并进行比较，那个小就 先加入到temp临时数组中</p>
<p>3.当其中一组子序列遍历完毕，就可将另一组子序列全部放入temp中</p>
<p>4.此时temp中存放的数据就是这两个有序子序列中的所有值，并且排好序，只需将temp中的值全部导入到相邻序列中</p>
<p><a href="https://imgtu.com/i/6YEMvt"><img src="https://s3.ax1x.com/2021/03/10/6YEMvt.png" alt="6YEMvt.png"></a></p>
<h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分与和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//先从左开始分</span></span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//再从右开始分</span></span><br><span class="line">            mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//进行合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   最左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid    中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  最右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp   暂时存放排序数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一.将数组左右两边的数依次比较，哪个小就把哪个放入临时数组temp中，直到有一组数据遍历完毕</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;  <span class="comment">// 记录临时数组存放位置的指针</span></span><br><span class="line">        <span class="keyword">int</span> l=left;  <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right)&#123;     <span class="comment">//循环结束就表示有一组数据全部填充完毕</span></span><br><span class="line">            <span class="comment">//进行比较判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l]&lt;=arr[r])&#123;   <span class="comment">//将左边的数据填充到 temp中，并 l++; t++;</span></span><br><span class="line">                temp[t]=arr[l];</span><br><span class="line">                l++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t]=arr[r];  <span class="comment">//将右边的数据填充到 temp中，并 r++; t++;</span></span><br><span class="line">                r++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二.将另一组没有遍历完的数据依次放入临时数组中</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到 temp</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123;</span><br><span class="line">            temp[t]=arr[l];</span><br><span class="line">            t++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[r];</span><br><span class="line">            t++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三.将临时数组中的数据导入到arr数组中 ,arr数组中的位置是 left~~right</span></span><br><span class="line">        <span class="keyword">int</span>  j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            arr[i]=temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 </p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 </p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展 </p>
</li>
<li><p>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。</p>
</li>
</ol>
<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>2.这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
<p><a href="https://imgtu.com/i/6YeBrt"><img src="https://s3.ax1x.com/2021/03/10/6YeBrt.png" alt="6YeBrt.png"></a></p>
<p><a href="https://imgtu.com/i/6YeDqP"><img src="https://s3.ax1x.com/2021/03/10/6YeDqP.png" alt="6YeDqP.png"></a></p>
<p><a href="https://imgtu.com/i/6YesVf"><img src="https://s3.ax1x.com/2021/03/10/6YesVf.png" alt="6YesVf.png"></a></p>
<h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先获取数组中最高位的个数,才能判断排序几轮</span></span><br><span class="line">       <span class="comment">//存放该数组中最大的数，默认第一个数最大</span></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(max&lt;arr[i])&#123;</span><br><span class="line">               max=arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxSize=(max+<span class="string">&quot;&quot;</span>).length();<span class="comment">//获取位数</span></span><br><span class="line">       <span class="comment">//创建一个二维数组，二维数组包含10个一维数组，每个一位数组表示一个桶，一维数组存放的数据就是arr存放的需要排序的数据</span></span><br><span class="line">       <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">       <span class="comment">//创建一个一维数组，表示每个桶里有多少个数据，便于后面将数据放回到arr中</span></span><br><span class="line">       <span class="keyword">int</span>[] bucketCount=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,n=<span class="number">1</span>;j&lt;=maxSize;j++,n*=<span class="number">10</span>)&#123; <span class="comment">//共排序maxSize轮,当前第j轮</span></span><br><span class="line">           <span class="comment">//开始排序,将数据放入桶中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">               <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">               <span class="keyword">int</span> digit = arr[i]/n % <span class="number">10</span>;  <span class="comment">//如果n=1，获取个位；n=10，获取十位；n=100，获取百位。。。。判断当前数该放在哪个桶</span></span><br><span class="line">               bucket[digit][bucketCount[digit]]=arr[i];<span class="comment">//放入第digit个桶中第bucketCount[digit]个位置</span></span><br><span class="line">               bucketCount[digit]++;<span class="comment">//该桶中的数量加一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将10个桶中结果依次放回到arr中</span></span><br><span class="line">           <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//指向放入arr中数据的位置</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bucketCount[i]!=<span class="number">0</span>)&#123;<span class="comment">//如果桶中没数据，则跳过该桶</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;bucketCount[i];m++)&#123;<span class="comment">//根据该桶显示的数据循环获取数据，放入arr中</span></span><br><span class="line">                       arr[index++]=bucket[i][m];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，当前桶 i 中的数据全部放回至arr中，需要当前桶需将bucketCount[i]中的数据改为0，表示桶i中没有了数据，为了下一轮的排序</span></span><br><span class="line">                   bucketCount[i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，全部桶中的数据全部放回到arr中</span></span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+j+<span class="string">&quot;轮排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 基数排序的说明:</p>
<ol>
<li><p>基数排序是对传统桶排序的扩展，速度很快. </p>
</li>
<li><p>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError（内存溢出异常） 。</p>
</li>
<li><p>基数排序时稳定的。</p>
</li>
<li><p>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。 </p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。 </p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 </p>
</li>
<li><p>大顶堆举例说明</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6B9M1H"><img src="https://s3.ax1x.com/2021/03/14/6B9M1H.png" alt="6B9M1H.png"></a></p>
<ol start="5">
<li>小顶堆举例说明</li>
</ol>
<p><a href="https://imgtu.com/i/6B93nI"><img src="https://s3.ax1x.com/2021/03/14/6B93nI.png" alt="6B93nI.png"></a></p>
<ol start="6">
<li>一般升序采用大顶堆，降序采用小顶堆</li>
</ol>
<h4 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h4><p>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，这里是大顶堆，此时，整个序列的最大值就是堆顶的根节点</p>
<p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; </p>
<ol start="3">
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次大值,如此反复执行，便能得到一个有序 序列了</li>
</ol>
<p>​        可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p>提示:最后一个非叶子节点:(arr.length/2-1) , 左子树:(n<em>2+1) , 右子树:(n</em>2+2) , 父节点:(n+1)/2</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//堆排序，从小到大</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//将数组变成大顶堆</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           adjust(arr,i,arr.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//循环遍历，将最大值依次放到数组最后</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="comment">//将根节点（最大值）与最后一个节点的数据交换位置</span></span><br><span class="line">           <span class="keyword">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">           arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">           <span class="comment">//再调整位置</span></span><br><span class="line">           adjust(arr,<span class="number">0</span>,i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;	</span><br><span class="line"><span class="comment">//------------------------------核心代码-------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr 要排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i   将当前树的 i 节点与左右子树比较，将大的排在前面</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length 排序的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//调整当前数组i位置的值，将该值要大于子树的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="comment">//保存当前值</span></span><br><span class="line">       <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">       <span class="comment">//如果存在子节点，循环遍历左子树</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=(i*<span class="number">2</span>+<span class="number">1</span>);k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果存在右子树，且大于左子树，将大的子树提出来</span></span><br><span class="line">           <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k+<span class="number">1</span>]&gt;arr[k])&#123;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断 k 指向的子树是否大于当前节点,如果大则将子节点放入到当前节点位置</span></span><br><span class="line">           <span class="keyword">if</span>(arr[k]&gt;temp)&#123;</span><br><span class="line">               arr[i]=arr[k];</span><br><span class="line">               i=k;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，最大值已经放入到当前树的根节点处</span></span><br><span class="line">       <span class="comment">//如果当前值被替换了，需将 temp 值放到调整后的位置</span></span><br><span class="line">       <span class="keyword">if</span>(temp!=arr[i])&#123;</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h3><p><a href="https://imgtu.com/i/6Ymrl9"><img src="https://s3.ax1x.com/2021/03/10/6Ymrl9.png" alt="6Ymrl9.png"></a></p>
<h4 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h4><ol>
<li><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</p>
</li>
<li><p>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； </p>
</li>
<li><p>内排序：所有排序操作都在内存中完成；</p>
</li>
<li><p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
</li>
<li><p>时间复杂度： 一个算法执行所耗费的时间。</p>
</li>
<li><p>空间复杂度：运行完一个程序所需内存的大小。</p>
</li>
<li><p>n: 数据规模 </p>
</li>
<li><p>k: “桶”的个数 </p>
</li>
<li><p>In-place: 不占用额外内存</p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ol>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/03/11/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 java 中，我们常用的查找有四种:  顺序(线性)查找 ；二分查找/折半查找 ； 插值查找 ； 斐波那契查找</p>
<a id="more"></a>

<h3 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h3><p>就是通过遍历数组，每次判断，如果当前值等于要查找的值，就返回下标即可，相当的easy啦，这里就不演示了</p>
<h3 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找/折半查找"></a>二分查找/折半查找</h3><p>只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.获取该数组中间下标 midIndex=(left+right)/2</p>
<p>2.如果查找的值是否小于中间值mid，则向左继续递归查找</p>
<p>3.如果查找的值是否大于中间值mid，则向右继续递归查找</p>
<p>3.如果等于，则将中间下标返回即可</p>
<p>4.如果遍历完毕还没找到需要查找的值，即 left&gt;right，就反回-1 </p>
<p>问题:上面方法只能找到一个值,如需找到所有该值的下标，需要改进步骤 3 </p>
<p>优化 ： 如果等于，不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只查找一个匹配的下标，并返回该下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchOne</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接返回-1即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">            <span class="keyword">return</span> midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找所有匹配的值，将下标放入集合中，并返回该集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">searchList</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//改进</span></span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到</span></span><br><span class="line">            <span class="comment">//但是不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//向左遍历，将左边一样的值放入list</span></span><br><span class="line">            <span class="keyword">int</span> temp=midIndex-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;<span class="number">0</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将中间值放入list</span></span><br><span class="line">            list.add(midIndex);</span><br><span class="line">            <span class="comment">//向右遍历，将右边一样的值放入list</span></span><br><span class="line">            temp=midIndex+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码（非递归形式查找）"><a href="#补充代码（非递归形式查找）" class="headerlink" title="补充代码（非递归形式查找）"></a>补充代码（非递归形式查找）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归形式查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchPlus</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">           mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="comment">//向左查找</span></span><br><span class="line">           <span class="keyword">if</span>(target&lt;arr[mid])&#123;</span><br><span class="line">               right=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;arr[mid])&#123;</span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h3><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>将折半查找中的求 mid 索引的公式进行改进 , low 表示左边索引 left, high 表示右边索引 right. key 就是我们需要查找的值</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6Nl0pV"><img src="https://s3.ax1x.com/2021/03/11/6Nl0pV.png" alt="6Nl0pV.png"></a></p>
<p>二分查找时，中间值下标  midIndex = (left+right)/2 = left+(right-left)*(1/2)</p>
<p>插值查找将上面的 1/2 做了改进，变成 (data-arr[left])/(arr[right]-arr[left])，让midIndex自适应</p>
<p>midIndex  = left+(right-left)*(data-arr[left])/(arr[right]-arr[left])    通过当前查找的值在最大值与最小值之间的比例来获得中间值</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><p>1.退出条件还需添加  data&lt;arr[left] 与  data&gt;arr[right]，查找的数不小于最小值，不大于最大值，这两个条件不仅是为了优化，还必须存在 （如果查找的数是个特别大或小的数，会造成下标越界异常）</p>
<p>2.插值查找适合在大量数据，且数据分布均匀的条件下使用，如果数据分布相当不均匀，不如用二分查找</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值查找，只查一个值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;插值查找~~&quot;</span>);</span><br><span class="line">       <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">       <span class="comment">// data&lt;arr[left] 与 data&gt;arr[right] 查找的数不小于最小值，不大于最大值，这两个条件不仅时为了优化，必须存在 （如果查找的数是个相当大或小的数，会造成下标越界异常）</span></span><br><span class="line">       <span class="keyword">if</span>(left&gt;right || data&lt;arr[left] || data&gt;arr[right])&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//中间值下标，自适应，(该算法的核心)</span></span><br><span class="line">       <span class="keyword">int</span> midIndex=left+(right-left)*(data-arr[left])/(arr[right]-arr[left]);</span><br><span class="line">       <span class="keyword">int</span> mid=arr[midIndex];</span><br><span class="line">       <span class="keyword">if</span>(data&lt;mid)&#123;<span class="comment">//查找值小于中间值，继续向左递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;<span class="comment">//查找值大于中间值，继续向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">           <span class="keyword">return</span> midIndex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契（黄金分割法）查找算法"><a href="#斐波那契（黄金分割法）查找算法" class="headerlink" title="斐波那契（黄金分割法）查找算法"></a>斐波那契（黄金分割法）查找算法</h3><ol>
<li><p>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神 奇的数字，会带来意向不大的效果。</p>
</li>
<li><p>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ，当前数等于两个数相加，并且斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
</li>
</ol>
<p>本人一直不知道该算法有何意义，真的是玄学算法，好玩倒是真的</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p>
<p><a href="https://imgtu.com/i/6N1UDe"><img src="https://s3.ax1x.com/2021/03/11/6N1UDe.png" alt="6N1UDe.png"></a></p>
<h6 id="对-F-k-1-1-的理解"><a href="#对-F-k-1-1-的理解" class="headerlink" title="对 F(k-1)-1 的理解"></a>对 F(k-1)-1 的理解</h6><p>1.由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段,再加上mid这个位置，即如上图所示。从而中间位置为 mid=low+F[k-1]-1</p>
<p>2.类似的，每一子段也可以用相同的方式分割</p>
<p>3.但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使 得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。</p>
<p> while(n&gt;fib[k]-1) {</p>
<p>​        k++;</p>
<p>}</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认斐波那契数组大小为20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize=<span class="number">20</span>;</span><br><span class="line">   <span class="comment">//创建一个斐波那契数组  &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55 , 89  ...... &#125;</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">       <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">       fib[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">           fib[i]=fib[i-<span class="number">1</span>]+fib[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fib;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//斐波那契算法，不用递归  mid=low+fib[k-1]-1</span></span><br><span class="line">   <span class="comment">// fib[k] = fib[k-1] + fib[k-2]</span></span><br><span class="line">   <span class="comment">// fib[k]-1 = (fib[k-1]-1) +(fib[k-2]-1) + 1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> low=<span class="number">0</span>;  <span class="comment">//最低点</span></span><br><span class="line">       <span class="keyword">int</span> high=arr.length-<span class="number">1</span>;  <span class="comment">//最高点</span></span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//斐波那契中k的值</span></span><br><span class="line">       <span class="keyword">int</span> mid=<span class="number">0</span>; <span class="comment">//中间值</span></span><br><span class="line">       <span class="keyword">int</span>[] fib = fib(); <span class="comment">//获取斐波那契数组</span></span><br><span class="line">       <span class="comment">//通过最大下标，获取k, fib[k]-1 要大于或等于 high</span></span><br><span class="line">       <span class="keyword">while</span> (high&gt;fib[k]-<span class="number">1</span>) &#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，获取到k值，这时arr的长度可能小于fib的长度，这时需要复制通过数组temp</span></span><br><span class="line">       <span class="keyword">int</span>[] temp= Arrays.copyOf(arr,fib[k]);</span><br><span class="line">       <span class="comment">//默认后面填充的值是0，需将0全部变成最后一个数</span></span><br><span class="line">       <span class="comment">//&#123;1,8, 10, 89, 1000, 1234, 0, 0, 0&#125; ==》 &#123;1,8, 10, 89, 1000, 1234, 1234, 1234, 1234&#125;</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=high+<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">           temp[i]=arr[high];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始循环，获取data下标</span></span><br><span class="line">       <span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">           mid=low+fib[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">           System.out.println(mid);</span><br><span class="line">           <span class="keyword">if</span>(data&lt;temp[mid])&#123;<span class="comment">//小于，向左继续查找</span></span><br><span class="line">               high=mid-<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//fib[k]=fib[k-1]+fib[k-2]</span></span><br><span class="line">               <span class="comment">//在前一部分的值中继续查找，前一部分也就是 fib[k-1]</span></span><br><span class="line">               k-=<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;temp[mid])&#123;<span class="comment">//大于，向右继续查找</span></span><br><span class="line">               low=mid+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//在后一部分的值中继续查找,后一部分也就是 fib[k-2]</span></span><br><span class="line">               k-=<span class="number">2</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//等于 ，</span></span><br><span class="line">               <span class="keyword">if</span>(mid&lt;=high)&#123;</span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> high;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/03/13/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/6waRI0"><img src="https://s3.ax1x.com/2021/03/13/6waRI0.png" alt="6waRI0.png"></a></p>
<p>哈希表中存放 链表数组，每一条链表都存放了雇员信息，如图</p>
<p><a href="https://imgtu.com/i/6w05z8"><img src="https://s3.ax1x.com/2021/03/13/6w05z8.png" alt="6w05z8.png"></a></p>
<h4 id="代码实现（暂时不包含相应的方法）"><a href="#代码实现（暂时不包含相应的方法）" class="headerlink" title="代码实现（暂时不包含相应的方法）"></a>代码实现（暂时不包含相应的方法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span> </span>&#123;</span><br><span class="line">    <span class="comment">//哈希表中的链表条数,默认8条（注:后期不能修改）</span></span><br><span class="line">    <span class="keyword">private</span> Integer size = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">private</span> LinkUser[] hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数，根据用户id判断该用户应该在哪一条链表中(这里根据链表条数进行取模计算)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个节点，默认为空</span></span><br><span class="line">    User head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一个用户（节点）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    User next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码实现-实现添加，遍历，查找，删除"><a href="#代码实现-实现添加，遍历，查找，删除" class="headerlink" title="代码实现(实现添加，遍历，查找，删除)"></a>代码实现(实现添加，遍历，查找，删除)</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].add(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].addByOrder(user);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line">	<span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不为空，找到最后一个节点，添加到最后</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,temp为最后一个节点</span></span><br><span class="line">       temp.next = user;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果等于头节点，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(head.id==user.id)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果新节点小于头节点，直接换头节点</span></span><br><span class="line">       <span class="keyword">if</span>(user.id&lt;head.id)&#123;</span><br><span class="line">           user.next=head;</span><br><span class="line">           head=user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果上面条件都不满足，找到需要添加位置的前一个节点</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="comment">//标记temp节点是否是最后一个节点</span></span><br><span class="line">       <span class="keyword">boolean</span> isLast=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(user.id&lt;temp.next.id)&#123;</span><br><span class="line">               isLast=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，要么找到了需要插入的位置，要么遍历到了最后</span></span><br><span class="line">       <span class="keyword">if</span>(isLast)&#123;</span><br><span class="line">           temp.next = user;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           user.next=temp.next;</span><br><span class="line">           temp.next=user;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//遍历哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;链表&quot;</span> + i + <span class="string">&quot;为\t&quot;</span>);</span><br><span class="line">            hash[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot; ==&gt; id=&quot;</span> + temp.id + <span class="string">&quot;,name=&quot;</span> + temp.name);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        User user = hash[i].find(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123; <span class="comment">//存在</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"> <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        <span class="keyword">return</span> hash[i].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.id==id)&#123;<span class="comment">//如果该用户是头节点，直接自我删除即可</span></span><br><span class="line">            head=head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//指向当前要删除的节点的前一个节点</span></span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h5 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h5><h6 id="1-数组存储方式的分析"><a href="#1-数组存储方式的分析" class="headerlink" title="1) 数组存储方式的分析"></a>1) 数组存储方式的分析</h6><a id="more"></a>

<p> 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</p>
<h6 id="2-链式存储方式的分析"><a href="#2-链式存储方式的分析" class="headerlink" title="2) 链式存储方式的分析"></a>2) 链式存储方式的分析</h6><p> 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<h6 id="3-树存储方式的分析"><a href="#3-树存储方式的分析" class="headerlink" title="3) 树存储方式的分析"></a>3) 树存储方式的分析</h6><p> 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度</p>
<p>数示意图:</p>
<p><a href="https://imgtu.com/i/6wsnyT"><img src="https://s3.ax1x.com/2021/03/13/6wsnyT.png" alt="6wsnyT.png"></a></p>
<p>树的常用术语(结合示意图理解): </p>
<ol>
<li><p>节点</p>
</li>
<li><p>根节点</p>
</li>
<li><p>父节点</p>
</li>
<li><p>子节点 </p>
</li>
<li><p>叶子节点 (没有子节点的节点) </p>
</li>
<li><p>节点的权(节点值)</p>
</li>
<li><p>路径(从 root 节点找到该节点的路线)</p>
</li>
<li><p>层 </p>
</li>
<li><p>子树 </p>
</li>
<li><p>树的高度(最大层数) </p>
</li>
<li><p>森林 :多颗子树构成森林</p>
</li>
</ol>
<h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><ol>
<li><p>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 </p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6wsw0e"><img src="https://s3.ax1x.com/2021/03/13/6wsw0e.png" alt="6wsw0e.png"></a></p>
<ol start="4">
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树</li>
</ol>
<p><a href="https://imgtu.com/i/6wsrtA"><img src="https://s3.ax1x.com/2021/03/13/6wsrtA.png" alt="6wsrtA.png"></a></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>使用前序，中序和后序对下面的二叉树进行遍历</p>
<ol>
<li><p>前序遍历: 先输出父节点，再递归遍历左子树，最后递归遍历右子树 </p>
</li>
<li><p>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</p>
</li>
<li><p>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 </p>
</li>
</ol>
<p>小结: 看输出父节点的顺序，就确定是前序，中序还是后序</p>
<h5 id="实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加"><a href="#实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加" class="headerlink" title="实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)"></a>实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历  父节点==》左节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历  左节点==》父节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历  左节点==》右节点==》父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-查找指定节点"><a href="#二叉树-查找指定节点" class="headerlink" title="二叉树-查找指定节点"></a>二叉树-查找指定节点</h4><p>使用前序查找，中序查找和后序查找</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><h6 id="前序查找"><a href="#前序查找" class="headerlink" title="前序查找"></a>前序查找</h6><p>1.先判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>2.如果不等，则判断当前节点左子树是否为空，如果不为空,则向左子树递归前序查找</p>
<p>3.如果左子树找到节点，直接返回，否则判断当前节点右子树是否为空，如果不空，则继续向右子树递归前序查找</p>
<h6 id="中序查找"><a href="#中序查找" class="headerlink" title="中序查找"></a>中序查找</h6><p>1.判断当前节点左子树是否为空，如果不为空,则向左子树递归中序查找</p>
<p>2.如果左子树找到节点，直接返回，否则判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>3.如果不是，则向右子树中序递归查找，找到就返回，没有就返回null</p>
<h6 id="后序查找"><a href="#后序查找" class="headerlink" title="后序查找"></a>后序查找</h6><p>1.先左，再右，后当前节点。。。。。与上面基本一样的套路</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是前序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//先判断当前节点,如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//没找到就向左子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//左子树没找到，就向右子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是中序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//如果左子树没找到，就判单当前节点，如果是，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当前节点没找到，就向右子树递归调用中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不管找到没找到，直接返回即可</span></span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当左子树没找到，就向右子树递归调用后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是后续查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">// 如果左子树没找到，就判断当前节点，如果是就返回当前</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果都没找到，就返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-删除节点（不考虑是否有子树，统一删除）"><a href="#二叉树-删除节点（不考虑是否有子树，统一删除）" class="headerlink" title="二叉树-删除节点（不考虑是否有子树，统一删除）"></a>二叉树-删除节点（不考虑是否有子树，统一删除）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先考虑:</p>
<p>改树是否为空树；根节点是否是要删除的节点；</p>
<p>然后进行以下步骤:</p>
<p>1.因为二叉树是单项的，所以我们需要判断当前节点的子树是否要删除的节点</p>
<p>2.如果当前节点的左子树不为空，并且左子树就是要删除节点，就将 this.left=null; 并返回（结束递归删除）</p>
<p>3.如果当前节点的右子树不为空，并且右子树就是要删除节点，就将 this.right=null; 并返回（结束递归删除）</p>
<p>4.如果第2步与第3步没有删除节点，则需要向左子树递归删除节点</p>
<p>5.如果第4步也没有删除节点，则需要向右子树递归删除</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;删除失败:该数为空！！！&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果要删除的节点是根节点，直接自我删除即可</span></span><br><span class="line">           <span class="keyword">if</span>(root.getNo()==no)&#123;</span><br><span class="line">               root=<span class="keyword">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果不是，就调用树节点的方法</span></span><br><span class="line">               root.deleteNode(no);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码--------------------------------- </span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先判断删除的节点是不是左子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//再判断删除的节点是不是右子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.right=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不是左右子树,则先向左子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树递归没找都，就再向右子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.right.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>数</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/2021/03/14/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>先看一个问题， 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. （ n+1=7 个空指针 )</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<a id="more"></a>

<p>问题分析: </p>
<ol>
<li><p>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } </p>
</li>
<li><p>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</p>
</li>
<li><p>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? </p>
</li>
<li><p>解决方案-线索二叉树</p>
</li>
</ol>
<h4 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h4><ol>
<li><p>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） </p>
</li>
<li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 </p>
</li>
<li><p>一个结点的前一个结点，称为前驱结点</p>
</li>
<li><p>一个结点的后一个结点，称为后继结点</p>
</li>
</ol>
<h4 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h4><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h5><p>中序遍历的结果：{8, 3, 10, 1, 14, 6}，如图</p>
<p><a href="https://imgtu.com/i/6ywk4J"><img src="https://s3.ax1x.com/2021/03/16/6ywk4J.png" alt="6ywk4J.png"></a></p>
<p>节点8，10。。没有左右子树，安装中序遍历结果，8的前驱节点为null，后继节点为3；10的前驱节点为3，后继节点为1。。。</p>
<p>1.我们可以定义一个前驱节点pre，默认为null</p>
<p>2.线索化左节点时，判断当前节点node是否有左子树，如果没有则让当前节点的左指针指向pre</p>
<p>3.线索化右节点时，判断前驱节点pre是否为null，是否有右子树，如果不为null，并且没有右子树，则让pre的右指针指向当前节点</p>
<p>4.每次线索化后，都让pre后移，即 pre=node</p>
<h6 id="说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况"><a href="#说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况" class="headerlink" title="说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:"></a>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</h6><ol>
<li><p>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. </p>
</li>
<li><p>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//用来表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> Node pre=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先向左递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化左指针</span></span><br><span class="line">        <span class="comment">//如果左子树为空，则将左指针指向前驱节点,并改变左指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化右指针</span></span><br><span class="line">        <span class="comment">//如果当前前驱节点不为空，且前驱节点没有右子树，则让他右指针指向它的后继节点（即当前节点），并改变右指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">        pre=node;</span><br><span class="line">        <span class="comment">//最高向右递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法</span></span><br><span class="line">        infixThreaded(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line">    <span class="comment">// 表示左指针指向的类型是什么，0表示左子树，1表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示右指针指向的类型是什么，0表示右子树，1表示后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历中序线索化二叉树"><a href="#遍历中序线索化二叉树" class="headerlink" title="遍历中序线索化二叉树"></a>遍历中序线索化二叉树</h4><p>对前面的中序线索化的二叉树， 进行遍历 </p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历 线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次 序应当和中序遍历保持一致。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       root.infixList();<span class="comment">//从根节点开始</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的(核心)==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前节点，从根节点开始</span></span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//先找到最左边的节点，也就是第一个有前驱的节点，注:即使前驱节点为空，leftType 也等于 1</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到第一个,直接打印</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//如果有后继节点，也直接打印</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getRightType()==<span class="number">1</span>)&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//最后将它变成右子树</span></span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//--------------创建线索化二叉树--------------------</span></span><br><span class="line">       Node root=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">       Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">       Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">       Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">       Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">       root.setLeft(node1);</span><br><span class="line">       root.setRight(node2);</span><br><span class="line">       node1.setLeft(node3);</span><br><span class="line">       node1.setRight(node4);</span><br><span class="line">       node2.setLeft(node5);</span><br><span class="line">       <span class="comment">//这里手动创建</span></span><br><span class="line">       ThreadedBinaryTree tree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">       tree.setRoot(root);</span><br><span class="line">       <span class="comment">//-------------------中序线索化 和 遍历  测试------------------</span></span><br><span class="line">       <span class="comment">//中序线索化</span></span><br><span class="line">       <span class="comment">//中序遍历后是 :  3, 1, 4, 0, 5, 2</span></span><br><span class="line">       <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">       <span class="comment">//但是在线索化后，节点3的前驱为null,后继为1; 节点4的前驱为1，后继为0; 节点5的前驱为0，后继为2</span></span><br><span class="line">       tree.infixThreaded();</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">     	<span class="comment">//中序线索化后遍历</span></span><br><span class="line">       System.out.println(<span class="string">&quot;中序线索化后的遍历:&quot;</span>);  <span class="comment">// 3, 1, 4, 0, 5, 2</span></span><br><span class="line">       tree.infixList();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>根据上面的思路，接下来我将实现前序线索化二叉树及遍历 与 后续线索化二叉树及遍历</p>
<p>注: 向左子树递归与向右子树递归还需加一个条件node.getLeftType()==0与node.getRightType()==0</p>
<p>不加会出现死循环，可自己画个图看看叶节点的前驱与后继是指向哪里</p>
<h4 id="前序线索化二叉树及其遍历"><a href="#前序线索化二叉树及其遍历" class="headerlink" title="前序线索化二叉树及其遍历"></a>前序线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">       pre=node;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           preThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">           preThreaded(node.getRight());</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       preThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.preList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//直接打印当前</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//先向左遍历</span></span><br><span class="line">           <span class="keyword">while</span> (temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示向左遍历完毕,继续获取的后继节点</span></span><br><span class="line">           <span class="keyword">if</span> (temp.getRightType()==<span class="number">1</span> )&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line">      <span class="comment">//前序遍历 : 0, 1, 3, 4, 2, 5</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为1，后继节点为4; 节点4的前驱为3，后继为2; 节点5的前驱为2，后继为null</span></span><br><span class="line">      tree.preThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.preList();</span><br></pre></td></tr></table></figure>
<h4 id="后续线索化二叉树及其遍历"><a href="#后续线索化二叉树及其遍历" class="headerlink" title="后续线索化二叉树及其遍历"></a>后续线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的======================</span></span><br><span class="line"> <span class="comment">//后序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//前驱指针向后移</span></span><br><span class="line">       pre=node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       postThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.postList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//这里本人写不出来，字节用递归的笨方法。。。。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(node);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//后序线索化后的的遍历，重构上面遍历方法，方便调用</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       postList(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line"><span class="comment">//前序遍历 : 3, 4, 1, 5, 2, 0</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为null，后继节点为4; 节点4的前驱为3，后继为1; 节点5的前驱为1，后继为2</span></span><br><span class="line">      tree.postThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.postList();</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼编码</title>
    <url>/2021/03/15/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="赫夫曼树基本介绍"><a href="#赫夫曼树基本介绍" class="headerlink" title="赫夫曼树基本介绍"></a>赫夫曼树基本介绍</h2><ol>
<li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 </li>
</ol>
<a id="more"></a>

<ol start="2">
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h5 id="赫夫曼树几个重要概念和举例说明"><a href="#赫夫曼树几个重要概念和举例说明" class="headerlink" title="赫夫曼树几个重要概念和举例说明"></a>赫夫曼树几个重要概念和举例说明</h5><ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 </p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结 点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 </p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 </p>
</li>
<li><p>WPL 最小的就是赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rMxqx"><img src="https://s3.ax1x.com/2021/03/15/6rMxqx.png" alt="6rMxqx.png"></a></p>
<h3 id="构成赫夫曼树："><a href="#构成赫夫曼树：" class="headerlink" title="构成赫夫曼树："></a>构成赫夫曼树：</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>将每一个数据变成一个节点，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树 </p>
</li>
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将该数字变成一颗霍夫曼树</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HufNode tree = createHuffmanTree(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;霍夫曼树为:&quot;</span>);</span><br><span class="line">        tree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入一个数组，将数组变成一颗赫夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HufNode <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组的每一个元素都组成一个节点，然后放入到list集合中</span></span><br><span class="line">        List&lt;HufNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HufNode(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历，直到list中只有一个值</span></span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先排好序</span></span><br><span class="line">        	Collections.sort(list);</span><br><span class="line">            <span class="comment">// 取出前两个节点(即最小值与次小值)，组成一颗新树</span></span><br><span class="line">            HufNode leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            HufNode rightNode = list.get(<span class="number">1</span>);</span><br><span class="line">            HufNode newNode = <span class="keyword">new</span> HufNode(leftNode.value+ rightNode.value,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//将之前的两个节点删除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新树放入到list集合中，再次排序</span></span><br><span class="line">            list.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时list中只有一个节点，该节点就是一颗完整的赫夫曼树，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HufNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HufNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    HufNode left;</span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    HufNode right;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HufNode o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value-o.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HufNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value, HufNode left, HufNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼编码基本介绍"><a href="#赫夫曼编码基本介绍" class="headerlink" title="赫夫曼编码基本介绍"></a>赫夫曼编码基本介绍</h2><ol>
<li><p>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 </p>
</li>
<li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 </p>
</li>
<li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 </p>
</li>
<li><p>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</p>
</li>
</ol>
<h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><h5 id="通信领域中信息的处理方式-1-定长编码"><a href="#通信领域中信息的处理方式-1-定长编码" class="headerlink" title="通信领域中信息的处理方式 1-定长编码"></a>通信领域中信息的处理方式 1-定长编码</h5><p><a href="https://imgtu.com/i/6rlKn1"><img src="https://s3.ax1x.com/2021/03/15/6rlKn1.png" alt="6rlKn1.png"></a></p>
<h5 id="通信领域中信息的处理方式-2-变长编码"><a href="#通信领域中信息的处理方式-2-变长编码" class="headerlink" title="通信领域中信息的处理方式 2-变长编码"></a>通信领域中信息的处理方式 2-变长编码</h5><p><a href="https://imgtu.com/i/6rlQ76"><img src="https://s3.ax1x.com/2021/03/15/6rlQ76.png" alt="6rlQ76.png"></a></p>
<h5 id="通信领域中信息的处理方式-3-赫夫曼编码"><a href="#通信领域中信息的处理方式-3-赫夫曼编码" class="headerlink" title="通信领域中信息的处理方式 3-赫夫曼编码"></a>通信领域中信息的处理方式 3-赫夫曼编码</h5><h5 id="传输的-字符串"><a href="#传输的-字符串" class="headerlink" title="传输的 字符串"></a>传输的 字符串</h5><ol>
<li><p>i like like like java do you like a java </p>
</li>
<li><p>d:1  y:1  u:1  j:2  v:2  o:2  l:4  k:4  e:4  i:5  a:5  &lt;空格&gt;:9 // 各个字符对应出现的次数 </p>
</li>
<li><p>按照上面字符出现的次数构建一颗赫夫曼树, 字符出现的次数作为权值  </p>
</li>
</ol>
<h5 id="构成赫夫曼树的步骤"><a href="#构成赫夫曼树的步骤" class="headerlink" title="构成赫夫曼树的步骤"></a>构成赫夫曼树的步骤</h5><p>1)将每一个数据变成一个节点 , 将上面的字符变成节点的值，字符出现的次数变成节点的权重，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树</p>
<ol start="2">
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rltcd"><img src="https://s3.ax1x.com/2021/03/15/6rltcd.png" alt="6rltcd.png"></a></p>
<ol start="4">
<li><p>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ，</p>
<p>编码 如下: o: 1000   u: 10010   d: 100110   y: 100111   i: 101   a : 110   k: 1110   e: 1111   j: 0000   v: 0001   l: 001  &lt;空格&gt;: 01 </p>
</li>
<li><p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注 意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110 </p>
</li>
</ol>
<p>通过赫夫曼编码处理 长度为 133 </p>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h6><p> 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% , 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 ,赫夫曼编码是无损处理方案</p>
<h4 id="压缩代码实现"><a href="#压缩代码实现" class="headerlink" title="压缩代码实现"></a>压缩代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================简单封装了下边的所有方法,方便调用 =========================</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   压缩后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(String s)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodeList(s);    <span class="comment">//根据数据获取节点，并放入list集合中</span></span><br><span class="line">        Node tree = createHuffmanTree(nodes); <span class="comment">// 根据所有的节点获取霍夫曼树</span></span><br><span class="line">        Map&lt;Byte, String&gt; table = createHuffmanTable(tree); <span class="comment">// 根据霍夫曼树或取霍夫曼编码表</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = huffmanZip(table, s); <span class="comment">//根据编码表将数据压缩，并返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//===========将字符串中的每一个字符及其出现的频率保存到 List&lt;Node&gt; 集合中=============</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodeList</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="comment">//转换成字符数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">//遍历该字符数组,将数据放入map集合中，key为字符，value为当前字符出现频率</span></span><br><span class="line">        Map&lt;Byte,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = map.get(b);</span><br><span class="line">            <span class="comment">//如果不存在，就直接存入</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(b,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//存在就频率+1</span></span><br><span class="line">                map.put(b,count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历map,将map中的数据全部转换成 Node ，并保存到list中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================创建根据List&lt;Node&gt;集合创建赫夫曼树==================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出最小与次小的两个节点，组成新树，并加入到list中</span></span><br><span class="line">            Node leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode=list.get(<span class="number">1</span>);</span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight, leftNode, rightNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">            <span class="comment">//删除之前的两个最小值</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面循环结束，list中只有一个node节点，该节点就是一颗完整的 赫夫曼树</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================根据霍夫曼树，创建霍夫曼编码表==================</span></span><br><span class="line">	<span class="comment">//霍夫曼编码表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanTable=<span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">    <span class="comment">//用来拼接编码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node   节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code   编码, 0表示左子树，1表示右子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用来拼接编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="comment">//如果不是叶节点，则递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node.data==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123; <span class="comment">//向左递归,0表示</span></span><br><span class="line">                createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;<span class="comment">//向右递归,1表示</span></span><br><span class="line">                createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是叶节点，就直接将编码保存到huffmanTable中</span></span><br><span class="line">            huffmanTable.put(node.data,stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//为了简便调用，重构上面方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//===========根据霍夫曼编码表将字符串进行压缩，得到压缩后的byte数组=============</span></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanTable  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text          需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              压缩完后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(Map&lt;Byte,String&gt; huffmanTable, String text)&#123;</span><br><span class="line">        <span class="comment">//将文本变成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">// 用来保存字节数组根据编码表转换后的内容</span></span><br><span class="line">        <span class="comment">// 如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">        StringBuilder codes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历字节数组，根据编码表将值替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            codes.append(huffmanTable.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时codes保存了译码后的内容，还需将codes内容8位为一体，转变成字节放入压缩后的字节数组zip中</span></span><br><span class="line">        <span class="comment">//根据codes判断zip数组大小，也可以这样写: len=(builder.length()+7)/8</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(codes.length()%<span class="number">8</span>==<span class="number">0</span>)&#123; <span class="comment">//刚好除8没有余数</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果有余数，长度+1即可</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放压缩后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] zip=<span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//标记zip的下标</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历builder，每次获取8位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;codes.length();i+=<span class="number">8</span>)&#123;</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span>&gt;=codes.length())&#123;</span><br><span class="line">                <span class="comment">//如果超过长度，字节截取到最后即可</span></span><br><span class="line">                data=codes.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                data=codes.substring(i,i+<span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为builder是字符串类型，需要先转换成二进制类型，再变成字节类型</span></span><br><span class="line">            zip[index]=(<span class="keyword">byte</span>)Integer.parseInt(data,<span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 字符</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">// 权重（字符出现的频率）</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight-o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">byte</span> data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据解压-使用赫夫曼编码解码"><a href="#数据解压-使用赫夫曼编码解码" class="headerlink" title="数据解压(使用赫夫曼编码解码)"></a>数据解压(使用赫夫曼编码解码)</h3><ol>
<li><p>前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77 , -57, 6, -24, -14, -117, -4, -60, -90, 28] </p>
</li>
<li><p>现在要求使用赫夫曼编码， 进行解码，又 重新得到原来的字符串”i like like like java do you like a java”</p>
</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> flag  标记是否需要补高位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b     需要转换的字节</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>      转换后的二进制字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//将一个字节变成二进制字符串形式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byteToBinaryString</span><span class="params">(<span class="keyword">boolean</span> flag,<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先将字节转换成整数</span></span><br><span class="line">       <span class="keyword">int</span> temp=b;</span><br><span class="line">       <span class="comment">//需要补高位</span></span><br><span class="line">       <span class="comment">//如果temp=1，他的二进制为0000 0001，但是Integer.toBinaryString()方法输出会省略前面的0，直接输出 1，但是前面的0我们也是需要的</span></span><br><span class="line">       <span class="comment">//256=》 1 0000 0000 ， 1 =》 0000 0001， 1|256 =》 1 0000 0001 ，后面再截取最后8位，这样就能补齐高位</span></span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           temp =temp | <span class="number">256</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String str = Integer.toBinaryString(temp);</span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           <span class="comment">//如果补了高位，就截取最后 8 位</span></span><br><span class="line">           <span class="keyword">return</span> str.substring(str.length()-<span class="number">8</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没有补高位就直接返回</span></span><br><span class="line">           <span class="keyword">return</span> str;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> huffmanTable   赫夫曼编码表</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bytes          需要解压的字节数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>               解压后的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//开始解压</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] unzip(Map&lt;Byte,String&gt; huffmanTable,<span class="keyword">byte</span>[] bytes)&#123;</span><br><span class="line">       <span class="comment">//遍历字节数组，将每一个字节转换成二进制字符串，添加到stringBuilder</span></span><br><span class="line">       <span class="comment">//如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">       StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果是最后一位，则不需要补高位</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = i==bytes.length-<span class="number">1</span>;</span><br><span class="line">           stringBuilder.append(byteToBinaryString(!flag, bytes[i]));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//根据哈夫曼编码表将二进制字符串解码</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//先转换一下哈夫曼编码表</span></span><br><span class="line">       HashMap&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;Byte,String&gt; table:huffmanTable.entrySet())&#123;</span><br><span class="line">           map.put(table.getValue(),table.getKey());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始解码</span></span><br><span class="line">       List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 扫描 二进制字符串</span></span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (index&lt;stringBuilder.length())&#123;</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">1</span>;        <span class="comment">//用于计数</span></span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;  <span class="comment">//标记是否计数</span></span><br><span class="line">           String str;         <span class="comment">//用于拼接</span></span><br><span class="line">           Byte value = <span class="keyword">null</span>;         <span class="comment">//用于存放解码后的字节</span></span><br><span class="line">           <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">               str=stringBuilder.substring(index,index+count);</span><br><span class="line">               value=map.get(str);</span><br><span class="line">               <span class="keyword">if</span>(value==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//当前没有找到，继续查找，计数器+1</span></span><br><span class="line">                   count++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//找到，可以结束当前</span></span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到，将value放入list中，并且index指针向后移count次</span></span><br><span class="line">           list.add(value);</span><br><span class="line">           index+=count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将list中的数据全部放入一个字节数组中，返回</span></span><br><span class="line">       <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">           result[i]=list.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩 </p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> srcFile   希望压缩的文件路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dstFile   压缩后文件的路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileZip</span><span class="params">(String srcFile,String dstFile)</span></span>&#123;</span><br><span class="line">      <span class="comment">//文件输入流</span></span><br><span class="line">      InputStream in = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件输出流</span></span><br><span class="line">      OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件对象输出流</span></span><br><span class="line">      ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// ===============写入================</span></span><br><span class="line">          in=<span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">          <span class="comment">//用来存放文件数据</span></span><br><span class="line">          <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">          <span class="comment">//开始写入</span></span><br><span class="line">          in.read(bytes);</span><br><span class="line">          <span class="comment">//================压缩================</span></span><br><span class="line">          <span class="keyword">byte</span>[] zip = HuffmanCoding.zip(bytes);</span><br><span class="line">          <span class="comment">//================输出===============</span></span><br><span class="line">          os=<span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">          oos=<span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">          <span class="comment">//将数据写入</span></span><br><span class="line">          oos.writeObject(zip);</span><br><span class="line">          <span class="comment">//还需将赫夫曼编码表写入</span></span><br><span class="line">          oos.writeObject(HuffmanCoding.huffmanTable);</span><br><span class="line">          System.out.println(<span class="string">&quot;压缩成功~~~&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          System.out.println(e.getMessage());</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//关闭流</span></span><br><span class="line">              in.close();</span><br><span class="line">              os.close();</span><br><span class="line">              oos.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">              System.out.println((ex.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> zipFile  需要解压的文件路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile   解压后的文件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileUnzip</span><span class="params">(String zipFile,String srcFile)</span></span>&#123;</span><br><span class="line">       <span class="comment">//文件输入流</span></span><br><span class="line">       InputStream is=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件对象输入流</span></span><br><span class="line">       ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件输出流</span></span><br><span class="line">       OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//=================输入==============</span></span><br><span class="line">           is=<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">           ois=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">           <span class="comment">//读取数据</span></span><br><span class="line">           <span class="keyword">byte</span>[] bytes =(<span class="keyword">byte</span>[]) ois.readObject();</span><br><span class="line">           <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">           Map&lt;Byte,String&gt; huffmanCodes=(Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line">           <span class="comment">//=================解压==============</span></span><br><span class="line">           <span class="keyword">byte</span>[] result = HuffmanCoding.unzip(huffmanCodes, bytes);</span><br><span class="line">           <span class="comment">//=================输出==============</span></span><br><span class="line">           os=<span class="keyword">new</span> FileOutputStream(srcFile);</span><br><span class="line">           os.write(result);</span><br><span class="line">           System.out.println(<span class="string">&quot;解压成功~~~&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//关闭流</span></span><br><span class="line">               is.close();</span><br><span class="line">               ois.close();</span><br><span class="line">               os.close();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               System.out.println(e.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//因为是对二进制进行压缩，所以可以压缩视频即图片</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要压缩的文件</span></span><br><span class="line">       String srcFile=<span class="string">&quot;c://test.png&quot;</span>;</span><br><span class="line">        <span class="comment">//压缩后的地址</span></span><br><span class="line">       String dstFile=<span class="string">&quot;c://test.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//解压后的地址</span></span><br><span class="line">       String srcFile2=<span class="string">&quot;c://test2.png&quot;</span>;</span><br><span class="line">       <span class="comment">//压缩</span></span><br><span class="line">       fileZip(srcFile,dstFile);</span><br><span class="line">       <span class="comment">//解压</span></span><br><span class="line">       fileUnzip(dstFile,srcFile2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>赫夫曼树</tag>
        <tag>压缩</tag>
        <tag>解压</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树与平衡二叉树</title>
    <url>/2021/03/17/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树：BST (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。 </p>
<p>特别说明：<a id="more"></a>如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><a href="https://imgtu.com/i/6cOefO"><img src="https://s3.ax1x.com/2021/03/17/6cOefO.png" alt="6cOefO.png"></a></p>
<h3 id="二叉排序树创建和遍历"><a href="#二叉排序树创建和遍历" class="headerlink" title="二叉排序树创建和遍历"></a>二叉排序树创建和遍历</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   Node left;</span><br><span class="line">   Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//小的添加到左边</span></span><br><span class="line">        <span class="keyword">if</span>(node.value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点有左子树，则递归左子树进行添加</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.left=node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.value&gt;<span class="keyword">this</span>.value)&#123; <span class="comment">//大的添加到右边</span></span><br><span class="line">            <span class="comment">//如果当前节点有右子树，则递归右子树进行添加</span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">this</span>.right.add(node);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.right=node;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>1.需求先去找到要删除的结点 targetNode </p>
<p>2.找到 targetNode 的 父结点 parent </p>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 </p>
<ol>
<li><p>删除叶子节点  </p>
</li>
<li><p>删除只有一颗子树的节点  </p>
</li>
<li><p>删除有两颗子树的节点. </p>
</li>
</ol>
<h5 id="情况一-删除叶子节点"><a href="#情况一-删除叶子节点" class="headerlink" title="情况一: 删除叶子节点"></a>情况一: 删除叶子节点</h5><p>1.确定 targetNode 是 parent 的左子结点 还是右子结点 </p>
<p>2.根据前面的情况来对应删除 </p>
<p>左子结点 parent.left = null </p>
<p>右子结点 parent.right = null;</p>
<h5 id="情况二-删除只有一颗子树的节点"><a href="#情况二-删除只有一颗子树的节点" class="headerlink" title="情况二: 删除只有一颗子树的节点"></a>情况二: 删除只有一颗子树的节点</h5><p>1.确定 targetNode 的子结点是左子结点还是右子结点 </p>
<p>2.确定targetNode 是 parent 的左子结点还是右子结点</p>
<p>3.根据上面的判断让parent直接指向targetNode 的子节点</p>
<h5 id="情况三-：-删除有两颗子树的节点"><a href="#情况三-：-删除有两颗子树的节点" class="headerlink" title="情况三 ： 删除有两颗子树的节点"></a>情况三 ： 删除有两颗子树的节点</h5><p>1.从 targetNode 的右子树找到最小的结点  (从左子树中找最大值也一样)</p>
<p>2.用一个临时变量temp，将 最小结点的值</p>
<p>3.删除该最小结点 </p>
<p>4.将当前节点的值指向临时变量  ，  targetNode.value = temp</p>
<h4 id="代码实现（前提）"><a href="#代码实现（前提）" class="headerlink" title="代码实现（前提）"></a>代码实现（前提）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line"><span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMaxNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node     当作一棵树的根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>          最小值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMinNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> root.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"> <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(value==<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&gt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没找到就返回空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点的父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果value等于当前节点的左子树的值 或 右子树的值  就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value==value))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; value&gt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没找到就返回空</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代码实现-和兴"><a href="#代码实现-和兴" class="headerlink" title="代码实现 (和兴)"></a>代码实现 (和兴)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要删除的节点是根节点，并且当前树只有该根节点，直接自我删除即可</span></span><br><span class="line">        <span class="keyword">if</span>(value==root.value &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到要删除的节点</span></span><br><span class="line">        Node target = <span class="keyword">this</span>.search(value);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:没有value值为:&quot;</span>+value+<span class="string">&quot;的节点&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除节点的父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.searchParent(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况一:当前要删除的节点是叶节点</span></span><br><span class="line">        <span class="keyword">if</span>(target.right==<span class="keyword">null</span> &amp;&amp; target.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断target是parent的左子树还是右子树</span></span><br><span class="line">            <span class="keyword">if</span>(parent.left!=<span class="keyword">null</span> &amp;&amp; parent.left.value== target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.left=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right!=<span class="keyword">null</span> &amp;&amp; parent.right.value==target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.right=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target.right!=<span class="keyword">null</span> &amp;&amp; target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//情况二:删除有两个子树的节点</span></span><br><span class="line">            <span class="comment">//思路:将左子树中的最大值或右子树中的最小值删除，再填充到当前节点</span></span><br><span class="line">            <span class="comment">//获取右子树中的最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = getAndDeleteMinNode(target.right);</span><br><span class="line">            <span class="comment">//将最小值填充到target中</span></span><br><span class="line">            target.value=min;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取左子树中最大的值(两种方法随便选一个即可)</span></span><br><span class="line"><span class="comment">//            int max =getAndDeleteMaxNode(target.left);</span></span><br><span class="line">            <span class="comment">//将最大值填充到target中</span></span><br><span class="line"><span class="comment">//            target.value=max;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况三:删除只有一个子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//删除的节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//删除的节点有右子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><p>看一个案例(说明二叉排序树可能的问题) </p>
<p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在</p>
<p><a href="https://imgtu.com/i/6cx1xS"><img src="https://s3.ax1x.com/2021/03/17/6cx1xS.png" alt="6cx1xS.png"></a></p>
<ol>
<li><p>左子树全部为空，从形式上看，更像一个单链表. </p>
</li>
<li><p>插入速度没有影响 </p>
</li>
<li><p>查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 </p>
</li>
<li><p>解决方案-平衡二叉树(AVL)</p>
</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 </p>
</li>
<li><p>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 </p>
</li>
<li><p>举例说明, 看看下面哪些 AVL 树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6cx2I1"><img src="https://s3.ax1x.com/2021/03/17/6cx2I1.png" alt="6cx2I1.png"></a></p>
<h3 id="单旋转-左旋转"><a href="#单旋转-左旋转" class="headerlink" title="单旋转(左旋转)"></a>单旋转(左旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p>
<p><a href="https://imgtu.com/i/6czfTs"><img src="https://s3.ax1x.com/2021/03/17/6czfTs.png" alt="6czfTs.png"></a></p>
<h4 id="代码实现-核心"><a href="#代码实现-核心" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><h6 id="注-下面的代码全是在上面的二叉查找树的基础上完成的"><a href="#注-下面的代码全是在上面的二叉查找树的基础上完成的" class="headerlink" title="注:下面的代码全是在上面的二叉查找树的基础上完成的"></a>注:下面的代码全是在上面的二叉查找树的基础上完成的</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//左旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//复制当前节点</span></span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       <span class="comment">//将新节点的左子树变成当前节点的左子树</span></span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">       <span class="comment">//将新节点的右子树变成当前节点的右子树的左子树</span></span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">       <span class="comment">//将当前节点的右子树的值覆盖当前节点（即将右子树代替当前节点）</span></span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line">       <span class="comment">//将当前节点的左子树变成新节点</span></span><br><span class="line">       <span class="keyword">this</span>.left = newNode;</span><br><span class="line">       <span class="comment">//将当前节点的右子树变成当前节点的右子树的右子树</span></span><br><span class="line">       <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="单旋转-右旋转"><a href="#单旋转-右旋转" class="headerlink" title="单旋转(右旋转)"></a>单旋转(右旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p>
<p><a href="https://imgtu.com/i/6gSg9x"><img src="https://s3.ax1x.com/2021/03/17/6gSg9x.png" alt="6gSg9x.png"></a></p>
<h4 id="代码实现-核心-1"><a href="#代码实现-核心-1" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//右旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">       <span class="keyword">this</span>.right = newNode;</span><br><span class="line">       <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================	</span></span><br><span class="line"><span class="comment">//获取当前树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Math.max(node.left == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left), node.right == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取左子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取右子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><p>在之前二叉查找树的节点类的新增方法上添加以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">     <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) </span><br><span class="line">         leftRotate();</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         rightRotate();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。例如: </p>
<p>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.</p>
<p>int[] arr = {2,1,6,5,7,3};   运行原来的代码可以看到，并没有转成 AVL 树</p>
<h5 id="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"><a href="#解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）" class="headerlink" title="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"></a>解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）</h5><p>1.当符合右旋转的条件时 (左子树长)</p>
<p>2.如果它的左子树的右子树高度大于它的左子树的高度</p>
<p>3.先对当前这个结点的左节点进行左旋转</p>
<p>4.再对当前结点进行右旋转的操作即可</p>
<h4 id="改进代码-1"><a href="#改进代码-1" class="headerlink" title="改进代码"></a>改进代码</h4><p>在上面的改进代码中再次改进（有点绕，自己画个图就能理解了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">      <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果右子树的左子树高于右子树，需要先将右子树进行右旋</span></span><br><span class="line">          <span class="keyword">if</span>(right.leftHeight()&gt;right.rightHeight())&#123;</span><br><span class="line">              right.rightRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          leftRotate();</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果左子树的右子树高于左子树，需要先将左子树进行左旋</span></span><br><span class="line">          <span class="keyword">if</span>(left.rightHeight()&gt;left.leftHeight())&#123;</span><br><span class="line">              left.leftRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          rightRotate();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2021/03/19/%E5%9B%BE/</url>
    <content><![CDATA[<p>为什么要有图 </p>
<ol>
<li><p>前面我们学了线性表和树 </p>
</li>
<li><p>线性表局限于一个直接前驱和一个直接后继的关系 </p>
</li>
<li><p>树也只能有一个直接前驱也就是父节点 </p>
</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>当我们需要表示多对多的关系时， 这里我们就用到了图。</li>
</ol>
<h3 id="图的举例说明"><a href="#图的举例说明" class="headerlink" title="图的举例说明"></a>图的举例说明</h3><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图：</p>
<p><a href="https://imgtu.com/i/6feD5q"><img src="https://s4.ax1x.com/2021/03/19/6feD5q.png" alt="6feD5q.png"></a></p>
<h4 id="图的常用概念"><a href="#图的常用概念" class="headerlink" title="图的常用概念"></a>图的常用概念</h4><ol>
<li><p>顶点(vertex) </p>
</li>
<li><p>边(edge) </p>
</li>
<li><p>路径 </p>
</li>
<li><p>无向图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feoPx"><img src="https://s4.ax1x.com/2021/03/19/6feoPx.png" alt="6feoPx.png"></a></p>
<ol start="5">
<li><p>有向图 </p>
</li>
<li><p>带权图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feHxO"><img src="https://s4.ax1x.com/2021/03/19/6feHxO.png" alt="6feHxO.png"></a></p>
<h3 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h3><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。</p>
<p><a href="https://imgtu.com/i/6fm9Rf"><img src="https://s4.ax1x.com/2021/03/19/6fm9Rf.png" alt="6fm9Rf.png"></a></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ol>
<li><p>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. </p>
</li>
<li><p>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6fmiQS"><img src="https://s4.ax1x.com/2021/03/19/6fmiQS.png" alt="6fmiQS.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放各顶点之间关系的二维数组，权重1表示有链接，0表示无连接(矩阵图)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//存放所有的顶点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeCount;</span><br><span class="line">    <span class="comment">//是否已访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edgeCount=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1      边的一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2      边的另一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  权重 (这里1表示链接，0表示不连接)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2]=<span class="number">1</span>;</span><br><span class="line">        edges[v2][v1]=<span class="number">1</span>;</span><br><span class="line">        edgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===============其他常用方法==============</span></span><br><span class="line">    <span class="comment">//获取顶点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgesCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edgeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取v1与v2的权重(是否链接)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isClose</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回下标 i 对应的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印edges</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arr=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>&#125;;</span><br><span class="line">    	<span class="comment">//创建图，并添加顶点</span></span><br><span class="line">       Graph graph = <span class="keyword">new</span> Graph(arr.length);</span><br><span class="line">       <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">           graph.addVertex(s);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加边</span></span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       graph.showEdges();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先遍历介绍"><a href="#图的深度优先遍历介绍" class="headerlink" title="图的深度优先遍历介绍"></a>图的深度优先遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 访问策略: </p>
<p>(1)深度优先遍历 </p>
<p>(2)广度优先遍历</p>
<h4 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h4><p>图的深度优先搜索(Depth First Search) 。 </p>
<ol>
<li><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 </p>
</li>
<li><p>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 </p>
</li>
<li><p>显然，深度优先搜索是一个递归的过程</p>
</li>
</ol>
<h5 id="深度优先遍历算法步骤"><a href="#深度优先遍历算法步骤" class="headerlink" title="深度优先遍历算法步骤"></a>深度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v，并标记结点 v 为已访问。</p>
</li>
<li><p>查找结点 v 的第一个邻接结点 w。</p>
</li>
<li><p>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 </p>
</li>
<li><p>若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 </p>
</li>
<li><p>查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 </p>
</li>
</ol>
<h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前顶点第一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前顶点当前邻接点的下一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=w+<span class="number">1</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度遍历(DFS)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">       <span class="comment">//没有访问过</span></span><br><span class="line">       <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">           System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">           <span class="comment">//标识已访问</span></span><br><span class="line">           isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取第一个邻接点</span></span><br><span class="line">       <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">       <span class="comment">//如果有邻接点，循环遍历</span></span><br><span class="line">       <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果没有被访问，就访问，并标识</span></span><br><span class="line">           <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">              DFS(w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续访问下一个</span></span><br><span class="line">           w=getNextNeighbor(v,w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//重构深度遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">       isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; vertexList.size();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">               DFS(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历基本思想"><a href="#广度优先遍历基本思想" class="headerlink" title="广度优先遍历基本思想"></a>广度优先遍历基本思想</h4><ol>
<li><p>图的广度优先搜索(Broad First Search) 。</p>
</li>
<li><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 访问这些结点的邻接结点 </p>
</li>
</ol>
<h5 id="广度优先遍历算法步骤"><a href="#广度优先遍历算法步骤" class="headerlink" title="广度优先遍历算法步骤"></a>广度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v 并标记结点 v 为已访问。 </p>
</li>
<li><p>结点 v 入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。 </p>
</li>
<li><p>出队列，取得队头结点 u。 </p>
</li>
<li><p>查找结点 u 的第一个邻接结点 w。 </p>
</li>
<li><p>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： </p>
</li>
</ol>
<p>​    6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 </p>
<p>​    6.2 结点 w 入队列 </p>
<p>​    6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度遍历(BFS)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="comment">//用LinkedList模拟一个队列，输出一个数据就将它放入队尾</span></span><br><span class="line">      LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">//没有被访问</span></span><br><span class="line">      <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">          System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">          isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">          queue.addLast(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//获取队列头</span></span><br><span class="line">          v = (<span class="keyword">int</span>)queue.removeFirst();</span><br><span class="line">          <span class="comment">//获取第一个邻接点</span></span><br><span class="line">          <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">          <span class="comment">//如果有邻接点</span></span><br><span class="line">          <span class="keyword">while</span> (w!=-<span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">                  System.out.print(vertexList.get(w)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">                  isVisited[w]=<span class="keyword">true</span>;</span><br><span class="line">                  queue.addLast(w);</span><br><span class="line">              &#125;</span><br><span class="line">              w=getNextNeighbor(v,w);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重构广度遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">      isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">              BFS(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2021/03/19/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<p>汉诺塔的传说 </p>
<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度<a id="more"></a>一个古老传说的益智玩具。大梵天创造世界的时候做了三根金 刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小 顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p> 假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百 亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 </p>
<h3 id="汉诺塔游戏的演示和思路分析"><a href="#汉诺塔游戏的演示和思路分析" class="headerlink" title="汉诺塔游戏的演示和思路分析:"></a>汉诺塔游戏的演示和思路分析:</h3><p>分治算法解决汉诺塔问题<br>1.如果只有一个盘就直接从a移动到c<br>2.如果个数大&gt;=2,就将盘分成最下面一个盘与上面的所有盘<br>3.将上面的所有盘从a移动到b，最下面一个盘从a移动到c，最后把上面的所有盘从b移动到c，依次递归执行</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num    盘的个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a      柱子 1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b      柱子 2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c      柱子 3</span></span><br><span class="line"><span class="comment">    */</span> 	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果只有一个盘</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;盘 1 :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//将上面的所有盘从a移动到b</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">           <span class="comment">//最下面一个盘从a移动到c</span></span><br><span class="line">           System.out.println(<span class="string">&quot;盘 &quot;</span>+num+<span class="string">&quot; :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">           <span class="comment">//最后把上面的所有盘从b移动到c</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试汉诺塔</span></span><br><span class="line">       hanoi(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2021/03/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>最小生成树(Minimum Cost Spanning Tree)，简称 MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树</p>
<a id="more"></a>

<h2 id="普里姆（prim）算法"><a href="#普里姆（prim）算法" class="headerlink" title="普里姆（prim）算法"></a>普里姆（prim）算法</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的 连通子图，也就是所谓的极小连通子图</p>
<h3 id="修路问题"><a href="#修路问题" class="headerlink" title="修路问题"></a>修路问题</h3><p><a href="https://imgtu.com/i/6xhH2D"><img src="https://z3.ax1x.com/2021/03/27/6xhH2D.png" alt="6xhH2D.png"></a></p>
<ol>
<li><p>有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通 </p>
</li>
<li><p>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 </p>
</li>
<li><p>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h4><p>有n个顶点，则需要获取n-1条边</p>
<p>每一次获取边一条边的步骤:</p>
<p>1.假如从A开始，将A设为已访问，获取所有已访问与未访问相连的边 如 &lt;A,C&gt;=7   &lt;A,B&gt;=5    &lt;A,G&gt;=2</p>
<p>2.上面三条边中取权值最小的一条边:&lt;A,G&gt;=2,并将G设为已访问</p>
<p>接下来获取第二条边时，A   G  已经是访问过的点了</p>
<p>可以获取 &lt;A,C&gt;=7   &lt;A,B&gt;=5   &lt;G,B&gt;=3   &lt;G,E&gt;=4   &lt;G,F&gt;=6   这5条边，选择最小的一条边: &lt;G,B&gt;=3,并将B设为已访问</p>
<p>循环 n-1次上面的操作</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  需要生产最小数的图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v      从哪个顶点下标开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(Graph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.vertexNum];</span><br><span class="line">        <span class="comment">//标记当前被访问过</span></span><br><span class="line">        isVisited[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记当前生产边的两个点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存放最小值，初始值可以用无穷大代替</span></span><br><span class="line">        <span class="keyword">int</span> minWeight=<span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为普利姆算法最后产生顶点个数x-1条边，每循环一次添加一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt; graph.vertexNum-<span class="number">1</span>;n++)&#123;</span><br><span class="line">            <span class="comment">// i 表示被访问过的顶点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; graph.vertexNum;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示没有被访问过的顶点下标</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph.vertexNum;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVisited[i]==<span class="number">1</span> &amp;&amp; isVisited[j]==<span class="number">0</span> &amp;&amp; graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        <span class="comment">//替换最小值 与顶点</span></span><br><span class="line">                        minWeight=graph.weight[i][j];</span><br><span class="line">                        h1=i;</span><br><span class="line">                        h2=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结束上面两个循环，就生产了一条边</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span>+graph.data[h1]+<span class="string">&quot;,&quot;</span>+graph.data[h2]+<span class="string">&quot;&gt;,&quot;</span>+minWeight);</span><br><span class="line">            <span class="comment">//标记当前点已访问</span></span><br><span class="line">            isVisited[h2]=<span class="number">1</span>;</span><br><span class="line">            minWeight=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexNum  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight     矩阵图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Graph <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum,<span class="keyword">char</span>[] data,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertexNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            graph.data[i]=data[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;</span><br><span class="line">                graph.weight[i][j]=weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> vertexNum;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] data;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexNum = vertexNum;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">        <span class="keyword">this</span>.weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顶点</span></span><br><span class="line">        <span class="keyword">char</span>[] data=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 矩阵图</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight=&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Graph graph = minTree.createGraph(data.length,data,weight);</span><br><span class="line">        <span class="comment">//生产最小数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最段路:&quot;</span>);</span><br><span class="line">        minTree.prim(graph,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h2><ol>
<li><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 </p>
</li>
<li><p>基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 </p>
</li>
<li><p>具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森 林中不产生回路，直至森林变成一棵树为止</p>
</li>
</ol>
<h3 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h3><p><a href="https://imgtu.com/i/6xoaWV"><img src="https://z3.ax1x.com/2021/03/27/6xoaWV.png" alt="6xoaWV.png"></a></p>
<ol>
<li><p>有北京有新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 </p>
</li>
<li><p>各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 </p>
</li>
<li><p>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第 1 步：将边加入 R 中。 边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbSmD"><img src="https://z3.ax1x.com/2021/03/27/6xbSmD.png" alt="6xbSmD.png"></a></p>
<p>第 2 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。</p>
<p><a href="https://imgtu.com/i/6xb9TH"><img src="https://z3.ax1x.com/2021/03/27/6xb9TH.png" alt="6xb9TH.png"></a></p>
<p>第 3 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbitA"><img src="https://z3.ax1x.com/2021/03/27/6xbitA.png" alt="6xbitA.png"></a></p>
<p>第 4 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbFfI"><img src="https://z3.ax1x.com/2021/03/27/6xbFfI.png" alt="6xbFfI.png"></a></p>
<p>第 5 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbApt"><img src="https://z3.ax1x.com/2021/03/27/6xbApt.png" alt="6xbApt.png"></a></p>
<p>第 6 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbE1P"><img src="https://z3.ax1x.com/2021/03/27/6xbE1P.png" alt="6xbE1P.png"></a></p>
<p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt;  &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;     </p>
<h5 id="克鲁斯卡尔算法重点需要解决的以下两个问-题："><a href="#克鲁斯卡尔算法重点需要解决的以下两个问-题：" class="headerlink" title="克鲁斯卡尔算法重点需要解决的以下两个问 题："></a>克鲁斯卡尔算法重点需要解决的以下两个问 题：</h5><h6 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h6><p>对图的所有边按照权值大小进行排序。很好解决，采用排序算法进行排序即可。</p>
<h6 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h6><p>将边添加到最小生成树中时，怎么样判断是否形成了回路。 </p>
<p>记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。 然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123; </span><br><span class="line">    <span class="comment">//用无穷大表示不存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line">    <span class="comment">//所有顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里全部采用复制拷贝的方式初始化，而不是直接赋值，是为了不改变原来传进来vertex，weight的值</span></span><br><span class="line">        <span class="keyword">int</span> len = vertex.length;</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="keyword">this</span>.vertex = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertex[i] = vertex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化矩阵图 与 边的个数</span></span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.weight[i][j] = weight[i][j];</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF &amp;&amp; weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edgeNum /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心算法(生产最小树)</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] kruskal() &#123;</span><br><span class="line">        <span class="comment">//存放最终结果</span></span><br><span class="line">        Edge[] result = <span class="keyword">new</span> Edge[vertex.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存放各个顶点的终点，该数组是不断变化的</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length];</span><br><span class="line">        <span class="comment">//获取所有边</span></span><br><span class="line">        Edge[] edges = getAllEdge();</span><br><span class="line">        <span class="comment">//将边从小到大排序</span></span><br><span class="line">        sort(edges);</span><br><span class="line">        <span class="comment">//遍历排序后的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取边的两个点的下标</span></span><br><span class="line">            <span class="keyword">char</span> v1 = edges[i].from;</span><br><span class="line">            <span class="keyword">int</span> p1 = getIndexOfVertex(v1);</span><br><span class="line">            <span class="keyword">char</span> v2 = edges[i].to;</span><br><span class="line">            <span class="keyword">int</span> p2 = getIndexOfVertex(v2);</span><br><span class="line">            <span class="comment">//然后获取两个点的终点,如果终点的值为0，返回的就是它的自己下标</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p1);</span><br><span class="line">            <span class="keyword">int</span> m =getEnd(ends,p2);</span><br><span class="line">            <span class="comment">//如果两个点的终点不一样就加入到树中,并且标记终点</span></span><br><span class="line">            <span class="keyword">if</span> (n != m) &#123;</span><br><span class="line">                result[index++] = edges[i];</span><br><span class="line">                ends[n] = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============其他补充的重要方法======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 存放每个顶点对应的终点，如果下标是0，则表示终点是自己</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需要查找终点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下标 i 对应的终点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取下标 i 的终点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据顶点获取该顶点所在的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndexOfVertex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex[i] == v) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边排序(从小到大,冒泡)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Edge[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    Edge temp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有边,如果边为INT 或 0（本身）则不显示</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] getAllEdge() &#123;</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> Edge[edgeNum];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF) &#123;</span><br><span class="line">                    Edge edge = <span class="keyword">new</span> Edge(vertex[i], vertex[j], weight[i][j]);</span><br><span class="line">                    edges[index++] = edge;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%13d&quot;</span>, weight[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> from;</span><br><span class="line">    <span class="keyword">char</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">char</span> from, <span class="keyword">char</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span> + from + <span class="string">&quot;,&quot;</span></span><br><span class="line">                + to +</span><br><span class="line">                <span class="string">&quot;&gt;=&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span>[][] weight = &#123;</span><br><span class="line">               <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">               <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">               <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">               <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">               <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">               <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//创建</span></span><br><span class="line">       Kruskal kruskal = <span class="keyword">new</span> Kruskal(vertex, weight);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       kruskal.show();</span><br><span class="line">       <span class="comment">//开始生产最小树</span></span><br><span class="line">       Edge[] result = kruskal.kruskal();</span><br><span class="line">       System.out.println(<span class="string">&quot;最小树为:&quot;</span>);</span><br><span class="line">       System.out.println(Arrays.toString(result));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>prim</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2021/03/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以 起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<p><a href="https://imgtu.com/i/6xz77V"><img src="https://z3.ax1x.com/2021/03/27/6xz77V.png" alt="6xz77V.png"></a></p>
<p>如何计算出 G 到 其它各个点的最短距离?</p>
<a id="more"></a>

<h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><ol>
<li><p>设置出发顶点为 G，顶点集合 V{v1,v2,vi…}，G 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis 集合记录着 G 到图中各顶点的距离(到自身可以看作 0，G 到 vi 距离对应为 di) </p>
</li>
<li><p>从 Dis 中选择值最小且没有访问的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 G 到 vi 即为最短路径</p>
</li>
<li><p>更新 Dis 集合，更新规则为：比较 G 到 V 集合中顶点的距离值，与 G 通过 vi 到 V 集合中顶点的距离值，保留 值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) </p>
</li>
<li><p>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dgraph</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line">    VisitedVertex vv;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 从哪个顶点开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//迪杰斯特拉算法，生产最短路径，结果在vv中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        vv=<span class="keyword">new</span> VisitedVertex(vertex.length,index);</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        vv.update(index,weight);</span><br><span class="line">        <span class="comment">//每循环一次，获取下一个位还没有访问的最小距离的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            index = vv.getNextVertex();</span><br><span class="line">            <span class="comment">//标记该顶点已访问</span></span><br><span class="line">            vv.visited[index]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//根据下一个顶点进行更新</span></span><br><span class="line">            vv.update(index,weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dgraph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showVV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vv.show(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints:weight)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取具体某个顶点路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        vv.getLoad(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放算法所需要的数组及方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span></span>&#123;</span><br><span class="line">    <span class="comment">//标记是顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">//标记出发点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] dis;</span><br><span class="line">    <span class="comment">//标记到该顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] pre_visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  从哪个顶点开始出发，寻找最短路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        dis=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        pre_visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="comment">//将其他顶点的距离设为最大值</span></span><br><span class="line">        Arrays.fill(dis,<span class="number">65532</span>);</span><br><span class="line">        <span class="comment">//本身的距离设置为0</span></span><br><span class="line">        dis[index]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记本身访问过</span></span><br><span class="line">        visited[index]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//前驱就是本身</span></span><br><span class="line">        pre_visited[index]=index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据index顶点与矩阵图更新VisitedVertex中的各个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="comment">//起点到index的距离加index到j的距离</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//遍历当前顶点的邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight[index].length;j++)&#123;</span><br><span class="line">            len=dis[index]+weight[index][j];</span><br><span class="line">            <span class="comment">//如果j点没有被访问，并且len小于起点到j的距离，则替换距离，并标记前驱</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; len&lt;dis[j])&#123;</span><br><span class="line">                dis[j]=len;</span><br><span class="line">                pre_visited[j]=index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取下一个顶点，如果当前顶点没有被访问，并且起点到该点的距离最小，就返回该点下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">65532</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dis.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; dis[j]&lt;min)&#123;</span><br><span class="line">                min=dis[j];</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径(dis)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span>[] vertex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">            System.out.print(vertex[i]+<span class="string">&quot;(&quot;</span>+dis[i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据某一个终点获取具体路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pre_visited[end]!=end) &#123;</span><br><span class="line">            System.out.print(end+<span class="string">&quot;&lt;=&quot;</span>);</span><br><span class="line">            end=pre_visited[end];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//表示该路不存在</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">65532</span>;</span><br><span class="line">        weight[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        weight[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        weight[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        weight[<span class="number">3</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        weight[<span class="number">4</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        weight[<span class="number">5</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        weight[<span class="number">6</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Dgraph graph = <span class="keyword">new</span> Dgraph(vertex, weight);</span><br><span class="line">        <span class="comment">//查看图的矩阵图</span></span><br><span class="line">        graph.show();</span><br><span class="line">        <span class="comment">//生产最短路径(从C开始)</span></span><br><span class="line">        graph.dijkstra(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最短路径:&quot;</span>);</span><br><span class="line">        graph.showVV();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n从C到D的路劲为:&quot;</span>);</span><br><span class="line">        graph.getLoad(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h2><ol>
<li><p>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法 名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 </p>
</li>
<li><p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p>
</li>
<li><p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 </p>
</li>
<li><p>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点 的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每 一个顶点到其他顶点的最短路径。</p>
</li>
</ol>
<h4 id="弗洛伊德-Floyd-算法图解分析"><a href="#弗洛伊德-Floyd-算法图解分析" class="headerlink" title="弗洛伊德(Floyd)算法图解分析"></a>弗洛伊德(Floyd)算法图解分析</h4><p><a href="https://imgtu.com/i/6zpMrR"><img src="https://z3.ax1x.com/2021/03/27/6zpMrR.png" alt="6zpMrR.png"></a></p>
<p>第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为：</p>
<ol>
<li>以 A 顶点作为中间顶点是，B-&gt;A-&gt;C = 12，C-&gt;A-&gt;G = 9 , B-&gt;A-&gt;G = 7 </li>
</ol>
<p>这里只需变换 B-&gt;C   与 C-&gt;G 的中间点，因为B-&gt;A-&gt;G = 7 路线更长，不需要变换</p>
<ol start="2">
<li>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li>
</ol>
<p><a href="https://imgtu.com/i/6zpOy9"><img src="https://z3.ax1x.com/2021/03/27/6zpOy9.png" alt="6zpOy9.png"></a></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fgraph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图(距离)</span></span><br><span class="line">    <span class="keyword">int</span>[][] dis;</span><br><span class="line">    <span class="comment">//中间顶点图（前驱）</span></span><br><span class="line">    <span class="keyword">int</span>[][] pre;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fgraph</span><span class="params">(<span class="keyword">char</span>[] vertex,<span class="keyword">int</span>[][] dis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex=vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis=dis;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            Arrays.fill(pre[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弗洛伊德算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// k 表示中间点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="comment">// i 表示起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示终点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertex.length;j++)&#123;</span><br><span class="line">                    len=dis[i][k]+dis[k][j]; <span class="comment">//表示起点 i 经过中间点 m ，再到终点 j 的距离</span></span><br><span class="line">                    <span class="comment">//如果 len 小于 起点直接到终点的距离，就替换距离与前驱点</span></span><br><span class="line">                    <span class="keyword">if</span>(len&lt;dis[i][j])&#123;</span><br><span class="line">                        dis[i][j]=len;</span><br><span class="line">                        <span class="comment">//替换前驱点(中间点)</span></span><br><span class="line">                        pre[i][j]=pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出pre与dis</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]]+<span class="string">&quot;\t\t\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span>+vertex[k]+<span class="string">&quot;-&gt;&quot;</span>+vertex[i]+<span class="string">&quot;=&quot;</span>+dis[k][i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">        dis[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">        dis[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">        dis[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        dis[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        dis[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Fgraph graph = <span class="keyword">new</span> Fgraph(vertex,dis);</span><br><span class="line">        System.out.println(<span class="string">&quot;距离图与前驱图:&quot;</span>);</span><br><span class="line">        graph.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n弗洛伊德计算后:&quot;</span>);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/03/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题：有一个背包，容量为 4 磅 ， 现有如下物品</p>
<p><a href="https://imgtu.com/i/6xs1Ag"><img src="https://z3.ax1x.com/2021/03/27/6xs1Ag.png" alt="6xs1Ag.png"></a></p>
<ol>
<li><p>要求达到的目标为装入的背包的<a id="more"></a>总价值最大，并且重量不超出 </p>
</li>
<li><p>要求装入的物品不能重复</p>
</li>
</ol>
<p>这里属于01背包问题，即每件物品只能放一次</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>算法的主要思想，利用动态规划来解决</p>
<p>1.定义物品的价格： p ，重量 w ，再定义一张表（列表示包能装的重量，行表示每一个物品）</p>
<p>2.遍历每一个物品，如果当前物品重量大于当前背包能装的重量，就采取前一个策列来装物品</p>
<p>3.如果包能装的重量大于或等于当前物品的重量，就需要判断— 上一个策略的价格 与 当前物品价格加剩余空间物品的价格，</p>
<p>哪个大，就把大的转入背包</p>
<p><a href="https://imgtu.com/i/6xsr4J"><img src="https://z3.ax1x.com/2021/03/27/6xsr4J.png" alt="6xsr4J.png"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的价格</span></span><br><span class="line">        <span class="keyword">int</span>[] p = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包容量</span></span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//物品个数</span></span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="comment">//表（列表示包能装的重量，行表示每一个物品）</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//标记当前物品路径</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//遍历整个表（因为表的大小是n+1，all+1，所以要从1开始遍历，将0出省略）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;        <span class="comment">// i表示第几个物品，j表示第几个重量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果包能装的重量小于当前物品重量，则采取向上的策略</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//包能装的重量大于或等于当前物品的重量，</span></span><br><span class="line">                    <span class="comment">//上一个策略的价格 与 当前物品价格加剩余空间物品的价格</span></span><br><span class="line">                    <span class="comment">//v[i-1][j]表示上一个策略的价格</span></span><br><span class="line">                    <span class="comment">//p[i-1]表示当前物品价格，v[i-1][all-w[i-1]]表示总重量减去当前物品重量在上一个策略中的价格</span></span><br><span class="line"><span class="comment">//                    v[i][j]=Math.max(v[i-1][j],p[i-1]+v[i-1][all-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//注:当加入的path之后，不能像上面一样直接填写价格高的，这里还需分开，如果当前物品加上一个策略剩余物品价格要高，就在path中添加当前物品标记</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j]=p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]];</span><br><span class="line">                        path[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        v[i][j]=v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将添加的物品表示出来</span></span><br><span class="line">        <span class="comment">//反向遍历，如果该物品标记了，就输出，并且将当前背包的重量减去当前物品重量</span></span><br><span class="line">        <span class="keyword">int</span> i=path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加了&quot;</span>+i+<span class="string">&quot;号物品&quot;</span>);</span><br><span class="line">                j-= w[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;填表过程:&quot;</span>);</span><br><span class="line">        show(v);</span><br><span class="line">        System.out.println(<span class="string">&quot;path标记:&quot;</span>);</span><br><span class="line">        show(path);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[][] v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>马踏棋盘算法</title>
    <url>/2021/03/27/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>马踏棋盘算法也被称为骑士周游问题 </p>
</li>
<li><p>将马随机放在国际象棋的 8×8 棋盘的某个方格中，马按走棋规则(马走日字)进行移动。要求 每个方格只进入一次，走遍棋盘上全部 64 个方格</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6zFtu4"><img src="https://z3.ax1x.com/2021/03/27/6zFtu4.png" alt="6zFtu4.png"></a></p>
<a id="more"></a>

<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发 现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……</p>
<p>1.假设当前位置可以走，设置当前已访问，并标记步数</p>
<p>1.获取马儿当前位置可以走的所有位置</p>
<p>2.遍历所有位置，如果该位置没走就递归走</p>
<p>3.一旦步数达到了棋盘总数，就标记  finished</p>
<p>3.如果遍历完毕，马儿走的步数没达到棋盘总数，或则没有完成，就表示当前位置走不了，清空当前位置的步数，且标记为未访问</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋盘的总列数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> X ;</span><br><span class="line">   <span class="comment">//棋盘的中行数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> Y;</span><br><span class="line">   <span class="comment">//马儿是否走过的位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">   <span class="comment">//开始走</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> row  当前马儿所在的 行 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> col  当前马儿所在的 列 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> step  当前的步数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>[][] chessBoard,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前步数</span></span><br><span class="line">       chessBoard[row][col]=step;</span><br><span class="line">       <span class="comment">//标记当前走过,当前位置在一位数组中表示: 当前行*总列数+当前列</span></span><br><span class="line">       visited[row*X+col]=<span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//获取当前位置可以走的位置</span></span><br><span class="line">       List&lt;Point&gt; nextList = getNext(<span class="keyword">new</span> Point(col, row));</span><br><span class="line">       <span class="comment">//遍历所有的下一步</span></span><br><span class="line">       <span class="keyword">while</span> (!nextList.isEmpty()) &#123;</span><br><span class="line">           Point next = nextList.remove(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//如果下一步没走，就走该位置</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[next.y*X+next.x])&#123;</span><br><span class="line">               go(chessBoard,next.y,next.x,step+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断马儿是否完成了任务</span></span><br><span class="line">       <span class="comment">// 如果上面的循环结束，step没有走到X*Y步，并且还没完成，就将当前位置设置成未访问，并且清空当前位置的步数</span></span><br><span class="line">       <span class="comment">// 如果 step==X*Y ,表示走完，将finished=true; 之后回溯的过程中就不需要清空当前位置的步数了</span></span><br><span class="line">       <span class="keyword">if</span>(step&lt;X*Y &amp;&amp; !finished )&#123;</span><br><span class="line">           chessBoard[row][col]=<span class="number">0</span>;</span><br><span class="line">           visited[row*X+col]=<span class="keyword">false</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           finished=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//获取当前马儿可以走的路线</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point&gt; <span class="title">getNext</span><span class="params">(Point curr)</span></span>&#123;</span><br><span class="line">       List&lt;Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Point p = <span class="keyword">new</span> Point();</span><br><span class="line">       <span class="comment">// 5</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 7</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 0</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 1</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X=<span class="number">6</span>;</span><br><span class="line">        Y=<span class="number">6</span>;</span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span> [][] chessBoard=<span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[X*Y];</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始走</span></span><br><span class="line">        go(chessBoard,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;消耗&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">//输出棋盘</span></span><br><span class="line">        System.out.println(<span class="string">&quot;棋盘为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] ints:chessBoard)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i:ints)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用贪心算法进行优化"><a href="#使用贪心算法进行优化" class="headerlink" title="使用贪心算法进行优化"></a>使用贪心算法进行优化</h4><p>基本思路: 遍历所有下一步可走的位置时，不直接遍历，先对该结果进行排序</p>
<p>排序规则: 当前位置的下一次可走位置次数越大，就排在越前面</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>再上面的遍历nextList的代码上加上  sort(nextList)   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序  point下一次可以走的次数递增排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Point&gt; list)</span></span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取下一步可以走的步数</span></span><br><span class="line">                <span class="keyword">int</span> count1=getNext(o1).size();</span><br><span class="line">                <span class="keyword">int</span> count2=getNext(o2).size();</span><br><span class="line">                <span class="keyword">if</span>(count1-count2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1-count2==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>贪心算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2021/03/27/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配问题：</p>
<ol>
<li><p>有一个字符串 str1= “我是我是怪狗 我是我是怪狗狗”，和一个子串 str2=”我是怪狗狗” </p>
</li>
<li><p>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
</li>
</ol>
<a id="more"></a>

<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><p>并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: </p>
<ol>
<li><p>如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 </p>
</li>
<li><p>如果失配（即 str1[i]! = str2[j]），令 i = i - j + 1，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 </p>
</li>
<li><p>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量 的时间。(不可行!)</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violence</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] s1=str1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2=str2.toCharArray();</span><br><span class="line">       <span class="comment">//指向s1的指针</span></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//指向s2的指针</span></span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;s1.length &amp;&amp; j&lt;s2.length)&#123;</span><br><span class="line">           <span class="comment">//如果匹配</span></span><br><span class="line">           <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//不匹配</span></span><br><span class="line">               <span class="comment">//i 回退到之前的位置，并且向前移动一位</span></span><br><span class="line">               i=i-j+<span class="number">1</span>;</span><br><span class="line">               j=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,</span></span><br><span class="line">       <span class="keyword">if</span>(j==s2.length)&#123;</span><br><span class="line">           <span class="keyword">return</span> i-j;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>介绍《部分匹配表》怎么产生的 </p>
<p>先介绍前缀，后缀是什么</p>
<p><a href="https://imgtu.com/i/6x2JOI"><img src="https://z3.ax1x.com/2021/03/27/6x2JOI.png" alt="6x2JOI.png"></a></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度,例如</p>
<p>”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1；</p>
<p>”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2；</p>
<h5 id="”部分匹配”的实质是"><a href="#”部分匹配”的实质是" class="headerlink" title="”部分匹配”的实质是:"></a>”部分匹配”的实质是:</h5><p>字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么 它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候如果发现 最后一个D不匹配，这时第二个”AB”向前移动 4 位（字符串长度   减去   部分匹配值），就可以来到第一个”AB”的位置。再继续匹配</p>
<p><a href="https://imgtu.com/i/6x2yXn"><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></a></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”</p>
<p><a href="https://imgtu.com/i/6xRQH0"><img src="https://z3.ax1x.com/2021/03/27/6xRQH0.png" alt="6xRQH0.png"></a></p>
<p><a href="https://imgtu.com/i/6xRBE6"><img src="https://z3.ax1x.com/2021/03/27/6xRBE6.png" alt="6xRBE6.png"></a></p>
<p>6.这个时候，如果是暴力算法，就会将继续遍历第三步中 Str1 的下一个字符与str2的第一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这 样就提高了效率）</p>
<p>7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》</p>
<p><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></p>
<p>8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数： </p>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值 </p>
<p>因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p>
<p><a href="https://imgtu.com/i/6xWDLn"><img src="https://z3.ax1x.com/2021/03/27/6xWDLn.png" alt="6xWDLn.png"></a></p>
<p><a href="https://imgtu.com/i/6xWhQJ"><img src="https://z3.ax1x.com/2021/03/27/6xWhQJ.png" alt="6xWhQJ.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str1  所有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str2  需要查找的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> next  str2的部分匹配表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>      需要查找的值的下标，没找到就返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">      <span class="comment">//  i扫描，j扫描str2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ========核心代码===========</span></span><br><span class="line">          <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; str1.charAt(i)!=str2.charAt(j))&#123;</span><br><span class="line">              j=next[j-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果j扫描完毕，就返回下标（因为上面 j++ 了，而 i 没来得及 ++ ，所以后面要 +1 ）</span></span><br><span class="line">          <span class="keyword">if</span>(j==str2.length())&#123;</span><br><span class="line">              <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取一个字符串的部分匹配表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String str)&#123;</span><br><span class="line">      <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">      <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line">      <span class="comment">//第一个数据默认为0（没有前缀与后缀）</span></span><br><span class="line">      next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">          <span class="comment">//如果不匹配，不能直接让len=0，要让len变成匹配表中上一位的匹配值指向的位置</span></span><br><span class="line">          <span class="keyword">while</span>(len&gt;<span class="number">0</span> &amp;&amp; chars[i]!=chars[len])&#123;</span><br><span class="line">              len=next[len-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// i表示当前截取的字符最后一位，如果char[i]==char[len],表示匹配了，匹配值就在上一次的基础上+1,len也要向后移动一位，为了下一次的匹配</span></span><br><span class="line">          <span class="keyword">if</span>(chars[i]==chars[len])&#123;</span><br><span class="line">              len++;</span><br><span class="line">              next[i]=len;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符匹配</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/03/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。<a id="more"></a></p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h4><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>双重for循环，暴力求解</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] ints=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>( (nums[i]+nums[j]) == target)&#123;</span><br><span class="line">                   ints[<span class="number">0</span>]=i;</span><br><span class="line">                   ints[<span class="number">1</span>]=j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ints;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>1.创建一个map集合，key为数组中的值，value为数组当前值的下标</p>
<p>2.循环遍历数组,查询map中是否存在 target 减去 当前值这个key </p>
<p>3.不存在就将当前值为key，下标为value ，存入map中</p>
<p>4.如果存在就直接返回</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>合并有序链表</title>
    <url>/2021/03/28/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/cpVCqO"><img src="https://z3.ax1x.com/2021/03/28/cpVCqO.png" alt="cpVCqO.png" style="zoom: 80%;" /></a></p>
<h3 id="思路一-迭代"><a href="#思路一-迭代" class="headerlink" title="思路一:迭代"></a>思路一:迭代</h3><p>1.创建一个头节点head，用来存放结果，curr指向当前插入的位置</p>
<p>2.循环比较 l1.val 与 l2.val , 哪个小就添加到 curr .next ,并后移,直到一个链表全部遍历完毕</p>
<p>3.将另一个链表中剩余的值 直接添加到curr.next</p>
<p>4.返回 head.next</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放返回的结果</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="comment">//遍历两个链表，依次加入到 head中</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next= (l1!=<span class="keyword">null</span>? l1:l2);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-递归"><a href="#思路二-递归" class="headerlink" title="思路二:递归"></a>思路二:递归</h3><p>l1.val 与 l2.val 比较，哪个小就递归该节点的下一个节点与较大的节点，并返回该小的节点</p>
<p>思路都差不多，看代码理解吧~~</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出口，哪个链表先结束就获取另一个链表</span></span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//哪个小就返回哪个，并且再返回前还需将当前较小的节点递归调用获取下一个节点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">           l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="提升"><a href="#提升" class="headerlink" title="提升:"></a>提升:</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="思路一-暴力求解（不推荐）"><a href="#思路一-暴力求解（不推荐）" class="headerlink" title="思路一:暴力求解（不推荐）"></a>思路一:暴力求解（不推荐）</h3><p>遍历数组中所有的链表，全部添加到一个新的链表，再对新链表排序，简单粗暴</p>
<h3 id="思路二-逐一合并"><a href="#思路二-逐一合并" class="headerlink" title="思路二:逐一合并"></a>思路二:逐一合并</h3><p>创建一条新链表，再遍历链表数组，将每一条链表与新链表合并，而合并两条链表再上面已讲解</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//逐一合并</span></span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            res=mergeTwoLists(res,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路三-两两合并-分治思想"><a href="#思路三-两两合并-分治思想" class="headerlink" title="思路三:两两合并(分治思想)"></a>思路三:两两合并(分治思想)</h3><p>根据下标将链表数组分成左右两部分，再递归将左右两部分继续分，直到分不了为止</p>
<p>依次将最小的两链表合并，并返回</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//两两合并,分治思想</span></span><br><span class="line">       <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">           <span class="keyword">return</span> lists[left];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取中间下标</span></span><br><span class="line">       <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//向左递归分</span></span><br><span class="line">       ListNode list1 = merge(lists, left, mid);</span><br><span class="line">       <span class="comment">//向右递归分</span></span><br><span class="line">       ListNode list2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">       <span class="comment">//将上面递归出来的两条链表合并，并返回</span></span><br><span class="line">       <span class="keyword">return</span> mergeTwoLists(list1,list2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路四-两两合并-迭代思想"><a href="#思路四-两两合并-迭代思想" class="headerlink" title="思路四:两两合并(迭代思想)"></a>思路四:两两合并(迭代思想)</h3><p>与上面实录差不多，只不过这里没有用递归而已</p>
<p> 将数组中相邻的两个链表进行合并，并依次添加到数组左边，数组大小依次压缩2倍，直到大小为1，并这最后的一个链表返回即可</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两两合并,迭代思想</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标志数组长度，依次 /2</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//如果只剩一个，直接添加就行</span></span><br><span class="line">                <span class="keyword">if</span>(i==k-<span class="number">1</span>)&#123;</span><br><span class="line">                    lists[index++]=lists[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lists[index++]=mergeTwoLists(lists[i],lists[i+<span class="number">1</span>]);<span class="comment">//合并</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压缩后更新数组大小</span></span><br><span class="line">            k=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>分治</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2021/03/28/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<a id="more"></a>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cpkusU"><img src="https://z3.ax1x.com/2021/03/28/cpkusU.png" alt="cpkusU.png"></a></p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p><a href="https://imgtu.com/i/cpkQZ4"><img src="https://z3.ax1x.com/2021/03/28/cpkQZ4.png" alt="cpkQZ4.png"></a></p>
<p>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：matrix = [[1]]<br>输出：[[1]]</p>
<h3 id="思路一-暴力求解"><a href="#思路一-暴力求解" class="headerlink" title="思路一:暴力求解"></a>思路一:暴力求解</h3><p>通过一个辅助数组完成</p>
<p>对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：</p>
<p><a href="https://imgtu.com/i/cpk0dH"><img src="https://z3.ax1x.com/2021/03/28/cpk0dH.png" alt="cpk0dH.png"></a></p>
<p>并且，第一行的第 x<em>x</em> 个元素在旋转后恰好是倒数第一列的第 x<em>x</em> 个元素。</p>
<p>对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：</p>
<p><a href="https://imgtu.com/i/cpkrFA"><img src="https://z3.ax1x.com/2021/03/28/cpkrFA.png" alt="cpkrFA.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，通过一个辅助数组完成</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                temp[j][temp.length-<span class="number">1</span>-i]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                matrix[i][j]=temp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-自身旋转"><a href="#思路二-自身旋转" class="headerlink" title="思路二: 自身旋转"></a>思路二: 自身旋转</h3><p>采用分层来进行平移的方式，将矩阵的每一层都分开进行旋转，比如5*5的矩阵可以分为3层</p>
<p><a href="https://imgtu.com/i/cpkjw4"><img src="https://z3.ax1x.com/2021/03/28/cpkjw4.png" alt="cpkjw4.png" style="zoom: 50%;" /></a></p>
<p>旋转的时候，每四个矩阵块作为一组进行相应的旋转，将这4个位置的值交换</p>
<p>​    <a href="https://imgtu.com/i/cpAi6K"><img src="https://z3.ax1x.com/2021/03/28/cpAi6K.png" alt="cpAi6K.png" style="zoom:33%;" /></a><img src="https://z3.ax1x.com/2021/03/28/cpA3nS.png" alt="cpA3nS.png" style="zoom:67%;" /></p>
<p>首先不考虑偏移量的时候写出左上角的坐标为(pos1,pos1),右上角的坐标为(pos1,pos2),左下角的坐标为(pos2,pos1),右下角的坐标为(pos2,pos2)。  可以看出，第二次旋转的时候比第一次旋转偏移了一格，这里我们使用add变量来记录矩阵块的偏移量，则能够写出偏移之后对应的坐标</p>
<p>每次计算完一层之后，矩阵向内收缩一层，让 post1++ ，post2– ,条件是  post1&lt;post2</p>
<p><a href="https://imgtu.com/i/cpAfc6"><img src="https://z3.ax1x.com/2021/03/28/cpAfc6.png" alt="cpAfc6.png" style="zoom: 33%;" /></a></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，自身旋转</span></span><br><span class="line">        <span class="keyword">int</span> post1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> post2=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//偏移量</span></span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次循环都将旋转最外圈的值</span></span><br><span class="line">        <span class="keyword">while</span> (post1&lt;post2)&#123;</span><br><span class="line">             add=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//开始循环替换 4 个为一组的值</span></span><br><span class="line">            <span class="comment">// post1,post1+len   post1+len,post2   post2,post2-len   post2-len,post1</span></span><br><span class="line">            <span class="keyword">while</span>(add&lt;post2-post1)&#123;</span><br><span class="line">                temp=matrix[post1][post1+add];</span><br><span class="line">                matrix[post1][post1+add]=matrix[post2-add][post1];</span><br><span class="line">                matrix[post2-add][post1]=matrix[post2][post2-add];</span><br><span class="line">                matrix[post2][post2-add]=matrix[post1+add][post2];</span><br><span class="line">                matrix[post1+add][post2]=temp;</span><br><span class="line">                add++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向内缩小</span></span><br><span class="line">            post1++;</span><br><span class="line">            post2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/03/28/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
<h3 id="思路一-递归跳跃-超时"><a href="#思路一-递归跳跃-超时" class="headerlink" title="思路一:递归跳跃(超时)"></a>思路一:递归跳跃(超时)</h3><p>1.判断当前步数有没有超过数组长度，如果超过就返回 true</p>
<p>2.如果没超过就获取当前位置的值，遍历当前位置能跳的所有情况，每次遍历就递归条越</p>
<p>3.如果遍历完毕还没有跳出，就返回false</p>
<p>4.这种方法严重超时，不推荐</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归跳跃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前值可以跳跃的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[n];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jump(nums,n+i))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-直推法"><a href="#思路二-直推法" class="headerlink" title="思路二:直推法"></a>思路二:直推法</h3><p>1.直接遍历当前数组，如果遇到0就停下，从当前0所在的位置向前遍历</p>
<p>2.判断前方是否存在:  (下标 + 值)  &gt;  0所在位置的下标，如果存在则说明这个0是可以跳过的，继续上面的遍历</p>
<p>3.如果不存在，就表示当前0是条不过去的，直接返回false</p>
<p>4.遍历结束，返回true</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果找到0，并且不是最后一个数，就向前遍历</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; i!=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                   <span class="comment">//说明前方有一个值可以跳过当前的0</span></span><br><span class="line">                   <span class="keyword">if</span>(nums[j]+j&gt;i)&#123;</span><br><span class="line">                       flag=<span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没找到可以跳跃的数，就返回 false</span></span><br><span class="line">               <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-覆盖法"><a href="#思路三-覆盖法" class="headerlink" title="思路三:覆盖法"></a>思路三:覆盖法</h3><p>1.用一个值can，表示当前最大可达下标</p>
<p>2.遍历数组，如果当前下标小于或等于最大可达下标，说明可以继续跳越，并且不断更新 can == 》Math.max(can ,  i+nums[i])</p>
<p>3.一旦发现当前下标大于最大可达下标，就返回false</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//表示最大可达的下标</span></span><br><span class="line">       <span class="keyword">int</span> can=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果最大可达下标大于当前下标，就不断更新最大可达下标，否则就返回 false</span></span><br><span class="line">           <span class="keyword">if</span>(can&gt;=i)&#123;</span><br><span class="line">               can=Math.max(can,i+nums[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>进阶</p>
<h3 id="跳跃游戏-二"><a href="#跳跃游戏-二" class="headerlink" title="跳跃游戏 二"></a>跳跃游戏 二</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<h3 id="思路一-递归（还是超时）"><a href="#思路一-递归（还是超时）" class="headerlink" title="思路一:递归（还是超时）"></a>思路一:递归（还是超时）</h3><p>遍历每一次跳跃能跳的所有次数, 哪个跳的次数小就返回哪个</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> jump(nums,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">1</span> &lt;&lt; <span class="number">31</span>-<span class="number">1</span>; <span class="comment">//默认最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i&lt;=nums[index]+index;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = jump(nums, i)+<span class="number">1</span>;</span><br><span class="line">            step=Math.min(step,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-反向查找出发位置"><a href="#思路二-反向查找出发位置" class="headerlink" title="思路二:(反向查找出发位置)"></a>思路二:(反向查找出发位置)</h3><p>从后向前遍历，可获取到达当前下标的所有位置，这时找一个离当前下标最远的位置即可，再更新当前下标为最远位置</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>; <span class="comment">//步数</span></span><br><span class="line">        <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isChange=<span class="keyword">false</span>;<span class="comment">//标记是否可以跳出当前</span></span><br><span class="line">            <span class="comment">//循环遍历，判断最左边是否有值可以跳过当前位置，如果可以跳过就更行 右指针</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+nums[i]&gt;=j)&#123;</span><br><span class="line">                    step++;</span><br><span class="line">                    j=i;</span><br><span class="line">                    isChange=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isChange)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-正向查找可到达的最大位置"><a href="#思路三-正向查找可到达的最大位置" class="headerlink" title="思路三:(正向查找可到达的最大位置)"></a>思路三:(正向查找可到达的最大位置)</h3><p>看官网解释方法二，这里我也不是很懂</p>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</a></p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">int</span> maxJump=<span class="number">0</span>;<span class="comment">//当前最大可跳的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//根据当前位置更新最大可达下标</span></span><br><span class="line">            maxJump=Math.max(maxJump,i+nums[i]);</span><br><span class="line">            <span class="comment">//更新边界</span></span><br><span class="line">            <span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">                end=maxJump;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>续。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2021/03/29/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cPSVeJ"><img src="https://z3.ax1x.com/2021/03/29/cPSVeJ.png" alt="cPSVeJ.png"></a></p>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，<a id="more"></a>在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p>
<h3 id="思路一-动态编程"><a href="#思路一-动态编程" class="headerlink" title="思路一:动态编程"></a>思路一:动态编程</h3><p><a href="https://imgtu.com/i/cPSB6S"><img src="https://z3.ax1x.com/2021/03/29/cPSB6S.png" alt="cPSB6S.png" style="zoom: 67%;" /></a></p>
<p>1.从左向右遍历，获取数组 leftMax , 存放左边最大值</p>
<p>2.从右向左遍历，获取数组 rightMax，存放右边最大值</p>
<p>3.遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差，将差累加起来，最后返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//存放左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差</span></span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span>(min&gt;height[i])&#123;</span><br><span class="line">                num+=(min-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>1.获取数组中的最高值</p>
<p>2.从将最高值看作山顶，最左边向山顶走是大概是递增函数，最右边向山顶走大概是递减函数</p>
<p>3.从左边遍历获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</p>
<p>4.从右边遍历获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//获取最高值</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;max)&#123;</span><br><span class="line">                max=height[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从左边获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=leftMax)&#123;</span><br><span class="line">                leftMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(leftMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右边获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=rightMax)&#123;</span><br><span class="line">                rightMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(rightMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>困难</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和、四数之和</title>
    <url>/2021/03/31/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>三数之和: 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = []<br>输出：[]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：nums = [0]<br>输出：[]</p>
<h3 id="方法一-双指针"><a href="#方法一-双指针" class="headerlink" title="方法一(双指针)"></a>方法一(双指针)</h3><h5 id="一二指针不动，第三指针移动"><a href="#一二指针不动，第三指针移动" class="headerlink" title="一二指针不动，第三指针移动"></a>一二指针不动，第三指针移动</h5><p>先对当前数组从小到大排序,这里定义三个指针</p>
<p>让第一个指针从头循环遍历该数组，每一次遍历先让第二指针指向第一指针的下一个位置，再让第二个指针循环遍历数组</p>
<p>第二指针遍历时让第三指针从最后开始走，如果三个指针的值相加大于0，就让第三指针左移，直到等于0，</p>
<p>将结果添加到集合，并最后返回该集合</p>
<h6 id="注意-指针要去重"><a href="#注意-指针要去重" class="headerlink" title="注意: 指针要去重"></a>注意: 指针要去重</h6><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//首先循环第一个指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span> &amp;&amp; nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> third=n-<span class="number">1</span>; <span class="comment">//第三个指针</span></span><br><span class="line">            <span class="keyword">int</span> target= -nums[first];<span class="comment">// 0 减去 头指针的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="comment">//第二个指针去重</span></span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span> &amp;&amp; nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//保证第二指针在第三指针的左边情况下，如果两数相加要大于target，就让第三个指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(second&lt;third &amp;&amp; nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(second==third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;<span class="comment">//条件成立,添加到list中</span></span><br><span class="line">                    List&lt;Integer&gt; add = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    add.add(nums[first]);</span><br><span class="line">                    add.add(nums[second]);</span><br><span class="line">                    add.add(nums[third]);</span><br><span class="line">                    list.add(add);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对上面的方法该进"><a href="#对上面的方法该进" class="headerlink" title="对上面的方法该进"></a>对上面的方法该进</h3><h5 id="一指针不动，二三指针同时移动"><a href="#一指针不动，二三指针同时移动" class="headerlink" title="一指针不动，二三指针同时移动"></a>一指针不动，二三指针同时移动</h5><p>二三指针这里变成左右指针，左指针一定要小于右指针</p>
<p>如果三个数相加小于0，左指针移动，大于0，右指针移动，等于0就将三个数添加到list集合，并同时移动左右指针</p>
<p>最后将集合返回</p>
<h6 id="注意-指针都要去重"><a href="#注意-指针都要去重" class="headerlink" title="注意:指针都要去重"></a>注意:指针都要去重</h6><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">int</span> left= i+<span class="number">1</span>;<span class="comment">//左指针</span></span><br><span class="line">            <span class="keyword">int</span> right=n-<span class="number">1</span>;<span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//添加到list</span></span><br><span class="line">                    list.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//左边去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>] )&#123; left++; &#125;</span><br><span class="line">                    <span class="comment">//右边去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) &#123; right--; &#125;</span><br><span class="line">                    <span class="comment">//指针同移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;  <span class="comment">//如果小了，就左指针移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果大了，就右指针移动</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h6><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [], target = 0<br>输出：[]</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>方法与三数之和相同，再三数之和的基础上再包一个for循环，看作是第四个数</p>
<p>定义四个指针 a ，b ，c ，d，   </p>
<p>a在最外层，从头遍历数组，b为下一层，从a的下一个数开始遍历数组，c与d为第三层，看作左右指针同时移动。。。。。。(参考两数之和改进后的方法)</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// -2,-1,0,0,1,2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n-<span class="number">3</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; nums[a]==nums[a-<span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]+nums[a+<span class="number">1</span>]+nums[a+<span class="number">2</span>]+nums[a+<span class="number">3</span>]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;n-<span class="number">2</span>;b++)&#123;</span><br><span class="line">                <span class="comment">//去重 b</span></span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span> &amp;&amp; nums[b]==nums[b-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[a]+nums[b]+nums[b+<span class="number">1</span>]+nums[b+<span class="number">2</span>]&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c=b+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> d=n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[a]+nums[b]+nums[c]+nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[c]==nums[c+<span class="number">1</span>]) &#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[d]==nums[d-<span class="number">1</span>]) &#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib与requests库的基本使用</title>
    <url>/2021/04/04/urllib%E4%B8%8Erequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-urllib库-—内置"><a href="#1-urllib库-—内置" class="headerlink" title="1.urllib库   —内置"></a>1.urllib库   —内置</h2><h3 id="urlopen函数："><a href="#urlopen函数：" class="headerlink" title="urlopen函数："></a>urlopen函数：</h3><p>创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。</p>
<p>url：请求的url。<a id="more"></a><br>data：请求的data，如果设置了这个值，那么将变成post请求。<br>返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。</p>
<h3 id="urlretrieve函数："><a href="#urlretrieve函数：" class="headerlink" title="urlretrieve函数："></a>urlretrieve函数：</h3><p>这个函数可以方便的将网页上的一个文件保存到本地。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request.urlretrieve(url,文件名)</span><br></pre></td></tr></table></figure>
<h3 id="urlencode函数：编码"><a href="#urlencode函数：编码" class="headerlink" title="urlencode函数：编码"></a>urlencode函数：编码</h3><p>urlencode可以把字典数据转换为URL编码的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;老王&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line">print(qs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#name=%E8%80%81%E7%8E%8B&amp;age=18&amp;greet=hello+world</span></span><br></pre></td></tr></table></figure>


<h3 id="parse-qs函数：解码"><a href="#parse-qs函数：解码" class="headerlink" title="parse_qs函数：解码"></a>parse_qs函数：解码</h3><p>可以将经过编码后的url参数进行解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(parse.parse_qs(qs))</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: [&#x27;老王&#x27;], &#x27;age&#x27;: [&#x27;18&#x27;], &#x27;greet&#x27;: [&#x27;hello world&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="urlparse和urlsplit函数：解析url"><a href="#urlparse和urlsplit函数：解析url" class="headerlink" title="urlparse和urlsplit函数：解析url"></a>urlparse和urlsplit函数：解析url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/index.html;user?id=S#comment&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"><span class="comment"># result = parse.urlsplit(url)</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line">print(result.scheme)</span><br><span class="line">print(result.netloc)</span><br><span class="line">print(result.path)</span><br><span class="line"><span class="comment">#urlparse里有params属性，而urlsplit没有这个params属性。</span></span><br><span class="line">print(result.params)</span><br></pre></td></tr></table></figure>




<h3 id="request-Request类：网络请求-可以增加请求头"><a href="#request-Request类：网络请求-可以增加请求头" class="headerlink" title="request.Request类：网络请求  可以增加请求头"></a>request.Request类：网络请求  可以增加请求头</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 			(KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rq = request.Request(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(rq)</span><br><span class="line"></span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


<h3 id="ProxyHandler处理器（代理设置）：封ip问题"><a href="#ProxyHandler处理器（代理设置）：封ip问题" class="headerlink" title="ProxyHandler处理器（代理设置）：封ip问题"></a>ProxyHandler处理器（代理设置）：封ip问题</h3><ol>
<li><p>代理原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，代理服务器拿到目的网站的数据后，再转发给我们的代码。</p>
</li>
<li><p><a href="http://httpbin.org：这个网站可以方便的查看http请求的一些参数。">http://httpbin.org：这个网站可以方便的查看http请求的一些参数。</a></p>
</li>
<li><p>在代码中使用代理  示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用代理</span></span><br><span class="line"><span class="comment"># 步骤</span></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/ip&#x27;</span></span><br><span class="line"><span class="comment">#1. 使用ProxyHandler,传入代理构建一个handler</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;122.193.244.243:9999&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#2. 使用上面创建的handler构建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#3. 使用opener去发送一个请求</span></span><br><span class="line">resp = opener.<span class="built_in">open</span>(url)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="cookie-登录"><a href="#cookie-登录" class="headerlink" title="cookie:           登录"></a>cookie:           登录</h3><ol>
<li><p>什么是cookie：指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据</p>
</li>
<li><p>cookie的格式：<br>Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；         Domain=DOMAIN_NAME；SECURE<br>参数意义：<br>NAME：cookie的名字。<br>VALUE：cookie的值。<br>Expires：cookie的过期时间。<br>Path：cookie作用的路径。<br>Domain：cookie作用的域名。<br>SECURE：是否只在https协议下起作用。</p>
</li>
</ol>
<h3 id="http-cookiejar模块：提供用于存储cookie的对象"><a href="#http-cookiejar模块：提供用于存储cookie的对象" class="headerlink" title="http.cookiejar模块：提供用于存储cookie的对象"></a>http.cookiejar模块：提供用于存储cookie的对象</h3><ol>
<li><p>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</p>
</li>
<li><p>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</p>
</li>
<li><p>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</p>
</li>
<li><p>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</p>
</li>
</ol>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span>  CookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录：https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F</span></span><br><span class="line"><span class="comment">#个人网页https://i.meishi.cc/cook.php?id=13686422</span></span><br><span class="line"></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.登录</span></span><br><span class="line"><span class="comment">#1.1 创建cookiejar对象</span></span><br><span class="line">cookiejar = CookieJar()</span><br><span class="line"><span class="comment">#1.2 使用cookiejar创建一个HTTPCookieProcess对象</span></span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line"><span class="comment">#1.3 使用上一步的创建的handler创建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#1.4 使用opener发送登录请求  (账号和密码)</span></span><br><span class="line"></span><br><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">post_data = parse.urlencode(&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">req = request.Request(post_url,data=post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">opener.<span class="built_in">open</span>(req)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.访问个人网页</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">rq = request.Request(url,headers=headers)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(rq)</span><br><span class="line">print(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>cookie加载与保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="comment"># cookiejar = MozillaCookieJar(&#x27;cookie.txt&#x27;)</span></span><br><span class="line"><span class="comment"># handler = request.HTTPCookieProcessor(cookiejar)</span></span><br><span class="line"><span class="comment"># opener = request.build_opener(handler)</span></span><br><span class="line"><span class="comment"># resp = opener.open(&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cookiejar.save(ignore_discard=True,ignore_expires=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore_discard=True  即使cookies即将被丢弃也要保存下来</span></span><br><span class="line"><span class="comment"># ignore_expires=True  如果cookies已经过期也将它保存并且文件已存在时将覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookie.txt&#x27;</span>)</span><br><span class="line">cookiejar.load()</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure>


<h2 id="2-requests库-—第三方库"><a href="#2-requests库-—第三方库" class="headerlink" title="2.requests库   —第三方库"></a>2.requests库   —第三方库</h2><p>Requests：让HTTP服务人类</p>
<h3 id="安装和文档地址："><a href="#安装和文档地址：" class="headerlink" title="安装和文档地址："></a>安装和文档地址：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>


<h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加headers和查询参数</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">kw = &#123;<span class="string">&#x27;wd&#x27;</span>:<span class="string">&#x27;中国&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com/s&#x27;</span>,headers=headers,params=kw)</span><br><span class="line">print(response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性</span></span><br><span class="line"><span class="comment"># 查询响应内容</span></span><br><span class="line">print(response.text)  <span class="comment">#返回unicode格式的数据</span></span><br><span class="line">print(response.content) <span class="comment">#返回字节流数据</span></span><br><span class="line">print(response.url)  <span class="comment">#查看完整url地址</span></span><br><span class="line">print(response.encoding) <span class="comment"># 查看响应头部字符编码</span></span><br></pre></td></tr></table></figure>


<h4 id="response-text和response-content的区别："><a href="#response-text和response-content的区别：" class="headerlink" title="response.text和response.content的区别："></a>response.text和response.content的区别：</h4><ol>
<li><code>response.content</code> ：这个是直接从网络上抓取的数据，没有经过任何的编码，所以是一个bytes类型，其实在硬盘上和网络上传输的字符串都是bytes类型</li>
<li><code>response.text</code>：这个是str的数据类型，是requests库将response.content进行解码的字符串，解码需要指定一个编码方式，requests会根据自己的猜测来判断编码的方式，所以有时候可能会猜测错误，就会导致解码产生乱码，这时候就应该进行手动解码，比如使用<code>response.content.decode(&#39;utf-8&#39;)</code></li>
</ol>
<h3 id="发送POST请求："><a href="#发送POST请求：" class="headerlink" title="发送POST请求："></a>发送POST请求：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>,data=data)</span><br></pre></td></tr></table></figure>
<p>POST请求方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;https://www.meishij.net/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.post(url,headers=headers,data=data)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="使用代理："><a href="#使用代理：" class="headerlink" title="使用代理："></a>使用代理：</h3><p>只要在请求的方法中（比如get或者post）传递proxies参数就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;111.77.197.127:9999&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://www.httpbin.org/ip&#x27;</span></span><br><span class="line">resp = requests.get(url,proxies=proxy)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h3><p>基本使用：模拟登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://www.zhihu.com/hot&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_zap=59cde9c3-c5c0-4baa-b756-fa16b5e72b10; d_c0=&quot;APDi1NJcuQ6PTvP9qa1EKY6nlhVHc_zYWGM=|1545737641&quot;; __gads=ID=237616e597ec37ad:T=1546339385:S=ALNI_Mbo2JturZesh38v7GzEeKjlADtQ5Q; _xsrf=pOd30ApWQ2jihUIfq94gn2UXxc0zEeay; q_c1=1767e338c3ab416692e624763646fc07|1554209209000|1545743740000; tst=h; __utma=51854390.247721793.1554359436.1554359436.1554359436.1; __utmc=51854390; __utmz=51854390.1554359436.1.1.utmcsr=zhihu.com|utmccn=(referral)|utmcmd=referral|utmcct=/hot; __utmv=51854390.100-1|2=registration_date=20180515=1^3=entry_date=20180515=1; l_n_c=1; l_cap_id=&quot;OWRiYjI0NzJhYzYwNDM3MmE2ZmIxMGIzYmQwYzgzN2I=|1554365239|875ac141458a2ebc478680d99b9219c461947071&quot;; r_cap_id=&quot;MmZmNDFkYmIyM2YwNDAxZmJhNWU1NmFjOGRkNDNjYjc=|1554365239|54372ab1797cba8c4dd224ba1845dd7d3f851802&quot;; cap_id=&quot;YzQwNGFlYWNmNjY3NDFhNGI4MGMyYjZjYjRhMzQ1ZmE=|1554365239|385cc25e3c4e3b0b68ad5747f623cf3ad2955c9f&quot;; n_c=1; capsion_ticket=&quot;2|1:0|10:1554366287|14:capsion_ticket|44:MmE5YzNkYjgzODAyNDgzNzg5MTdjNmE3NjQyODllOGE=|40d3498bedab1b7ba1a247d9fc70dc0e4f9a4f394d095b0992a4c85e32fd29be&quot;; z_c0=&quot;2|1:0|10:1554366318|4:z_c0|92:Mi4xOWpCeUNRQUFBQUFBOE9MVTBseTVEaVlBQUFCZ0FsVk5iZzJUWFFEWi1JMkxnQXlVUXh2SlhYb3NmWks3d1VwMXRB|81b45e01da4bc235c2e7e535d580a8cc07679b50dac9e02de2711e66c65460c6&quot;; tgw_l7_route=578107ff0d4b4f191be329db6089ff48&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(url,headers=headers)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h4 id="session：共享cookie"><a href="#session：共享cookie" class="headerlink" title="session：共享cookie"></a>session：共享cookie</h4><p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line"></span><br><span class="line">post_data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(post_url,headers=headers,data=post_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问个人页面</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">resp = session.get(url)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="处理不信任的SSL证书："><a href="#处理不信任的SSL证书：" class="headerlink" title="处理不信任的SSL证书："></a>处理不信任的SSL证书：</h3><p>对于那些已经被信任的SSL证书的网站，比如<a href="https://www.baidu.com/%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%BF%E7%94%A8requests%E7%9B%B4%E6%8E%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E3%80%82%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = requests.get(<span class="string">&#x27;https://inv-veri.chinatax.gov.cn/&#x27;</span>,verify=<span class="literal">False</span>)</span><br><span class="line">print(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫数据提取基础</title>
    <url>/2021/04/05/%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="XPath语法和lxml模块"><a href="#XPath语法和lxml模块" class="headerlink" title="XPath语法和lxml模块"></a>XPath语法和lxml模块</h1><p>xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p>
<h2 id="XPath节点"><a href="#XPath节点" class="headerlink" title="XPath节点"></a>XPath节点</h2><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p>
<a id="more"></a>

<h2 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h2><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>使用//获取整个页面当中的元素，然后写标签名，然后在写谓语进行提取，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[@lang=<span class="string">&#x27;en&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="需要注意的知识点："><a href="#需要注意的知识点：" class="headerlink" title="需要注意的知识点："></a>需要注意的知识点：</h3><ol>
<li><p>/和//的区别：/代表只获取子节点，//获取子孙节点，一般//用的比较多，当然也要视情况而定</p>
</li>
<li><p>contains：有时候某个属性中包含了多个值，那么可以使用contains函数，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[contains(@lang,<span class="string">&#x27;en&#x27;</span>)]</span><br></pre></td></tr></table></figure></li>
<li><p>谓词中下标是从1开始的，不是从0开始的</p>
</li>
</ol>
<h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 将字符串解析为html文档</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">print(html)</span><br><span class="line"><span class="comment"># 按字符串序列化html</span></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="从文件中读取html代码："><a href="#从文件中读取html代码：" class="headerlink" title="从文件中读取html代码："></a>从文件中读取html代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="在lxml中使用xpath语法"><a href="#在lxml中使用xpath语法" class="headerlink" title="在lxml中使用xpath语法"></a>在lxml中使用xpath语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法练习</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取所有li标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># for i in result:</span></span><br><span class="line"><span class="comment">#     print(etree.tostring(i))</span></span><br><span class="line"><span class="comment"># 获取所有li元素下的所有class属性的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下href为www.baidu.com的a标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a[@href=&quot;www.baidu.com&quot;]&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下所有span标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li//span&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下的a标签里的所有class：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a//@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取最后一个li的a的href属性对应的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()]/a/@href&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()-1]/a&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result[0].text)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容的第二种方式：</span></span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="实战（瓜子二手车）"><a href="#实战（瓜子二手车）" class="headerlink" title="实战（瓜子二手车）"></a>实战（瓜子二手车）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;...&#x27;</span> <span class="comment">#自己网页查找</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 根据首页获取所有详情页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHrefs</span>(<span class="params">indexUrl</span>):</span></span><br><span class="line">    <span class="comment"># 获取首页内容</span></span><br><span class="line">    index_url = indexUrl</span><br><span class="line">    res = requests.get(index_url, headers=head)</span><br><span class="line">    text = res.content.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 解析首页内容</span></span><br><span class="line">    html = etree.HTML(text)</span><br><span class="line">    ul = html.xpath(<span class="string">&#x27;//ul[@class=&quot;carlist clearfix js-top&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    hrefs = ul.xpath(<span class="string">&#x27;./li/a/@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取详细页面所需内容，保存到字典中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDetail</span>(<span class="params">detail_url</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.guazi.com&#x27;</span> + detail_url</span><br><span class="line">    detail = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    html = etree.HTML(detail)</span><br><span class="line">    title = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    title = title.replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip()</span><br><span class="line">    info = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/ul/li/span/text()&#x27;</span>)</span><br><span class="line">    price_now = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/span/text()&#x27;</span>)</span><br><span class="line">    price_origin = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/div/text()&#x27;</span>)</span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    res[<span class="string">&#x27;标题&#x27;</span>] = title</span><br><span class="line">    res[<span class="string">&#x27;里程表&#x27;</span>] = info[<span class="number">2</span>]</span><br><span class="line">    res[<span class="string">&#x27;排量&#x27;</span>] = info[<span class="number">3</span>]</span><br><span class="line">    res[<span class="string">&#x27;变速箱&#x27;</span>] = info[<span class="number">4</span>]</span><br><span class="line">    res[<span class="string">&#x27;价格&#x27;</span>] = price_now</span><br><span class="line">    res[<span class="string">&#x27;原价&#x27;</span>] = price_origin</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guazhi.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入文件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 遍历一到六页</span></span><br><span class="line">            hrefs = getHrefs(url.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">                detail = getDetail(href)</span><br><span class="line">                <span class="comment"># 开始文件写入</span></span><br><span class="line">                f.write(</span><br><span class="line">                    <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(detail[<span class="string">&#x27;标题&#x27;</span>], detail[<span class="string">&#x27;里程表&#x27;</span>], detail[<span class="string">&#x27;排量&#x27;</span>], detail[<span class="string">&#x27;变速箱&#x27;</span>], detail[<span class="string">&#x27;价格&#x27;</span>],</span><br><span class="line">                                                 detail[<span class="string">&#x27;原价&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url=<span class="string">&#x27;https://www.guazi.com/nc/buy/o&#123;&#125;/#bread&#x27;</span></span><br><span class="line">    main(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="BeautifulSoup4库"><a href="#BeautifulSoup4库" class="headerlink" title="BeautifulSoup4库"></a>BeautifulSoup4库</h1><p>和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。</p>
<h2 id="安装和文档："><a href="#安装和文档：" class="headerlink" title="安装和文档："></a>安装和文档：</h2><p>安装：<br>pip install bs4</p>
<p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>
<h2 id="常见的四种对象："><a href="#常见的四种对象：" class="headerlink" title="常见的四种对象："></a>常见的四种对象：</h2><ol>
<li>Tag：BeautifulSoup中所有的标签都是Tag类型，并且BeautifulSoup的对象其实本质上也是一个Tag类型。所以其实一些方法比如find、find_all并不是BeautifulSoup的，而是Tag的。</li>
<li>NavigableString：继承自python中的str，用起来就跟使用python的str是一样的。</li>
<li>BeautifulSoup：继承自Tag。用来生成BeaufifulSoup树的。对于一些查找方法，比如find、select这些，其实还是Tag的。</li>
<li>Comment：这个也没什么好说，就是继承自NavigableString。</li>
</ol>
<h2 id="contents和children："><a href="#contents和children：" class="headerlink" title="contents和children："></a>contents和children：</h2><p>返回某个标签下的直接子元素，其中也包括字符串。他们两的区别是：contents返回来的是一个列表，children返回的是一个迭代器。</p>
<h2 id="string和strings、stripped-strings属性以及get-text方法"><a href="#string和strings、stripped-strings属性以及get-text方法" class="headerlink" title="string和strings、stripped_strings属性以及get_text方法"></a>string和strings、stripped_strings属性以及get_text方法</h2><ol>
<li>string：获取某个标签下的非标签字符串。返回来的是个字符串。如果这个标签下有多行字符，那么就不能获取到了。</li>
<li>strings：获取某个标签下的子孙非标签字符串。返回来的是个生成器。</li>
<li>stripped_strings：获取某个标签下的子孙非标签字符串，会去掉空白字符。返回来的是个生成器。</li>
<li>get_text：获取某个标签下的子孙非标签字符串，以普通字符串形式返回</li>
</ol>
<h2 id="find-all的使用："><a href="#find-all的使用：" class="headerlink" title="find_all的使用："></a>find_all的使用：</h2><ol>
<li>在提取标签的时候，第一个参数是标签的名字。然后如果在提取标签的时候想要使用标签属性进行过滤，那么可以在这个方法中通过关键字参数的形式，将属性的名字以及对应的值传进去。或者是使用<code>attrs</code>属性，将所有的属性以及对应的值放在一个字典中传给<code>attrs</code>属性。</li>
<li>有些时候，在提取标签的时候，不想提取那么多，那么可以使用<code>limit</code>参数。限制提取多少个。</li>
</ol>
<h2 id="find与find-all的区别："><a href="#find与find-all的区别：" class="headerlink" title="find与find_all的区别："></a>find与find_all的区别：</h2><ol>
<li>find：找到第一个满足条件的标签就返回。说白了，就是只会返回一个元素。</li>
<li>find_all:将所有满足条件的标签都返回。说白了，会返回很多标签（以列表的形式）。</li>
</ol>
<h2 id="使用find和find-all的过滤条件："><a href="#使用find和find-all的过滤条件：" class="headerlink" title="使用find和find_all的过滤条件："></a>使用find和find_all的过滤条件：</h2><ol>
<li>关键字参数：将属性的名字作为关键字参数的名字，以及属性的值作为关键字参数的值进行过滤。</li>
<li>attrs参数：将属性条件放到一个字典中，传给attrs参数。</li>
</ol>
<h2 id="获取标签的属性："><a href="#获取标签的属性：" class="headerlink" title="获取标签的属性："></a>获取标签的属性：</h2><ol>
<li><p>通过下标获取：通过标签的下标的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>通过attrs属性获取：示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a.attrs[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="CSS选择器："><a href="#CSS选择器：" class="headerlink" title="CSS选择器："></a>CSS选择器：</h2><h3 id="select方法："><a href="#select方法：" class="headerlink" title="select方法："></a>select方法：</h3><p>使用以上方法可以方便的找出元素。但有时候使用<code>css</code>选择器的方式可以更加的方便。使用<code>css</code>选择器的语法，应该使用<code>select</code>方法。以下列出几种常用的<code>css</code>选择器方法：</p>
<h4 id="（1）通过标签名查找："><a href="#（1）通过标签名查找：" class="headerlink" title="（1）通过标签名查找："></a>（1）通过标签名查找：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（2）通过类名查找："><a href="#（2）通过类名查找：" class="headerlink" title="（2）通过类名查找："></a>（2）通过类名查找：</h4><p>通过类名，则应该在类的前面加一个<code>.</code>。比如要查找<code>class=sister</code>的标签。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（3）通过id查找："><a href="#（3）通过id查找：" class="headerlink" title="（3）通过id查找："></a>（3）通过id查找：</h4><p>通过id查找，应该在id的名字前面加一个＃号。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;#link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（4）组合查找："><a href="#（4）组合查找：" class="headerlink" title="（4）组合查找："></a>（4）组合查找：</h4><p>组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;p #link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>直接子标签查找，则使用 &gt; 分隔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（5）通过属性查找："><a href="#（5）通过属性查找：" class="headerlink" title="（5）通过属性查找："></a>（5）通过属性查找：</h4><p>查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（6）获取内容"><a href="#（6）获取内容" class="headerlink" title="（6）获取内容"></a>（6）获取内容</h4><p>以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.select(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    print(title.get_text())</span><br></pre></td></tr></table></figure>
<h3 id="实战（豆瓣top250）"><a href="#实战（豆瓣top250）" class="headerlink" title="实战（豆瓣top250）"></a>实战（豆瓣top250）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据首页获取所有详细页的网址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    lis = soup.find(<span class="string">&#x27;ol&#x27;</span>, class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    hrefs = []</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">        href = li.find(<span class="string">&#x27;a&#x27;</span>)[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">        hrefs.append(href)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据详情页获取相关信息并写入文件f中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_detail</span>(<span class="params">url, f</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    div = soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">    <span class="comment"># 电影名</span></span><br><span class="line">    name = <span class="built_in">list</span>(div.find(<span class="string">&#x27;h1&#x27;</span>).stripped_strings)</span><br><span class="line">    div = div.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;subjectwrap clearfix&#x27;</span>)</span><br><span class="line">    info = div.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;info&#x27;</span>).find_all(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;attrs&#x27;</span>)</span><br><span class="line">    <span class="comment"># 导演</span></span><br><span class="line">    direct = <span class="built_in">list</span>(info[<span class="number">0</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 编剧</span></span><br><span class="line">    production = <span class="built_in">list</span>(info[<span class="number">1</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 演员</span></span><br><span class="line">    actor = <span class="built_in">list</span>(info[<span class="number">2</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    score = div.find(<span class="string">&#x27;strong&#x27;</span>, class_=<span class="string">&#x27;ll rating_num&#x27;</span>).string</span><br><span class="line">    f.write(</span><br><span class="line">        <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>.join(name), <span class="string">&#x27;&#x27;</span>.join(direct), <span class="string">&#x27;&#x27;</span>.join(production), <span class="string">&#x27;&#x27;</span>.join(actor), <span class="string">&#x27;&#x27;</span>.join(score)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(name) + <span class="string">&#x27;写入完毕&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>, <span class="number">25</span>): <span class="comment"># 获取所有页数</span></span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        hrefs = get_detail_url(url) <span class="comment"># 获取所有详情页的url</span></span><br><span class="line">        <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                res = write_detail(href, f)</span><br><span class="line">                print(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><h2 id="单字符匹配："><a href="#单字符匹配：" class="headerlink" title="单字符匹配："></a>单字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配某个字符串：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;b&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点（.）：匹配任意的字符(除了&#x27;\n&#x27;)：</span></span><br><span class="line"><span class="comment"># text = &quot;\nabc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;.&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \d：匹配任意的数字：</span></span><br><span class="line"><span class="comment"># text = &quot;aab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\d&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \D：匹配任意的非数字：</span></span><br><span class="line"><span class="comment"># text = &quot;cab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\D&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \s：匹配的是空白字符（包括：\n，\t，\r和空格）：</span></span><br><span class="line"><span class="comment"># text = &quot; ab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\s&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \S：非空白字符：</span></span><br><span class="line"><span class="comment"># text = &quot;\nab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\S&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \w：匹配的是a-z和A-Z以及数字和下划线：</span></span><br><span class="line"><span class="comment"># text = &quot;+bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\w&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \W：匹配的是和\w相反的：</span></span><br><span class="line"><span class="comment"># text = &quot;1bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\W&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []组合的方式，只要满足中括号中的某一项都算匹配成功：</span></span><br><span class="line"><span class="comment"># text = &quot;bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[1b]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式[0-9]\d：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[^0-9]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式实现\w：</span></span><br><span class="line">text = <span class="string">&quot;+bc&quot;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;[^a-zA-Z0-9_]&#x27;</span>,text)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多字符匹配："><a href="#多字符匹配：" class="headerlink" title="多字符匹配："></a>多字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *：匹配0个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\D*&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># +：匹配1个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ?：匹配前一个字符0个或者1个：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w?&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m&#125;：匹配m个字符:</span></span><br><span class="line"><span class="comment"># text = &quot;+1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w&#123;2&#125;&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m,n&#125;：匹配m-n之间的个数的字符：</span></span><br><span class="line">text = <span class="string">&quot;1abc+&quot;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;\w&#123;1,3&#125;&#x27;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="开始-结束-贪婪和非贪婪："><a href="#开始-结束-贪婪和非贪婪：" class="headerlink" title="开始/结束/贪婪和非贪婪："></a>开始/结束/贪婪和非贪婪：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ^：以...开头：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;world&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $：以...结尾：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;hello$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"><span class="comment"># text = &quot;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;^$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># |：匹配多个字符串或者表达式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪婪和非贪婪：在后面加 ?</span></span><br><span class="line"><span class="comment"># text = &quot;12345&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;\d+?&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：提取html标签名称：</span></span><br><span class="line"><span class="comment"># text = &quot;&lt;h1&gt;这是标题&lt;/h1&gt;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;&lt;.+?&gt;&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：验证一个字符是不是0-100之间的数字：</span></span><br><span class="line"><span class="comment"># 0,1,99,100</span></span><br><span class="line"><span class="comment"># 01</span></span><br><span class="line">text = <span class="string">&quot;101&quot;</span></span><br><span class="line">result = re.match(<span class="string">&quot;0$|[1-9]\d?$|100$&quot;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<h2 id="转义字符和原生字符串："><a href="#转义字符和原生字符串：" class="headerlink" title="转义字符和原生字符串："></a>转义字符和原生字符串：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的转义字符：</span></span><br><span class="line"><span class="comment"># raw</span></span><br><span class="line"><span class="comment"># text = r&quot;hello\nworld&quot;</span></span><br><span class="line"><span class="comment"># print(text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式中的转义字符：</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,range price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(&quot;\$\d+&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生字符串和正则表达式：</span></span><br><span class="line"><span class="comment"># 正则表达式的字符串解析规则：</span></span><br><span class="line"><span class="comment"># 1. 先把这个字符串放在Python语言层面进行解析。</span></span><br><span class="line"><span class="comment"># 2. 把Python语言层面解析的结果再放到正则表达式层间进行解析。</span></span><br><span class="line">text = <span class="string">&quot;\cba c&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&quot;\\\\c&quot;,text) # \\\\c =(Python语言层面)&gt; \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">result = re.match(<span class="string">r&quot;\\c&quot;</span>,text) <span class="comment"># \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line">result = re.search(<span class="string">&#x27;.+(\$\d+).+(\$\d+)&#x27;</span>,text)</span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># group()/group(0)：匹配整个分组</span></span><br><span class="line"><span class="comment"># group(1)：匹配第一个分组</span></span><br><span class="line"><span class="comment"># group(2)：匹配第二个分组</span></span><br><span class="line"><span class="comment"># groups()：获取所有的分组</span></span><br></pre></td></tr></table></figure>

<h2 id="re中常用的函数："><a href="#re中常用的函数：" class="headerlink" title="re中常用的函数："></a>re中常用的函数：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># findall：查找所有满足条件的</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(r&#x27;\$\d+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub：根据规则替换其他字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># new_text = text.replace(&quot; &quot;,&quot;\n&quot;)</span></span><br><span class="line"><span class="comment"># new_text = re.sub(r&#x27; |,&#x27;,&#x27;\n&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(new_text)</span></span><br><span class="line"><span class="comment"># html = &quot;&lt;p&gt;4、有机会转为招商银行内部员工；&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="comment"># new_html = re.sub(r&#x27;&lt;.+?&gt;&#x27;,&quot;&quot;,html)</span></span><br><span class="line"><span class="comment"># print(new_html)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split：根据规则分割字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.split(r&#x27; |,&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile：编译正则表达式</span></span><br><span class="line">text = <span class="string">&quot;apple price is 34.56&quot;</span></span><br><span class="line"><span class="comment"># r = re.compile(r&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># \d+ # 整数部分</span></span><br><span class="line"><span class="comment"># \.? # 小数点</span></span><br><span class="line"><span class="comment"># \d* # 小数部分</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;,re.VERBOSE)</span></span><br><span class="line"><span class="comment"># result = re.search(r,text)</span></span><br><span class="line">result = re.search(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">\d+ # 整数部分</span></span><br><span class="line"><span class="string">\.? # 小数点</span></span><br><span class="line"><span class="string">\d* # 小数部分</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>,text,re.VERBOSE)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<p>如果想要在正则表达式中加注释，那么需要在正则表达式的函数最后加一个<code>re.VERBOSE</code>。</p>
<h3 id="实战-糗事百科"><a href="#实战-糗事百科" class="headerlink" title="实战(糗事百科)"></a>实战(糗事百科)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>&#125;</span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使用正则表达式直接切割</span></span><br><span class="line">    texts = re.findall(<span class="string">&#x27;&lt;div\sclass=&quot;content&quot;&gt;.+?&lt;span&gt;(.+?)&lt;/span&gt;&#x27;</span>, html, re.DOTALL)</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># 去除多余标签</span></span><br><span class="line">        text = re.sub(<span class="string">&#x27;&lt;br/&gt;+?&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        print(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.qiushibaike.com/text/page/&#123;&#125;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>):</span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        get_detail(url)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据提取</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储基础</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JSON字符串处理："><a href="#JSON字符串处理：" class="headerlink" title="JSON字符串处理："></a>JSON字符串处理：</h1><h2 id="将Python对象dump成JSON字符串："><a href="#将Python对象dump成JSON字符串：" class="headerlink" title="将Python对象dump成JSON字符串："></a>将Python对象dump成JSON字符串：</h2><ol>
<li>dumps：把Python对象转换成JSON格式的字符串。</li>
<li>dump：把Python对象转换成JSON格式的字符串，并且还可以接收一个文件指针fp参数，可以写入到文件中。</li>
<li><a id="more"></a>这两个方法都有一个`ensure_ascii`参数，默认情况下这个参数的值是True，也就是说转换后的JSON字符串是只能存储ascii格式的，不能存储中文，如果想要存储成中文，那么可以将他设置为False。


</li>
</ol>
<h2 id="将JSON字符串load成Python对象："><a href="#将JSON字符串load成Python对象：" class="headerlink" title="将JSON字符串load成Python对象："></a>将JSON字符串load成Python对象：</h2><ol>
<li>loads：将JSON字符串转换成Python对象。</li>
<li>load：将JSON字符串转换成Python对象，并且是直接从文件中获取JSON字符串。</li>
</ol>
<h1 id="CSV文件处理："><a href="#CSV文件处理：" class="headerlink" title="CSV文件处理："></a>CSV文件处理：</h1><h2 id="CSV文件读取的两种方式："><a href="#CSV文件读取的两种方式：" class="headerlink" title="CSV文件读取的两种方式："></a>CSV文件读取的两种方式：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式读取到的每一条数据是一个列表，所以需要通过下标的方式获取具体某一个值</span></span><br><span class="line"><span class="comment"># with open(&quot;stock.csv&quot;,&#x27;r&#x27;,encoding=&#x27;gbk&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     reader = csv.reader(fp)</span></span><br><span class="line"><span class="comment">#     for x in reader:</span></span><br><span class="line"><span class="comment">#         print(x[3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式读取到的每一条数据是一个字典，所以可以通过列名获取数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stock.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    reader = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> reader:</span><br><span class="line">        print(x[<span class="string">&#x27;secShortName&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="CSV文件的写入的两种方式："><a href="#CSV文件的写入的两种方式：" class="headerlink" title="CSV文件的写入的两种方式："></a>CSV文件的写入的两种方式：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">headers = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;height&#x27;</span>)</span><br><span class="line"><span class="comment"># students = [</span></span><br><span class="line"><span class="comment">#     (&quot;张三&quot;,18,180),</span></span><br><span class="line"><span class="comment">#     (&quot;李四&quot;,19,190),</span></span><br><span class="line"><span class="comment">#     (&quot;王五&quot;,20,170)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;height&quot;</span>:<span class="number">180</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;height&quot;</span>:<span class="number">190</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;height&quot;</span>:<span class="number">170</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&quot;students.csv&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;,newline=&#x27;&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     writer = csv.writer(fp)</span></span><br><span class="line"><span class="comment">#     writer.writerow(headers) # 写入一行</span></span><br><span class="line"><span class="comment">#     writer.writerows(students) # 写入多行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;students.csv&quot;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    writer = csv.DictWriter(fp,headers) <span class="comment"># 需要指定头</span></span><br><span class="line">    <span class="comment"># 虽然DictWriter创建的时候有一个headers，但是想要写入数据进去</span></span><br><span class="line">    <span class="comment"># 还是需要调用writer.writeheader()方法，否则，表头数据写入不进去</span></span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerows(students)</span><br></pre></td></tr></table></figure>
<h1 id="Excel文件处理："><a href="#Excel文件处理：" class="headerlink" title="Excel文件处理："></a>Excel文件处理：</h1><h2 id="读取Sheet相关的操作："><a href="#读取Sheet相关的操作：" class="headerlink" title="读取Sheet相关的操作："></a>读取Sheet相关的操作：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workbook = xlrd.open_workbook(<span class="string">&quot;成绩表.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的sheet名字</span></span><br><span class="line">print(workbook.sheet_names())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引获取指定的sheet对象</span></span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据名称获取指定的sheet对象</span></span><br><span class="line">sheet = workbook.sheet_by_name(<span class="string">&quot;2班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的sheet对象</span></span><br><span class="line">sheets = workbook.sheets()</span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">    print(sheet.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定sheet的行数和列数</span></span><br><span class="line">rows= sheet.nrows</span><br><span class="line">cols= sheet.ncols</span><br></pre></td></tr></table></figure>
<h2 id="Cell相关的操作："><a href="#Cell相关的操作：" class="headerlink" title="Cell相关的操作："></a>Cell相关的操作：</h2><p>每个Cell代表的是表格中的一格。以下方法可以方便获取想要的cell： </p>
<ol>
<li>sheet.cell(row,col)：获取指定行和列的cell对象。 </li>
<li> sheet.row_slice(row,start_col,end_col)：获取指定行的某几列的cell对象。 </li>
<li>sheet.col_slice(col,start_row,end_row)：获取指定列的某几行的cell对象。 </li>
<li>sheet.cell_value(row,col)：获取指定行和列的值。 </li>
<li>sheet.row_values(row,start_col,end_col)：获取指定行的某几列的值。 </li>
<li>sheet.col_values(col,start_row,end_row)：获取指定列的某几行的值。</li>
</ol>
<h2 id="Cell中常用的数据类型："><a href="#Cell中常用的数据类型：" class="headerlink" title="Cell中常用的数据类型："></a>Cell中常用的数据类型：</h2><ol>
<li><p>xlrd.XL_CELL_TEXT（Text）：文本类型,表示1</p>
</li>
<li><p>xlrd.XL_CELL_NUMBER（Number）：数值类型,表示2</p>
</li>
<li><p> xlrd.XL_CELL_DATE（Date）：日期时间类型,表示3</p>
</li>
<li><p>  xlrd.XL_CELL_BOOLEAN（Bool）：布尔类型,表示4</p>
</li>
<li><p> xlrd.XL_CELL_EMPTY：空白数据类型,表示0</p>
</li>
</ol>
<h2 id="写入Excel"><a href="#写入Excel" class="headerlink" title="写入Excel"></a>写入Excel</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet = workbook.add_sheet(<span class="string">&quot;sheet1&quot;</span>) <span class="comment"># 添加一个sheet</span></span><br><span class="line"><span class="comment"># 在(1,1)处写入&#x27;tom&#x27; </span></span><br><span class="line">sheet.write(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存到&quot;成绩2.xls&quot;</span></span><br><span class="line">workbook.save(<span class="string">&quot;成绩2.xls&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实战-计算一个Excel文件中的总分与平均分"><a href="#实战-计算一个Excel文件中的总分与平均分" class="headerlink" title="实战(计算一个Excel文件中的总分与平均分)"></a>实战(计算一个Excel文件中的总分与平均分)</h3><p>1 .  先将当前文件编辑</p>
<p>2 . 将当前文件中的值全都复制到另一个文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">rbook = xlrd.open_workbook(<span class="string">&#x27;成绩.xls&#x27;</span>)</span><br><span class="line">rsheet = rbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算总分</span></span><br><span class="line">rsheet.put_cell(<span class="number">0</span>, rsheet.ncols, xlrd.XL_CELL_TEXT, <span class="string">&#x27;总分&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rsheet.nrows):</span><br><span class="line">    values = rsheet.row_values(row, <span class="number">1</span>, rsheet.ncols - <span class="number">1</span>)</span><br><span class="line">    sums = <span class="built_in">sum</span>(values)</span><br><span class="line">    print(<span class="built_in">type</span>(sums))</span><br><span class="line">    rsheet.put_cell(row, <span class="number">4</span>, xlrd.XL_CELL_NUMBER, sums, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 计算平均分</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    grades = rsheet.col_values(col, <span class="number">1</span>, rsheet.nrows)</span><br><span class="line">    avg = <span class="built_in">sum</span>(grades) / <span class="built_in">len</span>(grades)</span><br><span class="line">    rsheet.put_cell(rsheet.nrows, col, xlrd.XL_CELL_NUMBER, avg, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># copy</span></span><br><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet = workbook.add_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, rsheet.nrows):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        sheet.write(row, col, rsheet.cell_value(row, col))</span><br><span class="line">workbook.save(<span class="string">&quot;成绩2.xls&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="MySQL处理"><a href="#MySQL处理" class="headerlink" title="MySQL处理"></a>MySQL处理</h1><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db=pymysql.connect(</span><br><span class="line">    host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">3306</span>, user=<span class="string">&quot;root&quot;</span>, password=<span class="string">&quot;nofuck&quot;</span>, database=<span class="string">&quot;py_hui&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取游标，通过该游标操作</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM USER&quot;</span>)</span><br><span class="line">result = cursor.fetchmany(<span class="number">2</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>cursor.fetchone()    # 获取第一条数据</p>
<p>cursor.fetchall()       # 获取所有数据</p>
<p>cursor.fetchmany(2)   # 获取前两条数据</p>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p>sql语句中可用 %s 占一个位置，后面用原组填充进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;怪狗狗&#x27;</span></span><br><span class="line">gender = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">age = <span class="number">2</span></span><br><span class="line">sql = <span class="string">&#x27;insert into user (id,name,gender,age) values (null,%s,%s,%s)&#x27;</span></span><br><span class="line">cursor.execute(sql, (name, gender, age))</span><br><span class="line">db.commit() <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure>
<p>注意: 执行完sql语句后记得要 db.close() 关闭链接！！！</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
        <tag>Excel</tag>
        <tag>CSV</tag>
        <tag>JSON</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程爬虫</title>
    <url>/2021/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="如何创建一个基本的多线程："><a href="#如何创建一个基本的多线程：" class="headerlink" title="如何创建一个基本的多线程："></a>如何创建一个基本的多线程：</h2><p>使用<code>threading</code>模块下的<code>Thread</code>类即可创建一个线程。这个类有一个<code>target</code>参数，需要指定一个函数，那么以后这个线程执行的时候，就会执行这个函数的代码。示例代码如下：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">code</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=code, name=<span class="string">&quot;胖虎&quot;</span>)</span><br><span class="line">    t2 = threading.Thread(target=dance, name=<span class="string">&quot;静香&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    multi_thread() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="查看当前线程："><a href="#查看当前线程：" class="headerlink" title="查看当前线程："></a>查看当前线程：</h2><ol>
<li>threading.current_thread：在线程中执行这个函数，会返回当前线程的对象,如上面例子可以给线程取名。</li>
<li>threading.enumerate：获取整个程序中所有的线程。</li>
</ol>
<h2 id="继承自threading-Thread类："><a href="#继承自threading-Thread类：" class="headerlink" title="继承自threading.Thread类："></a>继承自threading.Thread类：</h2><ol>
<li><p>自己写的类继承自<code>threading.Thread</code>类。</p>
</li>
<li><p>线程代码需要放在run方法中执行。</p>
</li>
<li><p>以后创建线程的时候，直接使用我们自己创建的类来创建线程就可以了。</p>
</li>
<li><p>为什么要使用类的方式创建线程呢？原因是因为类可以更加方便的管理我们的代码，可以让我们使用面向对象的方式进行编程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dance</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread_plus</span>():</span></span><br><span class="line">    t1 = Code()</span><br><span class="line">    t2 = Dance()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="全局变量共享的问题："><a href="#全局变量共享的问题：" class="headerlink" title="全局变量共享的问题："></a>全局变量共享的问题：</h2><p>在多线程中，如果需要修改全局变量，那么需要在修改全局变量的地方使用锁锁起来，执行完成后再把锁释放掉。<br>使用锁的原则：</p>
<ol>
<li><strong>把尽量少的和不耗时的代码放到锁中执行。</strong></li>
<li><strong>代码执行完成后要记得释放锁。</strong><br>在Python中，可以使用<code>threading.Lock</code>来创建锁，<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作。</li>
</ol>
<h2 id="生产者和消费者模式："><a href="#生产者和消费者模式：" class="headerlink" title="生产者和消费者模式："></a>生产者和消费者模式：</h2><p>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。通过生产者和消费者模式，可以让代码达到高内聚低耦合的目标，程序分工更加明确，线程更加方便管理。</p>
<h3 id="Lock版本的生产者和消费者模式："><a href="#Lock版本的生产者和消费者模式：" class="headerlink" title="Lock版本的生产者和消费者模式："></a>Lock版本的生产者和消费者模式：</h3><p>通过<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作</p>
<h2 id="Condition版本的生产者和消费者模式："><a href="#Condition版本的生产者和消费者模式：" class="headerlink" title="Condition版本的生产者和消费者模式："></a>Condition版本的生产者和消费者模式：</h2><p>Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下是一些常用的函数：</p>
<ol>
<li>acquire：上锁。</li>
<li>release：解锁。</li>
<li>wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li>
<li>notify：通知某个正在等待的线程，默认是第1个等待的线程。</li>
<li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li>
</ol>
<h2 id="线程安全的队列Queue："><a href="#线程安全的队列Queue：" class="headerlink" title="线程安全的队列Queue："></a>线程安全的队列Queue：</h2><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：<br>初始化Queue(maxsize)：创建一个先进先出的队列。</p>
<ol>
<li>qsize()：返回队列的大小。</li>
<li>empty()：判断队列是否为空。</li>
<li>full()：判断队列是否满了。</li>
<li>get()：从队列中取最后一个数据。默认情况下是阻塞的，也就是说如果队列已经空了，那么再调用就会一直阻塞，直到有新的数据添加进来。也可以使用<code>block=False</code>，来关掉阻塞。如果关掉了阻塞，在队列为空的情况获取就会抛出异常。</li>
<li>put()：将一个数据放到队列中。跟get一样，在队列满了的时候也会一直阻塞，并且也可以通过block=False来关掉阻塞，同样也会抛出异常。</li>
</ol>
<h3 id="实战（下载王者荣耀壁纸）"><a href="#实战（下载王者荣耀壁纸）" class="headerlink" title="实战（下载王者荣耀壁纸）"></a>实战（下载王者荣耀壁纸）</h3><h4 id="版本一-不加线程"><a href="#版本一-不加线程" class="headerlink" title="版本一: 不加线程"></a>版本一: 不加线程</h4><p>壁纸的内容是通过后台数据渲染上去的，这些数据是通过</p>
<p>“workList_inc.cgi?activityId=2735&amp;sVerifyCode=ABCD&amp;…267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1618065287348”</p>
<p>该请求获取的，获取该请求的url，就可以获取json数据，json数据中有图片的地址及其他详细信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据主页获取所有详细照片的内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://pvp.qq.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;....&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将获取到的数据变成json格式，即dict个数</span></span><br><span class="line">    datas = requests.get(url, headers=head).json()</span><br><span class="line">    <span class="keyword">return</span> datas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析json详细照片内容,将照片的真实递增返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        url = parse.unquote(data[<span class="string">&#x27;sProdImgNo_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)])</span><br><span class="line">        url = url.replace(<span class="string">&quot;/200&quot;</span>, <span class="string">&quot;/0&quot;</span>)</span><br><span class="line">        urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=0&amp;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>): <span class="comment"># 获取25页全部内容</span></span><br><span class="line">        page_url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        datas = get_detail(page_url)</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">            urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">            name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">            <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">            dir_name = os.path.join(<span class="string">&#x27;image01&#x27;</span>, name)</span><br><span class="line">            os.mkdir(dir_name)  <span class="comment"># 创建该文件</span></span><br><span class="line">            print(name)</span><br><span class="line">            <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                print(url)</span><br><span class="line">                <span class="comment"># 开始下载</span></span><br><span class="line">                request.urlretrieve(url, os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(index))))</span><br><span class="line">                print(dir_name + <span class="string">&quot;\\&quot;</span> + <span class="built_in">str</span>(index + <span class="number">1</span>) + <span class="string">&quot;保存完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="版本二：-加线程"><a href="#版本二：-加线程" class="headerlink" title="版本二： 加线程"></a>版本二： 加线程</h4><p>get_detail 与 get_data 两个后去数据的方法不变，其他的进行优化</p>
<p>1.把所有page页的url放入page_queen队列中，让多个生产者根据队列中url生产图片的地址，并保存到image_queen队列中；</p>
<p>2.多个消费者根据page_queen队列中的内容消费，即根据对应图片url下载图片</p>
<p>注: 继承threading.Thread类如果要传参数，就需要重写初始化（init） 方法 , 还需调用父类的init方法</p>
<p>super(Product, self).<strong>init</strong>(*args, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产图片地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, page_queen, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Product, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queen = page_queen</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.page_queen.empty():</span><br><span class="line">            datas = get_detail(self.page_queen.get())</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">                name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">                print(name)</span><br><span class="line">                <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">                dir_name = os.path.join(<span class="string">&#x27;image02&#x27;</span>, name)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):  <span class="comment"># 创建该文件</span></span><br><span class="line">                    os.mkdir(dir_name)</span><br><span class="line">                urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">                <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                    image_detail = &#123;<span class="string">&#x27;image_url&#x27;</span>: url,</span><br><span class="line">                                    <span class="string">&#x27;image_path&#x27;</span>: os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(index+<span class="number">1</span>))&#125;</span><br><span class="line">                    self.image_queen.put(image_detail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费图片地址，下载到本地</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                image_detail = self.image_queen.get(timeout=<span class="number">10</span>)  <span class="comment"># 10秒超时就会报错</span></span><br><span class="line">                url = image_detail.get(<span class="string">&#x27;image_url&#x27;</span>)</span><br><span class="line">                path = image_detail.get(<span class="string">&#x27;image_path&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(url, path)</span><br><span class="line">                    print(path + <span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(path + <span class="string">&quot;下载失败&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=&#123;&#125;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    page_queen = queue.Queue(<span class="number">25</span>)  <span class="comment"># 保存基本页的安全队列</span></span><br><span class="line">    image_queen = queue.Queue(<span class="number">1000</span>)  <span class="comment"># 保存图片地址的安全队列</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):  <span class="comment"># 获取25页地址</span></span><br><span class="line">        page_queen.put(base_url.<span class="built_in">format</span>(page))</span><br><span class="line">        print(page_queen.get())</span><br><span class="line">    <span class="comment"># 3个生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        product = Product(page_queen, image_queen, name=<span class="string">&#x27;生产者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        product.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5个消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        consumer = Consumer(image_queen, name=<span class="string">&#x27;消费者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        consumer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/2021/04/07/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><a href="https://imgtu.com/i/cG2ODP"><img src="https://z3.ax1x.com/2021/04/07/cG2ODP.png" alt="cG2ODP.png"></a></p>
<a id="more"></a>

<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：m = 3, n = 7<br>输出：28</p>
<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>
<h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一: 动态规划"></a>方法一: 动态规划</h3><p>对于(0,0)这个点来说，它只能往右走、或者往下走。<br>那么反过来看，哪个点可以到达(2,2)呢？</p>
<p>1.只能是它的上方(1,2)这个点<br>2.或者是它的左方(2,1)这个点</p>
<p><a href="https://imgtu.com/i/cGzbB6"><img src="https://z3.ax1x.com/2021/04/08/cGzbB6.png" alt="cGzbB6.png" style="zoom:50%;" /></a></p>
<p>搞清楚这个关系，动态规划的转移方程就可以很容易写出来了，第一一个二维数组，用来存放途中每一个点的路径数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure>
<p>这里还需要额外处理第一行与第一列，将他们的值只设置成1即可</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">      ints[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 第一列</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          ints[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第一行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          ints[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">              ints[i][j] = ints[i - <span class="number">1</span>][j] + ints[i][j - <span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ints[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>我们在二维数组推导的时发现,  dp(i)(j) 的值来自于 dp(i-1)(j)和 dp(i)(j-1)。<br>也就是只需要上一行的值就可以了，上上一行的并不需要了，所以这里可以用滚动数组的方式优化一下空间。</p>
<p>将原先<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code><br>改为：<br><code>dp[j] = dp[j] + dp[j - 1]</code></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       <span class="comment">// 默认全都填充为 1</span></span><br><span class="line">       Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">              dp[j]=dp[j]+dp[j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>


<h3 id="方法二-递归"><a href="#方法二-递归" class="headerlink" title="方法二: 递归"></a>方法二: 递归</h3><p><a href="https://imgtu.com/i/cGWyO1"><img src="https://z3.ax1x.com/2021/04/07/cGWyO1.png" alt="cGWyO1.png" style="zoom:50%;" /></a></p>
<p>从(0,0)出发，走到(m,n)的所有路径，应该是由两条路线加起来的：</p>
<p>1.从(0,0)为起点，往右的所有路径<br>2.从(0,0)为起点，往下的所有路径<br>把上面的(1)和(2)加起来即为总路径了。<br>所以递归的核心逻辑就是:</p>
<p>result = dfs(i + 1, j) + dfs(i, j + 1)</p>
<p>就是到达边界时，会触发递归终止，然后返回</p>
<p>也就是当<code>i == m - 1</code>时，或者<code>j == n - 1</code>时，递归返回</p>
<p><a href="https://imgtu.com/i/cGWXtS"><img src="https://z3.ax1x.com/2021/04/07/cGWXtS.png" alt="cGWXtS.png" style="zoom:50%;" /></a></p>
<p>有大量的重复调用会导致超时，如起点为<code>(0,0)</code>时，会有大量重复调用。<br>这里用纯递归是不行的，需要加个缓存</p>
<p><a href="https://imgtu.com/i/cGfI4U"><img src="https://z3.ax1x.com/2021/04/07/cGfI4U.png" alt="cGfI4U.png" style="zoom:50%;" /></a></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dfs(<span class="keyword">new</span> HashMap&lt;Pair, Integer&gt;(), <span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归不同路径</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;Pair, Integer&gt; cache, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      Pair p = <span class="keyword">new</span> Pair(i, j);</span><br><span class="line">      <span class="comment">// 如果存在就直接返回，节省时间</span></span><br><span class="line">      <span class="keyword">if</span> (cache.containsKey(p)) &#123;</span><br><span class="line">          <span class="keyword">return</span> cache.get(p);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到了边界就返回</span></span><br><span class="line">      <span class="keyword">if</span> (i == m - <span class="number">1</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 加入缓存，key为当前p，value为向左递归 + 向右的递归值</span></span><br><span class="line">      cache.put(p, dfs(cache, i + <span class="number">1</span>, j, m, n) + dfs(cache, i, j + <span class="number">1</span>, m, n));</span><br><span class="line">      <span class="keyword">return</span> cache.get(p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同路径二"><a href="#不同路径二" class="headerlink" title="不同路径二"></a>不同路径二</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<h3 id="方法一-动态规划-1"><a href="#方法一-动态规划-1" class="headerlink" title="方法一:动态规划"></a>方法一:动态规划</h3><p>在上面的基础上添加条件即可,如果 obstacleGrid(i)(j)== 1 就跳过该点，不添加</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">       ints[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">               <span class="comment">// 只添加可走的值，障碍物默认为0</span></span><br><span class="line">               <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       ints[i][j] = ints[i - <span class="number">1</span>][j] + ints[i][j - <span class="number">1</span>];</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;  <span class="comment">//  第一列,添加上一个的值</span></span><br><span class="line">                       ints[i][j] = ints[i - <span class="number">1</span>][j];</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;  <span class="comment">// 第一行，添加左边的值</span></span><br><span class="line">                       ints[i][j] = ints[i][j - <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回最后一个值</span></span><br><span class="line">       <span class="keyword">return</span> ints[ints.length - <span class="number">1</span>][ints[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>动态爬虫</title>
    <url>/2021/04/10/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="动态网页爬虫的解决方案："><a href="#动态网页爬虫的解决方案：" class="headerlink" title="动态网页爬虫的解决方案："></a>动态网页爬虫的解决方案：</h2><ol>
<li>直接分析ajax调用的接口。然后通过代码请求这个接口。</li>
<li>使用Selenium+chromedriver模拟浏览器行为获取数据。</li>
</ol>
<a id="more"></a>

<h2 id="selenium和chromedriver："><a href="#selenium和chromedriver：" class="headerlink" title="selenium和chromedriver："></a>selenium和chromedriver：</h2><p>基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># chromedriver在本地的地址</span></span><br><span class="line">path = <span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span></span><br><span class="line">driver = webdriver.Chrome(path)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用selenium关闭浏览器："><a href="#使用selenium关闭浏览器：" class="headerlink" title="使用selenium关闭浏览器："></a>使用selenium关闭浏览器：</h3><ol>
<li>driver.close():关闭当前的页面。</li>
<li>driver.quit()：关闭整个浏览器。</li>
</ol>
<h3 id="selenium定位元素："><a href="#selenium定位元素：" class="headerlink" title="selenium定位元素："></a>selenium定位元素：</h3><ol>
<li>find_element_by_id：根据id来查找某个元素。</li>
<li>find_element_by_class_name：根据类名查找元素。</li>
<li>find_element_by_name：根据name属性的值来查找元素。</li>
<li>find_element_by_tag_name：根据标签名来查找元素。</li>
<li>find_element_by_xpath：根据xpath语法来获取元素。</li>
<li>find_element_by_css_selector：根据css选择器选择元素。</li>
<li>find_element_by_link_text: 根据超链接的文本选中元素</li>
</ol>
<p>要注意，find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素，find_element_by_id除外</p>
<h3 id="selenium表单操作："><a href="#selenium表单操作：" class="headerlink" title="selenium表单操作："></a>selenium表单操作：</h3><ol>
<li><p>webelement.send_keys：给输入框填充内容。</p>
</li>
<li><p>webelement.click：点击。</p>
</li>
<li><p>操作select标签：需要首先用<code>from selenium.webdriver.support.ui import Select</code>来包装一下选中的对象，才能进行<code>select</code>选择：</p>
<ul>
<li>select_by_index：按索引进行选择。</li>
<li>select_by_value：按值进行选择。</li>
<li>select_by_visible_text：按照可见文本进行选择。</li>
</ul>
<h5 id="登入知乎小案例"><a href="#登入知乎小案例" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line">login = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">login.click()</span><br><span class="line">username = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">username.send_keys(<span class="string">&#x27;17379621235&#x27;</span>)</span><br><span class="line">password.send_keys(<span class="string">&#x27;12313&#x27;</span>)</span><br><span class="line">do_login = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line">do_login.click()</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="selenium行为链："><a href="#selenium行为链：" class="headerlink" title="selenium行为链："></a>selenium行为链：</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类selenium.webdriver.common.action_chains.ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。</p>
<h4 id="登入知乎小案例-1"><a href="#登入知乎小案例-1" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line"><span class="comment"># 激活行为链</span></span><br><span class="line">chains = ActionChains(driver)</span><br><span class="line"><span class="comment"># 移动到密码登入，再单击,进入到密码登入</span></span><br><span class="line">loginTag = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">chains.move_to_element(loginTag)</span><br><span class="line">chains.click()</span><br><span class="line">chains.perform()</span><br><span class="line">usernameTag = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">passwordTag = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">doLoginTag = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line"><span class="comment"># 移动到用户名表单，再输入</span></span><br><span class="line">chains.move_to_element(usernameTag)</span><br><span class="line">chains.send_keys_to_element(usernameTag,<span class="string">&quot;17379621235&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到密码表单，再输入</span></span><br><span class="line">chains.move_to_element(passwordTag)</span><br><span class="line">chains.send_keys_to_element(passwordTag,<span class="string">&quot;xxxxxxxx&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到登入按钮，再单击</span></span><br><span class="line">chains.move_to_element(doLoginTag)</span><br><span class="line">chains.click()</span><br><span class="line"><span class="comment"># 执行上面操作</span></span><br><span class="line">chains.perform()</span><br></pre></td></tr></table></figure>
<p>还有更多的鼠标相关的操作。<br>click_and_hold(element)：点击但不松开鼠标。<br>context_click(element)：右键点击。<br>double_click(element)：双击。 </p>
<p>更多方法请参考：<a href="http://selenium-python.readthedocs.io/api.html">http://selenium-python.readthedocs.io/api.html</a></p>
<p><strong>为什么需要行为链条？</strong><br>因为有些网站可能会在浏览器端做一些验证行为是否符合人类的行为来做反爬虫。这时候我们就可以使用行为链来模拟人的操作。行为链有更多的复杂操作，比如双击，右键等，在自动化测试中非常有用。</p>
<h3 id="操作cookie："><a href="#操作cookie：" class="headerlink" title="操作cookie："></a>操作cookie：</h3><ol>
<li><p>获取所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure></li>
<li><p>根据cookie的key获取value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>删除所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure></li>
<li><p>删除某个cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>添加cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.add_cookie(&#123;“name”:”username”,”value”:”abc”&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="隐式等待和显式等待："><a href="#隐式等待和显式等待：" class="headerlink" title="隐式等待和显式等待："></a>隐式等待和显式等待：</h3></li>
<li><p>隐式等待：指定一个时间，在这个时间内一直会处于等待状态。隐式等待需要使用<code>driver.implicitly_wait</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"><span class="comment"># 隐式等待</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># 等待10秒</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;ksdjflksd&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>显式等待：指定在某个时间内，如果某个条件满足了，那么就不会再等待，如果在指定的时间内条件都不满足，那么就不会再等待了。显式等待用的方法是<code>from selenium.webdriver.support.ui import WebDriverWait</code>。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait  <span class="comment"># 显示等待</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC  <span class="comment"># 条件</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示等待(12306小案例)</span></span><br><span class="line">driver.get(<span class="string">&quot;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&quot;</span>)</span><br><span class="line"><span class="comment"># 满足以下两个条件或则等待10秒再向下执行</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">   	</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;fromStationText&#x27;</span>), <span class="string">&#x27;长沙&#x27;</span>),</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;toStationText&#x27;</span>), <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">print(<span class="string">&quot;skdjflfhgjklksdjflk&quot;</span>)</span><br><span class="line">search = driver.find_element_by_id(<span class="string">&#x27;query_ticket&#x27;</span>)</span><br><span class="line">search.click()</span><br></pre></td></tr></table></figure>
<h3 id="打开新窗口和切换页面："><a href="#打开新窗口和切换页面：" class="headerlink" title="打开新窗口和切换页面："></a>打开新窗口和切换页面：</h3></li>
<li><p>selenium中没有专门的打开新窗口的方法，是通过<code>window.execute_script()</code>来执行<code>js</code>脚本的形式来打开新窗口的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.execute_script(<span class="string">&quot;window.open(&#x27;https://www.douban.com/&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>打开新的窗口后<code>driver</code>当前的页面依然还是之前的，如果想要获取新的窗口的源代码，那么就必须先切换过去。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.switch_to.window(driver.window_handlers[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3></li>
</ol>
<p>设置代理通过<code>ChromeOptions</code>来设置，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://110.52.235.176:9999&quot;</span>)</span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&quot;D:\ProgramApp\chromedriver\chromedriver73.exe&quot;</span>,chrome_options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;http://httpbin.org/ip&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li>webelement.get_property：获取html标签中官方写好的属性。</li>
<li>webelement.get_attribute：获取html标签中官方和非官方的属性。</li>
<li>driver.save_screenshoot（”curr.png”）：获取当前页面的截图，有时候请求失败了，那么可以把当前网页的截图保存下来，方便后期进行分析。</li>
<li>print(driver.page_source) ： 获取网页源代码</li>
</ol>
<h3 id="12306抢票实战"><a href="#12306抢票实战" class="headerlink" title="12306抢票实战"></a>12306抢票实战</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9：商务座 ，M：一等座，O：二等座，3：硬卧，4：软卧，1：硬座 ....</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    login_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/resources/login.html&#x27;</span></span><br><span class="line">    person_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/view/index.html&#x27;</span></span><br><span class="line">    select_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&#x27;</span></span><br><span class="line">    sure_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/confirmPassenger/initDc&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trains:&#123;&quot;G67&quot;: [&#x27;M&#x27;, &#x27;O&#x27;],&quot;G533&quot;: [&#x27;9&#x27;, &#x27;M&#x27;, &#x27;O&#x27;]&#125;   表示可以接受的列车与座位</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, from_station, to_station, date, trains, users</span>):</span></span><br><span class="line">        self.from_station = from_station</span><br><span class="line">        self.to_station = to_station</span><br><span class="line">        self.date = date</span><br><span class="line">        self.trains = trains</span><br><span class="line">        self.users = users</span><br><span class="line">        self.station_code = &#123;&#125;</span><br><span class="line">        self.initCode()</span><br><span class="line">        self.train_number = <span class="literal">None</span></span><br><span class="line">        self.train_place = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据地名获取该地名相关代号,文件内容在stations.csv中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initCode</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stations.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.DictReader(f)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">                name = line.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                code = line.get(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">                self.station_code[name] = code</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.login_url)</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.person_url)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选票</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.select_url)</span><br><span class="line">        <span class="comment"># 关闭提示弹框</span></span><br><span class="line">        sure = driver.find_element_by_id(<span class="string">&quot;qd_closeDefaultWarningWindowDialog_id&quot;</span>)</span><br><span class="line">        sure.click()</span><br><span class="line">        <span class="comment"># 起始地 , 通过js脚本给隐藏的input标签赋值</span></span><br><span class="line">        from_input = driver.find_element_by_id(<span class="string">&quot;fromStation&quot;</span>)</span><br><span class="line">        from_code = self.station_code[self.from_station]  <span class="comment"># &#x27;BOP&#x27;, &#x27;北京&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % from_code, from_input)</span><br><span class="line">        <span class="comment"># 目的地</span></span><br><span class="line">        to_input = driver.find_element_by_id(<span class="string">&quot;toStation&quot;</span>)</span><br><span class="line">        to_code = self.station_code[self.to_station]  <span class="comment"># &#x27;长沙&#x27;: &#x27;CSQ&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % to_code, to_input)</span><br><span class="line">        <span class="comment"># 时间</span></span><br><span class="line">        date_input = driver.find_element_by_id(<span class="string">&quot;train_date&quot;</span>)</span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % self.date, date_input)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        search = driver.find_element_by_id(<span class="string">&quot;query_ticket&quot;</span>)</span><br><span class="line">        search.click()</span><br><span class="line">        <span class="comment"># 等待加载完毕，再预定合适的票</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 获取所有列车信息，并遍历</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 一直循环查询，直到选中票</span></span><br><span class="line">            trains = driver.find_elements_by_xpath(<span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr[not(@datatran)]&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> train <span class="keyword">in</span> trains:</span><br><span class="line">                train_list = train.text.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                print(train_list)</span><br><span class="line">                number = train_list[<span class="number">0</span>]  <span class="comment"># 车次</span></span><br><span class="line">                <span class="comment"># 如果当前列车是自己可以接受的列车，就进行选座位</span></span><br><span class="line">                <span class="keyword">if</span> number <span class="keyword">in</span> self.trains:</span><br><span class="line">                    is_selected = <span class="literal">False</span>  <span class="comment"># 标记是否选中了座位</span></span><br><span class="line">                    select_place = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 标记选中的座位</span></span><br><span class="line">                    places = self.trains[number]  <span class="comment"># 获取该车次可以接受的座位</span></span><br><span class="line">                    <span class="keyword">for</span> place <span class="keyword">in</span> places:</span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;9&quot;</span>:  <span class="comment"># 商务坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">7</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">7</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;M&quot;</span>:  <span class="comment"># 一等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">8</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">8</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;M&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;O&quot;</span>:  <span class="comment"># 二等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">9</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">9</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                    <span class="comment"># 如果选中了座位，就结束循环，并预定</span></span><br><span class="line">                    <span class="keyword">if</span> is_selected:</span><br><span class="line">                        pre = train.find_element_by_xpath(<span class="string">&quot;.//a[@class=&#x27;btn72&#x27;]&quot;</span>)</span><br><span class="line">                        pre.click()</span><br><span class="line">                        self.train_number = number</span><br><span class="line">                        self.train_place = select_place</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确认乘客与座位，正式预定</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sure_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.sure_url)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 选中乘车人</span></span><br><span class="line">        users = driver.find_elements_by_xpath(<span class="string">&quot;//ul[@id=&#x27;normal_passenger_id&#x27;]/li/label&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">            <span class="keyword">if</span> user.text <span class="keyword">in</span> self.users:</span><br><span class="line">                user.click()</span><br><span class="line">        <span class="comment"># 选中座位类型</span></span><br><span class="line">        place_select = Select(driver.find_element_by_id(<span class="string">&quot;seatType_1&quot;</span>))</span><br><span class="line">        place_select.select_by_value(self.train_place)</span><br><span class="line">        <span class="comment"># 提交订单</span></span><br><span class="line">        sure_btn = driver.find_element_by_id(<span class="string">&quot;submitOrder_id&quot;</span>)</span><br><span class="line">        sure_btn.click()</span><br><span class="line">        <span class="comment"># 等待加载核对信息对话框,与确定按钮</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//div[@id=&#x27;content_checkticketinfo_id&#x27;]&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">&quot;qr_submit_id&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 单击确定按钮，正式生产订单,这里确定按钮不生效，一直循环暴力点击确定按钮，直到获取不到该按钮</span></span><br><span class="line">        sure_btn_final = driver.find_element_by_id(<span class="string">&quot;qr_submit_id&quot;</span>)</span><br><span class="line">        sure_btn_final.click()</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     try:</span></span><br><span class="line">        <span class="comment">#         sure_btn_final.click()</span></span><br><span class="line">        <span class="comment">#         # sure_btn_final = driver.find_element_by_id(&quot;qr_submit_id&quot;)</span></span><br><span class="line">        <span class="comment">#         sure_btn_final = driver.find_element_by_id(&quot;back_edit_id&quot;)</span></span><br><span class="line">        <span class="comment">#     except ElementNotInteractableException:</span></span><br><span class="line">        <span class="comment">#         print(&quot;抢票成功,车次:&quot; + self.train_number + &quot;,席位:&quot; + self.train_place)</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行该代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.select_ticket()</span><br><span class="line">        self.sure_ticket()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    spider = Spider(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;长沙&quot;</span>, <span class="string">&quot;2021-04-17&quot;</span>, &#123;<span class="string">&quot;K21&quot;</span>: [<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], <span class="string">&quot;G529&quot;</span>: [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]&#125;, [<span class="string">&#x27;李昭辉&#x27;</span>])</span><br><span class="line">    spider.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















































]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Selenium</tag>
        <tag>chromedriver</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬虫</title>
    <url>/2021/04/12/%E5%8F%8D%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h3 id="图片验证码识别"><a href="#图片验证码识别" class="headerlink" title="图片验证码识别"></a>图片验证码识别</h3><p>平台</p>
<p>1.云打码     2.斐斐打码 <a id="more"></a></p>
<p>这里主要介绍斐斐打码</p>
<p>官网 <a href="http://www.fateadm.com/login.html%E4%B8%AD%E6%89%BE%E5%88%B0python3">http://www.fateadm.com/login.html中找到python3</a> demo的下载链接</p>
<p><a href="http://www.fateadm.com/download/demo/python3.zip">http://www.fateadm.com/download/demo/python3.zip</a></p>
<p>下载该文件</p>
<p>该文件的使用案例在TestFunc方法中，可以复制该方法，模仿着写，并识别验证码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fateadm_api <span class="keyword">import</span> FateadmApi</span><br><span class="line"></span><br><span class="line">pd_id = <span class="string">&quot;129281&quot;</span>  <span class="comment"># 用户中心页可以查询到pd信息</span></span><br><span class="line">pd_key = <span class="string">&quot;GmNxNIU5XL4N+A49UFNtC7G0nsn456yQ&quot;</span></span><br><span class="line">app_id = <span class="string">&quot;329281&quot;</span>  <span class="comment"># 开发者分成用的账号，在开发者中心可以查询到</span></span><br><span class="line">app_key = <span class="string">&quot;Cawup44zVSJTGukiJaT3MysZs4ITe3xQ&quot;</span></span><br><span class="line">api = FateadmApi(app_id, app_key, pd_id, pd_key)</span><br><span class="line"><span class="comment"># 识别类型，</span></span><br><span class="line">pred_type = <span class="string">&quot;20500&quot;</span></span><br><span class="line"><span class="comment"># 通过文件形式识别：</span></span><br><span class="line">file_name = <span class="string">&quot;img.png&quot;</span></span><br><span class="line">res = api.PredictFromFileExtend(pred_type, file_name)</span><br><span class="line">print(<span class="string">&quot;识别后的内容为:&quot;</span>+res)</span><br></pre></td></tr></table></figure>
<h3 id="字体识别"><a href="#字体识别" class="headerlink" title="字体识别"></a>字体识别</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.网页开发者自己创造一种字体，因为在字体中每个文字都有其代号，那么以后在网页中不会 直接显示这个文字的最终的效果，而是显示他的代号，因此即使获取到了网页中的文本内 容，也只是获取到文字的代号，而不是文字本身。 </p>
<p>2.因为创造字体费时费力，并且如果把中国3000多常用汉字都实现，那么这个字体将达到几十 兆，也会影响网页的加载。一般情况下为了反爬虫，仅会针对0-9以及少数汉字进行自己单独 创建，其他的还是使用用户系统中自带的字体。</p>
<h4 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h4><p>1.一般情况下为了考虑网页渲染性能，通常网页开发者会把字体编码成base64的方式，因此我 们可以到网页中找到@font-face属性，然后获取里面的base64代码，再用Python代码进行 解码，然后再保存本地。</p>
<p>2.如果没有使用base64，还有另外一种方式，就是直接把字体文件放到服务器上，然后前端通 过@font-face中的url函数进行加载。</p>
<h4 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h4><p>1.分析字体需要将字体转换成xml文件，然后查看其中的cmap和glyf中的属性。其中cmap存储 的是code和name的映射，而glyf下存储的是每个name下的字体绘制规则。 </p>
<p>2.从第1步中我们知道了name对应的字体的绘制规则，但是还是不知道字体是长什么样子，那 么可以通过一款叫做FontCreator的软件来打开.tff的字体文件，这样就可以看到每个name对 应的字体最终的呈现效果。</p>
<p>3.在网页中，直接显示的是字体的code，而不是name。并且网页开发者为了增加爬虫的难 度，有可能在多次请求之间</p>
<p>code-&gt;name-&gt;最终字体的映射    会发生改变。但是最终字体的形 状是不会改变的，因此我们可以通过形状对比来进行判断。</p>
<p>4.我们可以通过分析字体，得出每个字体形状对应的文字，然后保存到一个字典中。以后再请 求网页的时候，就进行反向解析，先获取字体的形状，再通过字体形状反向获取代号所对应 的具体文字内容</p>
<p><a href="https://imgtu.com/i/cD7ZDA"><img src="https://z3.ax1x.com/2021/04/12/cD7ZDA.png" alt="cD7ZDA.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实习僧小案例 ，只爬取一个详情页的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================获取xml文件和ttf文件，先分析name与形状之间的关系，保存到base_font_map中=============================</span></span><br><span class="line"><span class="comment"># 保存font-face</span></span><br><span class="line">font_face = <span class="string">&#x27;。。。&#x27;</span></span><br><span class="line">binary = base64.b64decode(font_face)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 ttf 文件，以便后面的分析</span></span><br><span class="line"><span class="comment"># with open(&quot;实习僧.ttf&quot;, &#x27;wb&#x27;) as fb:</span></span><br><span class="line"><span class="comment">#     fb.write(binary)</span></span><br><span class="line">base_font = TTFont(<span class="string">&quot;实习僧.ttf&quot;</span>)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 xml 文件，以便后面的分析保存为xml文件</span></span><br><span class="line"><span class="comment"># base_font.saveXML(&quot;实习僧.xml&quot;)</span></span><br><span class="line"><span class="comment"># 获取形状映射关系</span></span><br><span class="line">glyf = base_font[<span class="string">&#x27;glyf&#x27;</span>]</span><br><span class="line"><span class="comment"># 存放正确字体与形状</span></span><br><span class="line">shape_name_map = &#123;</span><br><span class="line">    <span class="number">0</span>: glyf[<span class="string">&quot;uni30&quot;</span>],</span><br><span class="line">    <span class="number">1</span>: glyf[<span class="string">&quot;uni31&quot;</span>],</span><br><span class="line">    <span class="number">2</span>: glyf[<span class="string">&quot;uni32&quot;</span>],</span><br><span class="line">    <span class="number">3</span>: glyf[<span class="string">&quot;uni33&quot;</span>],</span><br><span class="line">    <span class="number">4</span>: glyf[<span class="string">&quot;uni34&quot;</span>],</span><br><span class="line">    <span class="number">5</span>: glyf[<span class="string">&quot;uni35&quot;</span>],</span><br><span class="line">    <span class="number">6</span>: glyf[<span class="string">&quot;uni36&quot;</span>],</span><br><span class="line">    <span class="number">7</span>: glyf[<span class="string">&quot;uni37&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">9</span>: glyf[<span class="string">&quot;uni39&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================开始爬取网页，目的:将网页的源代码中乱的字体替换成正确字体:=================================</span></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">text = requests.get(<span class="string">&quot;https://m.shixiseng.com/intern/inn_sxjh0abyyqxf&quot;</span>, headers=head).text</span><br><span class="line"><span class="comment"># 获取font-face</span></span><br><span class="line">fontFace = re.search(<span class="string">r&#x27;font-family:myFont; src: url\(&quot;data:application/octet-stream;base64,(.+?)&quot;\)&#x27;</span>, text).group(<span class="number">1</span>)</span><br><span class="line">b = base64.b64decode(fontFace)</span><br><span class="line"><span class="comment"># 这里直接放入到管道内，不动用磁盘空间</span></span><br><span class="line">baseFont = TTFont(io.BytesIO(b))</span><br><span class="line">shapes = baseFont[<span class="string">&#x27;glyf&#x27;</span>]  <span class="comment"># 所有形状</span></span><br><span class="line">cmap = baseFont.getBestCmap()  <span class="comment"># code 与 name 的映射</span></span><br><span class="line"><span class="keyword">for</span> code, name <span class="keyword">in</span> cmap.items():  <span class="comment"># code == 0xe06e</span></span><br><span class="line">    <span class="comment"># 通过名字获取形状</span></span><br><span class="line">    shape = shapes[name]</span><br><span class="line">    <span class="comment"># 遍历之前获取的shape_name_map，如果形状相等，就将code替换成正确的字体 k</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> shape_name_map.items():</span><br><span class="line">        <span class="keyword">if</span> shape == v:</span><br><span class="line">            code = <span class="built_in">hex</span>(code)  <span class="comment"># 先把code替换成16进制  57454 ==》 0xe06e</span></span><br><span class="line">            <span class="comment"># 把code替换成网页的code形式  0xe06e ==》 &amp;#xe06e</span></span><br><span class="line">            webCode = <span class="built_in">str</span>(code).replace(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;&amp;#&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 把网页的code替换成正确的字体</span></span><br><span class="line">            text = re.sub(webCode, <span class="built_in">str</span>(k),text)</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>图片验证码识别</tag>
        <tag>字体识别</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架</title>
    <url>/2021/04/16/scrapy%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Scrapy框架："><a href="#Scrapy框架：" class="headerlink" title="Scrapy框架："></a>Scrapy框架：</h2><p>写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此Scrapy把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用Scrapy框架来解决。</p>
<a id="more"></a>

<h3 id="安装Scrapy框架："><a href="#安装Scrapy框架：" class="headerlink" title="安装Scrapy框架："></a>安装Scrapy框架：</h3><ol>
<li>pip install scrapy</li>
</ol>
<h3 id="Scrapy框架架构："><a href="#Scrapy框架架构：" class="headerlink" title="Scrapy框架架构："></a>Scrapy框架架构：</h3><ol>
<li><p>Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。</p>
</li>
<li><p>Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是需要的，都是由程序员自己决定。</p>
</li>
<li><p>Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。</p>
</li>
<li><p>Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。</p>
</li>
<li><p>Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。</p>
</li>
<li><p>Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。</p>
</li>
<li><p>Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。</p>
<p><a href="https://imgtu.com/i/cRzQ1S"><img src="https://z3.ax1x.com/2021/04/16/cRzQ1S.png" alt="cRzQ1S.png" style="zoom:50%;" /></a></p>
</li>
</ol>
<h3 id="创建Scrapy项目："><a href="#创建Scrapy项目：" class="headerlink" title="创建Scrapy项目："></a>创建Scrapy项目：</h3><ol>
<li>创建项目：<code>scrapy startproject [项目名称]</code>.</li>
<li>创建爬虫：<code>cd到项目中-&gt;scrapy genspider [爬虫名称] [域名]</code>.</li>
</ol>
<h3 id="项目文件作用："><a href="#项目文件作用：" class="headerlink" title="项目文件作用："></a>项目文件作用：</h3><ol>
<li><code>settings.py</code>：用来配置爬虫的。</li>
<li><code>middlewares.py</code>：用来定义中间件。</li>
<li><code>items.py</code>：用来提前定义好需要下载的数据字段。</li>
<li><code>pipelines.py</code>：用来保存数据。</li>
<li><code>scrapy.cfg</code>：用来配置项目的。</li>
</ol>
<h3 id="CrawlSpider爬虫："><a href="#CrawlSpider爬虫：" class="headerlink" title="CrawlSpider爬虫："></a>CrawlSpider爬虫：</h3><ol>
<li>作用：可以定义规则，让Scrapy自动的去爬取我们想要的链接。而不必跟Spider类一样，手动的yield Request。</li>
<li>创建：scrapy genspider -t crawl [爬虫名] [域名]</li>
<li>提取的两个类：<ul>
<li>LinkExtrator：用来定义需要爬取的url规则。</li>
<li>Rule：用来定义这个url爬取后的处理方式，比如是否需要跟进，是否需要执行回调函数等。</li>
</ul>
</li>
</ol>
<h3 id="Scrapy-Shell："><a href="#Scrapy-Shell：" class="headerlink" title="Scrapy Shell："></a>Scrapy Shell：</h3><p>在命令行中，进入到项目所在的路径。然后：<br><code>scrapy shell 链接</code><br>在这个里面，可以先去写提取的规则，没有问题后，就可以把代码拷贝到项目中。方便写代码。</p>
<h3 id="使用twisted异步保存mysql数据：（猎云网案例）"><a href="#使用twisted异步保存mysql数据：（猎云网案例）" class="headerlink" title="使用twisted异步保存mysql数据：（猎云网案例）"></a>使用twisted异步保存mysql数据：（猎云网案例）</h3><p>在Lspider中获取网页信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> LieyunItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunSpiderSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;lieyun_spider&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;lieyunwang.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://lieyunwang.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/latest/p\d+\.html&#x27;</span>), follow=<span class="literal">True</span>),</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/archives/\d+&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">False</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        title_list = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/text()&quot;</span>).getall()</span><br><span class="line">        title = <span class="string">&quot;&quot;</span>.join(title_list).strip()</span><br><span class="line">        pub_time = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/span/text()&quot;</span>).get()</span><br><span class="line">        author = response.xpath(<span class="string">&quot;//a[contains(@class,&#x27;author-name&#x27;)]/text()&quot;</span>).get()</span><br><span class="line">        context = response.xpath(<span class="string">&quot;//div[@id=&#x27;main-text-id&#x27;]&quot;</span>).getall()</span><br><span class="line">        item = LieyunItem(title=title, pub_time=pub_time, author=author, context=context, detail_url=response.url)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>在pipeline中，使用twisted.enterprise.adbapi来创建一个连接对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunPipeline</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,mysql_config</span>):</span></span><br><span class="line">    self.dbpool = adbapi.ConnectionPool(</span><br><span class="line">        mysql_config[<span class="string">&#x27;DRIVER&#x27;</span>],</span><br><span class="line">        host=mysql_config[<span class="string">&#x27;HOST&#x27;</span>],</span><br><span class="line">        port=mysql_config[<span class="string">&#x27;PORT&#x27;</span>],</span><br><span class="line">        user=mysql_config[<span class="string">&#x27;USER&#x27;</span>],</span><br><span class="line">        password=mysql_config[<span class="string">&#x27;PASSWORD&#x27;</span>],</span><br><span class="line">        db=mysql_config[<span class="string">&#x27;DATABASE&#x27;</span>],</span><br><span class="line">        charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 重写该方法,获取配置文件中的MYSQL_CONFIG信息，再调用构造器</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">    mysql_config = crawler.settings[<span class="string">&#x27;MYSQL_CONFIG&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> cls(mysql_config)</span><br></pre></td></tr></table></figure>
<p>在插入数据的函数中，使用<code>runInteraction</code>来运行真正执行sql语句的函数。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">      <span class="comment"># 执行插入操作</span></span><br><span class="line">      result = self.dbpool.runInteraction(self.item_insert, item)</span><br><span class="line">      <span class="comment"># 失败调用</span></span><br><span class="line">      result.addErrback(self.insert_error)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 插入数据，通过游标cursor插入item中的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">item_insert</span>(<span class="params">self, cursor, item</span>):</span></span><br><span class="line">      sql = <span class="string">&quot;insert into lieyun values(null,%s,%s,%s,%s,%s)&quot;</span></span><br><span class="line">      args = (item[<span class="string">&#x27;title&#x27;</span>], item[<span class="string">&#x27;author&#x27;</span>], item[<span class="string">&#x27;detail_url&#x27;</span>], item[<span class="string">&#x27;pub_time&#x27;</span>], item[<span class="string">&#x27;context&#x27;</span>])</span><br><span class="line">      cursor.execute(sql, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出报错信息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_error</span>(<span class="params">self,fail</span>):</span></span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line">      print(fail)</span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Scrapy下载图片："><a href="#Scrapy下载图片：" class="headerlink" title="Scrapy下载图片："></a>Scrapy下载图片：</h3><ol>
<li>根据网页解析图片的链接。</li>
<li>定义一个item，上面有一定要有两个字段，一个是image_urls，一个是images。其中image_urls是用来存储图片的链接，由开发者把数据爬取下来后添加的，images时存放相关信息的，我们不需要管他</li>
<li>使用scrapy.pipelines.images.ImagesPipeline来作为数据保存的pipeline。</li>
<li>在settings.py中设置IMAGES_SOTRE来定义图片下载的路径。</li>
</ol>
<h4 id="在settings-py这样定义"><a href="#在settings-py这样定义" class="headerlink" title="在settings.py这样定义"></a>在settings.py这样定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="comment"># &#x27;zcool.pipelines.ZcoolPipeline&#x27;: 300,</span></span><br><span class="line">    <span class="comment"># 不用自己的pipeline，用scrapy自带的图片pipeline</span></span><br><span class="line">    <span class="string">&#x27;scrapy.pipelines.images.ImagesPipeline&#x27;</span>: <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 图片保存路径</span></span><br><span class="line">IMAGES_STORE = os.path.join(os.path.dirname(os.path.dirname(__file__)), <span class="string">&#x27;images&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果上面这样写的换，图片路径全在images/full中</p>
<p>如果想要有更复杂的图片保存的路径需求，可以在pipeline中重写ImagePipeline的file_path方法，这个方法用来返回每个图片的保存路径。而<code>file_path</code>方法没有<code>item</code>对象，所以我们还需要重写<code>get_media_requests</code>方法，来把<code>item</code>绑定到<code>request</code>上。注:settings.py中要改回自定义的pipeline</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> zcool <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZcoolPipeline</span>(<span class="params">ImagesPipeline</span>):</span></span><br><span class="line">    <span class="comment"># 将item数据挂载到request中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span>(<span class="params">self, item, info</span>):</span></span><br><span class="line">        requests = <span class="built_in">super</span>(ZcoolPipeline, self).get_media_requests(item, info)</span><br><span class="line">        <span class="keyword">for</span> request <span class="keyword">in</span> requests:</span><br><span class="line">            request.item = item</span><br><span class="line">        <span class="keyword">return</span> requests</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 获取原来的图片路径</span></span><br><span class="line">        origin_path = <span class="built_in">super</span>(ZcoolPipeline, self).file_path(request, response, info)</span><br><span class="line">        <span class="comment"># 获取标题，并将不合法字符删除</span></span><br><span class="line">        title = request.item[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        title = re.sub(<span class="string">r&#x27;\\/:\*\?\|&lt;&gt;&quot;&#x27;</span>, title)</span><br><span class="line">        <span class="comment"># 根据图片的标题创建文件夹</span></span><br><span class="line">        dir_path = os.path.join(settings.IMAGES_STORE, title)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_path):</span><br><span class="line">            os.mkdir(dir_path)</span><br><span class="line"></span><br><span class="line">        curr_path = origin_path.replace(<span class="string">&quot;/full&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> os.path.join(dir_path,curr_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="下载器中间件："><a href="#下载器中间件：" class="headerlink" title="下载器中间件："></a>下载器中间件：</h2><p>下载器中间件是引擎和下载器之间通信的中间件。在这个中间件中我们可以设置代理、更换请求头等来达到反反爬虫的目的。要写下载器中间件，可以在下载器中实现两个方法。</p>
<ol>
<li>process_request(self,request,spider)：  请求发送之前会执行</li>
<li>process_response(self,request,response,spider)：数据下载到引擎之前执行</li>
</ol>
<p><a href="https://imgtu.com/i/cRzl6g"><img src="https://z3.ax1x.com/2021/04/16/cRzl6g.png" alt="cRzl6g.png" style="zoom:50%;" /></a></p>
<h3 id="Scrapy中更换请求头：使用fake-useragent-动态更换"><a href="#Scrapy中更换请求头：使用fake-useragent-动态更换" class="headerlink" title="Scrapy中更换请求头：使用fake_useragent 动态更换"></a>Scrapy中更换请求头：使用fake_useragent 动态更换</h3><p>pip install fake_useragent</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 自定义跟换请求头中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        <span class="comment"># 更换请求头</span></span><br><span class="line">        request.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = ua.random</span><br></pre></td></tr></table></figure>
<h3 id="Scrapy中设置代理："><a href="#Scrapy中设置代理：" class="headerlink" title="Scrapy中设置代理："></a>Scrapy中设置代理：</h3><ol>
<li><p>设置普通代理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义更换代理中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    proxies = &#123;<span class="string">&quot;code&quot;</span>: <span class="number">0</span>, <span class="string">&quot;data&quot;</span>: [&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;36.6.146.163&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4225</span>&#125;, &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;119.54.15.185&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4258</span>&#125;],<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;success&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        <span class="comment"># 任意选中一个代理对象</span></span><br><span class="line">        proxy = random.choice(self.proxies[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">        <span class="comment"># 更换代理</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = <span class="string">&#x27;http://&#x27;</span> + proxy[<span class="string">&#x27;ip&#x27;</span>]+<span class="string">&quot;:&quot;</span>+<span class="built_in">str</span>(proxy[<span class="string">&#x27;port&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>设置独享代理：需要提供密钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPProxyDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request,spider</span>):</span></span><br><span class="line">        proxy = <span class="string">&#x27;121.199.6.124:16816&#x27;</span></span><br><span class="line">        user_password = <span class="string">&quot;970138074:rcdj35xx&quot;</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = proxy</span><br><span class="line">        <span class="comment"># bytes</span></span><br><span class="line">        b64_user_password = base64.b64encode(user_password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        request.headers[<span class="string">&#x27;Proxy-Authorization&#x27;</span>] = <span class="string">&#x27;Basic &#x27;</span> + b64_user_password.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>代理服务商：</p>
<ul>
<li>芝麻代理：<a href="http://http.zhimaruanjian.com/">http://http.zhimaruanjian.com/</a></li>
<li>太阳代理：<a href="http://http.taiyangruanjian.com/">http://http.taiyangruanjian.com/</a></li>
<li>快代理：<a href="http://www.kuaidaili.com/">http://www.kuaidaili.com/</a></li>
<li>讯代理：<a href="http://www.xdaili.cn/">http://www.xdaili.cn/</a></li>
<li>蚂蚁代理：<a href="http://www.mayidaili.com/">http://www.mayidaili.com/</a></li>
<li>极光代理：<a href="http://www.jiguangdaili.com/">http://www.jiguangdaili.com/</a></li>
</ul>
</li>
</ol>
<h3 id="猎聘网动态更换ip代理案例"><a href="#猎聘网动态更换ip代理案例" class="headerlink" title="猎聘网动态更换ip代理案例"></a>猎聘网动态更换ip代理案例</h3><h4 id="定义一个模型，根据代理ip的json数据，解析里面的代理ip"><a href="#定义一个模型，根据代理ip的json数据，解析里面的代理ip" class="headerlink" title="定义一个模型，根据代理ip的json数据，解析里面的代理ip"></a>定义一个模型，根据代理ip的json数据，解析里面的代理ip</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, proxy_dict</span>):</span></span><br><span class="line">        proxy_data = proxy_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        self.proxy_url = <span class="string">&quot;https://&quot;</span> + proxy_data[<span class="string">&#x27;ip&#x27;</span>] + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(proxy_data[<span class="string">&#x27;port&#x27;</span>])</span><br><span class="line">        self.expire_time = datetime.datetime.strptime(proxy_data[<span class="string">&#x27;expire_time&#x27;</span>], <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        self.is_backed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 时间是否过去</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_expire</span>(<span class="params">self</span>):</span></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        <span class="comment"># 如果超时或还剩5秒就返回True</span></span><br><span class="line">        <span class="keyword">if</span> (self.expire_time - now) &lt; datetime.timedelta(seconds=<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在中间件中定义代理ip的动态更换"><a href="#在中间件中定义代理ip的动态更换" class="headerlink" title="在中间件中定义代理ip的动态更换"></a>在中间件中定义代理ip的动态更换</h4><p>process_request : 更换 ip </p>
<p>process_response: 判断返回的网页是否有问题，如果有就标记  is_backed 为True，表示当前ip加入了黑名单</p>
<p>update_proxy：调用模型更新代理ip，将ip信息赋给 self.proxy_model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> proxy_model <span class="keyword">import</span> model</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiepinDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LiepinDownloaderMiddleware, self).__init__()</span><br><span class="line">        <span class="comment"># 存放代理ip的相关数据</span></span><br><span class="line">        self.proxy_model = <span class="literal">None</span></span><br><span class="line">        self.proxy_url = <span class="string">&#x27;通过代理服务商获取ip地址&#x27;</span></span><br><span class="line">        self.head = &#123; 。。。 &#125;</span><br><span class="line">        self.update_proxy()  <span class="comment"># 一开始就用代理ip</span></span><br><span class="line">        self.lock = threading.Lock() <span class="comment"># 锁</span></span><br><span class="line">        <span class="comment"># 另外开启一条线程管理ip代理</span></span><br><span class="line">        threading.Thread(target=self.update_proxy_in_thread).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = self.proxy_model.proxy_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response, spider</span>):</span></span><br><span class="line">        <span class="comment"># 如果状态码步数200，说明该代理ip加入黑名单了，需要标记一下,并直接返回request对象，下次继续加载该请求</span></span><br><span class="line">        <span class="keyword">if</span> response.status != <span class="number">200</span>:</span><br><span class="line">            self.lock.locked()  <span class="comment"># 加锁</span></span><br><span class="line">            self.proxy_model.is_backed = <span class="literal">True</span></span><br><span class="line">            self.lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line">            <span class="keyword">return</span> request</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新代理ip，将ip信息赋给self.proxy_model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy</span>(<span class="params">self</span>):</span></span><br><span class="line">        proxy_dict = requests.get(self.proxy_url, headers=self.head).json()</span><br><span class="line">        proxy_model = model(proxy_dict)</span><br><span class="line">        self.proxy_model = proxy_model</span><br><span class="line">        print(<span class="string">&quot;更换了代理&quot;</span>)</span><br><span class="line">        print(self.proxy_model.proxy_url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程的方式更新代理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy_in_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="comment"># 每过5秒检查一次，如果代理 运行了60秒或 加入黑名单或 超时，就更换代理</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">60</span> <span class="keyword">or</span> self.proxy_model.is_backed <span class="keyword">or</span> self.proxy_model.is_expire:</span><br><span class="line">                self.update_proxy()</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count + <span class="number">5</span></span><br><span class="line">                print(<span class="string">&quot;代理运行了&quot;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;秒&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Scrapy中使用selenium动态爬虫"><a href="#Scrapy中使用selenium动态爬虫" class="headerlink" title="Scrapy中使用selenium动态爬虫"></a>Scrapy中使用selenium动态爬虫</h2><p>在中间件的request中使用selenium获取网页数据，直接返回给爬虫进行解析数据</p>
<h3 id="简书案例-获取加载更多中的全部数据"><a href="#简书案例-获取加载更多中的全部数据" class="headerlink" title="简书案例,获取加载更多中的全部数据"></a>简书案例,获取加载更多中的全部数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> scrapy.http.response.html <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianshuDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="comment"># 初始化dirver</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(JianshuDownloaderMiddleware, self).__init__()</span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拦截请求，自定义发送动态爬虫，直接返回response对象给爬虫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        self.driver.get(request.url)</span><br><span class="line">        <span class="comment"># 等待加载</span></span><br><span class="line">        WebDriverWait(self.driver, <span class="number">8</span>).until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, <span class="string">&quot;//section[position()=2]/h3&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 循环点击加载更多，直到加载完毕即可</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                add_more = self.driver.find_element_by_xpath(<span class="string">&quot;//section[position()=2]/div/div[@role=&#x27;button&#x27;]&quot;</span>)</span><br><span class="line">                print(add_more)</span><br><span class="line">                self.driver.execute_script(<span class="string">&quot;arguments[0].click();&quot;</span>, add_more)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        response = HtmlResponse(request.url, request=request, body=self.driver.page_source,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>此时爬虫spider中获取的response是从上面这个方法中传过来的，可以根据自己的需求获取相关数据</p>
<p>更多的介绍请参考API：<a href="https://scrapyd.readthedocs.io/en/stable/api.html">https://scrapyd.readthedocs.io/en/stable/api.html</a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas库</title>
    <url>/2021/04/18/pandas%E5%BA%93/</url>
    <content><![CDATA[<p>pandas的基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pandas.Series(</span><br><span class="line"> data = <span class="literal">None</span>,</span><br><span class="line"> index = <span class="literal">None</span>,</span><br><span class="line"> dtype = <span class="literal">None</span>,</span><br><span class="line"> name = <span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Serires的dtype"><a href="#Serires的dtype" class="headerlink" title="Serires的dtype"></a>Serires的dtype</h3><p>• int8/int16/int32/int64(默认): 整型 </p>
<p>• float16/float32/float64(默认): 浮点型 </p>
<p>• str/string: 字符串 • bool: 布尔 </p>
<p>• category: 分类 • datetime64[ns]: 时间戳(纳秒) </p>
<p>• period[Y/M/D]: 时间周期(年/月/日) </p>
<p>• object: python对象混合类型</p>
<h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><h3 id="通过2维的list-like创建"><a href="#通过2维的list-like创建" class="headerlink" title="通过2维的list-like创建"></a>通过2维的list-like创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]], columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="通过字典创建"><a href="#通过字典创建" class="headerlink" title="通过字典创建"></a>通过字典创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">6</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">2</span>, <span class="number">8</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="通过读取Excel表-最常用"><a href="#通过读取Excel表-最常用" class="headerlink" title="通过读取Excel表(最常用)"></a>通过读取Excel表(最常用)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(<span class="string">&quot;xxx.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas读excel文件-pandas-read-excel-的参数"><a href="#pandas读excel文件-pandas-read-excel-的参数" class="headerlink" title="pandas读excel文件:pandas.read_excel()的参数"></a>pandas读excel文件:pandas.read_excel()的参数</h2><h3 id="io-路径-StringIO-URL"><a href="#io-路径-StringIO-URL" class="headerlink" title="io    路径, StringIO, URL"></a>io    路径, StringIO, URL</h3><p>可以使用os.chdir(“….”)来切换当前路径</p>
<h3 id="sheet-name-0-选择子表-sheet"><a href="#sheet-name-0-选择子表-sheet" class="headerlink" title="sheet_name=0    选择子表(sheet)"></a>sheet_name=0    选择子表(sheet)</h3><p>• int: 选第几个sheet, 下标从0开始    • str: sheet名字     • list: [0, “2月”], 返回字典    • None: 全部sheet, 返回字典</p>
<h3 id="nrows-None-要解析的行数"><a href="#nrows-None-要解析的行数" class="headerlink" title="nrows=None    要解析的行数"></a>nrows=None    要解析的行数</h3><p>norws=3   只解析当前表格的前3行，不包括表头</p>
<h3 id="sheet-header-0-指定作为’列索引’的行"><a href="#sheet-header-0-指定作为’列索引’的行" class="headerlink" title="sheet_header=0    指定作为’列索引’的行"></a>sheet_header=0    指定作为’列索引’的行</h3><p>header=[0, 1]   将第一行与第二行作为列索引，也可以   header=[‘姓名’,’年龄’]模式</p>
<h3 id="index-col-None-指定作为’行索引’的列"><a href="#index-col-None-指定作为’行索引’的列" class="headerlink" title="index_col=None     指定作为’行索引’的列"></a>index_col=None     指定作为’行索引’的列</h3><p>index_col=[0, 1]    将第一列与第二列作为行索引，注意不可以  index_col=[‘姓名’,’年龄’]   模式</p>
<h3 id="usecols-None-指定只使用哪些列"><a href="#usecols-None-指定只使用哪些列" class="headerlink" title="usecols=None    指定只使用哪些列"></a>usecols=None    指定只使用哪些列</h3><p>• int-list: [0, 2]    •str-list: [‘AAA’, ‘CCC’]   • str: ‘A,C’, ‘A,C:E’     • 函数: lambda x: x == ‘CCC’ </p>
<h3 id="skiprows-None-跳过⾏"><a href="#skiprows-None-跳过⾏" class="headerlink" title="skiprows=None  跳过⾏"></a>skiprows=None  跳过⾏</h3><p>skiprows=1  跳过第一行   ；   skiprows=[0, 2]  跳过0和2行</p>
<h3 id="dtype-None-设置列的类型"><a href="#dtype-None-设置列的类型" class="headerlink" title="dtype=None   设置列的类型"></a>dtype=None   设置列的类型</h3><p>dtype = {‘a’: ‘float64’, ‘b’: ‘int32’}</p>
<h3 id="names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。"><a href="#names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。" class="headerlink" title="names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。"></a>names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。</h3><p>header=None    </p>
<p>names=[‘⽉份’ , ‘销量’ , ‘销售额’]</p>
<h3 id="parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12"><a href="#parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12" class="headerlink" title="parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12"></a>parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12</h3><p>• True -&gt; 尝试解析index的格式</p>
<p>• [0, 1] 或 [‘a’, ‘b’] -&gt; 尝试解析指定列作为一个单独的日期列 </p>
<p>• [[0, 1, 2]] -&gt; 结合多列解析为单个日期列 ，如果年月日不在一起，可以这样使用将他们结合</p>
<p>• {‘日期’: [0, 1, 2]} -&gt; 同上, 结果的列名改为’日期’ •</p>
<h3 id="date-parser-None-function-解析日期格式的函数"><a href="#date-parser-None-function-解析日期格式的函数" class="headerlink" title="date_parser=None    function, 解析日期格式的函数"></a>date_parser=None    function, 解析日期格式的函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date_parser=<span class="keyword">lambda</span> x: pd.to_datetime(x, <span class="built_in">format</span>=<span class="string">&quot;%Y年%m月%d日&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="na-values-None-识别为-NaN-缺失值-的其他字符串"><a href="#na-values-None-识别为-NaN-缺失值-的其他字符串" class="headerlink" title="na_values=None    识别为 NaN(缺失值) 的其他字符串"></a>na_values=None    识别为 NaN(缺失值) 的其他字符串</h3><p>missing data (缺失值) (NaN)    Not a Number </p>
<p>默认情况下，以下值被解析为NaN</p>
<p> ‘-1.#IND’     ‘1.#IND’      ‘NA’     ‘#N/A’   ‘-1.#QNAN’     ‘1.#QNAN’     ‘NULL’     ‘#NA’     ‘-NaN’     ‘NaN’     ‘#N/A N/A’     ‘-nan’     ‘N/A’     ‘n/a’</p>
<p>na_values=[‘空值’, 0]   将’空值‘字符串和0变成NaN</p>
<p>na_values={1: [‘空值’, 0]}    将第二列中的’空值‘字符串和0变成NaN</p>
<h3 id="converters-None-值转换函数，注意传递的是dict"><a href="#converters-None-值转换函数，注意传递的是dict" class="headerlink" title="converters=None      值转换函数，注意传递的是dict"></a>converters=None      值转换函数，注意传递的是dict</h3><p>converters={ </p>
<p>“a”: lambda x: x +1, # 将 列’a‘中的值 + 1 </p>
<p>“b”: lambda x: x * 2, #  将列’b‘中的值 * 2</p>
<p>}</p>
<h3 id="true-values-None-变成-True-的值"><a href="#true-values-None-变成-True-的值" class="headerlink" title="true_values=None    变成 True 的值"></a>true_values=None    变成 True 的值</h3><p>true_values=[‘a’, ‘b’]     将’a‘与’b‘变成布尔类型TRUE</p>
<h3 id="false-values-None-变成-False-的值"><a href="#false-values-None-变成-False-的值" class="headerlink" title="false_values=None   变成 False 的值"></a>false_values=None   变成 False 的值</h3><p> false_values=[‘c’, ‘d’]     将’c‘与’d‘变成布尔类型FALSE</p>
<p>注意:上面的两个参数只对字符串起作⽤，并要一整列要么全部变要么全部不变</p>
<h3 id="mangle-dupe-cols-True-列名是否重复"><a href="#mangle-dupe-cols-True-列名是否重复" class="headerlink" title="mangle_dupe_cols=True   列名是否重复"></a>mangle_dupe_cols=True   列名是否重复</h3><p>如果重复命名,会自动修改 :   a    b     b   -&gt;  a   b    b.1</p>
<p>mangle_dupe_cols=False  如果出现重复命名将会报错:</p>
<p>ValueError: Setting mangle_dupe_cols=False is not supported yet</p>
<h2 id="pandas写excel文件"><a href="#pandas写excel文件" class="headerlink" title="pandas写excel文件:"></a>pandas写excel文件:</h2><h3 id="DataFrame写入excel"><a href="#DataFrame写入excel" class="headerlink" title="DataFrame写入excel"></a>DataFrame写入excel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(</span><br><span class="line"> self,</span><br><span class="line"> excel_writer, <span class="comment"># ⽂件路径/ExcelWriter</span></span><br><span class="line"> sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, <span class="comment"># sheet名字</span></span><br><span class="line"> index=<span class="literal">True</span>, <span class="comment"># 是否输出index</span></span><br><span class="line"> float_format=<span class="literal">None</span>, <span class="comment"># 浮点数输出格式, 如: &quot;%.2f&quot;</span></span><br><span class="line"> na_rep=<span class="string">&#x27;&#x27;</span> <span class="comment"># 缺失值输出的表示形式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="用pandas-ExcelWriter类写入"><a href="#用pandas-ExcelWriter类写入" class="headerlink" title="用pandas.ExcelWriter类写入"></a>用pandas.ExcelWriter类写入</h3><p>1: 设置datatime输出格式       2: 输出多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">&#x27;tb.xlsx&#x27;</span>,datetime_format=<span class="string">&quot;YYYY-MM-DD&quot;</span>) <span class="keyword">as</span> writer:</span><br><span class="line"> df1.to_excel(writer, sheet_name=<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line"> df2.to_excel(writer, sheet_name=<span class="string">&#x27;BBB&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas写-读csv"><a href="#pandas写-读csv" class="headerlink" title="pandas写/读csv"></a>pandas写/读csv</h2><h3 id="read-csv"><a href="#read-csv" class="headerlink" title="read_csv()"></a>read_csv()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(</span><br><span class="line"> filepath, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,    <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="to-csv"><a href="#to-csv" class="headerlink" title="to_csv()"></a>to_csv()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(</span><br><span class="line"> path_or_buf, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,   <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据表处理"><a href="#pandas数据表处理" class="headerlink" title="pandas数据表处理"></a>pandas数据表处理</h2><h3 id="一-数据常用筛选方法"><a href="#一-数据常用筛选方法" class="headerlink" title="一.数据常用筛选方法"></a>一.数据常用筛选方法</h3><p>1.基础索引方式,就是直接引用 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic[[<span class="string">&#x27;户主姓名&#x27;</span>,<span class="string">&#x27;农户生产经营类型&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>2.loc [行索引名称或者条件,列索引名称或者标签]   # 左闭右闭</p>
<p>可以接多个条件(&amp; , | )：（basic[‘age’]&gt;10）&amp; (basic[‘age’]&lt;2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.loc[<span class="number">0</span>:<span class="number">2</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>]] </span><br><span class="line">basic.loc[basic[<span class="string">&#x27;健康状况&#x27;</span>]== <span class="string">&#x27;良好&#x27;</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>,<span class="string">&#x27;健康状况&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>3.iloc [行索引位置,列索引位置]   # 左闭右开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.iloc[<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">order.iloc[:,[<span class="number">0</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="二-数据增加和删除"><a href="#二-数据增加和删除" class="headerlink" title="二.数据增加和删除"></a>二.数据增加和删除</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h4><p>df.insert(loc, column, value)   添加一列,loc添加位置,column字段名,value添加的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.insert(<span class="number">0</span>, <span class="string">&#x27;出生年月&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h4><p>del  df[column]   # 删除一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> basic[<span class="string">&#x27;数据&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>df.drop(labels,axis,inplace=True)    </p>
<p>labels表示删除的数据, axis表示作用轴，inplace=True表示是否对原数据生效</p>
<p>axis=0按行操作, axis=1按列操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.drop(labels = [<span class="string">&#x27;日期&#x27;</span>, <span class="string">&#x27;销量&#x27;</span>],axis = <span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">basic.drop(labels= <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">11</span>),axis=<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="三-数据修改和查找"><a href="#三-数据修改和查找" class="headerlink" title="三.数据修改和查找"></a>三.数据修改和查找</h3><p>db.rename()     修改列名称或者行索引名称   ，  inplace = True表示生效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.rename(columns = &#123;<span class="string">&#x27;出生年月&#x27;</span>:<span class="string">&#x27;出生日期&#x27;</span>,<span class="string">&#x27;文化程度&#x27;</span>:<span class="string">&#x27;受教育水平&#x27;</span> &#125;,inplace = <span class="literal">True</span>) <span class="comment">#修改列</span></span><br><span class="line">basic.rename(index = &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;10&#x27;</span>:<span class="string">&#x27;ten&#x27;</span> &#125;,inplace = <span class="literal">True</span>)  <span class="comment">#修改行</span></span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>)   <span class="comment">#  重置索引，从0开始</span></span><br></pre></td></tr></table></figure>
<p>使用loc方法修改数据，查询到数据后直接赋值即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[ df[<span class="string">&#x27;性别&#x27;</span>]== <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;女‘  # 将性别为0的变成女</span></span><br></pre></td></tr></table></figure>
<p>条件与条件之间用 &amp; ， |  连接，分别代表‘且’和‘或’ ，也可以使用between和isin选择满足条件的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].between(<span class="number">18</span>,<span class="number">20</span>,inclusive=<span class="literal">True</span>)]   <span class="comment"># 获取age在18到20的行，inclusive=True表示是左右包含，False为不包含</span></span><br><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].isin([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])]  <span class="comment"># 获取age为10，20，30的行</span></span><br></pre></td></tr></table></figure>
<h3 id="四-数据整理"><a href="#四-数据整理" class="headerlink" title="四.数据整理"></a>四.数据整理</h3><p>pd.concat(objs,axis,join,ignore_index)  </p>
<p>连接多张表，objs: 表的集合, axis =1用于横向，0代表纵向,join=’inner’表示交集,等于’outer’表示并集，ignore_index=True表示重构索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([order1,order2,order3],axis=<span class="number">0</span>,ignore_index=<span class="literal">False</span>)  </span><br><span class="line"><span class="comment"># 纵向连接3张表，不重构索引，可以在后面使用df.reset_index(inplace=True),默认并集</span></span><br></pre></td></tr></table></figure>
<p>pd.merge(left,right,how,left_on,right_on)      # 很想MySQL数据库中的内连接</p>
<p>合并left与right两张表，how是链接方式，默认inner（内连接），left_on与right_on表示采用左右表的哪个字段链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp.merge(left=df1,right=df2,how=<span class="string">&#x27;inner&#x27;</span>,left_on=<span class="string">&#x27;user_id&#x27;</span>,right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="五-层次化索引"><a href="#五-层次化索引" class="headerlink" title="五.层次化索引"></a>五.层次化索引</h3><p>在一个轴上拥有两个或者两个以上的索引 </p>
<p> 使用loc语句进行访问 , loc里面接受tuple,   如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[(<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;江西&#x27;</span>),<span class="string">&#x27;name&#x27;</span>]  <span class="comment"># 获取&#x27;中国&#x27;索引中的&#x27;江西&#x27;索引的行里面的name列</span></span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">10</span>,(<span class="string">&#x27;第一季&#x27;</span>,[<span class="string">&#x27;销量&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>])]   <span class="comment"># 获取0到10行中&#x27;第一季&#x27;索引下的&#x27;销量&#x27;与&#x27;利润&#x27;列表</span></span><br></pre></td></tr></table></figure>
<h2 id="pandas数据转换"><a href="#pandas数据转换" class="headerlink" title="pandas数据转换"></a>pandas数据转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将列的数据类型变成最接近的类型</span></span><br><span class="line">df.convert_dtypes()</span><br><span class="line"><span class="comment"># 选中string类型的列</span></span><br><span class="line">df.select_dtypes(include=<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="comment"># 转换类型</span></span><br><span class="line">df[<span class="string">&#x27;销量&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一-日期格式数据处理"><a href="#一-日期格式数据处理" class="headerlink" title="一.日期格式数据处理"></a>一.日期格式数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成时间格式 datetime64</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>] = pd.to_datetime(d1[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 时间格式可以使用dt提取年月日时分秒</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>].dt.year</span><br></pre></td></tr></table></figure>
<h3 id="二-高阶函数数据处理"><a href="#二-高阶函数数据处理" class="headerlink" title="二.高阶函数数据处理"></a>二.高阶函数数据处理</h3><p>apply函数，axis=0表示对行进行操作,axis=1表示对列进行操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;贷款余额&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x).strip() )</span><br></pre></td></tr></table></figure>
<p>map函数，将dict中出现的键全部替换成值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;gender&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="三-字符串数据处理"><a href="#三-字符串数据处理" class="headerlink" title="三.字符串数据处理"></a>三.字符串数据处理</h3><p>通过 df[col].str 属性访问下列方法，例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;姓名&#x27;</span>].<span class="built_in">str</span>.srip()  <span class="comment"># 去除空白字符</span></span><br></pre></td></tr></table></figure>
<p>contains()      返回表示各str是否含有指定模式的字符串 </p>
<p>replace() 替换字符串。 </p>
<p>lower() 返回字符串的副本，其中所有字母都转换为小写。 </p>
<p>upper() 返回字符串的副本，其中所有字母都转换为大写。 </p>
<p>split() 返回字符串中的单词列表。 </p>
<p>strip() 删除前导和后置空格。 </p>
<p>join() 返回一个字符串，该字符串是给定序列中所有字符串的连接</p>
<h2 id="pandas数据统计"><a href="#pandas数据统计" class="headerlink" title="pandas数据统计"></a>pandas数据统计</h2><h3 id="一-数据分组运算"><a href="#一-数据分组运算" class="headerlink" title="一.数据分组运算"></a>一.数据分组运算</h3><p>使用 df.groupby方法进行分组计算，得到分组对象GroupBy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g1 = df.groupby(by = <span class="string">&#x27;product’)</span></span><br><span class="line"><span class="string">g2 = df.groupby(by = [&#x27;</span>product<span class="string">&#x27;,&#x27;</span>jgmc’]) </span><br></pre></td></tr></table></figure>
<p>分组对象GroupBy可以运用描述性统计方法, 如count、mean 、 median 、 max和min等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Group.mean() </span><br><span class="line">Group.<span class="built_in">sum</span>()</span><br><span class="line">Group.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<h3 id="二-聚合函数使用"><a href="#二-聚合函数使用" class="headerlink" title="二.聚合函数使用"></a>二.聚合函数使用</h3><p>象使用agg聚合函数   (np=numpy)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped.agg([np.mean,np.<span class="built_in">max</span>]).head(<span class="number">20</span>)</span><br><span class="line">grouped.agg(&#123;<span class="string">&#x27;ye&#x27;</span>:np.mean,<span class="string">&#x27;dkje&#x27;</span>:np.<span class="built_in">max</span>&#125;)</span><br><span class="line">df[[<span class="string">&#x27;销售额&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>]].agg([np.<span class="built_in">sum</span>,np.mean])</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据预处理"><a href="#pandas数据预处理" class="headerlink" title="pandas数据预处理"></a>pandas数据预处理</h2><h3 id="一-重复值处理"><a href="#一-重复值处理" class="headerlink" title="一.重复值处理"></a>一.重复值处理</h3><p>df.duplicated()   判断是否有重复值,返回掩码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.dumplicated()]  <span class="comment"># 获取重复值</span></span><br><span class="line">np.<span class="built_in">sum</span>(df.duplicated())   <span class="comment"># 获取重复的行数</span></span><br></pre></td></tr></table></figure>
<p>df.drop_duplicates()  删除重复值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>)  </span><br><span class="line"><span class="comment"># 如果[&#x27;appname&#x27;,&#x27;size&#x27;]中的值重复就表示为重复着</span></span><br><span class="line">df.drop_duplicates(subset= [<span class="string">&#x27;appname&#x27;</span>,<span class="string">&#x27;size&#x27;</span>],inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二-缺失值处理"><a href="#二-缺失值处理" class="headerlink" title="二.缺失值处理"></a>二.缺失值处理</h3><p>直接删除法 </p>
<p>df.dropna()        how=’any’ 表示只要一个是缺失值就删除，how=’all’表示全部是缺失值才删除，subset指定要判断的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(how=<span class="string">&#x27;any&#x27;</span>,subset=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])  </span><br></pre></td></tr></table></figure>
<p>均值替换、常数替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>,inplace=<span class="literal">True</span>)   <span class="comment"># 将所有缺省值替换成0,并在原表格中改变</span></span><br><span class="line">df.age.fillna(df.age.mean())     <span class="comment"># 在age中将缺失值替换成该字段的中位数</span></span><br><span class="line">df.fillna(value=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)   <span class="comment"># 根据不同情况填充不同的值</span></span><br></pre></td></tr></table></figure>
<p>前向、后向替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;age&#x27;</span>].fillna(method=<span class="string">&#x27;ffill&#x27;</span>)  <span class="comment"># 使用前一个值替换缺失值</span></span><br><span class="line">df[<span class="string">&#x27;name&#x27;</span>].fillna(method=<span class="string">&#x27;bfill&#x27;</span>)	<span class="comment"># 使用后一个值替换缺失值</span></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据清洗</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/05/07/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>git命令行操作</p>
<h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git<a id="more"></a></h4><p>git init</p>
<h4 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h4><h5 id="项目级别-仓库级别：仅在当前本地库范围内有效"><a href="#项目级别-仓库级别：仅在当前本地库范围内有效" class="headerlink" title="项目级别/仓库级别：仅在当前本地库范围内有效"></a>项目级别/仓库级别：仅在当前本地库范围内有效</h5><p>git config user.name hui</p>
<p>git config user.email <a href="mailto:&#x31;&#x37;&#x36;&#52;&#x35;&#48;&#x31;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x31;&#x37;&#x36;&#52;&#x35;&#48;&#x31;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a> </p>
<p>信息保存位置：./.git/config 文件</p>
<h5 id="系统用户级别：登录当前操作系统的用户范围"><a href="#系统用户级别：登录当前操作系统的用户范围" class="headerlink" title="系统用户级别：登录当前操作系统的用户范围"></a>系统用户级别：登录当前操作系统的用户范围</h5><p>git config –global user.name hui </p>
<p>git config –global <a href="mailto:&#x31;&#55;&#54;&#52;&#x35;&#48;&#49;&#x35;&#54;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#55;&#54;&#52;&#x35;&#48;&#49;&#x35;&#54;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a> </p>
<p>信息保存位置：~/.gitconfig 文件 </p>
<h5 id="注-就近原则-项目级别优先于系统用户级别"><a href="#注-就近原则-项目级别优先于系统用户级别" class="headerlink" title="注: 就近原则,项目级别优先于系统用户级别"></a>注: 就近原则,项目级别优先于系统用户级别</h5><h4 id="其他常规操作"><a href="#其他常规操作" class="headerlink" title="其他常规操作"></a>其他常规操作</h4><p><font size='4'>状态查看   git status </font></p>
<p><font size='4'>添加  git add[file name] </font></p>
<p><font size='4'>提交 git commit -m’提交日志’ [file name] </font></p>
<h4 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h4><p><font size='4'>git log</font></p>
<p><font size='4'>git reflog  ( 最常用 )</font></p>
<p><font size='4'>git log –pretty=oneline </font></p>
<p><font size='4'>git log –oneline </font></p>
<p>多屏显示控制方式： 空格向下翻页 , b 向上翻页 , q 退出</p>
<h4 id="前进后退版本"><a href="#前进后退版本" class="headerlink" title="前进后退版本"></a>前进后退版本</h4><p>git reset –hard [局部索引值]</p>
<p>git reset –hard HEAD^</p>
<p>注：一个^表示后退一步，n 个表示后退 n 步</p>
<p>git reset –hard HEAD~n</p>
<p>注：表示后退 n 步</p>
<h4 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h4><p>–soft</p>
<p>​        仅仅在本地库移动 HEAD 指针</p>
<p>–mixed</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区</p>
<p>–hard</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区 </p>
<p>​        重置工作区</p>
<h4 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h4><p>git diff [文件名] </p>
<p>将工作区中的文件和暂存区进行比较 </p>
<p>git diff [本地库中历史版本] [文件名] </p>
<p>将工作区中的文件和本地库历史记录比较 ，如果不带文件名则比较多个文件</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>查看分支  git branch -v</p>
<p>创建分支  git branch [分支名]</p>
<p>切换分支  git checkout [分支名]</p>
<p>合并分支  git merge [有新内容分支名]</p>
<p>解决合并分支的冲突</p>
<p>​    第一步：编辑文件，删除特殊字符 </p>
<p>​    第二步：把文件修改到满意的程度，保存退出 </p>
<p>​    第三步：git add [文件名] </p>
<p>​    第四步：git commit -m “日志信息” </p>
<p>​    注意：此时 commit 一定不能带具体文件名</p>
<h4 id="github基本命令"><a href="#github基本命令" class="headerlink" title="github基本命令"></a>github基本命令</h4><p>git clone [远程地址]     克隆项目</p>
<p>git remote -v     查看当前所有远程地址别名</p>
<p>git remote add [别名] [远程地址]     添加远程地址</p>
<p>git push [别名] [分支名]     推送</p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>pull=fetch+merge </p>
<p>git fetch [远程库地址别名] [远程分支名] </p>
<p>git merge [远程库地址别名] [远程分支名] </p>
<p>git pull [远程库地址别名] [远程分支名]</p>
<h5 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h5><p>如果不是基于GitHub远程库的最新版本所做的修改，不能推送，必须先拉取</p>
<p>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可</p>
<p>续。。。</p>
]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX笔记</title>
    <url>/2021/05/09/AJAX%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。<a id="more"></a></p>
<h3 id="前提-服务器用express测试"><a href="#前提-服务器用express测试" class="headerlink" title="前提 : 服务器用express测试"></a>前提 : 服务器用express测试</h3><p>安装 : npm i express</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> express();</span><br><span class="line"><span class="comment">// 开启一个接口，all可替换成get 、 post</span></span><br><span class="line">app.all(<span class="string">&#x27;/server&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 请求头设置跨域 </span></span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="string">&quot;res&quot;</span>:<span class="string">&quot;ajax&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">    response.send(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动8000端口监听</span></span><br><span class="line">app.listen(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器已启动，8000 端口监听中...&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>启动： 打开终端，输入  node  express.js</p>
<h3 id="原生AJAX"><a href="#原生AJAX" class="headerlink" title="原生AJAX"></a>原生AJAX</h3><h4 id="基本API使用"><a href="#基本API使用" class="headerlink" title="基本API使用"></a>基本API使用</h4><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr =<span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure>
<h5 id="初始化-open-requestType-url"><a href="#初始化-open-requestType-url" class="headerlink" title="初始化    open( requestType , url)"></a>初始化    open( requestType , url)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&quot;http://127.0.0.1:8000/server_post?page=1&amp;count=10&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-rulencoded&quot;</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;odd-dog&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="发送-参数是post请求体，如果是get请求则不用传参数"><a href="#发送-参数是post请求体，如果是get请求则不用传参数" class="headerlink" title="发送       参数是post请求体，如果是get请求则不用传参数"></a>发送       参数是post请求体，如果是get请求则不用传参数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="string">&#x27;username=admin&amp;pwd=123&#x27;</span>) </span><br><span class="line"><span class="comment">// xhr.send(&#x27;username:admin&amp;pwd:123&#x27;)</span></span><br></pre></td></tr></table></figure>
<h5 id="事件绑定，处理服务器返回结果"><a href="#事件绑定，处理服务器返回结果" class="headerlink" title="事件绑定，处理服务器返回结果"></a>事件绑定，处理服务器返回结果</h5><p>onreadystatechange : 当readystata属性被改变时调用</p>
<p>readystata 表示xhr中状态的属性 : 0 ，1 ，2 ，3：返回部分响应 ，4：返回全部响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> )&#123;</span><br><span class="line">        <span class="comment">// 如果状态码为 200 </span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status === <span class="number">200</span> )&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status)   <span class="comment">// 状态码</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText)  <span class="comment">//  状态码提示文字</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.getAllResponseHeaders())  <span class="comment">// 打印所有响应头</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response) <span class="comment">//  响应数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理返回的JSON数据"><a href="#处理返回的JSON数据" class="headerlink" title="处理返回的JSON数据"></a>处理返回的JSON数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接转换</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(xhr.response)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.responseType=<span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过该时间就取消请求</span></span><br><span class="line">xhr.timeout = <span class="number">2000</span> </span><br><span class="line"><span class="comment">// 时间超时回调函数</span></span><br><span class="line">xhr.ontimeout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">&quot;网络延迟，请稍后重试！！！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure>
<h6 id="可以解决重复发送请求问题"><a href="#可以解决重复发送请求问题" class="headerlink" title="可以解决重复发送请求问题"></a>可以解决重复发送请求问题</h6><p>先定义一个全局变量  let isSending = false </p>
<p>发送请求前先判断，如果当前正在发送，就取消该次的请求，再标识当前正在发送 ，重新发送</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSending)&#123;</span><br><span class="line">    xhr.abort()</span><br><span class="line">&#125;</span><br><span class="line">isSending = <span class="literal">true</span> </span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>发送完毕就标记 isSending = false</p>
<h3 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>$.get(url, [data], [callback], [type])</p>
<p>type:设置返回内容格式，xml, html, script, json, text, _default。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;http://127.0.0.1:8000/server_get&quot;</span>,&#123;<span class="string">&#x27;page&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;num&#x27;</span>:<span class="number">10</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>$.post(url, [data], [callback], [type]) </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">&quot;http://127.0.0.1:8000/server_post&quot;</span>,&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jerry&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">13</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注：get中的data参数是设置params，而post是设置请求体</p>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://127.0.0.1:8000/server&quot;</span>,</span><br><span class="line">    data : &#123;<span class="string">&quot;username&quot;</span> : <span class="string">&quot;admin&quot;</span> , <span class="string">&quot;gender&quot;</span> : <span class="string">&quot;man&quot;</span> &#125;,</span><br><span class="line">    type : <span class="string">&quot;POST&quot;</span>,  	<span class="comment">// 请求类型</span></span><br><span class="line">    dataType : <span class="string">&quot;json&quot;</span>,  <span class="comment">// 数据类型</span></span><br><span class="line">    timeout : <span class="number">2000</span> , 	<span class="comment">// 超时时间</span></span><br><span class="line">    <span class="comment">// 成功调用</span></span><br><span class="line">    success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败调用</span></span><br><span class="line">    error : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求失败，请重试！！！&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    headers : &#123;</span><br><span class="line">        name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        age : <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>设置通用地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL= <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>axios.get(url  [, config])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;server&quot;</span>,&#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">1</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p>axios#post(url[, data [, config]])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;server&quot;</span>,&#123;<span class="attr">username</span> : <span class="string">&#x27;tom&#x27;</span>,<span class="attr">pwd</span> : <span class="string">&#x27;123&#x27;</span>&#125;, &#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">10</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;jerry&#x27;</span>,<span class="attr">age</span>:<span class="number">3</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h4><p>axios( {config} )</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;server&#x27;</span>,</span><br><span class="line">    method : <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    params : &#123;<span class="attr">width</span>:<span class="number">100</span>,<span class="attr">height</span>:<span class="number">200</span>&#125;,</span><br><span class="line">    data : &#123;<span class="attr">name</span>:<span class="string">&#x27;kyrie&#x27;</span>,<span class="attr">job</span>:<span class="string">&#x27;ball&#x27;</span>&#125;,</span><br><span class="line">    headers:&#123;<span class="attr">sure</span>:<span class="string">&#x27;yes&#x27;</span>&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求拦截器---成功&quot;</span>)</span><br><span class="line">    config.params=&#123;<span class="attr">page</span>:<span class="number">100</span>&#125;</span><br><span class="line">    <span class="comment">// throw &quot;error..........&quot;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求拦截器---失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;响应拦截器---成功&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.data</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;响应拦截器---失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    url:<span class="string">&quot; http://localhost:3000/posts&quot;</span>,</span><br><span class="line">    <span class="comment">// 设置取消请求</span></span><br><span class="line">    cancelToken:<span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">        cancel=c</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用该方法即可取消上面axios的请求</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>
<p>详情请参考   <a href="https://github.com/axios/axios">https://github.com/axios/axios</a> </p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。</p>
<p>同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。</p>
<h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><ol>
<li><p>JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 </p>
</li>
<li><p>在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p>
</li>
<li><p>JSONP 的使用</p>
</li>
</ol>
<p>通过script.src来访问需跨域的服务器，但是script返回的不能是单纯数据，需要返回一个函数的调用，这里事先定义一个函数 fn，让script返回 fn 函数的调用，在函数调用里面传入数据</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>动态创建script标签，设置src值，url参数设为回调函数名，然后讲scripy添加到body中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数中的data就是跨域后获取的数据，需要依靠script返回的结果来调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	alert(data.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>获取回调函数名，用拼接的方式返回该函数的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;/testAJAX&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 获取回调函数名</span></span><br><span class="line">   	<span class="keyword">var</span> callback = request.query.callback </span><br><span class="line">   	<span class="comment">// 获取数据(随便定义一下，一般这里是从数据库中获取)</span></span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;怪狗狗&#x27;</span>&#125;</span><br><span class="line">  	<span class="comment">// 返回函数的调用</span></span><br><span class="line">    response.send(callback+<span class="string">&quot;(&quot;</span>+ <span class="built_in">JSON</span>.stringify(data) +<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ol>
<li><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p>
</li>
<li><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 </p>
</li>
<li><p>CORS 的使用</p>
</li>
</ol>
<p>主要是服务器端来设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)   <span class="comment">// 允许任意源访问</span></span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)  <span class="comment">// 允许设置自定义请求头</span></span><br></pre></td></tr></table></figure>
<p>了解更多CORS，请参考   <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6+新特性</title>
    <url>/2021/05/11/ES6-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个<a id="more"></a></p>
<p>ECMA-262（ECMAScript）历史版本查看网址</p>
<p> <a href="http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm">http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm</a></p>
<p><a href="https://imgtu.com/i/gU0McT"><img src="https://z3.ax1x.com/2021/05/11/gU0McT.png" alt="gU0McT.png"></a></p>
<h3 id="ES6-兼容性"><a href="#ES6-兼容性" class="headerlink" title="ES6 兼容性"></a>ES6 兼容性</h3><p><a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a> 可查看兼容性</p>
<p><a href="https://imgtu.com/i/gUBuad"><img src="https://z3.ax1x.com/2021/05/11/gUBuad.png" alt="gUBuad.png"></a></p>
<h3 id="ECMASript-6-新特性"><a href="#ECMASript-6-新特性" class="headerlink" title="ECMASript 6 新特性"></a>ECMASript 6 新特性</h3><h4 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h4><ol>
<li><p>不允许重复声明 </p>
</li>
<li><p>块儿级作用域 </p>
</li>
<li><p>不存在变量提升 </p>
</li>
<li><p>不影响作用域链 </p>
</li>
</ol>
<p>应用场景：以后声明变量使用 let 就对了</p>
<h4 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h4><ol>
<li><p>声明必须赋初始值 </p>
</li>
<li><p>标识符一般为大写 </p>
</li>
<li><p>不允许重复声明 </p>
</li>
<li><p>值不允许修改 </p>
</li>
<li><p>块儿级作用域</p>
</li>
</ol>
<p>应用场景：声明对象类型使用 const，非对象类型声明选择 let</p>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称 为解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;张学友&#x27;</span>, <span class="string">&#x27;刘德华&#x27;</span>, <span class="string">&#x27;黎明&#x27;</span>, <span class="string">&#x27;郭富城&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [zhang, liu, li, guo] = arr;</span><br><span class="line"><span class="comment">//对象的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">     name: <span class="string">&#x27;林志颖&#x27;</span>,</span><br><span class="line">     tags: [<span class="string">&#x27;车手&#x27;</span>, <span class="string">&#x27;歌手&#x27;</span>, <span class="string">&#x27;小旋风&#x27;</span>, <span class="string">&#x27;演员&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, tags&#125; = lin;</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识</p>
<ol>
<li><p>字符串中可以出现换行符</p>
</li>
<li><p>可以使用 ${xxx} 形式输出变量</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量拼接</span></span><br><span class="line"><span class="keyword">let</span> star = <span class="string">&#x27;王宁&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">`<span class="subst">$&#123;star&#125;</span>在前几年离开了开心麻花`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性和方法简写</span></span><br><span class="line"><span class="keyword">let</span> atguigu = &#123;</span><br><span class="line">     name,</span><br><span class="line">     slogon,</span><br><span class="line">     improve,</span><br><span class="line">     <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;可以改变你&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="箭头函数-lambda"><a href="#箭头函数-lambda" class="headerlink" title="箭头函数 lambda"></a>箭头函数 lambda</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">item</span> =&gt;</span> item * item</span><br></pre></td></tr></table></figure>
<h5 id="注-箭头函数-this-指向声明时所在作用域下-this-的值-；不能使用-arguments"><a href="#注-箭头函数-this-指向声明时所在作用域下-this-的值-；不能使用-arguments" class="headerlink" title="注: 箭头函数 this 指向声明时所在作用域下 this 的值  ；不能使用 arguments"></a>注: 箭头函数 this 指向声明时所在作用域下 this 的值  ；不能使用 arguments</h5><h4 id="rest-参数-与-spread-扩展运算符"><a href="#rest-参数-与-spread-扩展运算符" class="headerlink" title="rest 参数 与 spread 扩展运算符"></a>rest 参数 与 spread 扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rest 参数可以传任一个，但必须放最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// spread 对数组进行解构</span></span><br><span class="line"><span class="keyword">let</span> tfboys = [<span class="string">&#x27;德玛西亚之力&#x27;</span>,<span class="string">&#x27;德玛西亚之翼&#x27;</span>,<span class="string">&#x27;德玛西亚皇子&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> number = [<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;bob&#x27;</span>,<span class="string">&#x27;jerry&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> sum = [...tfboys, ...number];</span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提 供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p>
<p>ES6 创造了一种新的遍历命令 for…of/in 循环，Iterator 接口主要供 for…of/in 消费</p>
<p>具备iterator接口的数据有  Array、Arguments 、Set 、 Map、 String、 TypedArray 、NodeList</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>创建一个指针对象index，指向当前数据结构的起始位置 </p>
<p>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p>
<p>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</p>
<p>每调用 next 方法返回一个包含 value 和 done 属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代器iterator ，迭代team中的member数组</span></span><br><span class="line"><span class="keyword">let</span> team =&#123;</span><br><span class="line">    name : <span class="string">&#x27;hui&#x27;</span>,</span><br><span class="line">    member : [<span class="string">&#x27;怪狗狗&#x27;</span>,<span class="string">&#x27;super Saiya&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;jerry&#x27;</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="comment">// 定义一个指针</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            next:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( index &lt; <span class="built_in">this</span>.member.length)&#123;</span><br><span class="line">                    <span class="keyword">const</span> res= &#123;<span class="attr">value</span> : <span class="built_in">this</span>.member[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">                    index ++ </span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span> : <span class="string">&quot;迭代完毕&quot;</span>,<span class="attr">done</span> :<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> team)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器  *"></a>生成器  *</h4><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>1.生成器返回的结果是一个迭代器对象，调用该迭代器中的next方法可执行yield之间的代码块</p>
<p>2.yield相当于函数中的暂停标志, next方法可以传递参数，作为yield语句的返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;用户数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderData</span>(<span class="params">user_data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取user_data:&#x27;</span>+user_data)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;订单数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goodsData</span>(<span class="params">order_data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取order_data:&#x27;</span>+order_data)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;商品数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user_data = <span class="keyword">yield</span> userData()</span><br><span class="line">    <span class="keyword">let</span> order_data = <span class="keyword">yield</span> orderData(user_data)</span><br><span class="line">    goods_data = <span class="keyword">yield</span> goodsData(order_data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取goods_data:&#x27;</span>+goods_data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。 </p>
<h5 id="基本API调用"><a href="#基本API调用" class="headerlink" title="基本API调用"></a>基本API调用</h5><h6 id="new-Premose-fn"><a href="#new-Premose-fn" class="headerlink" title="new Premose(fn)"></a>new Premose(fn)</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用 resolve(data)   改变pending状态PromiseState : fulfilled</span></span><br><span class="line"> <span class="comment">// 使用 reject(data)	   改变pending状态PromiseState : rejected</span></span><br><span class="line"><span class="comment">//  抛出异常 throw:&#x27;xxx&#x27;  如果当前是 pending 就会变为 rejected</span></span><br><span class="line"><span class="keyword">let</span> p =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;<span class="attr">code</span>:<span class="number">200</span> ,<span class="attr">data</span> :<span class="string">&quot;数据....&quot;</span>,<span class="attr">error_message</span>:<span class="literal">null</span>&#125;</span><br><span class="line">    <span class="comment">// let res = &#123;code:403 ,data:null,error_message :&#x27;权限不足！！！&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">if</span>(res.code===<span class="number">200</span>)&#123;</span><br><span class="line">        resolve(res.data)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(res.error_message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-prototype-then-fn1-fn2"><a href="#Promise-prototype-then-fn1-fn2" class="headerlink" title="Promise.prototype.then(fn1[,fn2])"></a>Promise.prototype.then(fn1[,fn2])</h6><p>如果状态成功，就调用fn1，失败就调用[fn2]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success:&quot;</span>+value)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;failed:&quot;</span>+reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-prototype-catch-fn"><a href="#Promise-prototype-catch-fn" class="headerlink" title="Promise.prototype.catch(fn)"></a>Promise.prototype.catch(fn)</h6><p>失败就调用 fn函数  （为了让 语法与 then 区分）</p>
<h6 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h6><p>​    value: 成功的数据或 promise 对象</p>
<p>​    说明: 返回一个成功/失败的 promise 对象</p>
<h6 id="Promise-reject-value"><a href="#Promise-reject-value" class="headerlink" title="Promise.reject(value)"></a>Promise.reject(value)</h6><p>​    reason: 失败的原因 </p>
<p>​    说明: 返回一个失败的 promise 对象</p>
<h6 id="Promise-all-promises"><a href="#Promise-all-promises" class="headerlink" title="Promise.all(promises)"></a>Promise.all(promises)</h6><p>​    promises: 包含 n 个 promise对象 的数组 </p>
<p>​    说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就 直接失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;resolve(<span class="string">&quot;oh year&quot;</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-race-promises"><a href="#Promise-race-promises" class="headerlink" title="Promise.race(promises)"></a>Promise.race(promises)</h6><p>​    promises: 包含 n 个 promise 的数组 </p>
<p>​    说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(()=&#123;</span><br><span class="line">         resolve(<span class="string">&quot;oh year&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Promise</span>.race([p1,p2,p3])   </span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
<h5 id="promise-then-返回的新-promise-的结果状态"><a href="#promise-then-返回的新-promise-的结果状态" class="headerlink" title="promise.then()  返回的新 promise 的结果状态"></a>promise.then()  返回的新 promise 的结果状态</h5><p>① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p>
<p>② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p>
<p>③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p>
<p>因此 then() 可以链式调用</p>
<h5 id="promise-异常穿透"><a href="#promise-异常穿透" class="headerlink" title="promise 异常穿透"></a>promise 异常穿透</h5><p>使用promise的then链式调用时，可以在最后指定失败的回调 ,</p>
<p>前面任何操作出现了异常，都会传到最后失败的回调中处理</p>
<h5 id="中断-promise-链"><a href="#中断-promise-链" class="headerlink" title="中断 promise 链"></a>中断 promise 链</h5><p>当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>可在回调函数中返回一个 pendding 状态的 promise 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><p>新的数据结构，类似与java中的Set集合，去重 </p>
<p>常用方法  size   、 add 、 delete 、has 、clear</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> arr_set = [...new <span class="built_in">Set</span>(arr)] </span><br><span class="line"><span class="keyword">let</span> arr2_set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> res = arr_set.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2_set.has(item))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;交集:&quot;</span>+res)</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> res2 = [...new <span class="built_in">Set</span>([...arr,...arr2])]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;并集:&quot;</span>+res2)</span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> res3 = arr_set.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr2_set.has(item))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集:&quot;</span>+res3)</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>新的数据结构，类似与对象，但是‘ 键 ’ 的范围不限与字符串</p>
<p>常用方法 : size  、 set 、 get  、 has  、 clear</p>
<h4 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h4><p>新的 class 写法只是让对象 原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, color, price</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对象方法</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我可以打电话!!!&#x27;</span>)</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类   extends 继承 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, color, price, screen, pixel</span>)</span> &#123;</span><br><span class="line">         <span class="comment">// 调用父类方法</span></span><br><span class="line">         <span class="built_in">super</span>(brand, color, price);</span><br><span class="line">         <span class="built_in">this</span>.screen = screen;</span><br><span class="line">         <span class="built_in">this</span>.pixel = pixel;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">     <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;我可以进行视频通话!!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类方法</span></span><br><span class="line">     <span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	 <span class="built_in">console</span>.log(<span class="string">&#x27;我可以拍照!!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">     <span class="keyword">static</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;我可以运行程序&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">const</span> Nokia = <span class="keyword">new</span> Phone(<span class="string">&#x27;诺基亚&#x27;</span>, <span class="string">&#x27;灰色&#x27;</span>, <span class="number">230</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone6s = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>, <span class="number">6088</span>,<span class="string">&#x27;4.7inch&#x27;</span>,<span class="string">&#x27;500w&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="get-与-set"><a href="#get-与-set" class="headerlink" title="get 与 set"></a>get 与 set</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get_price。。。 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">money</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set_price...  &#x27;</span>+ money)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p =<span class="keyword">new</span> phone()</span><br><span class="line">p.price <span class="comment">// 调用get</span></span><br><span class="line">p.price = <span class="number">100</span>  <span class="comment">// 调用set</span></span><br></pre></td></tr></table></figure>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;odd-dog&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wolf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集体导出</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;smith&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wolf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hhhhh&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;name , wolf&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    wolf :<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;xxxxxxxx&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 常规引入</span></span><br><span class="line">    <span class="keyword">import</span> * as m1 from <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> * as m2 from <span class="string">&quot;./m2.js&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> * as m3 from <span class="string">&quot;./m3.js&quot;</span></span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 结构赋值形式 （不能重名）</span></span><br><span class="line">    <span class="keyword">import</span> &#123;name,wolf&#125; <span class="keyword">from</span> <span class="string">&quot;./m1.js&quot;</span></span><br><span class="line">    <span class="keyword">import</span> &#123;name <span class="keyword">as</span> n2,wolf <span class="keyword">as</span> w2&#125; <span class="keyword">from</span> <span class="string">&quot;./m2.js&quot;</span></span><br><span class="line">    <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m3 &#125; <span class="keyword">from</span> <span class="string">&quot;./m3.js&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 简便形式(针对默认导出)</span></span><br><span class="line">    <span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&#x27;./m3.js&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(m3)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="引入入口文件"><a href="#引入入口文件" class="headerlink" title="引入入口文件"></a>引入入口文件</h5><p>将所有的导入放入一个文件中  , 例如 app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来引入所需的所有js文件</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">&#x27;./m2.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">&#x27;./m3.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"><span class="built_in">console</span>.log(m2)</span><br><span class="line"><span class="built_in">console</span>.log(m3)</span><br></pre></td></tr></table></figure>
<p>index.html中这样引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./app.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-7-新特性"><a href="#ECMASript-7-新特性" class="headerlink" title="ECMASript 7 新特性"></a>ECMASript 7 新特性</h3><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h4><p>方法用来检测数组中是否包含某个元素，返回布尔类型值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mingzhu = [<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;水浒传&quot;</span>,<span class="string">&quot;红楼梦&quot;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&quot;西游记&quot;</span>))   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&quot;金瓶梅&quot;</span>))   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂运算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>)    <span class="comment">// 型特性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>))  <span class="comment">// 老方法</span></span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-8-新特性"><a href="#ECMASript-8-新特性" class="headerlink" title="ECMASript 8 新特性"></a>ECMASript 8 新特性</h3><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>​    1.async 函数的返回值为 promise 对象</p>
<p>​    2. 返回的promise 对象的由 async 函数执行的返回值决定</p>
<h4 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h4><ol>
<li><p>await 必须写在 async 函数中</p>
</li>
<li><p>await 右侧的表达式一般为 promise 对象 </p>
</li>
<li><p>await 返回的是 promise 成功的值 </p>
</li>
<li><p>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</p>
</li>
</ol>
<p>用async 与 await 发送AJAX</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将发送AJAX封装到一个promise方法中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAJAX</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&quot;get&quot;</span>,url)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">299</span>)&#123;</span><br><span class="line">                    resolve(xhr.response)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(<span class="string">&quot;出错了！！！&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来方法使用 then 调用,如果要使用then中的value，还需嵌套调用</span></span><br><span class="line"><span class="comment">// sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value =&gt; console.log(value))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用async 与 await 发送AJAX（让异步函数可以同步执行）</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;http://127.0.0.1:8000/server&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res3 = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;http://127.0.0.1:80000/server&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(res3)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h4 id="Object-keys-、values-和-entries"><a href="#Object-keys-、values-和-entries" class="headerlink" title="Object.keys  、values 和 entries"></a>Object.keys  、values 和 entries</h4><p>Object.keys()   获取对象 所有 键</p>
<p>Object.values() 获取对象 所有 值</p>
<p>Object.entries() 获取对象 [key,value] 的数组</p>
<h3 id="ECMASript-9-新特性"><a href="#ECMASript-9-新特性" class="headerlink" title="ECMASript 9 新特性"></a>ECMASript 9 新特性</h3><h4 id="为对象提供-Rest-Spread-属性"><a href="#为对象提供-Rest-Spread-属性" class="headerlink" title="为对象提供 Rest/Spread 属性"></a>为对象提供 Rest/Spread 属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================  扩展运算符 与rest 参数 ==================== </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span> (<span class="params">&#123;username,password, ...other_config&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="built_in">console</span>.log(password)</span><br><span class="line">    <span class="built_in">console</span>.log(other_config) <span class="comment">// 该属性包含了一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    username : <span class="string">&#x27;hui&#x27;</span>,</span><br><span class="line">    password : <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    port : <span class="number">3306</span>,</span><br><span class="line">    host : <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">connect(data)</span><br><span class="line"><span class="comment">// 对对象进行解构</span></span><br><span class="line"><span class="keyword">const</span> skillOne = &#123;<span class="attr">q</span> : <span class="string">&#x27;天音波&#x27;</span>&#125;;<span class="keyword">const</span> skillTwo = &#123;<span class="attr">w</span> : <span class="string">&#x27;金钟罩&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> skillThree = &#123;<span class="attr">e</span> : <span class="string">&#x27;拍地板&#x27;</span>&#125;;<span class="keyword">const</span> skillFour = &#123;<span class="attr">r</span> : <span class="string">&#x27;一库&#x27;</span>&#125; </span><br><span class="line"><span class="keyword">const</span> mangSeng = &#123;...skillOne , ...skillTwo , ...skillThree , ...skillFour&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mangSeng)</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h4><p>允许命名捕获组中使用符  ?&lt; name &gt; ,这样获取捕获结果可读性更强</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;a href=&quot;www.baidu.com&quot;&gt;去百度&lt;/a&gt;&#x27;</span></span><br><span class="line"><span class="comment">// 以前版本</span></span><br><span class="line"><span class="keyword">let</span> reg  = <span class="regexp">/&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/</span></span><br><span class="line"><span class="keyword">const</span> result = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span></span><br><span class="line"><span class="keyword">let</span> result2 =reg2.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(result2.groups.url)</span><br><span class="line"><span class="built_in">console</span>.log(result2.groups.text)</span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-10-新特性"><a href="#ECMASript-10-新特性" class="headerlink" title="ECMASript 10 新特性"></a>ECMASript 10 新特性</h3><p>trimStart 和 trimEnd   去除前后空字符</p>
<p>Array.prototype.flat 与 flatMap   降维</p>
<p>Symbol.prototype.description  获取Symbol的字符串描述</p>
<h3 id="ECMASript-11-新特性"><a href="#ECMASript-11-新特性" class="headerlink" title="ECMASript 11 新特性"></a>ECMASript 11 新特性</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p>定义属性时前面加 # 号，外部将不能直接访问私有属性</p>
<h4 id="Promise-allSettled-与-all"><a href="#Promise-allSettled-与-all" class="headerlink" title="Promise.allSettled 与 all"></a>Promise.allSettled 与 all</h4><p>批量处理异步函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;用户数据--1&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;用户数据--2&quot;</span>)</span><br><span class="line">        <span class="comment">// reject(&quot;出错了！！！&quot;)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// allSettled 永远返回成功</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Promise</span>.allSettled([p1,p2])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">// all 异步任务全部成功才返回成功的值，只要失败一个，就返回该失败的值</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line"><span class="built_in">console</span>.log(res2)</span><br></pre></td></tr></table></figure>
<h4 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符   ?."></a>可选链操作符   ?.</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果直接这样写，用户没传数据则会报错</span></span><br><span class="line">    <span class="comment">// this.port = config.data.port</span></span><br><span class="line">    <span class="comment">// 原来的解决方法</span></span><br><span class="line">    <span class="comment">// this.port = config &amp;&amp; config.data &amp;&amp; config.data.port </span></span><br><span class="line">    <span class="comment">// 现在使用 可选链操作符</span></span><br><span class="line">    <span class="built_in">this</span>.port = config?.data?.port</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态-import-导入"><a href="#动态-import-导入" class="headerlink" title="动态 import 导入"></a>动态 import 导入</h4><p>懒加载，使用时动态导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// ===================  单击事件中动态导入module  =====================</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//import 返回一个Promise对象，该对象中有暴露的方法与属性</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./m.js&#x27;</span>).then(<span class="function"><span class="params">module</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.hello()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h4><p>无论在哪个环境中，globalThis都代表全局对象 window </p>
<h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>  </span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 存放回调函数</span></span><br><span class="line">        <span class="built_in">this</span>.callback = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现resolve</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 如果状态已经改变了，就不能继续改变状态与值了</span></span><br><span class="line">            <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span> </span><br><span class="line">            <span class="comment">// 改变promise状态与值</span></span><br><span class="line">            self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">            self.PromiseResult = data</span><br><span class="line">            <span class="comment">// 如果有回调函数就调用，遍历该回调函数数组</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.callback.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                    item.onResolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现reject</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span> </span><br><span class="line">            <span class="comment">// 改变promise状态与值</span></span><br><span class="line">            self.PromiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">            self.PromiseResult = data</span><br><span class="line">            <span class="comment">// 如果有回调函数就调用，遍历该回调函数数组</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.callback.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                    item.onReject(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用传递过来的方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onResolve,onReject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onResolve !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            onResolve = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onReject !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            onReject = <span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> reason</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 封装返回Promise的回调函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> result = type(self.PromiseResult)</span><br><span class="line">                    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                        result.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                            resolve(value)</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            reject(reason)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功回调</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 执行函数返回的结果影响着then的Promise返回结果</span></span><br><span class="line">                <span class="comment">// 变成异步</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    callback(onResolve)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败回调</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&quot;rejected&quot;</span>)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    callback(onReject)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态没改变，保留回调方法,等待状态改变时调用</span></span><br><span class="line">            <span class="comment">// 回调方法放入放入一个对象中，再压入数组中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState ===<span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.callback.push(&#123;</span><br><span class="line">                    onResolve:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        callback(onResolve)</span><br><span class="line">                    &#125; , </span><br><span class="line">                    onReject:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        callback(onReject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch</span></span><br><span class="line">    <span class="keyword">catch</span>(onReject)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onReject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  resolve</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                value.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(v)</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  reject</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  all</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历Promise数组，一旦有失败的Promise就立刻返回，并结束遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> res = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.length;i++)&#123;</span><br><span class="line">                promises[i].then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    res[i]=v</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  race</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function"><span class="params">p</span>=&gt;</span>&#123;</span><br><span class="line">                p.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(v)</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象笔记</title>
    <url>/2021/05/26/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>基本概念 : 构造方法名与类名完全相同并且没有返回值类型，连void都不许有。</p>
<p>默认构造方法 : 当一个类中没有定义任何构造方法时，编译器会自动添加一个无参空构 造构造方法，叫做默认/缺省构造方法， 若类中出现了构造方法，则编译器不再提供任何形式的构造方法 <a id="more"></a></p>
<p>作用 : 使用new关键字创建对象时会自动调用构造方法实现成员变量初始化工作</p>
<h2 id="方法重载（OverLoad）"><a href="#方法重载（OverLoad）" class="headerlink" title="方法重载（OverLoad）"></a>方法重载（OverLoad）</h2><p>基本概念 : 方法名称相同，参数列表不同，这样的方法之间构成重载关系</p>
<p>体现形式 : 方法重载的主要形式体现在：参数的个数不同、参数的类型不同、参数 的顺序不同，与返回值类型和形参变量名无关，但建议返回值类型最好 相同</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>基本概念 :</p>
<p>​    1.若在构造方法中出现了this关键字，则代表当前正在构造的对象</p>
<p>​    2.若在成员方法中出现了this关键字，则代表当前正在调用的对象</p>
<p>​    3.this关键字本质上就是当前类类型的引用变量</p>
<p>使用方式:</p>
<p>​    1. 当局部变量名与成员变量名相同时，在方法体中会优先使用局部变量(就 近原则)，若希望使用成员变量，则需要在成员变量的前面加上this.的前 缀，明确要求该变量是成员变量</p>
<p>​    2. this关键字除了可以通过this.的方式调用成员变量和成员方法外，还可以 作为方法的返回值</p>
<p>​    3. 再构造方法的第一行可以使用this()的方式来调用本类中的其他构造方法</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>基本概念 : 使用static关键字修饰成员变量表示静态的含义，此时成员变量由对象层 级提升为类层级，也就是整个类只有一份并被所有对象共享，该成员变 量随着类的加载准备就绪，与是否创建对象无关。  </p>
<p>注意事项 : </p>
<p>​        1.static关键字修饰的成员可以使用引用.的方式访问，但推荐类名.的方式</p>
<p>​        2. 在非静态成员方法中既能访问非静态的成员又能访问静态的成员</p>
<p>​        3. 在静态成员方法中只能访问静态成员不能访问非静态成员</p>
<h2 id="构造快和静态代码块"><a href="#构造快和静态代码块" class="headerlink" title="构造快和静态代码块"></a>构造快和静态代码块</h2><p>构造块：在类体中直接使用{}括起来的代码块。 每创建一个对象都会执行一次构造块。 </p>
<p>静态代码块：使用static关键字修饰的构造块 static{} 。  静态代码块随着类加载时执行一次。</p>
<p>执行顺序 ：静态代码块  =》 构造快 =》 构造方法</p>
<h2 id="单例设计模式的概念"><a href="#单例设计模式的概念" class="headerlink" title="单例设计模式的概念"></a>单例设计模式的概念</h2><p>在某些特殊场合中，一个类对外提供且只提供一个对象时，这样的类叫 做单例类，而设计单例的流程和思想叫做单例设计模式。单例设计模式的实现方式有两种：饿汉式 和 懒汉式。在以后的开发中推荐 饿汉式。</p>
<p>单例设计模式的实现流程 ：</p>
<pre><code>1. 私有化构造方法，使用private关键字修饰。 
2. 声明本类类型的引用指向本类类型的对象，并使用private static关键字共 同修饰。 
3.  提供公有的get方法负责将对象返回出去，并使用public static关键字共同 修饰。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">// 创建示例对象，保存到静态成员中，并且私有化，不允许被修改</span></span><br><span class="line">	<span class="comment">//private static Singleton sin = new Singleton();  // 饿汉式	</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton sin = <span class="keyword">null</span>;	   <span class="comment">// 懒汉式</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 私有化构造方法 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取实例，将实例对象暴露出去</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 懒汉式需加此判断</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span>==sin)&#123;</span><br><span class="line">			sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sin;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承(extends)"></a>继承(extends)</h2><p>概念  :  当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成 一个公共类，让多个类吸收公共类中已有特征和行为,而在多个类型只需 要编写自己独有特征和行为的机制，叫做继承。</p>
<p>特点:</p>
<p>1.子类不能继承父类的构造方法和私有方法，但私有成员变量可以被继承 只是不能直接访问。</p>
<p>2.无论使用何种方式构造子类的对象时都会自动调用父类的无参构造方法， 来初始化从父类中继承的成员变量，相当于在构造方法的第一行增加代 码   super()   的效果,也可以手动调用 super(arguments) 来调用父类的其他构造方法</p>
<p>重写(Override):</p>
<ol>
<li>要求方法名相同、参数列表相同以及返回值类型相同，从Java5开始允许 返回子类类型。 </li>
<li> 要求方法的访问权限不能变小，可以相同或者变大。 </li>
<li> 要求方法不能抛出更大的异常(异常机制)。</li>
</ol>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>常用的访问控制符</p>
<p><a href="https://imgtu.com/i/2CAd58"><img src="https://z3.ax1x.com/2021/05/26/2CAd58.png" alt="2CAd58.png" style="zoom:50%;" /></a></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>基本概念 : final本意为”最终的、不可改变的”，可以修饰类、成员方法以及成员变量</p>
<p>使用方式:</p>
<p>​    1.final关键字修饰类体现在该类不能被继承</p>
<p>​    2.final关键字修饰成员方法体现在该方法不能被重写但可以被继承。</p>
<p>​    3.final关键字修饰成员变量体现在该变量必须初始化且不能改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>  String AB = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="comment">// 也可以在代码块中定义常量,当然在构造函数中也行</span></span><br><span class="line"><span class="keyword">final</span> String CD;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.CD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量（constant）：在以后的开发中很少单独使用final关键字来修饰成员变量，通常使用 public static final关键字共同修饰成员变量来表达常量的含义，命名字母一般大写且下划线分开</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的语法格式： 父类类型 引用变量名 = new 子类类型() ；</p>
<p>特点:</p>
<p>​    1.当父类类型的引用指向子类类型的对象时，父类类型的引用可以直接调 用父类独有的方法。</p>
<p>​    2.当父类类型的引用指向子类类型的对象时，父类类型的引用不可以直接 调用子类独有的方法。</p>
<p>​    3.对于父子类都有的非静态方法来说，编译阶段调用父类版本，运行阶段 调用子类重写的版本（动态绑定）</p>
<p>​    4.对于父子类都有的静态方法来说，编译和运行阶段都调用父类版本</p>
<p>对于第二点，如果要调用子类独有的方法，可强制类型转换(向下转型)，将父类型转换成子类型，若强转目标类型不是该引用类型的真正指向的类型，编译会通过，但是运行阶段会发生类型转换异常ClassCastException。为了避免这种情况发生，可以在转换之前判断： if(引用变量 instanceof 数据类型) </p>
<p>多态的实际意义 :  在于屏蔽不同子类的差异性实现通用的编程带来不同的 效果。</p>
<h1 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h1><h2 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h2><p>抽象方法: 主要指不能具体实现的方法并且使用abstract关键字修饰，也就 是没有方法体。</p>
<p>抽象类 : 类主要指不能具体实例化的类并且使用abstract关键字修饰，也就是 不能创建对象.</p>
<p>抽象类与抽象方法的关系:</p>
<p>​    1.抽象类中可以有成员变量、构造方法、成员方法； </p>
<p>​    2.抽象类中可以没有抽象方法，也可以有抽象方法； </p>
<p>​    3.拥有抽象方法的类必须是抽象类，因此真正意义上的抽象类应该是具有 抽象方法并且使用abstract关键字修饰的类。</p>
<p>实际意义 : </p>
<p>​    1.抽象类的实际意义不在于创建对象而在于被继承。 </p>
<p>​    2.当一个类继承抽象类后必须重写抽象方法，否则该类也变成抽象类，也 就是抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</p>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><p>接口是一种比抽象类还抽象的类，体现在所有方法都为抽象方法。</p>
<p>接口与抽象类之间的关系:</p>
<p><a href="https://imgtu.com/i/2CaZMd"><img src="https://z3.ax1x.com/2021/05/27/2CaZMd.png" alt="2CaZMd.png" style="zoom:50%;" /></a></p>
<p>接口与类的主要区别:</p>
<p>1.定义抽象类的关键字是abstract class，而定义接口的关键字是interface。 </p>
<p>2.继承抽象类的关键字是extends，而实现接口的关键字是implements。 </p>
<p>3.继承抽象类支持单继承，而实现接口支持多实现。 </p>
<p>4.抽象类中可以有构造方法，成员变量，成员方法，而接口中只能有抽象方法与常量。  </p>
<p>5.抽象类中增加方法时子类可以不用重写，而接口中增加方法时实现类需 要重写（Java8以前的版本）。 </p>
<p>6.从Java8开始增加新特性，接口中允许出现非抽象方法和静态方法，但非 抽象方法需要使用default关键字修饰。 </p>
<p>7.从Java9开始增加新特性，接口中允许出现私有方法。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类 （Inner），而这个内部类所在的类叫做外部类（Outer）</p>
<h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>-直接将一个类的定义放在另外一个类的类体中。</p>
<p>使用方式:</p>
<p>​    1.普通内部类和普通类一样可以定义成员变量、成员方法以及构造方法等</p>
<p>​    2.如果内部类访问外部类中与本类内部同名的成员变量或方法时，需要使 用this关键字。</p>
<p>​    3. 普通内部类需要使用外部类对象来创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先创建外部类</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">// 根据外部类创建内部类</span></span><br><span class="line">Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>- 使用static关键字修饰的内部类，隶属于类层级</p>
<p>使用方式:</p>
<p>​    1.静态内部类不能直接访问外部类的非静态成员。</p>
<p>​    2.如果静态内部类访问外部类中与本类内同名的成员变量或方法时，需要 使用类名.的方式访问 </p>
<p>​    3. 静态内部类可以直接创建对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Inner inner = <span class="keyword">new</span>  Outer.Inner();</span><br></pre></td></tr></table></figure>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul>
<li>直接将一个类的定义放在方法体的内部时</li>
</ul>
<p>使用方式:</p>
<p>​    1.局部内部类只能在该方法的内部可以使用。 </p>
<p>​    2.局部内部类可以在方法体内部直接创建对象。 </p>
<p>​    3.局部内部类不能使用访问控制符和static关键字修饰符,直接 class 类名{ … } 即可</p>
<p>​    4.局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内 部类和局部变量的声明周期不同所致</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> - 就是指没有名字的内部类</p>
<p>语法格式 : 接口/父类类型 引用变量名 = new 接口/父类类型() { 方法的重写 }；</p>
<h2 id="枚举类（enum）"><a href="#枚举类（enum）" class="headerlink" title="枚举类（enum）"></a>枚举类（enum）</h2><p>在日常生活中这些事物的取值只有明确的几个固定值，此时描述这些事 物的所有值都可以一一列举出来，而这个列举出来的类型就叫做枚举类 型。</p>
<p>用class模拟写一个枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个方向类枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="comment">// 对外暴露4个类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction UP = <span class="keyword">new</span> Direction(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction DOWN = <span class="keyword">new</span> Direction(<span class="string">&quot;向下&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction LEFT = <span class="keyword">new</span> Direction(<span class="string">&quot;向左&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction RIGHT = <span class="keyword">new</span> Direction(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line">	<span class="comment">// 构造方法(必须是私有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类的定义:</p>
<p>​    1.使用public static final表示的常量描述较为繁琐，使用enum关键字来定 义枚举类型取代常量，枚举类型是从Java5开始增加的一种引用数据类型。 </p>
<p>​    2.枚举值就是当前类的类型，也就是指向本类的对象，默认使用public static final关键字共同修饰，因此采用 枚举类型. 的方式调用。 </p>
<p>​    3.枚举类可以自定义构造方法，但是构造方法的修饰符必须是private，默 认也是私有的。</p>
<p>定义一个枚举类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DirectionEnum</span> <span class="keyword">implements</span> <span class="title">Dir</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义枚举类暴露的类型个数,必须放在第一行</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>) ;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DirectionEnum</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的枚举类都继承自java.lang.Enum类，常用方法如下:</p>
<p><a href="https://imgtu.com/i/2CBb38"><img src="https://z3.ax1x.com/2021/05/27/2CBb38.png" alt="2CBb38.png" style="zoom:50%;" /></a></p>
<p>枚举类实现接口后需要重写抽象方法，而重写方法的方式有两种：</p>
<p>​    1.重写 一个</p>
<p>​    2.每个枚举对象都重写。(匿名内部类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UP(<span class="string">&quot;向上&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向上移动！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, DOWN(<span class="string">&quot;向下&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向下移动！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解（annotation）"><a href="#注解（annotation）" class="headerlink" title="注解（annotation）"></a>注解（annotation）</h2><p>又叫标注,从Java5开始增加的一种引用数据类型。注解本质上就是代码中的特殊标记，通过这些标记可以在编译、类加载、 以及运行时执行指定的处理。自动继承java.lang.annotation.Annotation接口</p>
<p>注解的使用方式:</p>
<p>参数成员类型只能是八 种基本数据类型、String类型、Class类型、enum类型及Annotation类型.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default表示默认值</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hui&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>可以注解到注解上的注解，或者说元注解是一种基本注解</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>说明该注解的生命周期，取值如下:</p>
<p>RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时 它将被丢弃忽视。</p>
<p>RetentionPolicy.CLASS： 注解只被保留到编译进行的时候，它并不会被加 载到 JVM 中，默认方式。</p>
<p>RetentionPolicy.RUNTIME: 注解可以保留到程序运行的时候，它会被加载 进入到 JVM 中，所以在程序运行时可以获取到它们</p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>用于指定被该注解将被javadoc工具提取成文档。 </p>
<p>定义为@Documented的注解必须设置Retention值为RUNTIME</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>用于指定被修饰的注解能用于哪些元素的修饰</p>
<p><a href="https://imgtu.com/i/2CrTl8"><img src="https://z3.ax1x.com/2021/05/27/2CrTl8.png" alt="2CrTl8.png" style="zoom:67%;" /></a></p>
<p>从Java8开始参数类型ElementType枚举值增加了两个：</p>
<p>ElementType.TYPE_PARAMETER ：该注解能写在类型变量的声明 语句中，如：泛型。</p>
<p>ElementType.TYPE_USE : 该注解能写在使用类型的任何语句中。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>如果一个超类被该注解标记，子类没有被任何注解应用时，则子类就继承超类的注解。</p>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>表示自然可重复使用的含义，从Java8开始增加的新特性</p>
<p>java8之前如果要重复使用一个注解，需要这样定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要重复使用的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义另一个注解，成员参数为上面的注解的数组类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过数组的方式使用重复注解</span></span><br><span class="line"><span class="meta">@MyAnnotations(</span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        @MyAnnotation(value=&quot;怪狗狗&quot;),</span></span><br><span class="line"><span class="meta">        @MyAnnotation(value=&quot;oddDog&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>java8有了@Repeatable元注解使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要重复使用的注解添加该元注解,参数为数组注解的class文件</span></span><br><span class="line"><span class="meta">@Repeatable(value = MyAnnotations.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用重复注解，注解调用两次即可</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;怪狗狗&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;oddDog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见的预制注解"><a href="#常见的预制注解" class="headerlink" title="常见的预制注解"></a>常见的预制注解</h3><p>​    预制注解就是Java语言自身提供的注解，具体如下:</p>
<p><a href="https://imgtu.com/i/2C6Mod"><img src="https://z3.ax1x.com/2021/05/27/2C6Mod.png" alt="2C6Mod.png" style="zoom:50%;" /></a></p>
<p><a href="https://imgtu.com/i/2C6GSP"><img src="https://z3.ax1x.com/2021/05/27/2C6GSP.png" alt="2C6GSP.png" style="zoom:50%;" /></a></p>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心类库</title>
    <url>/2021/05/30/java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><p><strong>基本概念</strong> : java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间 接子类。 如果定义一个Java类时没有使用extends关键字声明其父类，则其父类为 java.lang.Object 类。 Object类定义了“对象”的基本行为, 被子类默认继承。</p>
<p><strong>常用方法</strong> <a id="more"></a></p>
<ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>方法声明</th>
<th align="left">功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object()</td>
<td align="left">使用无参方式构造对象</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td align="left">用于判断调用对象是否与参数对象相等。 该方法默认比较两个对象的地址是否相等，与 == 运算符的结果一致 若希望比较两个对象的内容，则需要重写该方法。 若该方法被重写后，则应该重写hashCode方法来保证结果的一致 性。</td>
</tr>
<tr>
<td>int hashCode()</td>
<td align="left">用于获取调用对象的哈希码值(内存地址的编号)。 若两个对象调用equals方法相等，则各自调用该方法的结果必须相 同 若两个调用对象equals方法不相等，则各自调用该方法的结果应该 不相同。 为了使得该方法与equals方法保持一致，需要重写该方法。</td>
</tr>
<tr>
<td>String toString()</td>
<td align="left">用于获取调用对象的字符串形式 该方法默认返回的字符串为：包名.类名@哈希码值的十六进制 为了返回更有意义的数据，需要重写该方法 使用print或println打印引用或字符串拼接引用都会自动调用该方法</td>
</tr>
<tr>
<td>Class getClass()</td>
<td align="left">用于返回调用对象执行时的Class实例，反射机制使用</td>
</tr>
</tbody></table>
</li>
</ul>
<p>重写 equals()与hashCode() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == obj) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">        <span class="comment">// 通过 id 判断两类型是否相等</span></span><br><span class="line">        <span class="comment">// return this.getId() == ((Student) obj).getId();</span></span><br><span class="line">        <span class="comment">// 通过 name 判断两类型是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(((Student) obj).getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写hashCode,返回当前对象的name的哈希值并加上一些别的计算</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return 12 * 30 * this.getId();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span> * <span class="number">30</span> * <span class="keyword">this</span>.getName().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p><strong>概念</strong>  : 通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变 量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装 类。</p>
<p><strong>分类</strong> :  Byte , Short , Integer , Long , Float , Double , Character , Boolean</p>
<p>包装类的常用常量 :</p>
<table>
<thead>
<tr>
<th>常量类型和名称</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>public static final T  SIZE</td>
<td>表示 T 类型采用二进制补码形式的位数</td>
</tr>
<tr>
<td>public static final T BYTES</td>
<td>表示 T 类型所占的字节个数</td>
</tr>
<tr>
<td>public static final Class TYPE</td>
<td>表示 T 类型的Class实例</td>
</tr>
</tbody></table>
<p>包装类的常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Integer valueOf (xx i)</td>
<td>根据参数指定基本数据类型得到包装类xx的对象</td>
</tr>
<tr>
<td>xx xxValue()</td>
<td>将包装类xx转变成相对应的基本数据类型</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较调用对象与参数指定的对象是否相等</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回描述调用对象数值的字符串形式</td>
</tr>
<tr>
<td>static xxx parsexxx(String s)</td>
<td>将字符串类型转换为xxx基本数据类型并返回</td>
</tr>
<tr>
<td>static String toString(xxx i)</td>
<td>获取包装类的字符串的形式</td>
</tr>
</tbody></table>
<p><strong>装箱和拆箱的概念</strong></p>
<p>在Java5发布之前使用包装类对象进行运算时，需要较为繁琐的“拆箱”和“装箱”操作；即运算前先将 包装类对象拆分为基本类型数据，运算后再将结果封装成包装类对象。 从Java5开始增加了自动拆箱和自动装箱的功能。</p>
<h2 id="Integer-类的基本使用"><a href="#Integer-类的基本使用" class="headerlink" title="Integer 类的基本使用"></a>Integer 类的基本使用</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static String toBinaryString(int i)</td>
<td>获取参数指定整数的二进制字符串形式</td>
</tr>
<tr>
<td>static String toHexString(int i)</td>
<td>获取参数指定整数的十六进制字符串形式</td>
</tr>
<tr>
<td>static String toOctalString(int i)</td>
<td>获取参数指定整数的八进制字符串形式</td>
</tr>
</tbody></table>
<p><strong>自动装箱池</strong> </p>
<p>在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用 该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率</p>
<h2 id="Character-类的基本使用"><a href="#Character-类的基本使用" class="headerlink" title="Character 类的基本使用"></a>Character 类的基本使用</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static boolean isUpperCase(char ch)</td>
<td>判断参数指定字符是否为大写字符</td>
</tr>
<tr>
<td>static boolean isLowerCase(char ch)</td>
<td>判断参数指定字符是否为小写字符</td>
</tr>
<tr>
<td>static boolean isDigit(char ch)</td>
<td>判断参数指定字符是否为数字字符</td>
</tr>
<tr>
<td>static char toUpperCase(char ch)</td>
<td>将参数指定的字符转换为大写字符</td>
</tr>
<tr>
<td>static char toLowerCase(char ch)</td>
<td>将参数指定的字符转换为小写字符</td>
</tr>
</tbody></table>
<p>（其他包装类的用法跟Integer的用法基本相同，这里就不过多描述了）</p>
<h1 id="数学处理类"><a href="#数学处理类" class="headerlink" title="数学处理类"></a>数学处理类</h1><h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p> java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static int max(int a, int b)</td>
<td>返回两个参数中的最大值</td>
</tr>
<tr>
<td>static int min(int a, int b)</td>
<td>返回两个参数中的最小值</td>
</tr>
<tr>
<td>static double pow(double a, double b)</td>
<td>返回第一个参数的幂</td>
</tr>
<tr>
<td>static int abs(int a)</td>
<td>返回参数指定数值的绝对值</td>
</tr>
<tr>
<td>static long round(double a)</td>
<td>返回参数四舍五入的结果</td>
</tr>
<tr>
<td>static double sqrt(double a)</td>
<td>返回参数的平方根</td>
</tr>
<tr>
<td>static double random()</td>
<td>返回0.0到1.0的随机数</td>
</tr>
</tbody></table>
<h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>由于float类型和double类型在运算时可能会有误差，若希望实现精确运算则借助 java.math.BigDecimal类型加以描述。</p>
<p>BigDecimal(String val) 根据参数指定的字符串来构造对象</p>
<p>add 、 subtract 、 multiply 、 divide 分别实现加减乘除</p>
<h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。</p>
<p>BigInteger(String val) 根据参数指定的字符串来构造对象</p>
<p>add 、subtract 、multiply 、 divide 、remainder 、divideAndRemainder分别实现加减乘除、取余、取商和余数</p>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><strong>概述</strong> ：</p>
<ul>
<li><p>java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描 述。</p>
</li>
<li><p>该类由final关键字修饰，表示该类不能被继承。 </p>
</li>
<li><p>从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一 些空间。 </p>
</li>
<li><p>该类描述的字符串内容是个<strong>常量</strong>不可更改，因此可以被共享使用。</p>
</li>
</ul>
<p><strong>常量池的概念(原理)</strong></p>
<p> 由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量 池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对 象，从而提高了性能。（方法区）</p>
<p><strong>构造方法使用</strong></p>
<p>可传递 byte[] 与 char[] 数组 ，也能指定数组的起始位置与结束位置</p>
<p>也能传递String  xx ，根据参数指定的字符串内容来构造对象，新创建对象为参 数对象的副本。</p>
<p>这时在方法区有一个字符串 xx ，而栈区中也有一个 String对象 并指向方法区的xx。</p>
<p><strong>常用方法</strong> </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回字符串本身</td>
</tr>
<tr>
<td>byte[] getBytes()</td>
<td>将当前字符串内容转换为byte数组并返回</td>
</tr>
<tr>
<td>char[] toCharArray()</td>
<td>用于将当前字符串内容转换为char数组并返回</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串字符序列的长度</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>int compareTo(String anotherString)</td>
<td>用于比较调用对象和参数对象的大小关系</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>用于判断当前字符串是否包含参数指定的内容</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>返回字符串的大写形式</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回去掉前导和后继空白的字符串</td>
</tr>
<tr>
<td>boolean startsWith(String prefix)</td>
<td>判断字符串是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffix)</td>
<td>判断字符串是否以参数字符串结尾</td>
</tr>
</tbody></table>
<p><strong>有关查找的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>char charAt(int index)</td>
<td>方法charAt用于返回字符串指定位置的字符</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>在字符串中检索str返回其第一次出现的位置，若找不到返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>表示从字符串的fromIndex位置开始检索str第一次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>返回str指定字符串最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>用于从fromIndex位置开始反向搜索的第一次出现的下标。</td>
</tr>
<tr>
<td>String substring(int a, int b)</td>
<td>截取 a 到 b 下标的字符串</td>
</tr>
<tr>
<td>String substring(int  index)</td>
<td>从index开始截取到最后</td>
</tr>
</tbody></table>
<p><strong>正则表达式相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean matches(String regex)</td>
<td>判断当前正在调用的字符串是否匹配参数指定的正则表达式规则</td>
</tr>
<tr>
<td>String[] split(String regex)</td>
<td>参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>使用参数newChar替换此字符串中出现的所有参数oldChar</td>
</tr>
<tr>
<td>String replaceFirst(String regex,String replacement)</td>
<td>替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex,String replacement)</td>
<td>将字符串中匹配正则表达式regex的字符串替换成replacement</td>
</tr>
</tbody></table>
<h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p><strong>基本概念</strong></p>
<ul>
<li><p>由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串 时，只能单独申请和存储，此时会造成内存空间的浪费。 </p>
</li>
<li><p>为了解决上述问题，可以使用java.lang.StringBuilder类和java.lang.StringBuffer类来描述字符序 列可以改变的字符串</p>
</li>
<li><p>StringBuffer类是从jdk1.0开始存在，属于线程安全的类，因此效率比较低。 StringBuilder类是从jdk1.5开始存在，属于非线程安全的类，效率比较高</p>
</li>
</ul>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>使用无参方式构造对象，容量为16</td>
</tr>
<tr>
<td>StringBuilder(int capacity)</td>
<td>根据参数指定的容量来构造对象，容量为参数指定大小</td>
</tr>
<tr>
<td>StringBuilder(String str)</td>
<td>根据参数指定的字符串来构造对象，容量为：16+字符串长度</td>
</tr>
</tbody></table>
<p><strong>成员方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int capacity()</td>
<td>用于返回调用对象的容量</td>
</tr>
<tr>
<td>int length()</td>
<td>用于返回字符串的长度，也就是字符的个数</td>
</tr>
<tr>
<td>StringBuilder insert(int offset, String str)</td>
<td>插入字符串并返回调用对象的引用，就是自己。</td>
</tr>
<tr>
<td>StringBuilder append(String str)</td>
<td>追加字符串</td>
</tr>
<tr>
<td>StringBuilder deleteCharAt(int index)</td>
<td>将当前字符串中下标为index位置的单个字符删除</td>
</tr>
<tr>
<td>StringBuilder delete(int start，int end)</td>
<td>删除字符串</td>
</tr>
<tr>
<td>StringBuilder replace(int start，int end，String str)</td>
<td>替换字符串</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>字符串反转</td>
</tr>
</tbody></table>
<p><strong>注意</strong> ：</p>
<ul>
<li><p>作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值</p>
</li>
<li><p>StringBuilder的很多方法的返回值均为StringBuilder类型。这些方法的返回语句均为：return this。 由此可见，这些方法在对StringBuilder所封装的字符序列进行改变后又返回了该对象的引用。基 于这样设计的目的在于可以连续调用。</p>
</li>
</ul>
<h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><p>System中的  currentTimeMillis()    返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</p>
<h2 id="java8-之前的日期类型"><a href="#java8-之前的日期类型" class="headerlink" title="java8 之前的日期类型"></a>java8 之前的日期类型</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.util.Date类主要用于描述特定的瞬间，也就是年月日时分秒，可以精确到毫秒</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Date()</td>
<td>使用无参的方式构造对象，也就是当前系统时间</td>
</tr>
<tr>
<td>Date(long date)</td>
<td>根据参数指定毫秒数构造对象， 参数为距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>long getTime()</td>
<td>获取调用对象距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>void setTime(long time)</td>
<td>设置调用对象为距离基准时间time毫秒的时间点</td>
</tr>
</tbody></table>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p>搭配Date类的使用，将日期格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建  SimpleDateFormat  对象并指定格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 格式化日期</span></span><br><span class="line">String time = sdf.format(date);</span><br><span class="line"><span class="comment">// 将String格式的日期变成Date类型</span></span><br><span class="line">Date date = sdf.parse(time);</span><br></pre></td></tr></table></figure>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li>java.util.Calender类主要用于描述特定的瞬间，取代Date类中的过时方法实现全球化。</li>
<li> 该类是个抽象类，因此不能实例化对象，其具体子类针对不同国家的日历系统，其中应用最广泛的 是GregorianCalendar（格利高里日历），对应世界上绝大多数国家/地区使用的标准日历系统</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Calendar getInstance()</td>
<td>用于获取Calendar类型的引用</td>
</tr>
<tr>
<td>void set(int year, int month, int date, int hourOfDay, intminute, int second)</td>
<td>用于设置年月日时分秒信息</td>
</tr>
<tr>
<td>Date getTime()</td>
<td>用于将Calendar类型转换为Date类型</td>
</tr>
<tr>
<td>void set(int field, int value)</td>
<td>设置指定字段 (例如Calendar.YEAR) 的数值</td>
</tr>
<tr>
<td>void add(int field, int amount)</td>
<td>向指定字段增加数值</td>
</tr>
</tbody></table>
<h2 id="java8-中的日期类型"><a href="#java8-中的日期类型" class="headerlink" title="java8 中的日期类型"></a>java8 中的日期类型</h2><h3 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h3><p>LocalDate() + “T” + LocalTime()</p>
<p><strong>常用方法</strong> </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDateTime now()</td>
<td>从默认时区的系统时间中获取当前日期时间</td>
</tr>
<tr>
<td>static LocalDateTime of(int year, int month, intdayOfMonth, int hour, int minute, int second)</td>
<td>根据参数指定的年月日时分秒信息来设置日期时间</td>
</tr>
<tr>
<td>int getYear()</td>
<td>获取年份字段的数值</td>
</tr>
<tr>
<td>LocalDateTime withYear(int year)</td>
<td>设置为参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime plusYears(long years)</td>
<td>加上参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime minusYears(long years)</td>
<td>减去参数指定的年</td>
</tr>
</tbody></table>
<p><strong>注</strong>：后面4个方法，对于月日时分秒方法也一样</p>
<h3 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h3><p>java.time.Instant类主要用于描述瞬间的时间点信息，不会自动添加时区</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Instant now()</td>
<td>从系统时钟上获取当前时间OffsetDateTime</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>将此瞬间与偏移量组合以创建偏移日期时间</td>
</tr>
<tr>
<td>static Instant ofEpochMilli(long epochMilli)</td>
<td>根据参数指定的毫秒数来构造对象，参数为距离1970年1月1</td>
</tr>
<tr>
<td>long toEpochMilli()</td>
<td>获取距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间，不添加时区</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line"><span class="comment">// 添加8小时时区</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"><span class="comment">// 变成毫秒数</span></span><br><span class="line"><span class="keyword">long</span> l = instant.toEpochMilli();</span><br><span class="line"><span class="comment">// 根据毫秒数获取 instant对象，参数为距离1970年1月1</span></span><br><span class="line">Instant instant2 = Instant.ofEpochMilli(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h3><p>java.time.format.DateTimeFormatter类主要用于格式化和解析日期</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static DateTimeFormatter ofPattern(String pattern)</td>
<td>根据参数指定的模式来获取对象</td>
</tr>
<tr>
<td>String format(TemporalAccessor temporal)</td>
<td>将参数指定日期时间转换为字符串</td>
</tr>
<tr>
<td>TemporalAccessor parse(CharSequence text)</td>
<td>将参数指定字符串转换为日期时间</td>
</tr>
</tbody></table>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>java.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，因此该接口里定义的方法 既可用于操作List集合，也可用于操作Queue集合和Set集合</p>
<p><a href="https://imgtu.com/i/2VhVyD"><img src="https://z3.ax1x.com/2021/05/30/2VhVyD.png" alt="2VhVyD.png" style="zoom: 67%;" /></a></p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向集合中添加对象</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>用于将参数指定集合c中的所有元素添加到当前集合中</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断是否包含指定对象</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>判断是否包含参数指定的所有对象</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>保留当前集合中存在且参数集合中存在的所有对象（交集）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中删除对象</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>从集合中删除参数指定的所有对象</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>用于获取子List</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合</td>
</tr>
<tr>
<td>int size()</td>
<td>返回包含对象的个数</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>判断是否相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取当前集合的哈希码值</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>将集合转换为数组</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>获取当前集合的迭代器</td>
</tr>
</tbody></table>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p><strong>概念</strong> </p>
<ul>
<li>java.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。</li>
<li> java.util.Collection接口继承Iterator接口，因此所有实现Collection接口的实现类都可以使用该迭 代器对象。</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断集合中是否有可以迭代/访问的元素</td>
</tr>
<tr>
<td>E next()</td>
<td>用于取出一个元素并指向下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>用于删除访问到的最后一个元素</td>
</tr>
</tbody></table>
<ul>
<li>用迭代器打印 <strong>toString()</strong>  小案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合的toString()写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">MyToString</span><span class="params">(Iterator iterator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    s.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">            <span class="keyword">return</span> s.append(next+<span class="string">&quot;]&quot;</span>).toString();</span><br><span class="line">        s.append(next+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach 为增强版的for循环，也是经典迭代的“简化版”。</li>
</ul>
<p><strong><em>注</em></strong> ：在迭代的过程中不能使用集合中的remove方法，否则会出现并发修改异常 :UnsupportedOperationException</p>
<p>要使用iterator中的remove方法</p>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li><p>java.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。 </p>
</li>
<li><p>该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。 </p>
</li>
<li><p><strong><em>ArrayList</em></strong>类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。 </p>
</li>
<li><p><strong><em>LinkedList</em></strong>类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。 </p>
</li>
<li><p>可以认为ArrayList和LinkedList的方法在逻辑上完全一样，只是在性能上有一定的差别，ArrayList 更适合于随 机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。 </p>
</li>
<li><p><strong><em>Stack</em></strong>类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的 数据结构，叫做栈(last in first out LIFO)。 </p>
</li>
<li><p><strong><em>Vector</em></strong>类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的 类，效率比较低，以后开发中基本不用。</p>
<p>Arrays.asList()     可快速获取一个List集合</p>
</li>
</ul>
<h3 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>java.util.Queue集合是Collection集合的子集合，与List集合属于平级关系。 </li>
<li>该集合的主要用于描述具有先进先出特征的数据结构，叫做队列(first in first out FIFO)。 </li>
<li>该集合的主要实现类是<strong>LinkedList</strong>类，因为该类在增删方面比较有优势。</li>
</ul>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean offer(E e)</td>
<td>将一个对象添加至队尾，若添加成功则返回true</td>
</tr>
<tr>
<td>E poll()</td>
<td>从队首删除并返回一个元素</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队首的元素（但并不删除）</td>
</tr>
</tbody></table>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>java.util.Set集合是Collection集合的子集合，与List集合平级。 </li>
<li>该集合中元素没有先后放入次序，且不允许重复。 </li>
<li>该集合的主要实现类是：HashSet类 和 TreeSet类以及LinkedHashSet类。 </li>
<li><strong>HashSet</strong>类的底层是采用哈希表进行数据管理的。 </li>
<li><strong>TreeSet</strong>类的底层是采用红黑树进行数据管理的。 </li>
<li><strong>LinkedHashSet</strong>类与HashSet类的不同之处在于内部维护了一个双向链表，链表中记录了元 素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li>
</ul>
<p><strong>元素放入HashSet集合的原理</strong></p>
<ul>
<li>使用元素调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算出该元素在数组中的索 引位置。 </li>
<li>若该位置没有元素，则将该元素直接放入即可。 </li>
<li>若该位置有元素，则使用新元素与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放 入末尾。 </li>
<li>若新元素与已有元素的哈希值相同，则使用新元素调用equals方法与已有元素依次比较。 </li>
<li>若相等则添加元素失败，否则将元素直接放入即可。</li>
</ul>
<p><strong><em>思考</em></strong>   :  为什么要求重写equals方法后要重写hashCode方法呢?</p>
<p>当两个元素调用equals方法相等时证明这两个元素相同，重写hashCode方法后保证这两个元 素得到的哈希码值相同，由同一个哈希算法生成的索引位置相同，此时只需要与该索引位置已有元 素比较即可，从而提高效率并避免重复元素的出现。</p>
<p><strong><em>TreeSet集合的概念</em></strong></p>
<p>由于TreeSet集合的底层采用红黑树进行数据的管理，当有新元素插入到TreeSet集合时，需要使 用新元素与集合中已有的元素依次比较来确定新元素的合理位置。 </p>
<p>比较元素大小的规则有两种方式： </p>
<ul>
<li>使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口； </li>
<li>使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparator接口； </li>
<li>自然排序的规则比较单一，而比较器的规则比较多元化，而且比较器优先于自然排序；</li>
</ul>
<p><strong><em>自然排序规则</em></strong> 让一个Student类实现Comparable接口案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 重写比较的方法，返回正数表示当前对象大，负数表示小，0表示一样大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 名称一样的情况比较id(升序)</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="keyword">this</span>.getId() - o.getId() : i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>比较器规则</em></strong>   使用匿名内部类，也可以用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 名称一样的情况比较id(升序)</span></span><br><span class="line">        <span class="keyword">int</span> i = o1.getName().compareTo(o2.getName());</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? o1.getId() - o2.getId() : i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="泛型机制"><a href="#泛型机制" class="headerlink" title="泛型机制"></a>泛型机制</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此 从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换， 而强制类型转换可能会引发类型转换异常。 </li>
<li>为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt; 的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。</li>
<li> 泛型只在编译时期有效，在运行时期不区分是什么类型。</li>
</ul>
<p><strong><em>自定义泛型类</em></strong></p>
<p><strong><em>注</em></strong> :如果一个方法中使用了泛型的类型，则该方法不能用static修饰，因为泛型是创建对象时才能确定的，所以不能使用静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// E 表示泛型，可以传基本数据类型除外传任何类型 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> E gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>继承该泛型类</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没指定泛型类型，不继承泛型，父类泛型为Object类型</span></span><br><span class="line"><span class="comment">//public class SubPerson extends Person &#123;</span></span><br><span class="line"><span class="comment">// 指定泛型类型，不继承泛型，父类泛型为指定的类型，这里是Boolean类型</span></span><br><span class="line"><span class="comment">//public class SubPerson extends  Person&lt;Boolean&gt;&#123;</span></span><br><span class="line"><span class="comment">// 继承了该泛型，当然也可以有自己的泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; <span class="keyword">extends</span>  <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 使用自己的泛型</span></span><br><span class="line">    <span class="keyword">private</span> E type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>创建泛型对象</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定泛型，表示Object类型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 左边传入需要的类型，右边可以省略不写</span></span><br><span class="line">Person&lt;Integer&gt; p2 = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">SubPerson&lt;String,Boolean&gt; s= <span class="keyword">new</span> SubPerson();</span><br></pre></td></tr></table></figure>
<p><strong><em>自定义泛型方法</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型方法,该泛型方法与类中的泛型没有关系，使用该方法时，实参是什么类型该泛型就是什么类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">fan</span><span class="params">(X param)</span></span>&#123;</span><br><span class="line">    System.out.println(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>通配符的使用</em></strong>      （了解即可）</p>
<p>有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了。 如：之前传入的类型要求为Integer类型，但是后来业务需要Integer的父类Number类也可以传 入。 </p>
<p>泛型中有三种通配符形式： </p>
<ul>
<li><?>无限制通配符：表示我们可以传入任意类型的参数。 
</li>
<li><? extends E>表示类型的上界是E，只能是E或者是E的子类。 
</li>
<li><? super E>表示类型的下界是E，只能是E或者是E的父类。

</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://imgtu.com/i/2Vh8l8"><img src="https://z3.ax1x.com/2021/05/30/2Vh8l8.png" alt="2Vh8l8.png"></a></p>
<p><strong><em>基本概念</em></strong></p>
<ul>
<li>该集合中key是不允许重复的，而且一个key只能对应一个value。 </li>
<li>该集合的主要实现类有：HashMap类、TreeMap类、LinkedHashMap类、Hashtable类、 Properties类。 </li>
<li><strong><em>HashMap</em></strong>类的底层是采用哈希表进行数据管理的。 </li>
<li><strong><em>TreeMap</em></strong>类的底层是采用红黑树进行数据管理的。</li>
<li><strong><em>LinkedHashMap</em></strong>类与HashMap类的不同之处在于内部维护了一个双向链表，链表中记录了 元素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。 </li>
<li><strong><em>Hashtable</em></strong>类是古老的HashMap实现类，与HashMap类相比属于线程安全的类，且不允许null作 为key或者value的数值。 </li>
<li><strong><em>Properties</em></strong>类是Hashtable类的子类，该对象用于处理属性文件，key和value都是String类 型的。 </li>
<li>Map集合是面向查询优化的数据结构, 在大数据量情况下有着优良的查询性能。 经常用于根据key检索value的业务场景。</li>
</ul>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key, V value)</td>
<td>将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对应的Value，返回值为该Key原来所对应的</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td>返回与参数Key所对应的Value对象，如果不存在则返回null</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据参数指定的key进行删除</td>
</tr>
<tr>
<td>boolean containsKey(Objectkey)</td>
<td>判断集合中是否包含指定的Key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合中是否包含指定的Value</td>
</tr>
</tbody></table>
<p><strong><em>3种遍历的方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Set keySet()</td>
<td>返回此映射中包含的键的Set视图</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回此映射中包含的值的Set视图</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>返回此映射中包含的映射的Set视图</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// 获取所有key值，并遍历</span></span><br><span class="line">Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer i :set) &#123;</span><br><span class="line">    System.out.println(i+<span class="string">&quot;=&quot;</span>+map.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有value值，并遍历</span></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line"><span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有的键值对，并遍历</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entry = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; e:entry) &#123;</span><br><span class="line">    System.out.println(e.getKey()+<span class="string">&quot;=&quot;</span>+e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>元素放入HashMap集合的原理</em></strong>     </p>
<ul>
<li>使用元素的key调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算在数组中的索引 位置。 </li>
<li>若该位置没有元素，则将该键值对直接放入即可。 </li>
<li>若该位置有元素，则使用key与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放入到最后。 </li>
<li>若key与已有元素的哈希值相同，则使用key调用equals方法与已有元素依次比较。 </li>
<li>若相等则将对应的value修改，否则将键值对直接放入即可。</li>
</ul>
<p><strong><em>Map中的相关常量</em></strong></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量是16。 </li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子是0.75。 </li>
<li>threshold：扩容的临界值，该数值为：容量*填充因子，也就是12。 </li>
<li>TREEIFY_THRESHOLD：若Bucket中链表长度大于该默认值则转化为红黑树存储，该数值是8。</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，该数值是64。</li>
</ul>
<h2 id="Colleciotns工具类"><a href="#Colleciotns工具类" class="headerlink" title="Colleciotns工具类"></a>Colleciotns工具类</h2><p><strong><em>概念</em></strong>  :   java.util.Collections类主要提供了对集合操作或者返回集合的静态方法。</p>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static &lt;T extends Object &amp; Comparable&lt;?super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td>
<td>将一个列表中的所有元素复制到另一个列表中</td>
</tr>
<tr>
<td>static void reverse(List&lt;?&gt; list)</td>
<td>反转指定列表中元素的顺序</td>
</tr>
<tr>
<td>static void shuffle(List&lt;?&gt; list)</td>
<td>使用默认的随机源随机置换指定的列表</td>
</tr>
<tr>
<td>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list)</td>
<td>根据其元素的自然顺序将指定列表按升序排序</td>
</tr>
<tr>
<td>static void sort(List list, Comparator&lt;? super T&gt; c)</td>
<td>根据指定比较器指定的顺序对指定列表进行排序</td>
</tr>
<tr>
<td>static void swap(List&lt;?&gt; list, int i, int j)</td>
<td>交换指定列表中指定位置的元素</td>
</tr>
<tr>
<td>static void fill(List&lt;?&gt; list, T value)</td>
<td>向list中填充值value</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy  将list中的值复制到list2中，</span></span><br><span class="line"><span class="comment">// 注意如果 list.size()&gt;list2.size()   会报错:IndexOutOfBoundsException  下标越界异常</span></span><br><span class="line"><span class="comment">// 所以初始化list2时，要先给定初始值，确保其 size() </span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(<span class="keyword">new</span> Integer[list.size()]);</span><br><span class="line">Collections.copy(list2,list);</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心类库plus</title>
    <url>/2021/06/03/java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93plus/</url>
    <content><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><p><strong>基本概念</strong></p>
<p>java.lang.Throwable类是Java语言中错误(Error)和异常(Exception)的超类。 <a id="more"></a></p>
<p>Error类主要用于描述Java虚拟机无法解决的严重错误，通常无法编码解决，如：JVM挂掉了 等。Exception类主要用于描述因编程错误或偶然外在因素导致的轻微错误，通常可以编码解决， 如：0作为除数等。</p>
<p><strong>异常Exception的分类</strong></p>
<ul>
<li>RuntimeException ： 运行时异常，也叫作非检测性异常</li>
<li>IOException和其他异常 ：其他异常，也叫作检测性异常，指在编译阶段都能 被编译器检测出来的异常。</li>
</ul>
<p><a href="https://imgtu.com/i/21VZYq"><img src="https://z3.ax1x.com/2021/06/03/21VZYq.png" alt="21VZYq.png"></a></p>
<p><strong>异常的捕获</strong></p>
<p>使用try{} catch(){}finally{} 捕获异常，其中可以有多个catch捕获异常，切记小类型发在大类型前面。finally中的代码无论如何都会执行，如果catch中出现了return ，会先执行finally中的代码块再返回去执行catch中的return。</p>
<p><strong>异常的抛出</strong></p>
<p>如 ： public void show() throws IOException{} ，可以抛出多个异常</p>
<p>如果子类重写父类的方法，只能抛出相同、更小的异常，或则不抛异常，进行捕获处理。</p>
<p><strong>自定义异常</strong></p>
<p>流程:</p>
<ul>
<li><p>继承Exception类或其子类</p>
</li>
<li><p>提供两个版本的构造方法，一个是无参构造方法，另外一个是字符串作为参数的构造方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异常的产生</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;年龄不合法!!!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>根据参数指定的路径名来构造对象</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>根据参数指定的父路径和子路径信息构造对象</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>根据参数指定的父抽象路径和子路径信息构造对象</td>
</tr>
</tbody></table>
<p><strong>获取文件相关信息的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>测试此抽象路径名表示的文件或目录是否存在</td>
</tr>
<tr>
<td>String getName()</td>
<td>用于获取文件的名称</td>
</tr>
<tr>
<td>long length()</td>
<td>返回由此抽象路径名表示的文件的长度</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>用于获取文件的最后一次修改时间</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>用于获取绝对路径信息</td>
</tr>
</tbody></table>
<p><strong>有关文件或目录操作的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean delete()</td>
<td>用于删除文件，当删除目录时要求是空目录</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>用于创建新的空文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>用于创建目录</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>用于创建多级目录</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断是否为文件</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断是否为目录</td>
</tr>
<tr>
<td>File[] listFiles()</td>
<td>获取该目录下的所有内容</td>
</tr>
<tr>
<td>File[] listFiles(FileFilter filter)</td>
<td>获取目录下满足筛选器的所有内容</td>
</tr>
</tbody></table>
<p><strong>获取一个目录下的所有内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个目录下的所有内容</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">       File[] files = f.listFiles();</span><br><span class="line">       <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">           <span class="comment">// 如果是目录，就递归调用该方法获取子文件</span></span><br><span class="line">           String name = file.getName();</span><br><span class="line">           <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;目录:&quot;</span>+name);</span><br><span class="line">               getAllFile(<span class="keyword">new</span> File(f,name));</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;文件:&quot;</span>+name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取a目录下的所有文本文件，listFiles()的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File a = <span class="keyword">new</span> File(<span class="string">&quot;c://a&quot;</span>);</span><br><span class="line"><span class="comment">// 将所有文本文件保存到 File 数组中，遍历该数组即可</span></span><br><span class="line">File[] files = a.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda 表达式写法</span></span><br><span class="line">File[] file2 = a.listFiles((File f)-&gt;f.getName().endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><strong>分类</strong></p>
<ul>
<li><p>按照读写数据的基本单位不同，分为 字节流 和 字符流。 </p>
<p>其中字节流主要指以字节为单位进行数据读写的流，可以读写任意类型的文件。 </p>
<p>其中字符流主要指以字符(2个字节)为单位进行数据读写的流，只能读写文本文件。 </p>
</li>
<li><p>按照读写数据的方向不同，分为 输入流 和 输出流（站在程序的角度）。 </p>
<p>其中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件。 </p>
<p>其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件。 </p>
</li>
<li><p>按照流的角色不同分为节点流和处理流。 </p>
<p>其中节点流主要指直接和输入输出源对接的流。 </p>
<p>其中处理流主要指需要建立在节点流的基础之上的流。</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/21nJbD"><img src="https://z3.ax1x.com/2021/06/03/21nJbD.png" alt="21nJbD.png" style="zoom:67%;" /></a></p>
<p><a href="https://imgtu.com/i/21n25j"><img src="https://z3.ax1x.com/2021/06/03/21n25j.png" alt="21n25j.png" style="zoom:67%;" /></a></p>
<h2 id="FileWriter与-FileReader"><a href="#FileWriter与-FileReader" class="headerlink" title="FileWriter与  FileReader"></a>FileWriter与  FileReader</h2><p>FileWriter类主要用于将文本内容写入到文本文件，FileReader 类主要用于从文本文件读取文本数据内容</p>
<p><strong>FileWriter常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FileWriter(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>FileWriter(String fileName, boolean append)</td>
<td>以追加的方式根据参数指定的文件名来构造对象</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写入单个字符</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>将指定字符数组中从偏移量off开始的len个字符写入此文件输出流</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>将cbuf.length个字符从指定字符数组写入此文件输出流中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p><strong>FileReader常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FileReader(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字符的数据并返回，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf, intoffset, int length)</td>
<td>从输入流中将最多len个字符的数据读入一个字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>从此输入流中将最多 cbuf.length 个字符的数据读入字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p><strong>拷贝,将a.text文件复制一份到b.text</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取输入输出流</span></span><br><span class="line">        FileReader r = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r = <span class="keyword">new</span> FileReader(<span class="string">&quot;c://a.text&quot;</span>);</span><br><span class="line">            w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;c://b.text&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝数据,一个一个字符的传递</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始拷贝...&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = r.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                w.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FileOutputStream-与-FileInputStream"><a href="#FileOutputStream-与-FileInputStream" class="headerlink" title="FileOutputStream 与  FileInputStream"></a>FileOutputStream 与  FileInputStream</h2><p>主要用对图像、视频等二进制数据的输入输出，使用方法和 FileWriter与  FileReader  基本相同。</p>
<p>不过输入输出时传递的不是char数组，而是bute数组。</p>
<p><strong>实现对数据的拷贝方式</strong></p>
<p>方式一 : 一个字节一个字节拷贝，与上面案例一样</p>
<p>方式二 ：根据文件大小创建缓冲区，将文件所有内容读入到缓冲区，再将缓冲区的内容全部写入到相应文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取输入输出流</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan02.png&quot;</span>);</span><br><span class="line"><span class="comment">// 开始传递数据</span></span><br><span class="line"><span class="keyword">int</span> len = in.available();  		<span class="comment">// 获取文件大小</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   <span class="comment">// 根据文件大小创建缓冲区</span></span><br><span class="line"><span class="keyword">int</span> data = in.read(bytes);  	<span class="comment">// 全部读入</span></span><br><span class="line">System.out.println(<span class="string">&quot;读取数据大小:&quot;</span> + data);</span><br><span class="line">out.write(bytes);				<span class="comment">// 全部写入</span></span><br></pre></td></tr></table></figure>
<p>方式三 : 按照合理的缓冲区大小进行copy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取输入输出流</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan03.png&quot;</span>);</span><br><span class="line"><span class="comment">// 缓冲区一般设为 1024 的整数倍</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((res = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    out.write(bytes, <span class="number">0</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BufferedOutputStream-与-BufferedInputStream"><a href="#BufferedOutputStream-与-BufferedInputStream" class="headerlink" title="BufferedOutputStream  与 BufferedInputStream"></a>BufferedOutputStream  与 BufferedInputStream</h2><p>要用于描述缓冲输入输出流，此时不用为写入的每个字节调用底层系统.使用方法和 FileOutputStream 与  FileInputStream  基本相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法需要一个 InputStream 或 OutputStream的实现类，当然缓冲流中也可以指定一个缓存区</span></span><br><span class="line">BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>));</span><br><span class="line">BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan04.png&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="BufferedWriter-与-BufferedReader"><a href="#BufferedWriter-与-BufferedReader" class="headerlink" title="BufferedWriter  与  BufferedReader"></a>BufferedWriter  与  BufferedReader</h2><p>使用方法同上，不过 BufferedWriter 可以写入行newLine( ) ，BufferedReader可以读取一行readLine( ) ，如果读取完毕返回null</p>
<h2 id="OutputStreamWriter-与-InputStreamReader"><a href="#OutputStreamWriter-与-InputStreamReader" class="headerlink" title="OutputStreamWriter  与   InputStreamReader"></a>OutputStreamWriter  与   InputStreamReader</h2><p>类主要用于实现从字符流到字节流的转换，一个是输出时的转换，一个时输入时的转换</p>
<h2 id="PrintStream-与-PrintWriter"><a href="#PrintStream-与-PrintWriter" class="headerlink" title="PrintStream   与 PrintWriter"></a>PrintStream   与 PrintWriter</h2><p>主要用于更加方便地打印各种数据内容 ，例如熟悉的 ：println()</p>
<h2 id="ObjectOutputStream-与-ObjectInputStream"><a href="#ObjectOutputStream-与-ObjectInputStream" class="headerlink" title="ObjectOutputStream   与  ObjectInputStream"></a>ObjectOutputStream   与  ObjectInputStream</h2><p>用于对对象的输入输出。只能将支持 java.io.Serializable 接口的对象写入流中。 类通过实现 java.io.Serializable 接口以启用其序列化功能。</p>
<p><strong>序列化</strong> : 主要指将一个对象需要存储的相关信息有效组织成字节序列的转化过程。</p>
<p><strong>反序列化</strong> : 主要指将有效组织的字节序列恢复为一个对象及相关信息的转化过程</p>
<p><strong>序列化版本号</strong> : </p>
<p>序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如 果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 (InvalidCastException)</p>
<p><strong>transient 关键字</strong> :用来表示一个域不是该对象串行化的一部分。当一个对象被串行 化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transient表示该属性不参加序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String phone;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong> : 当希望将多个对象写入文件时，通常建议将多个对象放入一个集合中，然后将集合这个整体看做一 个对象写入输出流中，此时只需要调用一次readObject方法就可以将整个集合的数据读取出来， 从而避免了通过返回值进行是否达到文件末尾的判断</p>
<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>主要支持对随机访问文件的读写操作。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>RandomAccessFile(String name, Stringmode)</td>
<td>根据参数指定的名称和模式构造对象   r: 以只读方式打开     rw：打开以便读取和写入                                          rwd:打开以便读取和写入，同步文件内容的更新     rws:打开以便读取和写入，同步文件内容和元数据的更新</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字节的数据</td>
</tr>
<tr>
<td>void seek(long pos)</td>
<td>移动文件指针偏移量</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>在指针位置覆盖当前已有内容</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭流并释放有关的资源</td>
</tr>
</tbody></table>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程就是进程内部的程序流，也就是说操作系统内部支持多 进程的，而每个进程的内部又是支持多线程的，线程是轻量的，新建线程会共享所在进程的系统资 源，因此目前主流的开发都是采用多线程。 </p>
<p>多线程是采用时间片轮转法来保证多个线程的并发执行，所谓并发就是指宏观并行微观串行的机 制。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p><strong>概念</strong></p>
<ul>
<li><p>java.lang.Thread类代表线程，任何线程对象都是Thread类（子类）的实例。 </p>
</li>
<li><p>Thread类是线程的模板，封装了复杂的线程开启等操作，封装了操作系统的差异性</p>
</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Thread()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>Thread(String name)</td>
<td>根据参数指定的名称来构造对象</td>
</tr>
<tr>
<td>Thread(Runnable target)</td>
<td>根据参数指定的引用来构造对象，其中Runnable是个接口类型</td>
</tr>
<tr>
<td>Thread(Runnable target,String name)</td>
<td>根据参数指定引用和名称来构造对象</td>
</tr>
<tr>
<td>void run()</td>
<td>若使用Runnable引用构造了线程对象，调用该方法时最终调用接口中的方法，若没有使用Runnable引用构造线程对象，调用该方法调用时则啥也不做</td>
</tr>
<tr>
<td>void start()</td>
<td>用于启动线程，Java虚拟机会自动调用该线程的run方法</td>
</tr>
</tbody></table>
<p><strong>创建线程方式</strong></p>
<ul>
<li><p>自定义类继承Thread类并重写run方法，然后创建该类的对象调用start()方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建该类的对象调用start()方法。</span></span><br><span class="line">SubThread subThread = <span class="keyword">new</span> SubThread();</span><br><span class="line">subThread.start();</span><br></pre></td></tr></table></figure></li>
<li><p>自定义类实现Runnable接口并重写run方法，创建该类的对象作为实参来构造Thread类型的对 象，然后使用Thread类型的对象调用start方法。当然也能使用匿名内部类的方式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式二&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Thread构造方法，传递一个Runnable接口的实现类</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 匿名内部类方式创建线程</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方式三 : 内部类&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<p><strong>线程生命周期</strong></p>
</li>
</ul>
<p><a href="https://imgtu.com/i/21BBkj"><img src="https://z3.ax1x.com/2021/06/03/21BBkj.png" alt="21BBkj.png" style="zoom: 67%;" /></a></p>
<p><strong>Tread中有关线程编号和名称的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>long getId()</td>
<td>获取调用对象所表示线程的编号</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取调用对象所表示线程的名称</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置/修改线程的名称为参数指定的数值</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>获取当前正在执行线程的引用</td>
</tr>
</tbody></table>
<p><strong>其他常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static void yield()</td>
<td>当前线程让出处理器（离开Running状态），使当前线程进入Runnable状态等待</td>
</tr>
<tr>
<td>static void sleep(times)</td>
<td>使当前线程从 Running 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable如果其他线程打断当前线程的Block(sleep), 就会发生InterruptedException。</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>获取线程的优先级</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>修改线程的优先级。优先级越高的线程不一定先执行，但该线程获取到时间片的机会会更多一些</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>void join(long millis)</td>
<td>等待参数指定的毫秒数</td>
</tr>
<tr>
<td>boolean isDaemon()</td>
<td>用于判断是否为守护线程</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>用于设置线程为守护线程</td>
</tr>
</tbody></table>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p><strong>概念</strong></p>
<p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对线 程之间进行通信和协调，该机制就叫做线程的同步机制。</p>
<p><strong>异步操作</strong> :  多线程并发的操作，各自独立运行。</p>
<p><strong>同步操作</strong>  :  多线程串行的操作，有先后执行的顺序。</p>
<h3 id="使用synchronized关键字来实现线程同步"><a href="#使用synchronized关键字来实现线程同步" class="headerlink" title="使用synchronized关键字来实现线程同步"></a>使用synchronized关键字来实现线程同步</h3><p>1.实现部分代码的锁定，格式如下：</p>
<ul>
<li>synchronized(类类型的引用) { 编写所有需要锁定的代码； }</li>
</ul>
<p>2.实现所有代码的锁定， 直接使用synchronized关键字来修饰整个方法：</p>
<ul>
<li>public synchronized void test() { 方法体 }</li>
</ul>
<p>该方式等价于: synchronized(this) { 整个方法体的代码 } </p>
<p><strong>注意</strong> </p>
<p>1.对一个静态方法加锁，那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式:类名.class。</p>
<p>2.多个需要同步的线程在访问同步块时，看到的应该是同一个锁对象引用。 </p>
<p>3.在使用同步块时应当尽量减少同步范围以提高并发的执行效率</p>
<h3 id="使用Lock（锁）实现线程同步"><a href="#使用Lock（锁）实现线程同步" class="headerlink" title="使用Lock（锁）实现线程同步"></a>使用Lock（锁）实现线程同步</h3><p><strong>概念</strong></p>
<ul>
<li><p>从Java5开始提供了更强大的线程同步机制—使用显式定义的同步锁对象来实现。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</p>
</li>
<li><p>该接口的主要实现类是ReentrantLock类，该类拥有与synchronized相同的并发性，在以后的线程 安全控制中，经常使用ReentrantLock类显式加锁和释放锁。</p>
</li>
</ul>
<p><strong>lock 与 synchronized 比较</strong></p>
<p>Lock是显式锁，需要手动实现开启和关闭操作，而synchronized是隐式锁，执行锁定代码后自动 释放。 </p>
<p>Lock只有同步代码块方式的锁，而synchronized有同步代码块方式和同步方法两种锁。 </p>
<p>使用Lock锁方式时，Java虚拟机将花费较少的时间来调度线程，因此性能更好。</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock()</td>
<td>使用无参方式构造对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<h3 id="Object类常用的方法"><a href="#Object类常用的方法" class="headerlink" title="Object类常用的方法"></a>Object类常用的方法</h3><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>用于使得线程进入等待状态，直到其它线程调用notify()或notifyAll()方法</td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>用于进入等待状态，直到其它线程调用方法或参数指定的毫秒数已经过去为止</td>
</tr>
<tr>
<td>void notify()</td>
<td>用于唤醒等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>用于唤醒等待的所有线程</td>
</tr>
</tbody></table>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>通过上面的实现线程同步的方法，模拟一个生产者消费者模型。</p>
<p><strong>仓库，负责存储产品，容量为10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreHouse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 生产产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">productGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产了&quot;</span> + (count + <span class="number">1</span>) + <span class="string">&quot;号产品&quot;</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumerGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> + count + <span class="string">&quot;号产品&quot;</span>);</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生产者，生产产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须访问的是同一仓库</span></span><br><span class="line">    <span class="keyword">private</span> StoreHouse house;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(StoreHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            house.productGoods();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者，消费产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须访问的是同一仓库</span></span><br><span class="line">    <span class="keyword">private</span> StoreHouse house;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(StoreHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            house.consumerGoods();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 创建仓库</span></span><br><span class="line">    StoreHouse house = <span class="keyword">new</span> StoreHouse();</span><br><span class="line">    <span class="comment">// 创建生产者与消费者，当然可以创建多个</span></span><br><span class="line">    Product p = <span class="keyword">new</span> Product(house);</span><br><span class="line">    Consumer c = <span class="keyword">new</span> Consumer(house);</span><br><span class="line">    <span class="comment">// 开始生产与消费</span></span><br><span class="line">    p.start();</span><br><span class="line">    c.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>从Java5开始新增加创建线程的第三种方式为实现java.util.concurrent.Callable接口。该线程有返回值，主要用于计算。</p>
<p><strong>实现方式</strong>   : 实现  Callable 接口  —》 重写 call() 方法 </p>
<p><strong>FutureTask类</strong></p>
<p>java.util.concurrent.FutureTask类用于描述可取消的异步计算，该类提供了Future接口的基本实 现，包括启动和取消计算、查询计算是否完成以及检索计算结果的方法，也可以用于获取方法调用 后的返回结果。</p>
<p><strong>FutureTask类常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FutureTask(Callable callable)</td>
<td>根据参数指定的引用来创建一个未来任务</td>
</tr>
<tr>
<td>V get()</td>
<td>获取call方法计算的结果</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 1-1000 累加 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">        <span class="comment">// 接受结果</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callableTest);</span><br><span class="line">        <span class="comment">// 创建线程并开启</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取计算结果</span></span><br><span class="line">            Object o = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为；&quot;</span>+o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>从Java5开始提供了线程池的相关类和接口：java.util.concurrent.Executors类和 java.util.concurrent.ExecutorService接口。</p>
<p>其中Executors是个工具类和线程池的工厂类，可以创建并返回不同类型的线程池，常用方法如 下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static ExecutorService newCachedThreadPool()</td>
<td>创建一个可根据需要创建新线程的线程池</td>
</tr>
<tr>
<td>static ExecutorService newFixedThreadPool(int Threads)</td>
<td>创建一个可重用固定线程数的线程池</td>
</tr>
<tr>
<td>static ExecutorService newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池</td>
</tr>
</tbody></table>
<p>其中ExecutorService接口是真正的线程池接口，主要实现类是ThreadPoolExecutor，常用方法 如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务和命令，通常用于执行Runnable</td>
</tr>
<tr>
<td>Future submit(Callable task)</td>
<td>执行任务和命令，通常用于执行Callable</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>启动有序关闭</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启一个10条线程的线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 向线程池中添加任务</span></span><br><span class="line">    <span class="comment">// 添加实现 Runnable 接口的线程</span></span><br><span class="line">    executorService.execute(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">    <span class="comment">// 添加实现 Callable 接口的线程</span></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> CallableTest());</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程需要提供：IP地址 + 端口号，组合在一起叫做网络套接字：Socket。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议(Transmission Control Protocol)，是一种面向连接的协议，类似于打电话。 </p>
<ul>
<li>建立连接 =&gt; 进行通信 =&gt; 断开连接 在传输前采用”三次握手”方式。 </li>
<li>在通信的整个过程中全程保持连接，形成数据传输通道。 </li>
<li>保证了数据传输的可靠性和有序性。 </li>
<li>是一种全双工的字节流通信方式，可以进行大数据量的传输。 </li>
<li>传输完毕后需要释放已建立的连接，发送数据的效率比较低。</li>
</ul>
<p><strong>编程模型</strong></p>
<ul>
<li><p>服务器： </p>
<p>（1）创建ServerSocket类型的对象并提供端口号； </p>
<p>（2）等待客户端的连接请求，调用accept()方法； </p>
<p>（3）使用输入输出流进行通信； </p>
<p>（4）关闭Socket； </p>
</li>
<li><p>客户端： </p>
<p>（1）创建Socket类型的对象并提供服务器的IP地址和端口号； </p>
<p>（2）使用输入输出流进行通信； </p>
<p>（3）关闭Socket；</p>
</li>
</ul>
<p><strong>ServerSocket类</strong>  java.net.ServerSocket类主要用于描述服务器套接字信息</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>ServerSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>Socket accept()</td>
<td>侦听并接收到此套接字的连接请求</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>Socket类</strong>   java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Socket(String host, int port)</td>
<td>根据指定主机名和端口来构造对象</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>用于获取当前套接字的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>用于获取当前套接字的输出流</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>注</strong> ：客户端 Socket 与服务器端 Socket 对应, 都包含输入和输出流。</p>
<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">socket socket = server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="comment">// 获取输出流</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    <span class="keyword">if</span>(s.equalsIgnoreCase(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已下线!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:&quot;</span>+s);</span><br><span class="line">    <span class="comment">// 回复</span></span><br><span class="line">    ps.println(<span class="string">&quot;I received!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭所有连接。。。。。</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端连接服务区</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 获取输出流</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 传输数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要传输的内容:&quot;</span>);</span><br><span class="line">    String say = sc.next();</span><br><span class="line">    ps.println(say);</span><br><span class="line">    <span class="keyword">if</span>(say.equalsIgnoreCase(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器:&quot;</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭所有连接...</span></span><br></pre></td></tr></table></figure>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议(User Datagram Protocol)，是一种非面向连接的协议，类似于写信。 </p>
<ul>
<li>在通信的整个过程中不需要保持连接，其实是不需要建立连接。 </li>
<li>不保证数据传输的可靠性和有序性。 </li>
<li>是一种全双工的数据报通信方式，每个数据报的大小限制在64K内。 </li>
<li>发送数据完毕后无需释放资源，开销小，发送数据的效率比较高，速度快。</li>
</ul>
<p><strong>编程模型</strong></p>
<ul>
<li><p>接收方： </p>
<p>（1）创建DatagramSocket类型的对象并提供端口号； </p>
<p>（2）创建DatagramPacket类型的对象并提供缓冲区； </p>
<p>（3）通过Socket接收数据内容存放到Packet中，调用receive方法； </p>
<p>（4）关闭Socket； </p>
</li>
<li><p>发送方： </p>
<p>（1）创建DatagramSocket类型的对象； </p>
<p>（2）创建DatagramPacket类型的对象并提供接收方的通信地址； </p>
<p>（3）通过Socket将Packet中的数据内容发送出去，调用send方法； </p>
<p>（4）关闭Socket；</p>
</li>
</ul>
<p><strong>DatagramSocket类</strong>    java.net.DatagramSocket类主要用于描述发送和接收数据报的套接字(邮局)</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramSocket()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>DatagramSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>void receive(DatagramPacket p)</td>
<td>用于接收数据报存放到参数指定的位置</td>
</tr>
<tr>
<td>void send(DatagramPacket p)</td>
<td>用于将参数指定的数据报发送出去</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭Socket并释放相关资源</td>
</tr>
</tbody></table>
<p><strong>DatagramPacket类</strong>   java.net.DatagramPacket类主要用于描述数据报，数据报用来实现无连接包裹投递服务</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramPacket(byte[] buf, int length)</td>
<td>根据参数指定的数组来构造对象，用于接收长度为length的数据报</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf, int length,InetAddress address, int port)</td>
<td>根据参数指定数组来构造对象，将数据报发送到指定地址和端口</td>
</tr>
<tr>
<td>InetAddress getAddress()</td>
<td>用于获取发送方或接收方的通信地址</td>
</tr>
<tr>
<td>int getPort()</td>
<td>用于获取发送方或接收方的端口号</td>
</tr>
<tr>
<td>int getLength()</td>
<td>用于获取发送数据或接收数据的长度</td>
</tr>
</tbody></table>
<p><strong>接收方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;等待接收消息...&quot;</span>);</span><br><span class="line"><span class="comment">// 创建Socket</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 创建package</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line"><span class="comment">// 接受数据</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line">System.out.println(<span class="string">&quot;接收到的数据为:&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受到消息后回复</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="string">&quot;I received!&quot;</span>.getBytes();</span><br><span class="line">DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bytes2, bytes2.length, dp.getAddress(), dp.getPort());</span><br><span class="line">ds.send(dp2);</span><br><span class="line">System.out.println(<span class="string">&quot;回复消息成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<p><strong>发送方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Socket</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">// 创建package</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">&quot;hello&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//  InetAddress.getLocalHost() 用于获取当前主机的通信地址</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">System.out.println(<span class="string">&quot;发送数据完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收回复消息</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bytes2, bytes2.length);</span><br><span class="line">ds.receive(dp2);</span><br><span class="line">System.out.println(<span class="string">&quot;接收回复的消息是:&quot;</span> + <span class="keyword">new</span> String(bytes2, <span class="number">0</span>, bytes2.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<h2 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h2><p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>URL(String spec)</td>
<td>根据参数指定的字符串信息构造对象</td>
</tr>
<tr>
<td>URLConnection openConnection()</td>
<td>获取URLConnection类的实例</td>
</tr>
</tbody></table>
<p> <strong>URLConnection类</strong> </p>
<ul>
<li>java.net.URLConnection类是个抽象类，该类表示应用程序和URL之间的通信链接的所有类的超 类，主要实现类有支持HTTP特有功能的HttpURLConnection类</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream getInputStream()</td>
<td>获取输入流</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>断开连接</td>
</tr>
</tbody></table>
<p>模拟爬虫，获取一个网页的html代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.lagou.com/&quot;</span>);</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">HttpURLConnection HttpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">InputStream inputStream = HttpURLConnection.getInputStream();</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line"><span class="comment">// 根据输入流读取数据</span></span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 断开连接</span></span><br><span class="line">inputStream.close();</span><br><span class="line">HttpURLConnection.disconnect();</span><br></pre></td></tr></table></figure>
<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><p>反射机制就是用于动态创建对象并且动态调用方法的机制,也叫做动态编程技术</p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><strong>概念 :</strong> </p>
<p>java.lang.Class类的实例可以用于描述Java应用程序中的类和接口，也就是一种数据类型。 </p>
<p>该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造完成，本质上就是加载到内 存中的运行时类。</p>
<p><strong>获取Class对象的方式</strong></p>
<ul>
<li><p>数据类型.class（常用）</p>
</li>
<li><p>引用/对象.getClass()      基本数据类型不能使用该方法</p>
</li>
<li><p>包装类.TYPE       获取对应基本数据类型的Class对象。</p>
</li>
<li><p>Class.forName()    获取参数指定类型的Class对象（常用）。</p>
</li>
<li><p>使用类加载器ClassLoader的方式获取指定类型的Class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = String.class.getClassLoader(); <span class="comment">// 获取类加载器，随便哪个类的加载器都行</span></span><br><span class="line">classLoader.loadClass(<span class="string">&quot;java.util.Date&quot;</span>);  <span class="comment">// 根据类加载器获取时间对象</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt; forName(String className)</td>
<td>获取参数指定类型对应的Class对象并返回</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>创建该Class对象所表示类的实例（已过时）</td>
</tr>
</tbody></table>
<h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>获取此Class对象所表示类型中参数指定的公共构造方法</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>获取此Class对象所表示类型中所有的公共构造方法</td>
</tr>
</tbody></table>
<p> <strong>Constructor类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object… initargs)</td>
<td>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
</tbody></table>
<h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Field getDeclaredField(String name)</td>
<td>用于获取此Class对象所表示类中参数指定的单个成员变量信息</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>用于获取此Class对象所表示类中所有成员变量信息</td>
</tr>
</tbody></table>
<p> <strong>Field类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Object get(Object obj)</td>
<td>获取参数对象obj中此Field对象所表示成员变量的数值</td>
</tr>
<tr>
<td>void set(Object obj, Object value)</td>
<td>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值</td>
</tr>
<tr>
<td>void setAccessible(boolean flag)</td>
<td>当实参传递true时，则反射对象在使用时应该取消 Java 语言访问检查</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取成员变量的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType()</td>
<td>获取成员变量的数据类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取成员变量的名称</td>
</tr>
</tbody></table>
<h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Method getMethod(String name,Class&lt;?&gt;… parameterTypes)</td>
<td>用于获取该Class对象表示类中名字为name参数为parameterTypes的指定公共成员方法</td>
</tr>
<tr>
<td>Method[] getMethods()</td>
<td>用于获取该Class对象表示类中所有公共成员方法</td>
</tr>
</tbody></table>
<p> <strong>Method类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Object invoke(Object obj,Object… args)</td>
<td>使用对象obj来调用此Method对象所表示的成员方法，实参传递args</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getReturnType()</td>
<td>获取方法的返回值类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getExceptionTypes()</td>
<td>获取方法的异常信息</td>
</tr>
</tbody></table>
<h2 id="获取其它结构信息"><a href="#获取其它结构信息" class="headerlink" title="获取其它结构信息"></a>获取其它结构信息</h2><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Package getPackage()</td>
<td>获取所在的包信息</td>
</tr>
<tr>
<td>Class&lt;? super T&gt; getSuperclass()</td>
<td>获取继承的父类信息</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getInterfaces()</td>
<td>获取实现的所有接口</td>
</tr>
<tr>
<td>Annotation[] getAnnotations()</td>
<td>获取注解信息</td>
</tr>
<tr>
<td>Type[] getGenericInterfaces()</td>
<td>获取泛型信息</td>
</tr>
</tbody></table>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p><strong>代理模式作用</strong></p>
<ol>
<li>功能增强:在你原有的功能上,增加了额外的功能. </li>
<li>控制访问:代理类不让你访问目标,例如商家不让用户访问厂家</li>
</ol>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>模拟一个用户购买u盘的行为。</strong><br>用户是客户端类<br>商家：代理，代理某个品牌的u盘。<br>厂家：目标类。</p>
<p><strong>实现步骤</strong><br>1.创建一个接口,定义卖u盘的方法,表示厂家和商家做的事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="comment">// amount:表示一次购买的数量,返回值表示购买的u盘的价格</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建厂家类,实现1步骤的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标类:金士顿厂家,不接受用户的单独购买</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbKingFactory</span> <span class="keyword">implements</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设一个U盘  100 元</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100.0f</span>*amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建商家,就是代理,也需要实现1步骤中的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//淘宝是一个商家,代理金士顿U盘的销售</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBao</span> <span class="keyword">implements</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明 商家代理的厂家具体是谁</span></span><br><span class="line">    <span class="keyword">private</span> UsbKingFactory factory =<span class="keyword">new</span> UsbKingFactory();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//实现销售U盘功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">// 1.目标类中方法的调用，厂家需要多少钱</span></span><br><span class="line">        <span class="keyword">float</span> price = factory.sell(amount);</span><br><span class="line">        <span class="comment">// 2.功能增强，每个U盘价格+40</span></span><br><span class="line">        price = price + amount*<span class="number">40</span>;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.创建客户端类,调用商家的方法买一个u盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//  创建代理商家----淘宝对象</span></span><br><span class="line">    TaoBao taoBao = <span class="keyword">new</span> TaoBao();</span><br><span class="line">    <span class="comment">//  向淘宝代理购买买两件产品,得到报价</span></span><br><span class="line">    <span class="keyword">float</span> price = taoBao.sell(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;购买两件产品.淘宝的报价为: &quot;</span>+price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>    1. 实现简单     2. 容易理解。</p>
<p><strong>缺点</strong> </p>
<ol>
<li><p>当目标类增加了,代理类可能也需要成倍的增加</p>
</li>
<li><p>当你的接口中功能在增加了,或者修改了,会影响众多的实现类,厂家类,代理都需要修改,影响比较多</p>
</li>
</ol>
<h2 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h2><ol>
<li>动态代理是指代理类对象在程序运行时由JVM根据反射机制动态生成的。动态代理不需要定义代理类的，java源文件。</li>
<li>动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM。</li>
</ol>
<p><strong>两种方式</strong></p>
<ul>
<li>jdk动态代理(理解):使用java反射包中的类和接口实现动态代理的功能。反射包java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy</li>
<li>cglib动态代理(了解): cglib是第三方的工具库,创建代理对象<ul>
<li>cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中<br>重写父类中同名的方法，实现功能的修改。</li>
<li>因为cglib是继承，重写方法，所以要求目标类不能是fina1的，方法也不能是final的。cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用，<br>比如mybatis，spring框架中都有使用。</li>
</ul>
</li>
</ul>
<h3 id="InvocationHandler类"><a href="#InvocationHandler类" class="headerlink" title="InvocationHandler类"></a>InvocationHandler类</h3><p>代理类需要实现InvocationHandler类，重写invoke方法，代理类要完成的功能就写在invoke（）方法中。</p>
<p><strong>代理类完成的功能</strong>    </p>
<ol>
<li><p>调用目标方法,执行目标方法的功能    </p>
</li>
<li><p>功能增强,在目标方法调用时,增加功能</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Object  proxy</strong>        jdk创建的代理对象，无需赋值</p>
<p><strong>Method  method</strong>   目标类中的方法，jdk提供。</p>
<p><strong>Object[]  args</strong>          目标类中方法的参数，jkd提供。</p>
<h3 id="proxy类"><a href="#proxy类" class="headerlink" title="proxy类"></a>proxy类</h3><p>创建代理对象，使用其中的静态方法 <code>newProxyInstance()</code>  , 等同于静态代理中直接  new  商家(代理)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">( ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>ClassLoader loader</strong>   类加载器,负责向内存中加载对象的,使用反射机制获取对象的classLoader,</p>
<p><strong>Class&lt;?&gt;[] interfaces</strong>   接口,目标对象实现的接口,也是反射获取的</p>
<p><strong>InvocationHandler  h</strong>  : 我们自己写的,代理类要完成的功能</p>
<h3 id="实现动态代理的步骤"><a href="#实现动态代理的步骤" class="headerlink" title="实现动态代理的步骤"></a>实现动态代理的步骤</h3><ol>
<li>创建接口,定义目标类要完成的功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义卖u盘的方法,表示厂家和商家做的事情</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建目标类,并实现上面接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  厂家</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KingstonUSB</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 100 元一个usb</span></span><br><span class="line">        <span class="keyword">return</span> count * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建InvocationHandler接口的实现类,在invoke方法中完成代理类的功能<ol>
<li>调用目标方法</li>
<li>增强功能</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态代理，增强 KingstonUSB中的 sell 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KingstonUSBHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> USB kingstonUSB;</span><br><span class="line">	<span class="comment">// 构造方法，初始化 目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KingstonUSBHandler</span><span class="params">(USB kingstonUSB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kingstonUSB = kingstonUSB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原来的方法</span></span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) method.invoke(kingstonUSB, args);</span><br><span class="line">        <span class="comment">// 功能增强 , 每个 usb 价格 + 40 并 返回一张优惠券</span></span><br><span class="line">        res = res + ( (<span class="keyword">int</span>)args[<span class="number">0</span>] * <span class="number">40</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;淘宝优惠券一张！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用Proxy类的静态方法,创建代理对象,并把返回值转换成接口类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建目标对象</span></span><br><span class="line">    KingstonUSB usb = <span class="keyword">new</span> KingstonUSB();</span><br><span class="line">    <span class="comment">// 创建InvocationHandler对象</span></span><br><span class="line">    KingstonUSBHandler handler = <span class="keyword">new</span> KingstonUSBHandler(usb);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    USB proxyUSB =(USB) Proxy.newProxyInstance(usb.getClass().getClassLoader(), usb.getClass().getInterfaces(), handler);</span><br><span class="line">    <span class="comment">// 通过代理执行方法</span></span><br><span class="line">    <span class="keyword">int</span> money = proxyUSB.sell(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;价格为:&quot;</span>+money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java新特性</title>
    <url>/2021/06/05/java%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h1><p><strong>概述</strong>   Java8是 Java 语言的一个重要版本，该版本于2014年3月发布，是自Java5以来最具革命性的版 本，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。<a id="more"></a></p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul>
<li><p>函数式接口主要指只包含一个抽象方法的接口，如：java.lang.Runnable、java.util.Comparator 接口等。 </p>
</li>
<li><p>Java8提供@FunctionalInterface注解来定义函数式接口，若定义的接口不符合函数式的规范便会 报错</p>
</li>
<li><p>Java8中增加了java.util.function包，该包包含了常用的函数式接口，具体如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></td>
<td>void accept(T t)</td>
<td>根据指定的参数执行操作</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>得到一个返回值</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>根据指定的参数执行操作并返回</td>
</tr>
<tr>
<td>Predicate<T></td>
<td>boolean test(T t)</td>
<td>判断指定的参数是否满足条件</td>
</tr>
</tbody></table>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>Lambda 表达式是实例化函数式接口的重要方式，使用 Lambda 表达式可以使代码变的更加简洁 紧凑。</p>
<p>语法格式：(参数列表) -&gt; { 方法体; } - 其中()、参数类型、{} 以及return关键字 可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = ()-&gt; System.out.println(<span class="string">&quot;随便写写！&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用主要指通过方法的名字来指向一个方法而不需要为方法引用提供方法体，该方法的调用交 给函数式接口执行。所在特定场合下lambda表达式的一种简写形式。方法中传递与返回的数据类型要与函数是接口保持一致。</p>
<p>方法引用使用一对冒号 :: 将类或对象与方法名进行连接，通常使用方式如下：</p>
<ul>
<li><p>对象的非静态方法引用 ObjectName :: MethodName </p>
</li>
<li><p>类的静态方法引用 ClassName :: StaticMethodName </p>
</li>
<li><p>类的非静态方法引用 ClassName :: MethodName </p>
</li>
<li><p>构造器的引用 ClassName :: new </p>
</li>
<li><p>数组的引用 TypeName[] :: new</p>
</li>
</ul>
<h2 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h2><p><strong>概念</strong>    java.util.stream.Stream接口是对集合功能的增强，可以对集合元素进行复杂的查找、过滤、筛选 等操作。</p>
<p><strong>创建方式</strong></p>
<ul>
<li>通过调用集合的默认方法来获取流，如：default Stream stream() </li>
<li>通过数组工具类中的静态方法来获取流，如：static IntStream stream(int[] array) </li>
<li>通过Stream接口的静态方法来获取流，如：static Stream of(T… values) </li>
<li>通过Stream接口的静态方法来获取流，static Stream generate(Supplier s)</li>
</ul>
<p><strong>中间操作</strong></p>
<ul>
<li>筛选与切片</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream filter(Predicate&lt;? super T&gt; predicate)</td>
<td>返回一个包含匹配元素的流</td>
</tr>
<tr>
<td>Stream distinct()</td>
<td>返回不包含重复元素的流</td>
</tr>
<tr>
<td>Stream limit(long maxSize)</td>
<td>返回不超过给定元素数量的流</td>
</tr>
<tr>
<td>Stream skip(long n)</td>
<td>返回丢弃前n个元素后的流</td>
</tr>
</tbody></table>
<ul>
<li>映射</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream map(Function&lt;? super T,? extends R&gt; mapper)</td>
<td>返回每个处理过元素组成的流</td>
</tr>
<tr>
<td>Stream flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</td>
<td>返回每个被替换过元素组成的流，并将所有流合成一个流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取list集合中所有对象的name值，并答应出来</span></span><br><span class="line"><span class="comment">//list.stream().map(p-&gt; p.getName()).forEach(name -&gt; System.out.println(name));</span></span><br><span class="line">list.stream().map(Person::getName).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>排序</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream sorted()</td>
<td>返回经过自然排序后元素组成的流</td>
</tr>
<tr>
<td>Stream sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>返回经过比较器排序后元素组成的流</td>
</tr>
</tbody></table>
<p><strong>终止操作</strong></p>
<ul>
<li>匹配与查找</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional findFirst()</td>
<td>返回该流的第一个元素</td>
</tr>
<tr>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回所有元素是否匹配</td>
</tr>
<tr>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回没有元素是否匹配</td>
</tr>
<tr>
<td>Optional max(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回最大元素</td>
</tr>
<tr>
<td>Optional min(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回最小元素</td>
</tr>
<tr>
<td>long count()</td>
<td>返回元素的个数</td>
</tr>
<tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>对流中每个元素执行操作</td>
</tr>
</tbody></table>
<ul>
<li>规约</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional reduce(BinaryOperator accumulator)</td>
<td>返回结合后的元素值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算list集合中的所有对象的年龄和</span></span><br><span class="line"><span class="comment">//Optional&lt;Integer&gt; reduce = list.stream().map(Person::getAge).reduce((o1, o2) -&gt; o1 + o2);</span></span><br><span class="line">Optional&lt;Integer&gt; reduce = list.stream().map(Person::getAge).reduce(Integer::sum);</span><br><span class="line">System.out.println(<span class="string">&quot;年龄和为:&quot;</span>+reduce);</span><br></pre></td></tr></table></figure>
<ul>
<li>收集</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</td>
<td>使用收集器对元素进行处理</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取list中所有对象的name值，并保存到另一个集合中</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; collect = list.stream().map(p -&gt; p.getName()).collect(Collectors.toList());</span></span><br><span class="line">List&lt;String&gt; collect = list.stream().map(Person::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p><strong>概述</strong> java.util.Optional类可以理解为一个简单的容器，其值可能是null或者不是null，代表一个值存在 或不存在。 该类的引入很好的解决空指针异常，不用显式进行空值检测。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Optional ofNullable(T value)</td>
<td>根据参数指定数值来得到Optional类型的对象</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Optional  判断字符串是否为空，若不为空则打印字符串的长度，否则打印0</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;==============常规写法============================&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==str)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;str为null，长度为:0&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;长度为:&quot;</span>+str.length());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;==============Optional写法============================&quot;</span>);</span><br><span class="line"><span class="comment">// 将 str 放入Optional容器中</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line"><span class="comment">// 建立映射,传递一个  Function&lt;T,R&gt; 接口</span></span><br><span class="line">Optional&lt;Integer&gt; integer = optional.map(String::length);</span><br><span class="line"><span class="comment">// 获取长度，如果该值不存在就返回  0</span></span><br><span class="line">Integer len = integer.orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;长度为:&quot;</span>+len);</span><br></pre></td></tr></table></figure>
<h1 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h1><p><strong>概述</strong> :Java9发布于2017年9月发布，带来了很多新特性，其中最主要的变化是模块化系统。 模块就是代码和数据的封装体，模块的代码被组织成多个包，每个包中包含Java类和接口，模块的 数据则包括资源文件和其他静态信息。</p>
<p><strong>模块化的使用</strong></p>
<p>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块 , 具体如下： </p>
<p> module 模块名称 {</p>
<p>​     exports …         // 导出</p>
<p>​    requires …         // 导入</p>
<p>  }</p>
<p><strong>钻石操作符的使用升级</strong></p>
<p>在Java9中允许在匿名内部类的使用中使用钻石操作符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; c = <span class="keyword">new</span> Consumer&lt;&gt;() &#123;<span class="comment">//代码块&#125;</span></span><br></pre></td></tr></table></figure>
<p> <strong>集合工厂方法</strong></p>
<ul>
<li>Java9的List、Set和Map集合中增加了静态工厂方法of实现不可变实例的创建。 </li>
<li>不可变体现在无法添加、修改和删除它们的元素。 </li>
<li>不允许添加null元素对象</li>
</ul>
<p><strong>InputStream的增强</strong></p>
<p>InputStream类中提供了transferTo方法实现将数据直接传输到OutputStream中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件的复制，直接套用transferTo即可，内部封装了缓冲流</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://a&quot;</span>);</span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://b&quot;</span>);</span><br><span class="line">in.transferTo(out);</span><br></pre></td></tr></table></figure>
<h1 id="Java10新特性"><a href="#Java10新特性" class="headerlink" title="Java10新特性"></a>Java10新特性</h1><p>Java10于2018年3月发布，改进的关键点包括一个本地类型推断、一个垃圾回收的增强。</p>
<p>Java10计划只是一个短期版本，因此公开更新将在六个月内结束，9月份发布的Java11将是Java的 长期支持（LTS）版本，LTS版本的发布每三年发布一次。</p>
<p><strong>局部变量类型推断</strong></p>
<ul>
<li>Java10可以使用var作为局部变量类型推断标识符，此符号仅适用于局部变量，增强for循环的索 引，以及传统for循环的本地变量。 </li>
<li>它不能使用于方法形式参数，构造函数形式参数，方法返回类型，字段，catch形式参数或任何其 他类型的变量声明。</li>
</ul>
<h1 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h1><p><strong>概述</strong> java11于2018年9月正式发布，这是 Java 大版本周期变化 后的第一个长期支持版本，非常值得关 注。</p>
<p><strong>简化的编译运行操作</strong> </p>
<ul>
<li>在Java11中可以使用java命令一次性进行编译和运行操作。 </li>
<li>执行源文件中的第一个类必须包含主方法。 </li>
<li>不可以使用其它源文件中自定义的类。</li>
</ul>
<p><strong>String类新增方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isBlank()</td>
<td>判断字符串是否为空或只包含空白代码点</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>新特性</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO笔记</title>
    <url>/2021/06/07/NIO%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>概念</strong>   </p>
<ul>
<li><code>Java New IO</code></li>
<li>是1个全新的、 <code>JDK 1.4</code>后提供的 <code>IO API</code></li>
<li>Java API中提供了两套NIO，一套是针对<code>标准输入输出NIO</code>，另一套就是<code>网络编程NIO</code><a id="more"></a></li>
<li>IO是以<strong>流</strong>的方式处理数据，而NIO是以<strong>块</strong>的方式处理数据</li>
</ul>
<p><strong>面向流</strong>的IO一次一个字节的处理数据，一个输入流产生一个字节，一个输出流就消费一个字节。</p>
<p><strong>面向块</strong>的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多</p>
<p><a href="https://imgtu.com/i/2dhTaT"><img src="https://z3.ax1x.com/2021/06/07/2dhTaT.png" alt="2dhTaT.png"></a></p>
<h1 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h1><p><strong>概念</strong>  用来存放具体要被传输的数据。这里将数据装入 Buffer 再通过通道进行传输。Buffer 就是一个数组，用来保存不同数据类型的数据</p>
<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer，对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继承关系如下图所示</p>
<p><a href="https://imgtu.com/i/2d4dFU"><img src="https://z3.ax1x.com/2021/06/07/2d4dFU.png" alt="2d4dFU.png"></a></p>
<p><strong>ByteBuffer的创建方式</strong>(其他用法一样)</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static ByteBuffer allocate(int capacity)</td>
<td>在堆中创建缓冲区(常用)</td>
</tr>
<tr>
<td>static ByteBuffer allocateDirect(int capacity)</td>
<td>在系统内存创建缓冲区</td>
</tr>
<tr>
<td>static ByteBuffer wrap(byte[] arr)</td>
<td>通过普通数组创建缓冲区</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuffer put(byte b)</td>
<td>添加元素,返回自己(this)</td>
</tr>
<tr>
<td>ByteBuffer get(byte[] bytes)</td>
<td>获取元素,将buffer中的元素填充到bytes数组中，返回自己</td>
</tr>
<tr>
<td>byte[] array()</td>
<td>获取元素，将buffer中的数据变成byte数组</td>
</tr>
<tr>
<td>ByteBuffer flip()</td>
<td>更新limit与position的值，读与写的转换</td>
</tr>
<tr>
<td>ByteBuffer clear()</td>
<td>“清空”缓冲区，还原limit以及position的值，但是butter里的值还是存在的</td>
</tr>
<tr>
<td>ByteBuffer reset()</td>
<td>返回上一次操作，position的位置变成Mark所指的位置</td>
</tr>
</tbody></table>
<p><strong>4个核心变量属性</strong></p>
<ul>
<li><p>容量  Capacity</p>
<ul>
<li><strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li>
</ul>
</li>
<li><p>界限 Limit</p>
<ul>
<li><strong>缓冲区中可以操作数据的大小</strong>，代表了当前缓冲区中一共有多少数据（从limit开始后面的位置不能操作）</li>
</ul>
</li>
<li><p>位置 Position</p>
<ul>
<li><strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的 <code>get( )</code>和 <code>put( )</code>函数更新</li>
</ul>
</li>
<li><p>Mark</p>
<ul>
<li><strong>用于记录上一次读写的位置</strong>。一个备忘位置</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/2dHtm9"><img src="https://z3.ax1x.com/2021/06/07/2dHtm9.png" alt="2dHtm9.png" style="zoom:67%;" /></a></p>
<h1 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h1><p><strong>概述</strong> ：Channel 类似于传统的“<strong>流</strong>”。</p>
<p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<p> Java 为 Channel 接口提供的最主要实现类如下：</p>
<p><a href="https://imgtu.com/i/2wCAUS"><img src="https://z3.ax1x.com/2021/06/07/2wCAUS.png" alt="2wCAUS.png" style="zoom:67%;" /></a></p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。 </li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。 </li>
<li>SocketChannel：通过 TCP 读写网络中的数据。 </li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来 的连接都会创建一个 SocketChannel。</li>
</ul>
<p><strong>FileChannel实现文件的复制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FileChannel对文件的复制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建输入输出流</span></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://a.png&quot;</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://b.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取输入输出FileChannel</span></span><br><span class="line">        FileChannel inChannel = in.getChannel();</span><br><span class="line">        FileChannel outChannel = out.getChannel();</span><br><span class="line">        <span class="comment">// 获取buffer缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();  <span class="comment">// 切换</span></span><br><span class="line">            outChannel.write(buffer);</span><br><span class="line">            buffer.clear(); <span class="comment">// 还原初始化位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>ServerSocketChannel与SocketChannel网络编程收发信息</strong></p>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建客户端  socketChannel</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 创建一个buffer缓冲区,并放入数据</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello channel&quot;</span>.getBytes());</span><br><span class="line">        buffer.flip();  <span class="comment">// 更新一下 position 与 limit</span></span><br><span class="line">        <span class="comment">// 传递数据给客户端</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器  ServerSocketChannel </span></span><br><span class="line">        ServerSocketChannel serverSocketChannel =  ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接....&quot;</span>);</span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个buffer缓冲器</span></span><br><span class="line">        ByteBuffer buffer  =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 读客户端发来的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = socketChannel.read(buffer);</span><br><span class="line"><span class="comment">//        buffer.flip();</span></span><br><span class="line"><span class="comment">//        byte[] bytes = new byte[len];</span></span><br><span class="line"><span class="comment">//        buffer.get(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端:&quot;+new String(bytes));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端:&quot;</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器可以将accept设置为非阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器  ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 设置为非阻塞状态</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接....&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里将不会阻塞，继续向下执行，所以要注意空指针异常</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个buffer缓冲器</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">// 读客户端发来的数据</span></span><br><span class="line">                <span class="keyword">int</span> len = socketChannel.read(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端:&quot;</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在做其他事&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p><strong>多路复用的概念</strong>   一个选择器可以同时监听多个服务器端口, 帮多个服务器端口同时等待客户端的访问</p>
<p>Selector（选择器） 是 Channel（通道）的多路复用器，Selector 可以同时监控多个 通道的 IO（输入 输出） 状况。</p>
<p><strong>Selector作用</strong></p>
<p>选择器提供选择执行已经就绪的任务的能力。从底层来看，Selector提供了<strong>询问</strong>通道是否已经准备好执 行每个I/O操作的能力。Selector 允许单线程处理多个Channel。仅用单个线程来处理多个Channels的 好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道，这样会大量的减 少线程之间上下文切换的开销。</p>
<p><strong>可选择通道(SelectableChannel)</strong></p>
<p>继承了 SelectableChannel抽象类的Channel通道才能被复用</p>
<p><a href="https://imgtu.com/i/2wFxdP"><img src="https://z3.ax1x.com/2021/06/07/2wFxdP.png" alt="2wFxdP.png" style="zoom:67%;" /></a></p>
<p><strong>Chanel注册到Selector</strong></p>
<p>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上， 在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。Channel可以注册到多个Selector上。</p>
<p><a href="https://imgtu.com/i/2wk7T0"><img src="https://z3.ax1x.com/2021/06/07/2wk7T0.png" alt="2wk7T0.png" style="zoom:50%;" /></a></p>
<p>使用  <strong>Channel.register（Selector Selector，int ops）</strong>将一个通道注册到一个选择器时。</p>
<pre><code> Selector Selector：指定通道要注册的选择器

 int ops：指定选择器需要查询的通道操作 
</code></pre>
<p>可以供选择器查询的通道操作，从类型来分，包括以下四种：</p>
<ul>
<li>可读 : SelectionKey.OP_READ </li>
<li>可写 : SelectionKey.OP_WRITE </li>
<li>连接 : SelectionKey.OP_CONNECT </li>
<li>接收 : SelectionKey.OP_ACCEPT </li>
</ul>
<p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;</p>
<p><strong>选择键(SelectionKey)</strong></p>
<p>select（）对感兴趣的通道进行就绪状态的查询，如果没有事件可操作就会阻塞，返回值是可操作事件的个数</p>
<p>selectedKeys()  选择器会把被就绪的Channel对象放在Set集合中,这个方法就是返回一个Set集 合 </p>
<p><strong>Select的使用，多路复用多个服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建selector选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 创建多个服务器，服务器必须要非阻塞状态</span></span><br><span class="line">        ServerSocketChannel s1 = ServerSocketChannel.open();</span><br><span class="line">        s1.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line">        s1.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocketChannel s2 = ServerSocketChannel.open();</span><br><span class="line">        s2.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        s2.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocketChannel s3 = ServerSocketChannel.open();</span><br><span class="line">        s3.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        s3.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将服务器注册到选择器中,并且选中接收的类型</span></span><br><span class="line">        s1.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        s2.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        s3.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器全部准备就绪，等待连接。。。&quot;</span>);</span><br><span class="line">         <span class="comment">//  select() 在没有操作时是阻塞状态，当有事件操作时会变成非阻塞，并且返回操作事件的个数</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取当前所有可操作事件，保存在set集合中</span></span><br><span class="line">            Set&lt;SelectionKey&gt; set = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历该集合,</span></span><br><span class="line">            <span class="keyword">for</span> (SelectionKey selectionKey : set) &#123;</span><br><span class="line">                <span class="comment">// 如果是接收事件</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    <span class="comment">// 接收数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端:&quot;</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                    &#125;</span><br><span class="line">                    socketChannel.close();<span class="comment">//关闭</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移除当前选中键</span></span><br><span class="line">                set.remove(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭服务器</span></span><br><span class="line">        s1.close();</span><br><span class="line">        s2.close();</span><br><span class="line">        s3.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over  。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>常用的设计原则</strong> </p>
<ul>
<li>开闭原则（Open Close Principle） 对扩展开放对修改关闭，为了使程序的扩展性好，易于维护和升级。</li>
<li>里氏代换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现，多使用<a id="more"></a>多态的方式。 </li>
<li>依赖倒转原则（Dependence Inversion Principle） 尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性 </li>
<li>接口隔离原则（Interface Segregation Principle） 尽量多使用小接口而不是大接口，避免接口的污染，降低类之间耦合度。</li>
<li>迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少与其他实体之间发生相互作用，使系统功能模块相对独立。 高内聚，低耦合。 </li>
<li>合成复用原则（Composite Reuse Principle） 尽量多使用合成/聚合的方式，而不是继承的方式</li>
</ul>
<h1 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h1><p><strong>基本分类</strong></p>
<ul>
<li>创建型模式 - 单例设计模式、工厂方法模式、抽象工厂模式、… </li>
<li>结构型模式 - 装饰器模式、代理模式、… </li>
<li>行为型模式 - 模板设计模式、…</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式主要分为：饿汉式 和 懒汉式，懒汉式需要对多线程进行同步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == sin) &#123;</span><br><span class="line">            <span class="comment">// 锁定创建的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == sin) &#123;</span><br><span class="line">                    sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h3><p><strong>概念</strong>  普通工厂方法模式就是建立一个工厂类，对实现了同一接口的不同实现类进行实例的创建。</p>
<p><strong>缺点</strong>  在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，并且可能出现空指针异 常。</p>
<p><strong>注</strong>  这里创建了一个Toy接口，只有一个void paly() 方法，实现类有 DogToy  CatToy  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通工厂模式,根据传递的字符串创建相应的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">(String toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toy.equals(<span class="string">&quot;CatToy&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toy.equals(<span class="string">&quot;DogToy&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ToyFactory factory = <span class="keyword">new</span> ToyFactory();</span><br><span class="line">     Toy cat = factory.produce(<span class="string">&quot;CatToy&quot;</span>);</span><br><span class="line">     cat.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个工厂模式"><a href="#多个工厂模式" class="headerlink" title="多个工厂模式"></a>多个工厂模式</h3><p><strong>缺点</strong>  在多个工厂方法模式中，为了能够正确创建对象，先需要创建工厂类的对象才能调用工厂类中的生 产方法。代码有点啰嗦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多个工厂方法模式，根据不同的方法创建不同的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produceDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produceCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ToyFactory factory = <span class="keyword">new</span> ToyFactory();</span><br><span class="line">     Toy cat = factory.produceCat();</span><br><span class="line">     cat.play();</span><br><span class="line">     Toy dog = factory.produceDog();</span><br><span class="line">     dog.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><p><strong>缺点</strong>  工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序生产新的产 品，就必须对工厂类的代码进行修改，这就违背了开闭原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态工厂模式,不用创建工厂类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toy <span class="title">produceDogStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toy <span class="title">produceCatStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Toy dog = ToyFactory.produceDogStatic();</span><br><span class="line">     dog.play();</span><br><span class="line">     Toy cat4 = ToyFactory.produceCatStatic();</span><br><span class="line">     cat.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong>概念</strong>   定义一个工厂接口。如果新增了别的产品，继承该接口即可，不需要在原有的代码上更改，符合开闭原则</p>
<p>定义一个玩具工厂接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Toy <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个生产玩具狗工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDog</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个生产玩具猫工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryCat</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这时又新增了一个玩具熊BearToy类，需要新创建一个生产玩具熊的工厂类，直接实现接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBear</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BearToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Factory factory2 = <span class="keyword">new</span> FactoryDog();</span><br><span class="line">    Toy dog3 = factory2.produce();</span><br><span class="line">    dog3.play();</span><br><span class="line">    Factory factory3 =  <span class="keyword">new</span> FactoryCat();</span><br><span class="line">    Toy cat5 = factory3.produce();</span><br><span class="line">    cat5.play();</span><br><span class="line">    Factory factory4 = <span class="keyword">new</span> FactoryBear();</span><br><span class="line">    Toy bear = factory4.produce();</span><br><span class="line">    bear.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><strong>概念</strong> 装饰器模式就是给一个对象动态的增加一些新功能，要求装饰对象和被装饰对象实现同一个接口， 装饰对象持有被装饰对象的实例。</p>
<p>定义一个Source接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个SourcePlay类，实现Source接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourcePlay</span> <span class="keyword">implements</span> <span class="title">Source</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩Lol。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个装饰器，对 SourcePlay类 中扩展功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//装饰对象和被装饰对象实现同一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装饰对象持有被装饰对象的实例</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原有的方法</span></span><br><span class="line">        source.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;打完游戏后吃饭。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SourcePlay sourcePlay = <span class="keyword">new</span> SourcePlay();</span><br><span class="line">    sourcePlay.doSomething();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用装饰器模式在原有的代码上扩展功能&quot;</span>);</span><br><span class="line">    Decorator decorator = <span class="keyword">new</span> Decorator(<span class="keyword">new</span> SourcePlay());</span><br><span class="line">    decorator.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际意义</strong>  </p>
<ul>
<li>可以实现一个类功能的扩展。 </li>
<li>可以动态的增加功能，而且还能动态撤销（继承不行）。 </li>
</ul>
<p><strong>缺点</strong>   产生过多相似的对象，不易排错。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>概念</strong> 如果需要对类中原有的方法进行改进，可以采用一个代理类调用原有方法，并且对产生的 结果进行控制，这种方式就是代理模式。 </p>
<p>用代理模式定义一个类，对 SourcePlay类 中扩展功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  代理模式 , 实现同一个接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SourcePlay sourcePlay;</span><br><span class="line">    <span class="comment">// 不用手动传递被代理的对象，直接创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sourcePlay = <span class="keyword">new</span> SourcePlay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原有的功能</span></span><br><span class="line">        sourcePlay.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;不吃饭。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际意义</strong>     使用代理模式，可以将功能划分的更加清晰，有助于后期维护。</p>
<p><strong>代理模式和装饰器模式的比较</strong> </p>
<ul>
<li>装饰器模式通常的做法是将原始对象作为一个参数传给装饰者的构造器，而代理模式通常在一个代 理类中创建一个被代理类的对象。 </li>
<li>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong>概念</strong>  模板方法模式主要指一个抽象类中封装了一个固定流程，流程中的具体步骤可以由不同子类进行不 同的实现，通过抽象类让固定的流程产生不同的结果。</p>
<p><strong>实际意义</strong> </p>
<ul>
<li>将多个子类共有且逻辑基本相同的内容提取出来实现代码复用。 </li>
<li>不同的子类实现不同的效果形成多态，有助于后期维护。</li>
</ul>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>工厂模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql笔记</title>
    <url>/2021/06/10/MySql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>SQL语句的分类</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据定义语言</td>
<td>简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。</td>
</tr>
<tr>
<td>数据操作语言</td>
<td>简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。</td>
</tr>
<tr>
<td>数据查询语言</td>
<td>简称DQL(Data Query Language)，用来查询数据库中表的记录。</td>
</tr>
<tr>
<td>数据控制语言</td>
<td>简称DCL(Date Control Language)，用来定义数据库的访问权限和安全级别，及创建用户。(了解)</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h1><h2 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a>对数据库的操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>create database 数据库名</td>
<td>创建指定名称的数据库。</td>
</tr>
<tr>
<td>create database 数据库名 character set字符集</td>
<td>创建指定名称的数据库，并且指定字符集（一般都指定utf-8）</td>
</tr>
<tr>
<td>alter database 数据库名 character set 字符集</td>
<td>数据库的字符集修改操作</td>
</tr>
<tr>
<td>drop database 数据库名</td>
<td>从MySql中永久的删除某个数据库</td>
</tr>
</tbody></table>
<p><strong>查看/选择数据库</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>use 数据库</td>
<td>切换数据库</td>
</tr>
<tr>
<td>select database()</td>
<td>查看当前正在使用的数据库</td>
</tr>
<tr>
<td>show databases</td>
<td>查看Mysql中 都有哪些数据库</td>
</tr>
<tr>
<td>show create database 数据库名；</td>
<td>查看一个数据库的定义信息</td>
</tr>
</tbody></table>
<h2 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h2><p><strong>创建表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段名称1 字段类型（长度），</span><br><span class="line">    字段名称2 字段类型 -- 注意 最后一列不要加逗号</span><br><span class="line">)；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>查看表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show tables</td>
<td>查看当前数据库中的所有表名</td>
</tr>
<tr>
<td>desc 表名</td>
<td>查看数据表的结构</td>
</tr>
</tbody></table>
<p><strong>删除表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>drop table 表名</td>
<td>删除表（从数据库中永久删除某一张表）</td>
</tr>
<tr>
<td>drop table if exists 表名</td>
<td>判断表是否存在， 存在的话就删除,不存在就不执行删除</td>
</tr>
</tbody></table>
<p><strong>修改表</strong></p>
<ul>
<li><p>修改表名</p>
<ul>
<li>```mysql<br>RENAME TABLE category TO category1;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*  修改表的字符集</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    alter table category character set gbk;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>向表中添加列， 关键字 ADD</p>
<ul>
<li>```mysql<br>ALTER TABLE category ADD cdesc VARCHAR(20);<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 修改表中列的 数据类型或长度 ， 关键字 MODIFY</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    ALTER TABLE category MODIFY cdesc VARCHAR(50)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改列名称 , 关键字 CHANGE</p>
<ul>
<li>```mysql<br>ALTER TABLE category CHANGE cdesc description VARCHAR(30);<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 删除列 ，关键字 DROP</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    ALTER TABLE category DROP description;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>*数据类型**</p>
</li>
</ul>
<p>常用的有 varchar  、int 、double 、 date</p>
<p><a href="https://imgtu.com/i/2g7dFU"><img src="https://z3.ax1x.com/2021/06/10/2g7dFU.png" alt="2g7dFU.png"></a></p>
<h1 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h1><p><strong>insert</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名 （字段名1，字段名2...） values(字段值1，字段值2...);</span><br><span class="line">INSERT INTO 表名 VALUES(字段值1，字段值2...);</span><br></pre></td></tr></table></figure>
<p><strong>update</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 &#x3D; 值 [where 字段名 &#x3D; 值 ];</span><br></pre></td></tr></table></figure>
<p><strong>delete</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 逐条删除</span><br><span class="line">delete from 表名 [where 字段名 &#x3D; 值];</span><br><span class="line">-- 先删除整张表, 然后再重新创建一张一模一样的表</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<h1 id="DQL操作"><a href="#DQL操作" class="headerlink" title="DQL操作"></a>DQL操作</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select [distinct] 列名 from 表名 [where 字段名 &#x3D; 值]</span><br></pre></td></tr></table></figure>
<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</td>
<td>大于、小于、大于(小于)等于、不等于</td>
</tr>
<tr>
<td>BETWEEN …AND…</td>
<td>显示在某一区间的值例如: 2000-10000之间： Between 2000 and 10000</td>
</tr>
<tr>
<td>IN(集合)</td>
<td>集合表示多个值,使用逗号分隔,例如: name in (悟空，八戒)，in中的每个数据都会作为一次条件,只要满足条件就会显示</td>
</tr>
</tbody></table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>And &amp;&amp;</td>
<td>多个条件同时成立</td>
</tr>
<tr>
<td>Or  ||</td>
<td>多个条件任一成立</td>
</tr>
<tr>
<td>Not</td>
<td>不成立，取反。</td>
</tr>
</tbody></table>
<p><strong>模糊查询</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LIKE</td>
<td>模糊查询，通常搭配通配符，如查询 A 开头的数据:  ‘A%’</td>
</tr>
<tr>
<td>IS NULL</td>
<td>查询某一列为NULL的值, 注: 不能写 = NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>查询不为空的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>表示匹配任意多个字符串</td>
</tr>
<tr>
<td>_</td>
<td>表示匹配 一个字符</td>
</tr>
</tbody></table>
<p><strong>排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表名 [WHERE 字段 &#x3D; 值] ORDER BY 字段名 [ASC &#x2F; DESC]</span><br></pre></td></tr></table></figure>
<p>ASC  : 升序 （默认）</p>
<p>DESC : 降序</p>
<p>如果单个排序不能满足要求，可以组合排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表明 [WHERE 字段 &#x3D; 值 ] ORDER BY 字段名一 [ASC&#x2F;DESC],字段名二 [ASC&#x2F;DESC]; </span><br></pre></td></tr></table></figure>
<p><strong>聚合函数</strong></p>
<p>之前我们做的查询都是横向查询，而聚合函数查询是纵向 查询，它是对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空值)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 聚合函数(字段名) FROM 表名;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>count(字段)</td>
<td>统计指定列不为NULL的记录行数</td>
</tr>
<tr>
<td>sum(字段)</td>
<td>计算指定列的数值和</td>
</tr>
<tr>
<td>max(字段)</td>
<td>计算指定列的最大值</td>
</tr>
<tr>
<td>min(字段)</td>
<td>计算指定列的最小值</td>
</tr>
<tr>
<td>avg(字段)</td>
<td>计算指定列的平均值</td>
</tr>
</tbody></table>
<p><strong>分组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 分组字段&#x2F;聚合函数 FzROM 表名 GROUP BY 分组字段 [HAVING 条件];</span><br></pre></td></tr></table></figure>
<p>使用 GROUP BY 语句,对查询的信息进行分组,相同数据作为一组。分组如果不适用聚合函数，其结果只会显示每一组的第一行数据，没有任何意义。如果在分组后,对数据进行过滤,使用 关键字 having</p>
<ul>
<li>where 与 having的区别</li>
</ul>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>where</td>
<td>where 进行分组前的过滤<br/>where 后面不能写 聚合函数</td>
</tr>
<tr>
<td>having</td>
<td>having 是分组后的过滤<br/>having 后面可以写 聚合函数</td>
</tr>
</tbody></table>
<ul>
<li>案例 ： 查询平均薪资大于6000的部门</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT dept_name ,AVG(salary) FROM emp </span><br><span class="line">WHERE dept_name IS NOT NULL GROUP BY dept_name</span><br><span class="line">HAVING AVG(salary) &gt;6000 ;</span><br></pre></td></tr></table></figure>
<p><strong>limit关键字</strong></p>
<ul>
<li>限制返回的查询结果的行数 (可以通过limit指定查询多少行数据) ,  limit 语法是 MySql的方言,用来完成分页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 LIMIT offset [, length];</span><br></pre></td></tr></table></figure>
<ul>
<li>offset     起始行数, 从0开始记数, 如果省略 则默认为 0.</li>
<li>length 返回的行数</li>
<li>分页公式 :   起始索引 = (当前页 - 1) * 每页条数</li>
</ul>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>通过指定的条件去匹配两张表中的数据, 匹配上就显示,匹配不上就不显示</p>
<p><strong>隐式内连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 左表, 右表 WHERE 连接条件;</span><br></pre></td></tr></table></figure>
<p><strong>显式内连接   [inner] join</strong>     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件;</span><br></pre></td></tr></table></figure>
<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p><strong>左外连接   left [outer] join</strong>    </p>
<p>以左表为基准, 匹配右边表中的数据,如果匹配的上,就展示匹配到的数据 如果匹配不到, 左表中的数据正常展示, 右边的展示为null.</p>
<p><strong>右外连接   right [outer] join</strong></p>
<p>以右表为基准，匹配左边表中的数据，如果能匹配到，展示匹配到的数据 如果匹配不到，右表中的数据正常展示, 左边展示为null</p>
<p><a href="https://imgtu.com/i/2WkO4U"><img src="https://z3.ax1x.com/2021/06/11/2WkO4U.png" alt="2WkO4U.png" style="zoom: 67%;" /></a></p>
<h2 id="子查询-SubQuery"><a href="#子查询-SubQuery" class="headerlink" title="子查询 (SubQuery)"></a>子查询 (SubQuery)</h2><p>一条select 查询语句的结果, 作为另一条 select 语句的一部分</p>
<p><strong>分类</strong></p>
<ul>
<li><strong>where型</strong>  将子查询的结果, 作为父查询的比较条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM 表 WHERE 字段&#x3D;（子查询）;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>from型</strong>  将子查询的结果, 作为 一张表,提供给父层查询使用 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM （子查询）表别名 WHERE 条件;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>exists型</strong>  子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查 询的结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM 表 WHERE 字段 IN （子查询）;</span><br></pre></td></tr></table></figure>
<h1 id="DCL操作"><a href="#DCL操作" class="headerlink" title="DCL操作"></a>DCL操作</h1><p>MySql默认使用的都是 root 用户，超级管理员，拥有全部的权限。除了root用户以外，我们还可以通 过DCL语言来定义一些权限较小的用户, 分配不同的权限来管理和维护数据库。</p>
<p><strong>创建用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</span><br></pre></td></tr></table></figure>
<p>本地用户可用 ‘localhost’表示主机名，  如果想让该用户可以 从任意远程主机登陆，可以使用通配符 %</p>
<p> <strong>用户授权</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT 权限 1, 权限 2... ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p>权限为 ： CREATE、ALTER、SELECT、INSERT、UPDATE等，如果要赋值所有权限就使用 ‘ALL’</p>
<p>数据库名.表名  ：写成  *.*   代表可赋予所有数据库与表的操作</p>
<p> <strong>查看权限</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>删除用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p> <strong>查询用户</strong></p>
<p>用户的信息在 mysql的 数据库中的 user表,直接用 DQL语句即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM USER;</span><br></pre></td></tr></table></figure>
<h1 id="数据库备份-amp-还原"><a href="#数据库备份-amp-还原" class="headerlink" title="数据库备份&amp;还原"></a>数据库备份&amp;还原</h1><p> <strong>SQLYog的备份与还原</strong></p>
<p>直接使用图形化界面操作就行了，不过SQLYog的备份与还原是整个数据库的操作</p>
<p><strong>命令行的备份与还原</strong></p>
<p>命令行的备份与还原是将整个数据库的表全部提取出来，不会重新创建数据库</p>
<ul>
<li><p>备份</p>
<ul>
<li><p>进入到Mysql安装目录的 bin目录下, 打开DOS命令行，输入以下命令:</p>
</li>
<li><p>```mysql<br>mysqldump -u 用户名 -p 密码 数据库 &gt; 要保存到的文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 还原</span><br><span class="line"></span><br><span class="line">  * 先创建一个 相同名称的数据库</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;mysql</span><br><span class="line">    use 当前数据库;    --选中当前数据库   </span><br></pre></td></tr></table></figure></li>
<li><p>```mysql<br>source sql 文件地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># SQL约束</span><br><span class="line"></span><br><span class="line"> 约束的作用: 对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性. 违反约束的 不正确数据,将无法插入到表中</span><br><span class="line"></span><br><span class="line">**常见的约束**</span><br><span class="line"></span><br><span class="line">| 约束名 | 关键字      |</span><br><span class="line">| ------ | ----------- |</span><br><span class="line">| 主键   | primary key |</span><br><span class="line">| 唯一   | unique      |</span><br><span class="line">| 非空   | not null    |</span><br><span class="line">| 外键   | foreign key |</span><br><span class="line">| 默认值 | defaul      |</span><br><span class="line"></span><br><span class="line"># 事务（transaction）</span><br><span class="line"></span><br><span class="line">事务是一个整体,由一条或者多条SQL 语句组成,这些SQL语句要么都执行成功,要么都执行失败, 只要有一 条SQL出现异常,整个操作就会回滚,整个业务执行失败</span><br><span class="line"></span><br><span class="line">**手动提交事务**</span><br><span class="line"></span><br><span class="line">| 功能     | 语句                           |</span><br><span class="line">| -------- | ------------------------------ |</span><br><span class="line">| 开启事务 | start transaction; 或者 BEGIN; |</span><br><span class="line">| 提交事务 | commit;                        |</span><br><span class="line">| 回滚事务 | rollback;                      |</span><br><span class="line"></span><br><span class="line">[&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;z3.ax1x.com&#x2F;2021&#x2F;06&#x2F;11&#x2F;2WFIw6.png&quot; alt&#x3D;&quot;2WFIw6.png&quot; style&#x3D;&quot;zoom:50%;&quot; &#x2F;&gt;](https:&#x2F;&#x2F;imgtu.com&#x2F;i&#x2F;2WFIw6)</span><br><span class="line"></span><br><span class="line">**自动提交事务** </span><br><span class="line"></span><br><span class="line">MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执 行完毕 自动提交事务，MySQL 默认开始自动提交事务。</span><br><span class="line"></span><br><span class="line">**取消自动提交** </span><br><span class="line"></span><br><span class="line">MySQL默认是自动提交事务,设置为手动提交.</span><br><span class="line"></span><br><span class="line">* 登录mysql，查看autocommit状态。on ：自动提交 off : 手动提交</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p> 把 autocommit 改成 off;</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@autocommit&#x3D;off;</span><br></pre></td></tr></table></figure>
<p><strong>事务的四大特性 ACID</strong></p>
<ul>
<li><p><strong>原 子 性</strong> 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都 失败。 </p>
</li>
<li><p><strong>一 致 性</strong> 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前2个人的 总金额 是 2000，转账后 2 个人总金额也是 2000. </p>
</li>
<li><p><strong>隔 离 性</strong> 事务与事务之间不应该相互影响，执行时保持隔离的状态. </p>
</li>
<li><p><strong>持 久 性</strong> 一旦事务执行成功，对数据库的修改是持久的。就算关机，数据也是要保存下来的.</p>
</li>
<li><p>*并发访问会产生的问题**</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>并发访问的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读取到了另一个事务中尚未提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务中两次读取的数据内容不一致, 要求的是在一个事务中多次读取时数据是一致的. 这是进行 update 操作时引发的问题</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务中,某一次的 select 操作得到的结果所</td>
</tr>
</tbody></table>
<p><strong>四种隔离级别</strong>       (✔ 会出现问题 ✘ 不会出现问题)</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>名字</th>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>数据库的默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>读未提交</td>
<td>read uncommitted</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>读已提交</td>
<td>read committed</td>
<td>✘</td>
<td>✔</td>
<td>✔</td>
<td>Oracle和SQLServer</td>
</tr>
<tr>
<td>3</td>
<td>可重复读</td>
<td>repeatable read</td>
<td>✘</td>
<td>✘</td>
<td>✔</td>
<td>MySql</td>
</tr>
<tr>
<td>4</td>
<td>串行化</td>
<td>serializable</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td></td>
</tr>
</tbody></table>
<p><strong>隔离级别相关命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set global transaction isolation level 级别名称;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令MySQL的查询和 运行更加高效。</p>
<table>
<thead>
<tr>
<th>索引名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引 (primarykey)</td>
<td>主键是一种唯一性索引,每个表只能有一个主键, 用于标识数据表中的每一条记录</td>
</tr>
<tr>
<td>唯一索引 (unique)</td>
<td>唯一索引指的是 索引列的所有值都只能出现一次, 必须唯一.</td>
</tr>
<tr>
<td>普通索引 (index)</td>
<td>最常见的索引,作用就是 加快对数据的访问速度</td>
</tr>
</tbody></table>
<p><strong>索引的优点</strong> </p>
<ul>
<li>大大的提高查询速度 </li>
<li>可以显著的减少查询中分组和排序的时间。 </li>
</ul>
<p>索引的缺点</p>
<ul>
<li>创建索引和维护索引需要时间，而且数据量越大时间越长 </li>
<li>当对表中的数据进行增加，修改，删除的时候，索引也要同时进行维护，降低了数据的维护 速度</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h2><p>视图是一种虚拟表 , 建立在已有表的基础上, 视图赖以建立的这些表称为基表。</p>
<p><strong>创建视图</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名 [column_list] as select语句;</span><br></pre></td></tr></table></figure>
<p>对视图的其他操作与对表的操作一模一样</p>
<p><strong>视图与表的区别</strong></p>
<ul>
<li>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 </li>
<li>通过视图不能改变表中数据（一般情况下视图中的数据都是表中的列 经过计算得到的结果,不允许 更新） </li>
<li>删除视图，表不受影响，而删除表，视图不再起作用</li>
</ul>
<h2 id="存储过程（procedure）"><a href="#存储过程（procedure）" class="headerlink" title="存储过程（procedure）"></a>存储过程（procedure）</h2><p> 一堆 SQL 语句的合并。中间加入了一些逻辑控制。</p>
<p><strong>创建存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$ -- 声明语句结束符，可以自定义 一般使用$$</span><br><span class="line">-- 声明存储过程，形参可以有多个，返回参数只能有一个</span><br><span class="line">CREATE PROCEDURE 过程名称([IN 形参名 形参类型],[out 输出参数名 输出参数类型]) </span><br><span class="line">BEGIN -- 开始编写存储过程</span><br><span class="line">-- 要执行的操作</span><br><span class="line">END $$ -- 存储过程结束</span><br></pre></td></tr></table></figure>
<p><strong>调用存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名</span><br><span class="line">call 存储过程名(实参)</span><br><span class="line">call 存储过程名(实参,@输出数据)</span><br></pre></td></tr></table></figure>
<p><strong>变量赋值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @变量名&#x3D;值</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 向订单表 插入一条数据, 返回1,表示插入成功</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE orders_proc(IN o_id INT , IN g_id INT ,IN price INT, OUT out_num INT)</span><br><span class="line">BEGIN</span><br><span class="line">    -- 执行插入操作</span><br><span class="line">    INSERT INTO orders VALUES(o_id,o_id,price);</span><br><span class="line">    -- 设置 num的值为 1</span><br><span class="line">    SET @out_num &#x3D; 1;</span><br><span class="line">    -- 返回 out_num的值</span><br><span class="line">    SELECT @out_num;</span><br><span class="line">END $$</span><br><span class="line"># 调用存储过程插入数据,获取返回值</span><br><span class="line">CALL orders_proc(1,2,30,@out_num);</span><br></pre></td></tr></table></figure>
<h2 id="触发器（trigger）"><a href="#触发器（trigger）" class="headerlink" title="触发器（trigger）"></a>触发器（trigger）</h2><p> 当我们执行一条sql语句的时候，这条sql语句的执行会自动去触发执行其他的sql语句。</p>
<p><strong>四要素</strong></p>
<ul>
<li>监视地点（table） </li>
<li>监视事件（insert/update/delete） 3</li>
<li>触发时间（before/after） </li>
<li>触发事件（insert/update/delete）</li>
</ul>
<p><strong>创建触发器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $ -- 将Mysql的结束符号从 ; 改为 $,避免执行出现错误</span><br><span class="line">CREATE TRIGGER Trigger_Name -- 触发器名，在一个数据库中触发器名是唯一的</span><br><span class="line">before&#x2F;after（insert&#x2F;update&#x2F;delete） -- 触发的时机 和 监视的事件</span><br><span class="line">on table_Name -- 触发器所在的表</span><br><span class="line">for each row -- 固定写法 叫做行触发器, 每一行受影响，触发事件都执行</span><br><span class="line">begin</span><br><span class="line">-- begin和end之间写触发事件</span><br><span class="line">end $ -- 结束标记</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -- 在下订单的时候，对应的商品的库存量要相应的减少，卖出商品之后减少库存量</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE TRIGGER t1</span><br><span class="line">AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	UPDATE goods SET num &#x3D; num -1 WHERE gid &#x3D; 1;</span><br><span class="line">END$</span><br></pre></td></tr></table></figure>


<p>over 。。。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>XML笔记</title>
    <url>/2021/06/13/XML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>XML即可扩展标记语言（Extensible Markup Language） 。W3C在1998年2月发布1.0版本，2004年2月又发布1.1版本，但因为1.1版本不能向下兼容1.0版 本，所以1.1没有人用。同时，在2004年2月W3C又发布了1.0版本的第三版。我们要学习的还是 1.0版本 ! <a id="more"></a></p>
<p><strong>XML作用</strong></p>
<ul>
<li><ol>
<li>储数据     2) 配置文件   3)在网络中 传输 </li>
</ol>
</li>
</ul>
<p><strong>XML语法</strong></p>
<ul>
<li>文档声明必写在第一行</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--versioin：指定XML文档版本。encoding：指定当前文档的编码。可选属性，默认值是utf-8；--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML 必须有且只有一个根元素，它是所有其他元素的父元素</p>
</li>
<li><p>普通元素的结构开始标签、元素体、结束标签组成。类似于HTML标签</p>
</li>
</ul>
<h1 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h1><p>在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。 </p>
<p><strong>常见的xml约束</strong>    DTD 、 Schema</p>
<h2 id="DTD约束"><a href="#DTD约束" class="headerlink" title="DTD约束"></a>DTD约束</h2><p>DTD（Document Type Definition），文档类型定义，用来约束XML文档。规定XML文档中元素的名 称，子元素的名称及顺序，元素的属性等。</p>
<p><strong>创建一个约束文件student.dtd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT students (student+) &gt;</span><br><span class="line">&lt;!ELEMENT student (name,age,sex)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">&lt;!ATTLIST student number ID #REQUIRED&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">ELEMENT: 用来定义元素</span><br><span class="line">students (student+) : 代表根元素 必须是 &lt;students&gt;</span><br><span class="line">student+ : 根标签中至少有一个 student子元素, + 代表至少一个</span><br><span class="line">student (name,age,sex): student 标签中包含的子元素,按顺序出现</span><br><span class="line">#PCDATA: 是普通文本内容</span><br><span class="line">ATTLIST: 用来定义属性</span><br><span class="line">student number ID #REQUIRED</span><br><span class="line">student子元素中 有一个ID属性叫做 number,是必须填写的</span><br><span class="line">ID: 唯一 值只能是字母或者下划线开头</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p><strong>创建student.xml文件并引入DTD约束</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">students</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;student.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Schema约束"><a href="#Schema约束" class="headerlink" title="Schema约束"></a>Schema约束</h2><p><strong>概念</strong></p>
<ul>
<li>Schema是新的XML文档约束, 比DTD强大很多，是DTD 替代者； </li>
<li>Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。 </li>
<li>Schema 功能更强大，内置多种简单和复杂的数据类型 </li>
<li>Schema 支持命名空间 (一个XML中可以引入多个约束文档)</li>
</ul>
<p><strong>创建一个Schema约束文件student.xsd</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.hui.com/xml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.hui.com/xml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentsType&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentsType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ageType&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;sexType&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">type</span>=<span class="string">&quot;numberType&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;sexType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;ageType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:integer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;numberType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:pattern</span> <span class="attr">value</span>=<span class="string">&quot;hui_\d&#123;4&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建student.xml文件并引入Schema约束</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">&lt;students</span><br><span class="line">        xmlns=&quot;http://www.hui.com/xml&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.hui.com/xml student.xsd&quot;</span><br><span class="line">&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;hui_1234&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;hui_5678&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>3<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>xmlns</strong> 表示根元素来自哪个命名空间</p>
<p><strong>xmlns:xsi</strong>  引入 w3c的标准命名空间</p>
<p><strong>xsi:schemaLocation</strong>  表示引入的命名空间跟哪个xsd文件对应，第一个值为为命名空间 第二个值为xsd文件的路径</p>
<h1 id="XML-解析"><a href="#XML-解析" class="headerlink" title="XML 解析"></a>XML 解析</h1><p><strong>XML解析方式</strong></p>
<ul>
<li>DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象。 <ul>
<li>优点：元素与元素之间保留结构关系，故可以进行增删改查操作。 </li>
<li>缺点：XML文档过大，可能出现内存溢出显现。 </li>
</ul>
</li>
<li>SAX：是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。并以事件驱动的方 式进行具体解析，每执行一行，都将触发对应的事件。<ul>
<li>优点：占用内存少 处理速度快，可以处理大文件 </li>
<li>缺点：只能读，逐行后将释放资源。</li>
</ul>
</li>
</ul>
<p><strong>XML常见的解析器</strong></p>
<ul>
<li>JAXP：sun公司提供的解析器，支持DOM和SAX两种思想 </li>
<li>DOM4J：一款非常优秀的解析器 , Dom4j是一个易用的、开源的库，用于XML，XPath和XSLT。 它应用于Java平台，采用了Java集合框架并完全支持DOM，SAX和JAXP。</li>
<li> Jsoup：jsoup 是一款Java 的HTML解析器 ,也可以解析XML </li>
<li>PULL：Android内置的XML解析方式，类似SAX。</li>
</ul>
<h2 id="dom4j-的使用"><a href="#dom4j-的使用" class="headerlink" title="dom4j 的使用"></a>dom4j 的使用</h2><p>所需jar包   <strong>dom4j-1.6.1.jar</strong></p>
<p>通过核心类SaxReader加载xml文档获得Document，通过Document 对象获得文档的根元素，然后就 可以操作了</p>
<p><strong>SaxReader对象</strong>  read(…) 加载执行xml文档 </p>
<p><strong>Document对象</strong>  getRootElement() 获得根元素 </p>
<p><strong>Element对象</strong> </p>
<ul>
<li>elements(…) 获得指定名称的所有子元素。可以不指定名称 </li>
<li>element(…) 获得指定名称的第一个子元素。可以不指定名称 </li>
<li>getName() 获得当前元素的元素名 </li>
<li>attributeValue(…) 获得指定属性名的属性值 </li>
<li>elementText(…) 获得指定名称子元素的文本值 </li>
<li>getText() 获得当前元素的文本内容</li>
</ul>
<p><strong>使用案例</strong></p>
<ul>
<li>创建一个user.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;01&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;02&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>34<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;03&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 dom4j 解析user.xml文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">    	<span class="comment">// 构造获取SAXReader对象</span></span><br><span class="line">       SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    	<span class="comment">// 指定XML文件地址获取Document对象</span></span><br><span class="line">       Document document = saxReader.read(<span class="string">&quot;C:\\project\\javaCode\\java_base\\jdbc_xml\\xml\\src\\com\\hui\\dom4j\\user.xml&quot;</span>);</span><br><span class="line">    	<span class="comment">// 获取根元素</span></span><br><span class="line">       Element root = document.getRootElement();</span><br><span class="line">    	<span class="comment">// 获取根元素的所有子元素</span></span><br><span class="line">       List&lt;Element&gt; elements = root.elements();</span><br><span class="line">       <span class="comment">// 解析第一个子元素 user</span></span><br><span class="line">       Element user = elements.get(<span class="number">0</span>);</span><br><span class="line">       String name = user.getName();      					<span class="comment">// 获取标签名</span></span><br><span class="line">       String id = user.attributeValue(<span class="string">&quot;id&quot;</span>);				<span class="comment">// 获取user的id属性</span></span><br><span class="line">       String nameText = user.elementText(<span class="string">&quot;name&quot;</span>);			<span class="comment">// 获取name子元素的文本内容</span></span><br><span class="line">       String ageText = user.elementText(<span class="string">&quot;age&quot;</span>);		    <span class="comment">// 获取age子元素的文本内容</span></span><br><span class="line">       String hobbyText = user.element(<span class="string">&quot;hobby&quot;</span>).getText(); <span class="comment">// 获取hobby子元素的文本内容</span></span><br><span class="line">       System.out.println(name + <span class="string">&quot; : &quot;</span> + id + <span class="string">&quot; &quot;</span> + nameText + <span class="string">&quot; &quot;</span> + ageText + <span class="string">&quot; &quot;</span> + hobbyText);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="xpath方式读取xml"><a href="#xpath方式读取xml" class="headerlink" title="xpath方式读取xml"></a>xpath方式读取xml</h2><p>XPath 是一门在 XML 文档中查找信息的语言。 可以是使用xpath查找xml中的内容</p>
<p>所需jar包       <strong>jaxen-1.1-beta-6.jar</strong></p>
<p><strong>常用方法</strong></p>
<p><strong>Document对象</strong>   <strong>Element对象</strong>    <strong>Node对象</strong>都可应调用下面两个xpath查询的方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Node selectSingleNode(String query)</td>
<td>查找和 XPath 查询匹配的一个节点。 参数是Xpath 查询串。</td>
</tr>
<tr>
<td>Node selectNodes(String query)</td>
<td>得到的是xml根节点下的所有满足 xpath 的节点,参数是Xpath 查询串</td>
</tr>
</tbody></table>
<p>返回值是Node对象，该对象的方法与Element对象的方法差不多</p>
<table>
<thead>
<tr>
<th>xpath基本语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/AAA/DDD/BBB</td>
<td>表示一层一层的，AAA下面 DDD下面的BBB</td>
</tr>
<tr>
<td>//BBB</td>
<td>表示和这个名称相同，表示只要名称是BBB，都得到</td>
</tr>
<tr>
<td>//*</td>
<td>所有元素</td>
</tr>
<tr>
<td>BBB[1] , BBB[last()]</td>
<td>第一种表示第一个BBB元素, 第二种表示最后一个BBB元素</td>
</tr>
<tr>
<td>//BBB[@id]</td>
<td>表示只要BBB元素上面有id属性，都得到</td>
</tr>
<tr>
<td>//BBB[@id=’b1’]</td>
<td>表示元素名称是BBB,在BBB上面有id属性，并且id的属性值是b1</td>
</tr>
</tbody></table>
<h2 id="JDBC自定义XML"><a href="#JDBC自定义XML" class="headerlink" title="JDBC自定义XML"></a>JDBC自定义XML</h2><p><strong>创建自定义xml 文件jdbc-config.xml, 保存 数据库连接信息</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>nofuck<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>编写JDBC工具类 , 使用xpath 读取数据库信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.dom4j.jdbc;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: 李昭辉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/13/12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JDBC工具类，相关配置从 jdbc-config.xml 文件中获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String DRIVER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PASSWORD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取配置文件信息</span></span><br><span class="line">            SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = saxReader.read(<span class="string">&quot;C:\\project\\javaCode\\java_base\\jdbc_xml\\xml\\src\\com\\hui\\dom4j\\jdbc\\jdbc-config.xml&quot;</span>);</span><br><span class="line">            DRIVER = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;driverClass&#x27;]&quot;</span>).getText();</span><br><span class="line">            URL = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;jdbcUrl&#x27;]&quot;</span>).getText();</span><br><span class="line">            USER = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;user&#x27;]&quot;</span>).getText();</span><br><span class="line">            PASSWORD = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;password&#x27;]&quot;</span>).getText();</span><br><span class="line">            <span class="comment">// 加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>xpath</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC笔记</title>
    <url>/2021/06/12/JDBC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul>
<li><p>JDBC(Java Data Base Connectivity) 是 Java 访问数据库的标准规范.是一种用于执行SQL语句的Java API，可以为 多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范.<a id="more"></a></p>
</li>
<li><p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需 要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>所需jar包   mysql-connector-java-5.1.37-bin.jar</strong></p>
<ul>
<li>JDBC规范定义驱动接口： java.sql.Driver MySql</li>
<li>驱动包提供了实现类： com.mysql.jdbc.Driver</li>
</ul>
<p><strong>删除案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//1.注册驱动 , forName 方法执行将类进行初始化</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获得连接   url,用户名, 密码</span></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hui?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">    Connection con = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//3.获取语句执行平台</span></span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">	<span class="comment">//5.增删改操作 使用executeUpdate,增加一张表</span></span><br><span class="line">    <span class="keyword">int</span> i = statement.executeUpdate(<span class="string">&quot;delete form hui where id = 1&quot;</span>);</span><br><span class="line">    <span class="comment">//6.返回值是受影响的函数</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">//7.关闭流</span></span><br><span class="line">    statement.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Connection 的 createStatement() 方法 获取sql语句执行对象Statement </p>
<p><strong>Statement</strong> ： 代表一条语句对象，用于发送 SQL 语句给服务器，用于执行静态 SQL 语句并返回它所生成结 果的对象。</p>
<table>
<thead>
<tr>
<th>Statement类 常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int executeUpdate(String sql);</td>
<td>执行insert update delete语句.返回int类型,代表受影响的行数</td>
</tr>
<tr>
<td>ResultSet executeQuery(String sql);</td>
<td>执行select语句, 返回ResultSet结果集对象</td>
</tr>
</tbody></table>
<p><strong>结果集 ResultSet 的处理</strong></p>
<table>
<thead>
<tr>
<th>ResultSet接口方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean next()</td>
<td>游标向下一行 ，返回 boolean 类型，如果还有下一条记录，返回 true，否则返回 false</td>
</tr>
<tr>
<td>xxx getXxx( String or int)</td>
<td>传递字段名  或  字段的列号，从1开始</td>
</tr>
</tbody></table>
<p><strong>查询案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement statement = con.createStatement();</span><br><span class="line"><span class="comment">// 执行查询语句获取结果集</span></span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line"><span class="comment">// 遍历结果集，获取所有数据</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String username = resultSet.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    Date createTime = resultSet.getDate(<span class="string">&quot;createTime&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username+<span class="string">&quot;,createTime:&quot;</span>+createTime)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure>
<p><strong>步骤总结</strong></p>
<ol>
<li>获取驱动(可以省略) </li>
<li> 获取连接</li>
<li> 获取Statement对象 </li>
<li>处理结果集(只在查询时处理) </li>
<li>释放资源</li>
</ol>
<p><strong>自定义一个 JDBCUtil 工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: 李昭辉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/12/9:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JDBC 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(URL, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;nofuck&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SQL预处理对象"><a href="#SQL预处理对象" class="headerlink" title="SQL预处理对象"></a>SQL预处理对象</h2><p><strong>Sql注入问题</strong></p>
<ul>
<li>我们让用户输入的密码和 SQL 语句进行字符串拼接。用户输入的内容作为了 SQL 语句语法的一部分，改变了 原有 SQL 真正的意义，以上问题称为 SQL 注入 .</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--  这样一条SQL语句就表示查询所有</span><br><span class="line">SELECT * FROM jdbc_user WHERE username &#x3D; &#39;tom&#39; AND password&#x3D; &#39;123&#39;  OR  &#39;1&#39; &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure>
<p>因为SQL语句是用字符串拼接的，当用户输入密码时输入: XXX ‘  OR  ‘1’ = ‘1，就可以随便登入了，这时我们可以用JDBC中的预处理对象</p>
<p><strong>PreparedStatement 接口</strong></p>
<ul>
<li>PreparedStatement 是 Statement 接口的子接口，继承于父接口中所有的方法。</li>
<li>它是一个预编译的 SQL 语 句对象. 预编译: 是指SQL 语句被预编译,并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行 该语句。</li>
</ul>
<p><strong>优点</strong> ：1）因为有预先编译的功能，提高 SQL 的执行效率； 2）可以有效的防止 SQL 注入的问题，安全性更高</p>
<p><strong>获取预处理对象</strong> 通过连接 Connection.prepareStatement(sql语句) 直接获取</p>
<table>
<thead>
<tr>
<th>PreparedStatement接口常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int executeUpdate();</td>
<td>执行insert update delete语句.</td>
</tr>
<tr>
<td>ResultSet executeQuery();</td>
<td>执行select语句. 返回结果集对象 Resulet</td>
</tr>
<tr>
<td>void setXXX(int parameterIndex, XXX value)</td>
<td>设置占位符?parameterIndex出的值为XXX类型的value</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理防止注入问题</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       Connection con = JDBCUtil.getConnection(); <span class="comment">//获取链接</span></span><br><span class="line">       <span class="comment">// 获取预处理对象，先将sql放入，数据库可以预先编译，?表示占位符</span></span><br><span class="line">       String sql = <span class="string">&quot;select * from user where username=? and password= ? &quot;</span>;</span><br><span class="line">       PreparedStatement statement = con.prepareStatement(sql);</span><br><span class="line">       <span class="comment">// 控制台模拟用户输入用户名与密码</span></span><br><span class="line">       Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">       String name = sc.nextLine();</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);<span class="comment">// 输入 xxx&#x27; or &#x27;1&#x27;=&#x27;1 将无法注入</span></span><br><span class="line">       String pwd = sc.nextLine();</span><br><span class="line">       <span class="comment">// 将预处理中sql中的占位符填充数据</span></span><br><span class="line">       statement.setString(<span class="number">1</span>, name);</span><br><span class="line">       statement.setString(<span class="number">2</span>, pwd);</span><br><span class="line">       <span class="comment">// 执行SQL</span></span><br><span class="line">       ResultSet resultSet = statement.executeQuery();</span><br><span class="line">       System.out.println(resultSet.next() ? <span class="string">&quot;登入成功!&quot;</span> : <span class="string">&quot;登入失败!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>预处理插入多条数据案例</strong>   SQL语句发送给数据库，数据库只需要编译一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取预处理对象</span></span><br><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">&quot;insert into jdbc_user values(null,?,?)&quot;</span>);</span><br><span class="line"><span class="comment">//第一条数 设置占位符对应的参数</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"><span class="comment">//执行插入</span></span><br><span class="line">ps.executeUpdate();</span><br><span class="line"><span class="comment">//第二条数据</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//执行插入</span></span><br><span class="line">ps.executeUpdate();</span><br></pre></td></tr></table></figure>
<p> <strong>Statement 与 PreparedStatement的区别</strong></p>
<ul>
<li><p>Statement用于执行静态SQL语句，在执行时，必须指定一个事先准备好的SQL语句。</p>
</li>
<li><p>PrepareStatement是预编译的SQL语句对象，语句中可以包含动态参数“?”，在执行时可以为“?”动态设置参数 值</p>
</li>
<li><p>PrepareStatement可以减少编译次数提高数据库性能</p>
</li>
</ul>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p><strong>Connection中事务相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void setAutoCommit(boolean autoCommit)</td>
<td>参数是 true 或 false 如果设置为 false，表示关闭自动提交，相当于开启事务</td>
</tr>
<tr>
<td>void commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback()</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟银行转账操作 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = JDBCUtil.getConnection(); <span class="comment">// 获取连接</span></span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">            <span class="comment">// 预处理模拟转账操作</span></span><br><span class="line">            ps = con.prepareStatement(<span class="string">&quot;update account set money=money- ? where username = ?&quot;</span>);</span><br><span class="line">            ps.setInt(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);  <span class="comment">// 模拟出现异常</span></span><br><span class="line">            ps = con.prepareStatement(<span class="string">&quot;update account set money=money+ ? where username = ?&quot;</span>);</span><br><span class="line">            ps.setInt(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            con.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            JDBCUtil.close(con, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据库批处理batch"><a href="#数据库批处理batch" class="headerlink" title="数据库批处理batch"></a>数据库批处理batch</h2><p>批处理指的是一次操作中执行多条SQL语句，批处理相比于一次一次执行效率会提高很多。 当向数据库中添加大量的数据时，需要用到批处理。</p>
<p>Statement和PreparedStatement都支持批处理操作，这里介绍一下PreparedStatement的批处理方式</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addBatch()</td>
<td>将给定的 SQL 命令添加到此 Statement 对象的当前命令列表中。通过调用方法 executeBatch 可以批量执行此列表中的命令。</td>
</tr>
<tr>
<td>int[] executeBatch()</td>
<td>每次提交一批命令到数据库中执行，如果所有的命令都成功执行了，那么返回一个数组，这个数组是说明每条命令所影响的行数</td>
</tr>
</tbody></table>
<p><strong>注</strong> mysql 批处理是默认关闭的，所以需要加一个参数才能打开mysql 数据库批处理，在url中添加 rewriteBatchedStatements=true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/db5?characterEncoding=UTF-8&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure>
<p><strong>插入10000条数据案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批处理操作</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAdd</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       Connection con = JDBCUtil.getConnection();</span><br><span class="line">       PreparedStatement ps = con.prepareStatement(<span class="string">&quot;insert into user values(null,?,&#x27;123&#x27;, &#x27;2021-6-15&#x27;)&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           ps.setString(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span> + i);</span><br><span class="line">           ps.addBatch();</span><br><span class="line">       &#125;</span><br><span class="line">       ps.executeBatch();</span><br><span class="line">       JDBCUtil.close(con, ps);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MySql元数据MetaData"><a href="#MySql元数据MetaData" class="headerlink" title="MySql元数据MetaData"></a>MySql元数据MetaData</h2><p>除了表之外的数据都是元数据,可以分为三类 </p>
<ul>
<li>查询结果信息： UPDATE 或 DELETE语句 受影响的记录数。 </li>
<li>数据库和数据表的信息： 包含了数据库及数据表的结构信息。 </li>
<li>MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等</li>
</ul>
<p><strong>DatabaseMetaData类</strong>    </p>
<p>描述数据库的元数据对象，通过Connection 连接对象的 getMetaData () 方法获取</p>
<table>
<thead>
<tr>
<th>DatabaseMetaData方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>getURL() : 获取数据库的URL</td>
</tr>
<tr>
<td>getUserName(): 获取当前数据库的用户名</td>
</tr>
<tr>
<td>getDatabaseProductName(): 获取数据库的产品名称</td>
</tr>
<tr>
<td>getDatabaseProductVersion(): 获取数据的版本号</td>
</tr>
<tr>
<td>getDriverName(): 返回驱动程序的名称</td>
</tr>
<tr>
<td>isReadOnly(): 判断数据库是否只允许只读 true 代表只读</td>
</tr>
</tbody></table>
<p><strong>ResultSetMetaData类</strong>    </p>
<p>描述结果集的元数据对象，通过PrepareStatement 预处理对象的 getMetaData ()获取</p>
<table>
<thead>
<tr>
<th>ResultSetMetaData方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>getColumnCount() :v 当前结果集共有多少列</td>
</tr>
<tr>
<td>getColumnName(int i) : 获取指定列号的列名, 参数是整数 从1开始</td>
</tr>
<tr>
<td>getColumnTypeName(int i): 获取指定列号列的类型, 参数是整数 从1开始</td>
</tr>
</tbody></table>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>管理Connection连接的创建与销毁 ， 可以重复使用Connection。 当使用完Connection后，调用Connection的 close()方法也不会真的关闭Connection，而是把Connection“归还”给池。</p>
<p>Java为数据库连接池提供了公共的接口：javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。 这样应用程序可以方便的切换不同厂商的连接池。</p>
<h2 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h2><p> DBCP也是一个开源的连接池，是Apache成员之一，在企业开发中也比较常见，tomcat内置的连接池</p>
<p>所需jar包  : <strong>commons-dbcp-1.4.jar</strong>        <strong>commons-pool-1.5.6.jar</strong></p>
<p><strong>常见配置项</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>driverClassName</td>
<td>数据库驱动名称</td>
</tr>
<tr>
<td>url</td>
<td>数据库地址</td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
</tr>
<tr>
<td>maxActive</td>
<td>最大连接数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>最大空闲连接</td>
</tr>
<tr>
<td>minIdle</td>
<td>最小空闲连接</td>
</tr>
<tr>
<td>initialSize</td>
<td>初始化连接</td>
</tr>
</tbody></table>
<p><strong>DBCP 工具类</strong>                    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBCPUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_NAME = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="comment">// dbcp 连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化连接池</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pool = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">            pool.setDriverClassName(DRIVER_NAME);</span><br><span class="line">            pool.setUrl(URL);</span><br><span class="line">            pool.setUsername(USERNAME);</span><br><span class="line">            pool.setPassword(PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = pool.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p> C3P0是一个开源的JDBC连接池,支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、 Spring等</p>
<p>所需jar包    <strong>c3p0-0.9.5.2.jar</strong>      <strong>mchange-commons-java-0.2.12.jar</strong></p>
<p><strong>导入配置文件 c3p0-config.xml</strong>  </p>
<ul>
<li>c3p0-config.xml 文件名不可更改 。直接放到src下,也可以放到到资源文件夹中，连接池会直接读取</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--默认配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- initialPoolSize：初始化时获取三个连接，</span></span><br><span class="line"><span class="comment">			  取值应在minPoolSize与maxPoolSize之间。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- maxIdleTime：最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>60<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- maxPoolSize：连接池中保留的最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- minPoolSize: 连接池中保留的最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!--配置连接池mysql1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置连接池2,可以配置多个--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>C3P0 工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource pool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//        pool=new ComboPooledDataSource();</span></span><br><span class="line">        <span class="comment">// 指定使用配置文件中的哪个配置</span></span><br><span class="line">        pool = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = pool.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p> Druid（德鲁伊）是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行 情况。</p>
<p>所需jar包   <strong>druid-1.0.9.jar</strong></p>
<p><strong>导入配置文件</strong> </p>
<ul>
<li>properties形式，可以叫任意名称，但需要手动读取。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/db5?characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<p><strong>Druid工具类</strong></p>
<p> 通过 DruidDataSourceFactory工厂类的createDataSource( Properties properties)  获取连接池对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource; <span class="comment">// 连接池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取配置文件的输入流</span></span><br><span class="line">            InputStream stream = DruidUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建属性集对象，从字节流中读取配置文件</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(stream);</span><br><span class="line">            <span class="comment">// 通过工厂方法获取连接池</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DBUtils工具类"><a href="#DBUtils工具类" class="headerlink" title="DBUtils工具类"></a>DBUtils工具类</h1><p> Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程 序的开发，同时也不会影响程序的性能。</p>
<p>所需jar包      <strong>commons-dbutils-1.6.jar</strong></p>
<h2 id="QueryRunner核心类"><a href="#QueryRunner核心类" class="headerlink" title="QueryRunner核心类"></a>QueryRunner核心类</h2><p>提供对sql语句操作的API</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>QueryRunner()</td>
<td>手动模式，获取QueryRunner对象</td>
</tr>
<tr>
<td>QueryRunner(DataSource ds)</td>
<td>自动模式，提供数据源（连接池），DBUtils底层自动维护连接connection,后续操作不再需要提供Connection对象</td>
</tr>
<tr>
<td>update([Connection conn,] String sql, Object… params)</td>
<td>用来完成表数据的增加、删除、更新操作</td>
</tr>
<tr>
<td>query([Connection conn,] String sql, ResultSetHandler<T> rsh, Object… params)</td>
<td>用来完成表数据的查询操作</td>
</tr>
</tbody></table>
<h2 id="ResultSetHandler接口"><a href="#ResultSetHandler接口" class="headerlink" title="ResultSetHandler接口"></a>ResultSetHandler接口</h2><p>ResultSetHandler可以对查询出来的ResultSet结果集进行处理，达到一些业务上的需求。</p>
<table>
<thead>
<tr>
<th>ResultSetHandler实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayHandler</td>
<td>将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值</td>
</tr>
<tr>
<td>ArrayListHandler</td>
<td>将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。</td>
</tr>
<tr>
<td>BeanHandler</td>
<td>将结果集中第一条记录封装到一个指定的javaBean中.</td>
</tr>
<tr>
<td>BeanListHandler</td>
<td>将结果集中每一条记录封装到指定的javaBean中，再将这些javaBean在封装到List集合中</td>
</tr>
<tr>
<td>ColumnListHandler</td>
<td>将结果集中指定的列的字段值，封装到一个List集合中</td>
</tr>
<tr>
<td>KeyedHandler</td>
<td>将结果集中每一条记录封装到Map&lt;String,Object&gt;,在将这个map集合做为另一个Map的value,另一个Map集合的key是指定的字段的值。</td>
</tr>
<tr>
<td>MapHandler</td>
<td>将结果集中第一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值</td>
</tr>
<tr>
<td>MapListHandler</td>
<td>将结果集中每一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值，在将这些Map封装到List集合中。</td>
</tr>
<tr>
<td>ScalarHandler</td>
<td>它是用于封装单个数据。例如 select count(*) from 表操作</td>
</tr>
</tbody></table>
<p><strong>使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动模式,删除数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;delete from user where username=?&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = qr.update(sql, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;受影响行数:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 查询相关的操作,用javaBean封装数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;select * from user where id in (?,?)&quot;</span>;</span><br><span class="line">        List&lt;User&gt; query = qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(User.class), <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : query) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 查询相关的操作,获取用户个数，单个数据 scalar</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;select count(*) from user&quot;</span>;</span><br><span class="line">        Object query = qr.query(sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;());</span><br><span class="line">        System.out.println(<span class="string">&quot;用户个数为:&quot;</span> + query);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>JDBC</tag>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>javaWeb笔记</title>
    <url>/2021/06/18/javaWeb%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>JavaWeb</strong>主要指使用Java语言进行动态Web资源开发技术的统称，是解决相关Web互联网领域的技 术总和。JavaWeb有三大组件，分别为：<strong>Servlet</strong>、<strong>Filter</strong>、 <strong>Listener</strong>。<a id="more"></a></p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat 服务器是一个开源的轻量级Web应用服务器，在中小型系统和并发量小的场合下被普遍使 用，是开发和调试Servlet、JSP 程序的首选。</p>
<p><strong>目录结构说明</strong></p>
<ul>
<li>bin 主要存放二进制可执行文件和脚本。 </li>
<li>conf 主要存放各种配置文件。 </li>
<li>lib 主要用来存放Tomcat运行需要加载的jar包。 </li>
<li>logs 主要存放Tomcat在运行过程中产生的日志文件。 </li>
<li>temp 主要存放Tomcat在运行过程中产生的临时文件。 </li>
<li>webapps 主要存放应用程序，当Tomcat启动时会去加载该目录下的应用程序。 </li>
<li>work 主要存放tomcat在运行时的编译后文件，例如JSP编译后的文件。</li>
</ul>
<p><strong>启动和关闭</strong> </p>
<ul>
<li>启动方式 使用bin目录下的批处理文件startup.bat来启动Tomcat服务器，若出现一个毫秒数说明启动成 功。 </li>
<li>关闭方式 使用bin目录下的批处理文件shutdown.bat来关闭Tomcat服务器。 </li>
</ul>
<p><strong>注意事项</strong> 启动之前首先安装JDK并配置环境变量JAVA_HOME，若希望Tomcat服务器可以在任意路径启动， 则需要配置环境变量CATALINA_HOME。 </p>
<p><strong>启动信息乱码的处理方式</strong>    logging.properties文件修改编码java.util.logging.ConsoleHandler.encoding = GBK</p>
<p><strong>配置文件</strong></p>
<ul>
<li>server.xml文件是服务器的主配置文件，可以设置端口号、设置域名或IP、默认加载的项目、请求 编码等。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tomcat-users.xml文件用来配置管理Tomcat服务器的用户与权限 。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p><strong>基本概念</strong></p>
<ul>
<li>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，是Java语言编写 的服务器端程序，换句话说，Servlet就是运行在服务器上的Java类。 </li>
<li>Servlet用来完成B/S架构下客户端请求的响应处理，也就是交互式地浏览和生成数据，生成动态 Web内容。</li>
</ul>
<h2 id="Servlet的编程步骤"><a href="#Servlet的编程步骤" class="headerlink" title="Servlet的编程步骤"></a>Servlet的编程步骤</h2><ul>
<li><p>建立一个Java Web Application项目并配置Tomcat服务器。 </p>
</li>
<li><p>自定义类实现Servlet接口或继承其子类， 并重写service方法。 </p>
</li>
<li><p>将自定义类的信息配置到 web.xml文件并启动项目</p>
</li>
<li><p>在浏览器上访问的方式为：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/工程路径/servlet访问名</span><br></pre></td></tr></table></figure>
<h3 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h3><p><strong>xml方式配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> myServlet <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet类名的真实路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span> com.hui.MyServlet <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- myServlet是Servlet类的别名，与上述名称必须相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> myServlet <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /hello是供浏览器使用的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span> /hello <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注解方式配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  name是别名，urlPatterns是供浏览器使用的地址</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;myServlet4&quot;, urlPatterns = &quot;/my4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....................................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><p>javax.servlet.Servlet接口用于定义所有servlet必须实现的方法。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void init(ServletConfig config)</td>
<td>由servlet容器调用，以向servlet指示servlet正在被放入服务中</td>
</tr>
<tr>
<td>void service(ServletRequest req,ServletResponse res)</td>
<td>由servlet容器调用，以允许servlet响应请求</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>返回ServletConfig对象，该对象包含此servlet的初始化和启动参数</td>
</tr>
<tr>
<td>String getServletInfo()</td>
<td>返回有关servlet的信息，如作者、版本和版权</td>
</tr>
<tr>
<td>void destroy()</td>
<td>由servlet容器调用，以向servlet指示该servlet正在退出服务</td>
</tr>
</tbody></table>
<h3 id="GenericServlet类"><a href="#GenericServlet类" class="headerlink" title="GenericServlet类"></a>GenericServlet类</h3><p>javax.servlet.GenericServlet类主要用于定义一个通用的、与协议无关的servlet，该类实现了 Servlet接口。 若编写通用servlet，只需重写service抽象方法即可。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>abstract void service(ServletRequest req,ServletResponse res)</td>
<td>由servlet容器调用允许servlet响应请求</td>
</tr>
</tbody></table>
<h3 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类"></a>HttpServlet类</h3><p>javax.servlet.http.HttpServlet类是个抽象类并继承了GenericServlet类。 用于创建适用于网站的HTTP Servlet，该类的子类必须至少重写一个方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void doGet(HttpServletRequest req,HttpServletResponse resp)</td>
<td>处理客户端的GET请求</td>
</tr>
<tr>
<td>void doPost(HttpServletRequest req,HttpServletResponse resp)</td>
<td>处理客户端的POST请求</td>
</tr>
<tr>
<td>void init()</td>
<td>进行初始化操作</td>
</tr>
<tr>
<td>void service(HttpServletRequest req,HttpServletResponse resp)</td>
<td>根据请求决定调用doGet还是doPost方法</td>
</tr>
<tr>
<td>void destroy()</td>
<td>删除实例时释放资源</td>
</tr>
</tbody></table>
<ul>
<li><p>继承HttpServlet接口一般不实现service() 方法，而是实现 doGet()   和   doPost() 方法，因为service()方法里就是根据请求决定调用doGet还是doPost。</p>
</li>
<li><p>代码一般写在doPost() 方法里，而doGet() 方法中则直接调用doPost()方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br></pre></td></tr></table></figure>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3></li>
<li><p>构造方法只被调用一次，当第一次请求Servlet时调用构造方法来创建Servlet的实例。</p>
<ul>
<li>如果在配置文件中配置<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>标签 ，就会在程序启动时实例化该servlet</li>
</ul>
</li>
<li><p>init方法只被调用一次，当创建好Servlet实例后立即调用该方法实现Servlet的初始化。</p>
</li>
<li><p>service方法被多次调用，每当有请求时都会调用service方法来用于请求的响应。 </p>
</li>
<li><p>destroy方法只被调用一次，当该Servlet实例所在的Web应用被卸载前调用该方法来释放当前占用 的资源。</p>
</li>
</ul>
<h2 id="POST和GET请求"><a href="#POST和GET请求" class="headerlink" title="POST和GET请求"></a>POST和GET请求</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发出GET请求的主要方式：</span><br><span class="line">    （1）在浏览器输入URL按回车</span><br><span class="line">    （2）点击&lt;a&gt;超链接</span><br><span class="line">    （3）点击submit按钮，提交 &lt;form method&#x3D;“get”&gt;表单</span><br><span class="line">GET请求特点：</span><br><span class="line">	 会将请求数据添加到请求URL地址的后面，只能提交少量的数据、不安全</span><br></pre></td></tr></table></figure>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发出POST请求的方法如下：</span><br><span class="line">	点击submit按钮，提交 &lt;form method&#x3D;“post”&gt;表单</span><br><span class="line">POST请求的特点：</span><br><span class="line">	请求数据添加到HTTP协议体中，可提交大量数据、安全性好</span><br></pre></td></tr></table></figure>
<h3 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a>ServletRequest接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletRequest接口主要用于向servlet提供客户端请求信息，可以从中获取到任何 请求信息。 </li>
<li>Servlet容器创建一个ServletRequest对象，并将其作为参数传递给Servlet的service方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter(String name)</td>
<td>以字符串形式返回请求参数的值，如果该参数不存在，则返回空值</td>
</tr>
<tr>
<td>String[] getParameterValues(String name)</td>
<td>返回一个字符串对象数组，其中包含给定请求参数所具有的所有值，如果该参数不存在，则返回空值</td>
</tr>
<tr>
<td>Enumeration getParameterNames()</td>
<td>返回包含此请求中包含的参数名称的字符串对象的枚举。如果请求没有参数，则方法返回空枚举</td>
</tr>
<tr>
<td>Map&lt;String, String[]&gt; getParameterMap()</td>
<td>返回请求参数的键值对，一个键可以对应多个值</td>
</tr>
<tr>
<td>String getRemoteAddr()</td>
<td>返回发送请求的客户端或最后一个代理的IP地址</td>
</tr>
<tr>
<td>int  getRemotePort()</td>
<td>返回发送请求的客户端或最后一个代理的端口号</td>
</tr>
</tbody></table>
<h3 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.http.HttpServletRequest接口是ServletRequest接口的子接口，主要用于提供HTTP 请求信息的功能。 </li>
<li>不同于表单数据，在发送HTTP请求时，HTTP请求头直接由浏览器设置。 </li>
<li>可直接通过HttpServletRequest对象提供的一系列get方法获取请求头数据。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getRequestURI()</td>
<td>返回此请求的资源路径信息</td>
</tr>
<tr>
<td>StringBuffer getRequestURL()</td>
<td>返回此请求的完整路径信息</td>
</tr>
<tr>
<td>String getMethod()</td>
<td>返回发出此请求的HTTP方法的名称，例如GET、POST</td>
</tr>
<tr>
<td>String getQueryString()</td>
<td>返回路径后面请求中附带的参数</td>
</tr>
<tr>
<td>String getServletPath()</td>
<td>返回此请求中调用servlet的路径部分</td>
</tr>
</tbody></table>
<h3 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletResponse接口用于定义一个对象来帮助Servlet向客户端发送响应。 </li>
<li>Servlet容器创建ServletResponse对象，并将其作为参数传递给servlet的service方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter getWriter()</td>
<td>返回可向客户端发送字符文本的PrintWriter对象</td>
</tr>
<tr>
<td>String getCharacterEncoding()</td>
<td>获取响应内容的编码方式</td>
</tr>
<tr>
<td>void setContentType(String type)</td>
<td>如果尚未提交响应，则设置发送到客户端响应的内容类型。内容类型可以包括字符编码规范，例如text/html;charset=UTF-8</td>
</tr>
</tbody></table>
<h3 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.http.HttpServletResponse接口继承ServletResponse接口，以便在发送响应时提供 特定于HTTP的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sendRedirect(String location)</td>
<td>使用指定的重定向位置URL向客户端发送临时重定向响应</td>
</tr>
</tbody></table>
<h2 id="Servlet接收中文乱码"><a href="#Servlet接收中文乱码" class="headerlink" title="Servlet接收中文乱码"></a>Servlet接收中文乱码</h2><h3 id="接收乱码"><a href="#接收乱码" class="headerlink" title="接收乱码"></a>接收乱码</h3><p>浏览器在提交表单时，会对中文参数值进行自动编码。当Tomcat服务器接收到浏览器请求后自动 解码，当编码与解码方式不一致时,就会导致乱码。</p>
<p><strong>解决POST请求乱码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>解决GET请求乱码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将接收到的中文乱码重新编码  （万能方式）</span></span><br><span class="line">String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 将中文字符重新编码，默认编码为ISO-8859-1</span></span><br><span class="line">String userName = <span class="keyword">new</span> String(name.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="响应乱码"><a href="#响应乱码" class="headerlink" title="响应乱码"></a>响应乱码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h2><p><strong>基本概念</strong></p>
<p>javax.servlet.ServletConfig接口用于描述Servlet本身的相关配置信息，在初始化期间用于将信息 传递给Servlet配置对象。</p>
<p>Servlet接口中有 getServletConfig() 方法，子类中直接调用即可获取 ServletConfig对象。</p>
<p>init() 方法中，ServletConfig是init()的参数，可直接调用 ServletConfig对象。</p>
<p><strong>xml配置方法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中配置ServletConfig初始化参数,可配置多个init-param --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>actionservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lagou.demo01.ActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Serlvet 的初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 参数名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 参数值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>struts.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getServletName()</td>
<td>返回Servlet的别名</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>返回包含初始化参数值的字符串，如果该参数不存在，则返回null</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>返回对调用方正在其中执行的ServletContext的引用</td>
</tr>
</tbody></table>
<h2 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h2><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletContext接口主要用于定义一组方法，Servlet使用这些方法与其它的Servlet容 器通信。 </li>
<li>服务器容器在启动时会为每个项目创建唯一的一个ServletContext对象，用于实现多个Servlet之间 的信息共享和通信。 </li>
<li>在Servlet中通过this.getServletContext()方法可以获得ServletContext对象，也可以通过ServletConfig对象获取。</li>
</ul>
<p><strong>xml配置方法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中配置ServletContext初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hui<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123465<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getInitParameter(String name)</td>
<td>返回包含初始化参数值的字符串，如果该参数不存在，则返回null</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举</td>
</tr>
<tr>
<td>String getRealPath(String path)</td>
<td>返回包含给定虚拟路径的实际路径的字符串</td>
</tr>
<tr>
<td>String getContextPath()</td>
<td>返回与此上下文关联的主路径</td>
</tr>
<tr>
<td>InputStream getResourceAsStream(String path)</td>
<td>将位于指定路径的资源作为InputStream对象返回</td>
</tr>
<tr>
<td>void setAttribute(String name, Object object)</td>
<td>将指定的属性名和属性值绑定到当前对象</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>根据执行的属性名获取属性值</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>删除指定的属性名信息</td>
</tr>
</tbody></table>
<h2 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>首先客户浏览器发送http请求，当web服务器接受后发送302状态码响应及对应新的location给客 户浏览器，客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location 地址，服务器根据此请求寻找资源并发送给客户。</p>
<p><strong>实现</strong></p>
<p>实现重定向需要借助javax.servlet.http.HttpServletResponse接口中的以下方法：</p>
<table>
<thead>
<tr>
<th>response中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sendRedirect(String location)</td>
<td>使用指定的重定向位置URL向客户端发送临时重定向响应</td>
</tr>
</tbody></table>
<p><strong>特点</strong> </p>
<ul>
<li>重定向之后，浏览器地址栏的URL会发生改变。 </li>
<li>重定向过程中会将前面Request对象销毁，然后创建一个新的Request对象。 重定向的URL可以是其它项目工程。</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>一个Web组件（Servlet/JSP）将未完成的处理通过容器转交给另外一个Web组件继续处理，转发 的各个组件会共享Request和Response对象。</p>
<p><strong>实现</strong></p>
<ul>
<li>获取转发器对象</li>
</ul>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>RequestDispatcher getRequestDispatcher(String path)</td>
<td>返回一个RequestDispatcher对象，该对象充当位于给定路径上的资源的包装器，形参为要转发的地址</td>
</tr>
</tbody></table>
<ul>
<li>转发操作</li>
</ul>
<table>
<thead>
<tr>
<th>RequestDispatcher中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void forward(ServletRequest request, ServletResponse response)</td>
<td>将请求从一个servlet转发到服务器上的另一个资源（Servlet、JSP文件或HTML文件）</td>
</tr>
</tbody></table>
<p><strong>特点</strong> </p>
<ul>
<li>转发之后浏览器地址栏的URL不会发生改变。 </li>
<li>转发过程中共享Request对象，可以在request中使用setAttribute() 设置需要额外传递的数据。</li>
<li>转发的URL不可以是其它项目工程。</li>
</ul>
<h2 id="Servlet线程安全"><a href="#Servlet线程安全" class="headerlink" title="Servlet线程安全"></a>Servlet线程安全</h2><p>服务器在收到请求之后，会启动一个线程来进行相应的请求处理。 </p>
<p>默认情况下，服务器为每个Servlet只创建一个对象实例。当多个请求访问同一个Servlet时，会有 多个线程访问同一个Servlet对象，此时就可能发生线程安全问题。 </p>
<p>多线程并发逻辑，需要使用synchronized对代码加锁处理，但尽量避免使用。</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul>
<li>Web程序基于HTTP协议通信，而HTTP协议是”<strong>无状态</strong>”的协议，一旦服务器响应完客户的请求之 后，就断开连接，而同一个客户的下一次请求又会重新建立网络连接。 </li>
<li>服务器程有时是需要判断是否为同一个客户发出的请求，因此，有必 要跟踪同一个客户发出的一系列请求。 </li>
<li>把浏览器与服务器之间多次交互作为一个整体，将多次交互所涉及的数据保存下来，即状态管理。 多次交互的数据状态可以在客户端保存，也可以在服务器端保存。</li>
<li>状态管理主要分为以下两类： <ul>
<li>客户端管理：将状态保存在客户端。基于Cookie技术实现。 </li>
<li>服务器管理：将状态保存在服务器端。基于Session技术实现。</li>
</ul>
</li>
</ul>
<h3 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h3><p><strong>基本概念</strong></p>
<ul>
<li>Cookie本意为”饼干“的含义，在这里表示客户端以“键值对”形式进行保存的一种技术。 </li>
<li>浏览器向服务器发送请求时，服务器将数据以Set-Cookie消息头的方式响应给浏览器，然后浏览器 会将这些数据以文本文件的方式保存起来。 </li>
<li>当浏览器再次访问服务器时，会将这些数据以Cookie消息头的方式发送给服务器。</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><table>
<thead>
<tr>
<th>Cookie类中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie(String name, String value)</td>
<td>根据参数指定数值构造对象</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回此Cookie对象中的名字</td>
</tr>
<tr>
<td>String getValue()</td>
<td>返回此Cookie对象的数值</td>
</tr>
<tr>
<td>void setValue(String newValue)</td>
<td>设置Cookie的数值</td>
</tr>
</tbody></table>
<p><strong>request请求获取cookie对象</strong></p>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie[] getCookies()</td>
<td>返回此请求中包含的所有Cookie对象</td>
</tr>
</tbody></table>
<p><strong>response响应添加cookie对象</strong></p>
<table>
<thead>
<tr>
<th>respose中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void addCookie(Cookie cookie)</td>
<td>添加参数指定的对象到响应</td>
</tr>
</tbody></table>
<h4 id="Cookie的生命周期"><a href="#Cookie的生命周期" class="headerlink" title="Cookie的生命周期"></a>Cookie的生命周期</h4><p>默认情况下，浏览器会将Cookie信息保存在内存中，只要浏览器关闭，Cookie信息就会消失。 </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int getMaxAge()</td>
<td>返回cookie的最长使用期限（以秒为单位）</td>
</tr>
<tr>
<td>void setMaxAge(int expiry)</td>
<td>设置cookie的最长保留时间（秒）</td>
</tr>
</tbody></table>
<p><strong>setMaxAge中的形参设置</strong> : 0 表示立即删除  ，正数表示多少秒后删除，负数表示关闭浏览器就删除。</p>
<h4 id="Cookie的路径问题"><a href="#Cookie的路径问题" class="headerlink" title="Cookie的路径问题"></a>Cookie的路径问题</h4><ul>
<li>浏览器在访问服务器时，会比较Cookie的路径与请求路径是否匹配，只有匹配的Cookie才会发送 给服务器。 </li>
<li>Cookie的默认路径等于添加这个Cookie信息时的组件路径，例如：/项目名/目录/add 请求添加 了一个Cookie信息，则该Cookie的路径是 /项目名/目录。</li>
<li>访问的请求地址必须符合Cookie的路径或者其子路径时，浏览器才会发送Cookie信息。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void setPath(String uri)</td>
<td>设置cookie的路径信息</td>
</tr>
</tbody></table>
<h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><ul>
<li>将状态数据保存在浏览器端，不安全。 </li>
<li>保存数据量有限制，大约4KB左右。 </li>
<li>只能保存字符串信息。 </li>
<li>可以通过浏览器设置为禁止使用。</li>
</ul>
<h3 id="session技术"><a href="#session技术" class="headerlink" title="session技术"></a>session技术</h3><p><strong>基本概念</strong></p>
<ul>
<li>Session本意为”会话”的含义，是用来维护一个客户端和服务器关联的一种技术。 </li>
<li>浏览器访问服务器时，服务器会为每一个浏览器都在服务器端的内存中分配一个空间，用于创建一 个Session对象，该对象有一个id属性且该值唯一，我们称为SessionId，并且服务器会将这个 SessionId以Cookie方式发送给浏览器存储。 </li>
<li>浏览器再次访问服务器时会将SessionId发送给服务器，服务器可以依据SessionId查找相对应的 Session对象</li>
</ul>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p><strong>request请求中获取session</strong></p>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>HttpSession getSession()</td>
<td>返回此请求关联的当前Session，若此请求没有则创建一个</td>
</tr>
</tbody></table>
<p><strong>HttpSession接口中常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNew()</td>
<td>判断是否为新创建的Session</td>
</tr>
<tr>
<td>String getId()</td>
<td>获取Session的编号</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>返回在此会话中用指定名称绑定的对象，如果没有对象在该名称下绑定，则返回空值</td>
</tr>
<tr>
<td>void setAttribute(String name, Object value)</td>
<td>使用指定的名称将对象绑定到此会话</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>从此会话中删除与指定名称绑定的对象</td>
</tr>
</tbody></table>
<h4 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h4><p>为了节省服务器内存空间资源，服务器会将空闲时间过长的Session对象自动清除掉，服务器默认 的超时限制一般是30分钟。 </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int getMaxInactiveInterval()</td>
<td>获取失效时间</td>
</tr>
<tr>
<td>void setMaxInactiveInterval(int interval)</td>
<td>设置失效时间</td>
</tr>
</tbody></table>
<p>也可以通过xml配置设置session过期时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="session的特点"><a href="#session的特点" class="headerlink" title="session的特点"></a>session的特点</h4><ul>
<li>数据比较安全。 </li>
<li>能够保存的数据类型丰富，而Cookie只能保存字符串。 </li>
<li>能够保存更多的数据，而Cookie大约保存4KB。</li>
<li>数据保存在服务器端会占用服务器的内存空间，如果存储信息过多、用户量过大，会严重影响服务器的性能。</li>
</ul>
<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><p><strong>基本概念</strong></p>
<ul>
<li>JSP是Java Server Pages的简称，跟Servlet一样可以动态生成HTML响应， JSP文件命名为 xxx.jsp。 </li>
<li>与Servlet不同，JSP文件以HTML标记为主，然后内嵌Java代码段，用于处理动态内容。</li>
</ul>
<p><strong>JSP与Servlet的关系</strong></p>
<p><a href="https://imgtu.com/i/RCBNLt"><img src="https://z3.ax1x.com/2021/06/19/RCBNLt.png" alt="RCBNLt.png" style="zoom:80%;" /></a></p>
<p><strong>JSP语法结构</strong> </p>
<ul>
<li><p>声明区 </p>
</li>
<li><p>程序代码区 </p>
</li>
<li><p>表达式 </p>
</li>
<li><p>注释 </p>
</li>
<li><p>指令和动作 </p>
</li>
<li><p>内置对象</p>
</li>
</ul>
<h2 id="声明区"><a href="#声明区" class="headerlink" title="声明区"></a>声明区</h2><p>可以定义全局变量、方法、类。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span></span>&#123;… …&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h2><p>可以定义局部变量以及放入任何的Java程序代码</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</span><br><span class="line">    	… …</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>可以输出一个变量或一个具体内容，但 = 后面必须是字符串变量或者可以被转换成字符串的 表达式。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=“hello world”%&gt;</span><br><span class="line">&lt;%=i+<span class="number">1</span>%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--… …--&gt; HTML文件的注释，浏览器可以查看到</span><br><span class="line">&lt;%--… …--%&gt; JSP文件的注释，浏览器看不到</span><br><span class="line">&lt;%<span class="comment">//… …%&gt; Java语言中的单行注释，浏览器看不到</span></span><br><span class="line">&lt;%<span class="comment">/*… …*/</span>%&gt; Java语言中的多行注释，浏览器看不到</span><br></pre></td></tr></table></figure>
<h2 id="指令和动作"><a href="#指令和动作" class="headerlink" title="指令和动作"></a>指令和动作</h2><p><strong>指令格式</strong>   &lt;%@指令 属性=“属性值”%&gt;  指令的属性可以设定多个。 </p>
<p><strong>常用指令</strong>   page、taglib、include</p>
<h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><p>page指令用于导包和设置一些页面属性，常用属性如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import 导入相应的包，惟一允许在同一文档中多次出现的属性</span><br><span class="line">contentType 设置Content-Type响应报头，标明即将发送到浏览器的文档类型</span><br><span class="line">pageEncoding 设置页面的编码</span><br><span class="line">language 指定页面使用的语言,默认java</span><br><span class="line">session 控制页面是否参与HTTP会话</span><br><span class="line">errorPage 处理当前页面中抛出但未被捕获的任何异常</span><br><span class="line">isErrorPage 当前页是否可以作为其他页面的错误处理页面</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tablib指令"><a href="#tablib指令" class="headerlink" title="tablib指令"></a>tablib指令</h3><p>taglib指令用来扩展JSP程序的标签元素，引入其他功能的标签库文件。<strong>详情下面会写道</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- prefix属性用于指定库前缀 --&gt;</span><br><span class="line">&lt;!-- uri属性用于指定库的标识 --&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;tagLibary&quot;</span> prefix=<span class="string">&quot;prefix&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3><p>include指令用于引入另一个JSP程序或HTML文件等，格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;被包含的文件地址&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<p>JSP引擎会在JSP文件的转换时期先把file属性设定的文件包含进来，然后开始执行转换及编译的工 作。</p>
<h3 id="jsp-include动作"><a href="#jsp-include动作" class="headerlink" title="jsp:include动作"></a>jsp:include动作</h3><ul>
<li>jsp:include动作用于引入另一个JSP程序或HTML文件等。 </li>
<li>执行到include时，被include的文件才会被编译。 </li>
<li>如果include的是jsp文件，那它不会被转换成Servlet文件。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=“URLSpec” flush=“<span class="keyword">true</span>”/&gt;</span><br><span class="line">&lt;jsp:include page=“URLSpec” flush=“<span class="keyword">true</span>”&gt;</span><br><span class="line">&lt;jsp:param name=“key” value=“value”/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>
<p><strong>include指令和include动作的区别</strong> </p>
<ul>
<li>include指令是在JSP程序的转换时期就将file属性所指定的程序内容嵌入再编译执行（静态包 含）。 </li>
<li>include动作在转换时期是不会被编译的，只有在客户端请求时期被执行到才会被动态的编译载入 （动态包含，推荐）。</li>
</ul>
<h3 id="jsp-forward动作"><a href="#jsp-forward动作" class="headerlink" title="jsp:forward动作"></a>jsp:forward动作</h3><p>forward动作用于在JSP中实现转发，将请求转发到另一个指定的JSP程序或者Servlet中处理</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=“urlSpec” flush=“<span class="keyword">true</span>”/&gt;</span><br><span class="line">&lt;jsp:forward page=“urlSpec”&gt;</span><br><span class="line">    &lt;!-- 用于指定参数和其对应的值 --&gt;</span><br><span class="line">    &lt;jsp:param name=“key” value=“value”/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><p><strong>基本概念</strong> </p>
<ul>
<li>在JSP程序中有9个内置对象由容器为用户进行实例化，程序员可以不用定义就直接使用这些变量。 </li>
<li>在JSP转换成Servlet后，会自动追加这些变量的定义，使用内置对象可以简化JSP的开发。</li>
<li>内置对象的方法就是Servlet中对应类的使用</li>
</ul>
<table>
<thead>
<tr>
<th>对象变量</th>
<th>对象类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>out</td>
<td>JSPWriter</td>
<td>输出流</td>
</tr>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>请求信息</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
<td>响应信息</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>会话</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>全局的上下文对象</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
<td>JSP页面上下文</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>JSP页面本身</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>Servlet配置对象</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>捕获网页异常</td>
</tr>
</tbody></table>
<h3 id="out内置对象"><a href="#out内置对象" class="headerlink" title="out内置对象"></a>out内置对象</h3><p>out内置对象是一个缓冲的输出流，用来给客户端输出信息</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void println(String x)</td>
<td>向客户端输出各种类型数据</td>
</tr>
<tr>
<td>void newLine()</td>
<td>输出一个换行符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>int getBufferSize()</td>
<td>返回缓冲区的大小</td>
</tr>
<tr>
<td>int getRemaining()</td>
<td>返回缓冲区中未使用的字节数</td>
</tr>
<tr>
<td>void flush()</td>
<td>输出缓冲区里的数据</td>
</tr>
<tr>
<td>void clearBuffer()</td>
<td>清除缓冲区里的数据，同时把数据输出到客户端</td>
</tr>
<tr>
<td>void clear()</td>
<td>清除缓冲区里的数据，但不把数据输出到客户端</td>
</tr>
</tbody></table>
<h3 id="pageContext内置对象"><a href="#pageContext内置对象" class="headerlink" title="pageContext内置对象"></a>pageContext内置对象</h3><p>pageContext对象是PageContext类型的对象，可以使用这个对象来管理其他的隐含对象。 只在一个页面中保存数据。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String name, Object value,int scope)</td>
<td>使用适当的作用域设置指定的名称和值</td>
</tr>
<tr>
<td>Object getAttribute(String name, int scope)</td>
<td>返回指定作用域中名称关联的对象，若找不到则返回null</td>
</tr>
<tr>
<td>ServletRequest getRequest()</td>
<td>获取请求对象</td>
</tr>
<tr>
<td>ServletResponse getResponse()</td>
<td>获取响应对象</td>
</tr>
<tr>
<td>HttpSession getSession()</td>
<td>获取会话对象</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>获取配置对象</td>
</tr>
<tr>
<td>JspWriter getOut()</td>
<td>获取输出对象</td>
</tr>
<tr>
<td>Object getPage()</td>
<td>获取页面对象</td>
</tr>
<tr>
<td>Exception getException()</td>
<td>获取异常对象</td>
</tr>
</tbody></table>
<h3 id="exception内置对象"><a href="#exception内置对象" class="headerlink" title="exception内置对象"></a>exception内置对象</h3><p>exception 对象是Throwable的实例，表示的是JSP的异常信息。</p>
<p>如果要使用它，必须将对应异常页面page指令的isErrorPage属性设置成true。</p>
<ul>
<li>单页处理方法</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> errorPage=<span class="string">&quot;error.jsp&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml中配置统一的异常处理页面。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Throwable<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="javaBean组件"><a href="#javaBean组件" class="headerlink" title="javaBean组件"></a>javaBean组件</h2><p>JavaBean 是使用 Java 语言开发的一个可重用的组件，在 JSP 开发中可以使用 JavaBean 减少重复 代码，使整个 JSP 代码的开发更加简洁。</p>
<p><strong>使用方式</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--创建一个JavaBean对象，scope表示范围--%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;user&quot; scope=&quot;session&quot; class=&quot;com.hui.User&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%--set，如果是从前端获取的数据则可以使用param属性而不是value属性 --%&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;user&quot; property=&quot;name&quot; value=&quot;怪狗狗&quot;&gt;&lt;/jsp:setProperty&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;user&quot; property=&quot;age&quot; value=&quot;13&quot;&gt;&lt;/jsp:setProperty&gt;</span><br><span class="line">&lt;%--get--%&gt;</span><br><span class="line">姓名 : &lt;jsp:getProperty name=<span class="string">&quot;user&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">年龄 : &lt;jsp:getProperty name=<span class="string">&quot;user&quot;</span> property=<span class="string">&quot;age&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>JavaBean的保存范围scope有page、request、session以及application，默认是page范围。</p>
<p><strong>删除方式</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	内置对象.removeAttribute(“JavaBean的名字”);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p><strong>基本概念</strong></p>
<ul>
<li>MVC是模型(Model)和视图(View)以及控制器(Controller)的简写，是一种将数据、界面显示和业务 逻辑进行分离的组织方式，这样在改进界面及用户交互时，不需要重新编写业务逻辑，从而提高了 代码的可维护性。 <ul>
<li>M：主要用于封装业务数据的JavaBean(Bean) 和 业务逻辑的JavaBean(Service)及访问数据库的 DAO对象。 </li>
<li>V：主要负责数据收集 和 数据展现，通常由JSP文件完成。 </li>
<li>C：主要负责流程控制 和 页面跳转，通常由Servlet完成。</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/RChX7Q"><img src="https://z3.ax1x.com/2021/06/19/RChX7Q.png" alt="RChX7Q.png"></a></p>
<h1 id="EL和JSTL核心技术"><a href="#EL和JSTL核心技术" class="headerlink" title="EL和JSTL核心技术"></a>EL和JSTL核心技术</h1><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language）表达式提供了在JSP中简化表达式的方法，可以方便地访问各种数据 并输出。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li>依次访问pageContext、request、session和application作用域对象存储的数据。如需获取指定作用域数据则使用  xxxScope.xxx </li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">原来的访问request中的属性:&lt;%=request.getAttribute(<span class="string">&quot;varName&quot;</span>)%&gt;</span><br><span class="line">用EL实现: $&#123; varName &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取请求参数值。</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">在EL之前使用下列方式访问请求参数的数据</span><br><span class="line">request.getParameter(name);</span><br><span class="line">request.getParameterValues(hobby);</span><br><span class="line">在EL中使用下列方式访问请求参数的数据</span><br><span class="line">&lt;!-- 获取指定参数的数值 --&gt;</span><br><span class="line">$&#123;param.name&#125;</span><br><span class="line">&lt;!-- 获取指定参数中指定下标的数值 --&gt;</span><br><span class="line">$&#123;paramValues.hobby[<span class="number">0</span>]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问Bean对象的属性。 </li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">方式一: $&#123;user.name&#125;  </span><br><span class="line">方式二: $&#123;user[<span class="string">&quot;name&quot;</span>]&#125;</span><br><span class="line">当要存取的属性名中包含一些特殊字符，如： . 或 ,等并非字母或数字的符号，就一定要使用第二种方式</span><br><span class="line">使用第二种的方式可以动态取值，如获取request等作用域对象存储的数据，不用加双引号</span><br></pre></td></tr></table></figure>
<ul>
<li>访问集合中的数据。</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- student为ArrayList类型的对象 --&gt;</span><br><span class="line">$&#123;student[<span class="number">0</span>].name&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出简单的运算结果。</li>
</ul>
<h3 id="常用的内置对象"><a href="#常用的内置对象" class="headerlink" title="常用的内置对象"></a>常用的内置对象</h3><table>
<thead>
<tr>
<th>类别</th>
<th>标识符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JSP</td>
<td>pageContext</td>
<td>PageContext 处理当前页面</td>
</tr>
<tr>
<td>作用域</td>
<td>pageScope</td>
<td>同页面作用域属性名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>requestScope</td>
<td>同请求作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>sessionScope</td>
<td>同会话作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>applicationScope</td>
<td>同应用程序作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td>请求参数</td>
<td>param</td>
<td>根据名称存储请求参数的值的Map类</td>
</tr>
<tr>
<td></td>
<td>paramValues</td>
<td>把请求参数的所有值作为一个String数组来存储的Map类</td>
</tr>
<tr>
<td>请求头</td>
<td>header</td>
<td>根据名称存储请求头主要值的Map类</td>
</tr>
<tr>
<td></td>
<td>headerValues</td>
<td>把请求头的所有值作为一个String数组来存储的Map类</td>
</tr>
<tr>
<td></td>
<td>Cookie cookie</td>
<td>根据名称存储请求附带的cookie的Map类</td>
</tr>
<tr>
<td>初始化参数</td>
<td>initParam</td>
<td>根据名称存储Web应用程序上下文初始化参数的Map类</td>
</tr>
</tbody></table>
<h3 id="常用的运算符"><a href="#常用的运算符" class="headerlink" title="常用的运算符"></a>常用的运算符</h3><p><strong>算数运算符</strong></p>
<p>+    -       *      / 或 div      % 或 mod         这里的除会保留小数</p>
<p><strong>关系运算符</strong></p>
<p>==       &gt;     &gt;=        &lt;        &lt;=     !=</p>
<p><strong>逻辑运算符</strong></p>
<p>&amp;&amp; 或 and      || 或or       ! 或not </p>
<p><strong>条件运算符</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;条件表达式? 语句<span class="number">1</span> : 语句<span class="number">2</span>&#125;  就是三目运算符</span><br></pre></td></tr></table></figure>
<p><strong>验证运算符</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;empty 表达式&#125;</span><br><span class="line">返回布尔值,判断表达式是否为<span class="string">&quot;空&quot;</span>值，<span class="keyword">null</span>值、无元素的集合或数组、长度为零的String的值。</span><br></pre></td></tr></table></figure>
<h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><p><strong>基本概念</strong></p>
<ul>
<li>JSTL( JSP Standard Tag Library ) 被称为JSP标准标签库。 </li>
<li>开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护 难度。</li>
</ul>
<p>下载JSTL的jar包并添加到项目中，下载地址为：<a href="https://tomcat.apache.org/download-taglibs.cgi">https://tomcat.apache.org/download-taglibs.cgi</a></p>
<h3 id="核心标签"><a href="#核心标签" class="headerlink" title="核心标签"></a>核心标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%-- 使用taglib指令引入标签库 --%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出标签  out</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:out value=<span class="string">&quot;hello world&quot;</span>/&gt;  </span><br></pre></td></tr></table></figure>
<ul>
<li>设置标签 set</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- 相当于  &lt;% pageContext.setAttrivute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tom&quot;</span>); %&gt;--%&gt;</span><br><span class="line">&lt;c:set var=&quot;name&quot;  value=&quot;tom&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;name&#125;&quot;&gt;&lt;/c:out&gt; &lt;br&gt;</span><br><span class="line">&lt;%-- 创建一个实体类user，使用set对实体类进行赋值,在使用out输出user的属性 --%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;user&quot; class=&quot;com.hui.User&quot; scope=&quot;page&quot; &gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;c:set target=&quot;$&#123;user&#125;&quot; property=&quot;name&quot; value=&quot;jeerry&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:set target=&quot;$&#123;user&#125;&quot; property=&quot;age&quot; value=&quot;11&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;user[&#x27;name&#x27;]&#125;&quot;&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;user[&#x27;age&#x27;]&#125;&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除标签  remove</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:remove var=&quot;user&quot; scope=&quot;page&quot; &gt;&lt;/c:remove&gt;  删除pageContext作用域的user对象</span><br></pre></td></tr></table></figure>
<ul>
<li>单条件判断标签  if</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;age&quot; value=&quot;20&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;age&gt;18&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;已成年&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>多条件判断标签  chose &gt;  when —otherwise</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;age&quot; value=&quot;20&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;age&lt;18&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;未成年!&lt;/h1&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h1&gt;已成年&lt;/h1&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>循环标签</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	String[] arr = &#123;<span class="string">&quot;11&quot;</span>,<span class="string">&quot;22&quot;</span>,<span class="string">&quot;33&quot;</span>,<span class="string">&quot;44&quot;</span>,<span class="string">&quot;55&quot;</span>&#125;;</span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;arr&quot;</span>,arr);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;s&quot;</span> items=<span class="string">&quot;$&#123;arr&#125;&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;3&quot;</span> &gt;   &lt;%--包含下标<span class="number">1</span>到<span class="number">3</span> --%&gt;</span><br><span class="line">    &lt;span&gt;$&#123;s&#125;&lt;/span&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<h3 id="函数标签"><a href="#函数标签" class="headerlink" title="函数标签"></a>函数标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fn&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/functions&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>小案例</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;% pageContext.setAttribute(<span class="string">&quot;text&quot;</span>,<span class="string">&quot;Hello World&quot;</span>); %&gt;</span><br><span class="line">&lt;p&gt; $&#123;text&#125; &lt;/p&gt;</span><br><span class="line">&lt;p&gt;是否包含 world : $&#123;fn:contains(text,&quot;World&quot; )&#125;  &lt;/p&gt;</span><br><span class="line">&lt;p&gt;转大写 : $&#123;fn:toUpperCase(text)&#125; &lt;/p&gt;</span><br><span class="line">&lt;p&gt;转小写 : $&#123;fn:toLowerCase(text)&#125; &lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>小案例，格式化日期</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取系统时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;date&quot;</span>,date);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%--显示时间并格式化--%&gt;</span><br><span class="line">&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><ul>
<li>编写标签类继承SimpleTagSupport类重写doTag方法或继承TagSupport类并重写doStartTag方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义一个name属性，提供get set方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取输出流，向页面中输出数据</span></span><br><span class="line">        JspWriter out = <span class="keyword">this</span>.getJspContext().getOut();</span><br><span class="line">        out.println(<span class="string">&quot;自定义标签的参数为：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义标签库文件（tld标签库文件）并配置标签说明文件到到WEB-INF下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;taglib xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-jsptaglibrary_2_1.xsd&quot;</span><br><span class="line">        version&#x3D;&quot;2.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 这里定义版本，库前缀，库的标识 --&gt;</span><br><span class="line">    &lt;tlib-version&gt;1.0&lt;&#x2F;tlib-version&gt;</span><br><span class="line">    &lt;short-name&gt;me&lt;&#x2F;short-name&gt;</span><br><span class="line">    &lt;uri&gt;http:&#x2F;&#x2F;hui.com&lt;&#x2F;uri&gt;</span><br><span class="line">    </span><br><span class="line">	&lt;!-- 这里可以编写tag标签，每一个标签都要对应一个java类 --&gt;</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">    	&lt;name&gt;myTag&lt;&#x2F;name&gt;</span><br><span class="line">    	&lt;tag-class&gt;com.hui.MyTag&lt;&#x2F;tag-class&gt;</span><br><span class="line">    	&lt;body-content&gt;empty&lt;&#x2F;body-content&gt;</span><br><span class="line">    	&lt;attribute&gt;</span><br><span class="line">            &lt;name&gt;name&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;required&gt;true&lt;&#x2F;required&gt;</span><br><span class="line">    	&lt;&#x2F;attribute&gt;</span><br><span class="line">    &lt;&#x2F;tag&gt;</span><br><span class="line">&lt;&#x2F;taglib&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在JSP中添加taglib指令引入标签库就可以使用了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;me&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;hui.com&quot; %&gt;</span><br><span class="line">&lt;!-- 使用方式与其他标签一样 --&gt;</span><br><span class="line">&lt;me:myTag name&#x3D;&quot;怪狗狗&quot;&gt;&lt;&#x2F;me:myTag&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><p><strong>基本概念</strong></p>
<ul>
<li>Filter本意为”过滤“的含义，是JavaWeb的三大组件之一   </li>
<li>过滤器是向 Web 应用程序的请求和响应处理添加功能的 Web 服务组件。 </li>
<li>过滤器相当于浏览器与Web资源之间的一道过滤网，在访问资源之前通过一系列的过滤器对请求 进行修改、判断以及拦截等，也可以对响应进行修改、判断以及拦截等。</li>
</ul>
<p><strong>工作方式</strong></p>
<p><a href="https://imgtu.com/i/RVeA0J"><img src="https://z3.ax1x.com/2021/06/21/RVeA0J.png" alt="RVeA0J.png"></a></p>
<h2 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h2><ul>
<li>自定义类实现Filter接口并重写doFilter方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 放行，写在上面的代码是对请求的数据进行过滤</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 写在下面的代码是对响应后进行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml文件中配置过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hui.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    还能配置多个参数    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>k1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/main.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Filter接口"><a href="#Filter接口" class="headerlink" title="Filter接口"></a>Filter接口</h2><p>javax.servlet.Filter接口主要用于描述过滤器对象，可以对资源的请求和资源的响应操作进行筛选 操作。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void init(FilterConfig filterConfig)</td>
<td>实现过滤器的初始化操作</td>
</tr>
<tr>
<td>void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)</td>
<td>执行过滤操作的功能</td>
</tr>
<tr>
<td>void destroy()</td>
<td>实现过滤器的销毁操作</td>
</tr>
</tbody></table>
<p><strong>注</strong>   所有的过滤器都是在服务器启动时创建，所以init方法也是在服务器启动时调用，服务器关闭则会调用 destroy方法，每次访问过滤器都会调用doFilter方法进行过滤。</p>
<h2 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h2><p>javax.servlet.FilterConfig 接口主要用于描述过滤器的配置信息</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getFilterName()</td>
<td>获取过滤器的名字</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>获取指定的初始化参数信息</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>获取所有的初始化操作名称</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>获取ServletContext对象</td>
</tr>
</tbody></table>
<p><strong>多个过滤器的使用</strong> </p>
<p>如果有多个过滤器都满足过滤的条件，则容器依据映射 (filter-mapping) 的先后顺序来调用各个过滤器。</p>
<p><a href="https://imgtu.com/i/RVeyAs"><img src="https://z3.ax1x.com/2021/06/21/RVeyAs.png" alt="RVeyAs.png"></a></p>
<p><strong>过滤器优点</strong></p>
<p>实现代码的“可插拔性”，即增加或减少某个功能模块，不会影响程序的正常执行。 可以将多个相同处理逻辑的模块集中写在过滤器里面，可实现重复利用、也方便代码的维护。</p>
<h1 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h1><p><strong>基本概念</strong></p>
<ul>
<li>Servlet规范中定义的一种特殊的组件，用来监听Servlet容器产生的事件并进行相应的处理。 </li>
<li>容器产生的事件分类如下： <ul>
<li>生命周期相关的事件。 </li>
<li>属性状态相关的事件。 </li>
<li>存值状态相关的事件。 </li>
</ul>
</li>
<li>底层原理是采用接口回调的方式实现。</li>
</ul>
<p><strong>基本分类</strong></p>
<table>
<thead>
<tr>
<th>监听器类型</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>javax.servlet.ServletRequestListener</td>
<td>监听request作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.ServletRequestAttributeListener</td>
<td>监听request作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionListener</td>
<td>监听session作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionAttributeListener</td>
<td>监听session作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.ServletContextListener</td>
<td>监听application作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.ServletContextAttributeListener</td>
<td>监听application作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionBindingListener</td>
<td>监听对象与session的绑定和解除</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionActivationListener</td>
<td>监听session数值的钝化和活化</td>
</tr>
</tbody></table>
<h2 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>实现监听器接口,并重写相关方法，这里以ServletRequestListener监听器为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求销毁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置web.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.hui.RequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注</strong>   HttpSessionBindingListener与HttpSessionActivationListener两个监听器是单独写在一个实体类上的，所以不需要配置</p>
<h2 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h2><p>在ServletRequest创建和关闭时都会通知ServletRequestListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void requestInitialized(ServletRequestEvent sre)</td>
<td>实现ServletRequest对象的初始化</td>
</tr>
<tr>
<td>void requestDestroyed(ServletRequestEvent sre)</td>
<td>实现ServletRequest对象的销毁</td>
</tr>
</tbody></table>
<h2 id="ServletRequestAttributeListener"><a href="#ServletRequestAttributeListener" class="headerlink" title="ServletRequestAttributeListener"></a>ServletRequestAttributeListener</h2><p>向ServletRequest添加、删除或者替换一个属性的时候，将会通知 ServletRequestAttributeListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>增加属性时触发</td>
</tr>
<tr>
<td>void attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>修改属性时触发</td>
</tr>
<tr>
<td>void attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>删除属性时触发</td>
</tr>
</tbody></table>
<h2 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h2><p>当一个HttpSession刚被创建或者失效（invalidate）的时候，将会通知HttpSessionListener监听 器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionCreated(HttpSessionEvent se)</td>
<td>当一个HttpSession对象被创建时会调用这个方法</td>
</tr>
<tr>
<td>void sessionDestroyed(HttpSessionEvent se)</td>
<td>当一个HttpSession超时或者调用HttpSession的invalidate()方法让它销毁时，将会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h2><p>HttpSession中添加、删除或者替换一个属性的时候，将会通知HttpSessionAttributeListener监 听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(HttpSessionBindingEvent se)</td>
<td>当往会话中加入一个属性的时候会调用这个方法</td>
</tr>
<tr>
<td>void attributeRemoved(HttpSessionBindingEvent se)</td>
<td>当从会话中删除一个属性的时候会调用这个方法</td>
</tr>
<tr>
<td>void attributeReplaced(HttpSessionBindingEvent se)</td>
<td>当改变会话中的属性的时候会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h2><p>在ServletContext创建和关闭时都会通知ServletContextListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void contextInitialized(ServletContextEvent sce)</td>
<td>当ServletContext创建的时候，将会调用这个方法</td>
</tr>
<tr>
<td>void contextDestroyed(ServletContextEvent sce)</td>
<td>当ServletContext销毁的时候（例如关闭应用服务器或者重新加载应用），将会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h2><p>向ServletContext添加、删除或者替换一个属性的时候，将会通知 ServletContextAttributesListener监听器</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletContextAttributeEvent scae)</td>
<td>往ServletContext中加入一个属性的时候触发</td>
</tr>
<tr>
<td>void attributeRemoved(ServletContextAttributeEvent scae)</td>
<td>从ServletContext中删除一个属性的时候触发</td>
</tr>
<tr>
<td>void attributeReplaced(ServletContextAttributeEvent scae)</td>
<td>改变ServletContext中属性的时候触发</td>
</tr>
</tbody></table>
<h2 id="HttpSessionBindingListener"><a href="#HttpSessionBindingListener" class="headerlink" title="HttpSessionBindingListener"></a>HttpSessionBindingListener</h2><p>HttpSession中绑定和解除绑定时，将会通知HttpSessionListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void valueBound(HttpSessionBindingEvent event)</td>
<td>有对象绑定时调用该方法</td>
</tr>
<tr>
<td>void valueUnbound(HttpSessionBindingEvent event)</td>
<td>有对象解除绑定时调用该方法</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="comment">// User类实现了HttpSessionBindingListener接口</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">// 解绑</span></span><br><span class="line">    session.removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h2><p>当有session数值的钝化和活化操作时，将会通知HttpSessionActivationListener监听器</p>
<p><strong>钝化</strong>   关闭服务器时，将session中的实现了序列化接口的实体类保存到磁盘</p>
<p><strong>活化</strong>   开启服务器后，访问磁盘中的session数据，反序列化</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionWillPassivate(HttpSessionEvent se)</td>
<td>有钝化操作时调用该方法</td>
</tr>
<tr>
<td>void sessionDidActivate(HttpSessionEvent se)</td>
<td>有活化操作时调用该方法</td>
</tr>
</tbody></table>
<ul>
<li>配置tomcat中的config文件夹下的context.xml文件，可以改变session保存本地磁盘的地址</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.PersistentManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">saveOnRestart</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置文件存放的路径信息，可以自由指定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.FileStore&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">directory</span>=<span class="string">&quot;C:\session&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p><strong>统计在线人数</strong></p>
<p><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计人数  ,  session统计在线人数，servletContext作为全局变量保存总人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span>, <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    ServletContext servletContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 servletContext</span></span><br><span class="line">        servletContext = servletContextEvent.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        servletContext = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有一个用户上线了&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取总人数，+1</span></span><br><span class="line">        Integer count = (Integer) servletContext.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, ++count);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前在线人数:&quot;</span> + servletContext.getAttribute(<span class="string">&quot;count&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个用户下线&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取总人数，-1</span></span><br><span class="line">        Integer count = (Integer) servletContext.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, --count);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前在线人数:&quot;</span> + servletContext.getAttribute(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>web.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.hui.CountListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>jsp页面</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;统计人数&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">            当前访问人数 $&#123;applicationScope.count&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="通用Servlet"><a href="#通用Servlet" class="headerlink" title="通用Servlet"></a>通用Servlet</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>之前一个Servlet只对应一个功能，这样编码太麻烦，没必要这样细分。我们可以让一个Servlet对应一个模块的功能。</p>
<p>让前端传递 一个参数  <strong>methodName = xxx</strong>  ，这样可以判断当前要调用哪个方法。再调用相应的方法时，将request与response传递过去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过前端传递的参数，调用相应的方法</span></span><br><span class="line">  		<span class="keyword">if</span> (<span class="string">&quot;delete&quot;</span>.equals(method)) &#123;</span><br><span class="line">            delete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;update&quot;</span>.equals(method)) &#123;</span><br><span class="line">            update(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(method)) &#123;</span><br><span class="line">            add(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有该方法!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// methodName 相对应的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;删除。。。&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;修改。。。&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;添加。。。&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面的全是通过  if..else..  判断，比较的low。我们可以使用反射去对代码进行优化, 提升代码的可维护性/可扩展性.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;    </span><br><span class="line">    String methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过前端传递的参数，调用相应的方法    </span></span><br><span class="line">    <span class="keyword">if</span>(methodName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 通过反射优化代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过方法名与参数获取相关方法对象</span></span><br><span class="line">            Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BaseServlet类"><a href="#BaseServlet类" class="headerlink" title="BaseServlet类"></a>BaseServlet类</h2><p>当前代码依然存在问题，每个Servlet都需要写一份相同的反射代码</p>
<p><strong>解决方案</strong>: 将反射相关的代码抽取到一个 <strong>BaseServlet类</strong>  中, 让BaseServlet去继承HTTPServlet，其他的Servlet基础BaseServelt。</p>
<p>这样其他的Servlet可以不用重写 doPost() 与 doGet() 方法，直接写自己的功能即可。</p>
<p><strong>注意</strong>  其他Servelt中的方法要加形参  request 与 response</p>
<p><strong>BaseServlet类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(methodName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 通过反射优化代码</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过方法名与获取相关方法</span></span><br><span class="line">                Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">                <span class="comment">// 调用方法</span></span><br><span class="line">                method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理JSON请求数据"><a href="#处理JSON请求数据" class="headerlink" title="处理JSON请求数据"></a>处理JSON请求数据</h2><p>POST 请求方法常用的三种数据提交格式</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type : application/x-www-formurlencoded</td>
<td>请求体中的数据会以普通表单形式（键值对）发送到后端。</td>
</tr>
<tr>
<td>Content-Type : application/json ; charset=utf-8</td>
<td>请求体中的数据会以json字符串的形式发送到后端。</td>
</tr>
<tr>
<td>Content-Type : multipart/form-data</td>
<td>多部件上传既可以上传键值对 也可以上传文件。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>   第二种JSON格式与第三种多部件上传,使用 getParameter() 方法都无法获取数据</p>
<p>第三种多部件上传下面文件上传会介绍，这里解决第二种JSON格式, 我们需要修改  BaseServlet类</p>
<p><strong>在BaseServlet类 中创建一个方法,用来获取JSON格式的数据</strong></p>
<p>如果请求参数是JSON格式的数, 我们可以通过 request.getReader() 这个方法,获取一个流对象来进行 读取.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * POST请求格式为 application/json;charset=utf-8</span></span><br><span class="line"><span class="comment">   * 在这个方法中我们使用流的方式,获取到POST请求的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPostJSON</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 保存JSON数据</span></span><br><span class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">          <span class="comment">// 获取 BufferedReader 流</span></span><br><span class="line">          BufferedReader reader = req.getReader();</span><br><span class="line">          <span class="comment">// 读取流中的数据，保存到 sb 中</span></span><br><span class="line">          String temp = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">while</span> ((temp = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              sb.append(temp);</span><br><span class="line">          &#125;</span><br><span class="line">          reader.close();</span><br><span class="line">          <span class="keyword">return</span> sb.toString();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改BaseServlet中的doGet方法</strong></p>
<p>1.获取POST请求的 Content-Type类型 </p>
<p>2.判断传递的数据是不是JSON格式 </p>
<p>3.如果是 JSON格式</p>
<p>​    就调用上面编写的 getPostJSON方法,获取数据 ,将获取到的JSON格式的字符串转换为 Map </p>
<p>​    从Map中获取要调用的方法名 </p>
<p>​    将Map保存到request域对象中 (流只能使用一次)</p>
<p>4.如果不是JSON格式，就按照原来的方法     req.getParameter(“methodName”);</p>
<p>5.继续执行之前的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      String methodName = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 获取数据提交格式</span></span><br><span class="line">      String ContentType = req.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">      <span class="comment">// 如果数据是 JSON 的格式，需要解析</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;application/json;charset=utf-8&quot;</span>.equalsIgnoreCase(ContentType)) &#123;</span><br><span class="line"></span><br><span class="line">          String JsonDate = getPostJSON(req);</span><br><span class="line">          <span class="comment">// 将 JSON 字符串转换成 map 类型</span></span><br><span class="line">          Map&lt;String, Object&gt; map = JSON.parseObject(JsonDate, Map.class);</span><br><span class="line">          <span class="comment">// 获取请求的 功能</span></span><br><span class="line">          methodName = (String) map.get(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">          <span class="comment">// 将其他的数据保存到 request域 中</span></span><br><span class="line">          req.setAttribute(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通模式,可以直接获取</span></span><br><span class="line">          methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (methodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 通过反射优化代码</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 通过方法名与获取相关方法</span></span><br><span class="line">              Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">              <span class="comment">// 调用方法</span></span><br><span class="line">              method.invoke(<span class="keyword">this</span>, req, resp);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>








<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><a href="https://imgtu.com/i/WZh2QI"><img src="https://z3.ax1x.com/2021/07/14/WZh2QI.jpg" alt="WZh2QI.jpg"></a></p>
<p><strong>JSON的特点</strong></p>
<ul>
<li>JSON 是一种轻量级的数据交换格式。</li>
<li>JSON采用完全独立于语言的文本格式，就是说不同的编程语言JSON数据是一致的。</li>
<li>JSON易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</li>
</ul>
<p>目前, 前后端的ajax通讯几乎用的都是json格式的了,所以在开发的过程中,我们经常会涉及到JSON数据的转换</p>
<p><a href="https://imgtu.com/i/W9QnaD"><img src="https://z3.ax1x.com/2021/07/11/W9QnaD.jpg" alt="W9QnaD.jpg"></a></p>
<h2 id="XML与JSON的区别"><a href="#XML与JSON的区别" class="headerlink" title="XML与JSON的区别"></a>XML与JSON的区别</h2><ul>
<li><p>XML : 可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言。 </p>
</li>
<li><p>JSON:  (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</p>
</li>
<li><p>相同点:  </p>
<ul>
<li>它们都可以作为一种数据交换格式。</li>
</ul>
</li>
<li><p>二者区别:</p>
<ul>
<li><p>XML是重量级的，JSON是轻量级的,XML在传输过程中比较占带宽，JSON占带宽少，易于压缩。</p>
</li>
<li><p>XML和json都用在项目交互下，XML多用于做配置文件，JSON用于数据交互</p>
</li>
<li><p>JSON独立于编程语言存在,任何编程语言都可以去解析json</p>
</li>
</ul>
</li>
</ul>
<h2 id="JSON语法格式"><a href="#JSON语法格式" class="headerlink" title="JSON语法格式"></a>JSON语法格式</h2><p>用{} 包裹，用 逗号分隔数据，每个数据采用键值对的方式，键一定要用双引号引起，值如果是数字，可以不用双引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象格式</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 集合格式</span><br><span class="line">&#123;&quot;person&quot;:[&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;jack&quot;,&quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:22&#125;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组格式</span><br><span class="line">[&#123;&quot;name&quot;:&quot;老五&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;会长&quot;,&quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:12&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><ul>
<li>Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</li>
<li>FastJson特点如下：<ul>
<li> 能够支持将java bean序列化成JSON字符串，也能够将JSON字符串反序列化成Java bean。</li>
<li> 顾名思义，FastJson操作JSON的速度是非常快的。</li>
<li> 无其他包的依赖, 使用比较方便。</li>
</ul>
</li>
</ul>
<p><strong>基本使用</strong></p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.colobu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson-jaxrs-json-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常用方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>JSON.toJSONString(Object obj)</td>
<td>将Java对象转换为JSON字符串格式</td>
</tr>
<tr>
<td>JSON.parseObject(String jsonString [, Class&lt;T&gt; class] )</td>
<td>将JSON字符串转换为Java对象，注意反序列化时为对象时，必须要有默认无参的构造函数，否则会报异常。 可在后面加class的泛型，指定要转换的类型。</td>
</tr>
<tr>
<td>JSON.parseArray(String jsonString)</td>
<td>将JSON字符串转换为集合对象</td>
</tr>
</tbody></table>
<p>使用 JSON.toJSONString(Object obj) ，可以传递一个SimplePropertyPreFilter对象，指定需要格式化的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将course对象JSON格式化,如果只要 id 与 name 字段</span></span><br><span class="line">SimplePropertyPreFilter filter = <span class="keyword">new</span> SimplePropertyPreFilter(Course.class, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;course_name&quot;</span>);</span><br><span class="line">String res = JSON.toJSONString(course, filter);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Fastjson中的 <strong>@JSONField</strong> 注解</p>
<p>通过 <strong>@JSONField</strong> 我们可以自定义字段的名称进行输出，并控制字段的排序，还可以进行序列化标记。 </p>
<ul>
<li>name属性, 指定JSON格式化后的字段的名称 </li>
<li>ordinal属性, 指定字段的顺序</li>
<li>serialize属性, 指定字段不序列化</li>
</ul>
</li>
</ul>
<p>也可以通过  <strong>new JSONObject()</strong>  直接创建 JSON 对象，使用 <strong>jsonObject.put()</strong> 经行赋值</p>
<h1 id="BeanUtil工具类"><a href="#BeanUtil工具类" class="headerlink" title="BeanUtil工具类"></a>BeanUtil工具类</h1><p>BeanUtils 是 Apache commons组件的成员之一，主要用于简化JavaBean封装数据的操作。<strong>可以将一个表单提交的所有数据封装到JavaBean中</strong>。</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>BeanUtils 对象常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanUtils.populate(Object bean, Map properties)</td>
<td>将Map数据封装到指定Javabean中，<br />一般用于将表单的所有数据封装到javabean</td>
</tr>
<tr>
<td>BeanUtils.copyProperties(Object obj1, Object obj2);</td>
<td>将参数二中的数据封装到参数一中</td>
</tr>
<tr>
<td>setProperty(Object obj,String name,Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td>getProperty(Object obj,String name)</td>
<td>获得属性值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建course对象</span></span><br><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line"><span class="comment">//2.创建Map</span></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//3.向map集合中添加数据, key要与course的属性名保持一致,value的数据类型与course的属性的类型保持一致</span></span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;course_name&quot;</span>,<span class="string">&quot;大数据&quot;</span>);</span><br><span class="line"><span class="comment">//将map中的数据封装到 course中</span></span><br><span class="line">BeanUtils.populate(course,map);</span><br></pre></td></tr></table></figure>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传的实质：文件的拷贝</p>
<ul>
<li>文件上传：从本地将文件拷贝到服务器磁盘上 <ul>
<li>客户端:  需要编写文件上传表单</li>
<li>服务端:  需要编写代码接受上传的 文件</li>
</ul>
</li>
</ul>
<h2 id="客户端编码"><a href="#客户端编码" class="headerlink" title="客户端编码"></a>客户端编码</h2><p><strong>三要素</strong> </p>
<ul>
<li>使用表单的POST提交 (get方式提交有大小限制,post没有) </li>
<li>表单的enctype属性必须设置为   <strong>multipart/form-data.</strong>  <ul>
<li>encodetype就是编码类型的意思.</li>
<li>multipart/form-data是多部件文件上传 , 指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思。</li>
</ul>
</li>
<li>表单必须有文件上传项: <strong>file</strong>,必须要有name属性和值 </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;文件上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 默认情况下，表单的enctype的值是application/x-www-form-urlencoded，不能用于文件上传，只有使用了multipart/form-data，才能完整的传递文件数据</p>
<h2 id="服务端编码"><a href="#服务端编码" class="headerlink" title="服务端编码"></a>服务端编码</h2><p>服务端要接收文件上传的表单数据</p>
<h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><h4 id="上传文件-抓包分析"><a href="#上传文件-抓包分析" class="headerlink" title="上传文件, 抓包分析"></a>上传文件, 抓包分析</h4><p>使用360浏览器进行抓包,谷歌浏览器不方便查看</p>
<p><a href="https://imgtu.com/i/WVD0v4"><img src="https://z3.ax1x.com/2021/07/14/WVD0v4.jpg" alt="WVD0v4.jpg"></a></p>
<p>每个input都是一个表单项，被分隔符分开,如果是文件上传项，会有filenamme属性</p>
<h4 id="服务端获上传的文件"><a href="#服务端获上传的文件" class="headerlink" title="服务端获上传的文件"></a>服务端获上传的文件</h4><ol>
<li><p>通过request获取请求体的内容</p>
</li>
<li><p>解析请求体 </p>
<p>根据分隔符将请求中所有的内容,切割成数组,数组中的每一个元素 都是一个表单项</p>
</li>
<li><p>遍历数组,分清楚那个是普通的表单项, 哪个是 文件上传项</p>
<p>如何区分? 判断是否有 filename</p>
</li>
<li><p>获取到普通表单项中的内容,通过属性name获取</p>
</li>
<li><p>获取文件上传项内容</p>
<p>文件名: filname = aaa.txt</p>
<p>文件内容: </p>
</li>
<li><p>使用IO将文件内容,保存到服务器中</p>
</li>
</ol>
<h3 id="FileUpload工具类"><a href="#FileUpload工具类" class="headerlink" title="FileUpload工具类"></a>FileUpload工具类</h3><p>FileUpload包可以很容易地将文件上传到你的Web应用程序.</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>FileUpload 核心类介绍</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DiskFileItemFactory</td>
<td>磁盘文件项工厂, 读取文件时相关的配置,比如:  缓存的大小 , 临时目录的位置</td>
</tr>
<tr>
<td>ServletFileUplaod</td>
<td>文件上传的一个核心类</td>
</tr>
<tr>
<td>FileItem</td>
<td>代表每一个表单项</td>
</tr>
</tbody></table>
<p><strong>ServletFileUpload类 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean  isMultipartContent(request);</td>
<td>判断是否是一个文件上传的表单</td>
</tr>
<tr>
<td>List  parseRequest(request);</td>
<td>解析request获得表单项的集合</td>
</tr>
<tr>
<td>void  setHeaderEncoding(“UTF-8”);</td>
<td>设置上传的文件名的编码方式</td>
</tr>
</tbody></table>
<p><strong>FIleItem类 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean  isFormField()</td>
<td>判断是否是普通表单项</td>
</tr>
<tr>
<td>String  getFieldName()</td>
<td>获得表单的name属性值</td>
</tr>
<tr>
<td>String  getString()</td>
<td>获得表单的value值</td>
</tr>
<tr>
<td>String  getName()</td>
<td>获得上传文件的名称</td>
</tr>
<tr>
<td>InputStream  getInputStream()</td>
<td>获得上传文件的输入流</td>
</tr>
</tbody></table>
<p><strong>文件上传后台代码编写</strong></p>
<p>​    1、创建磁盘文件项工厂</p>
<p>​    2、创建文件上传的核心类</p>
<p>​    3、解析request—获得文件项集合</p>
<p>​    4、遍历文件项集合</p>
<p>​    5、判断普通表单项/文件上传项</p>
<p>​            普通表单项: 使用 getFieldName() 与  getString()  方法获取 普通表单的name属性值与value值</p>
<p>​            文件上传项: 使用getName()获取文件名称， getInputStream()获取输入流，通过IO流将文件保存到服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建磁盘文件项工厂</span></span><br><span class="line">            DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">            <span class="comment">// 创建文件上传的核心类</span></span><br><span class="line">            ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">            upload.setHeaderEncoding(<span class="string">&quot;UTF-8&quot;</span>);  <span class="comment">// 设置编码</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = upload.isMultipartContent(req);  <span class="comment">// 是否是一个文件上传的表单</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//解析request-- - 获得文件项集合</span></span><br><span class="line">                List&lt;FileItem&gt; itemList = upload.parseRequest(req);</span><br><span class="line">                <span class="comment">// 不为空，则遍历文件项集合</span></span><br><span class="line">                <span class="keyword">if</span> (itemList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (FileItem item : itemList) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> b = item.isFormField();</span><br><span class="line">                        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                            <span class="comment">//  普通表单项</span></span><br><span class="line">                            String fieldName = item.getFieldName();   <span class="comment">// 获取表单的键</span></span><br><span class="line">                            String value = item.getString(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">// 换取表单的值</span></span><br><span class="line">                            System.out.println(fieldName + <span class="string">&quot;=&quot;</span> + value); <span class="comment">// 输出打印</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 文件上传项</span></span><br><span class="line">                            String fileName = item.getName(); <span class="comment">// 换取文件的名</span></span><br><span class="line">                            <span class="comment">// 通过UUID 换取一个新的文件名</span></span><br><span class="line">                            String newFileName = UUIDUtils.getUUID() + fileName;</span><br><span class="line">                            <span class="comment">// 获取文件的输入流</span></span><br><span class="line">                            InputStream in = item.getInputStream();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将文件保存到tomcat中webapp下的upload文件夹中</span></span><br><span class="line">                            <span class="comment">// 获取项目的实际路径  C:\apache-tomcat-8.5.55\webapps\lagou_edu_home</span></span><br><span class="line">                            String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                            <span class="comment">// 将 lagou_edu_home截取掉，获取 C:\apache-tomcat-8.5.55\webapps\</span></span><br><span class="line">                            String path = realPath.substring(<span class="number">0</span>, realPath.indexOf(<span class="string">&quot;lagou_edu_home&quot;</span>));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 创建一个输出流，文件保存在tomcat中webapps下的upload文件中</span></span><br><span class="line">                            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(path + <span class="string">&quot;/upload/&quot;</span> + newFileName);</span><br><span class="line">                            <span class="comment">// 文件传输</span></span><br><span class="line">                            in.transferTo(out);</span><br><span class="line">                            <span class="comment">// 关闭流</span></span><br><span class="line">                            out.close();</span><br><span class="line">                            in.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将图片上传到tomcat服务器"><a href="#将图片上传到tomcat服务器" class="headerlink" title="将图片上传到tomcat服务器"></a>将图片上传到tomcat服务器</h2><p><strong>idea中部署项目两种方式</strong></p>
<ul>
<li>war模式：将项目以war包的形式上传真实到服务器的webapps目录中；</li>
<li>war exploded模式：仅仅是目录的映射，就相当于tomcat在项目源文件夹中启动一样；</li>
</ul>
<p><a href="https://imgtu.com/i/WVcn1K"><img src="https://z3.ax1x.com/2021/07/14/WVcn1K.jpg" alt="WVcn1K.jpg"></a></p>
<p>这里使用war模式，这样才能通过获取项目的路径，进入获取tomcat的路径，将文件保存到里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将文件保存到tomcat中webapp下的upload文件夹中</span></span><br><span class="line"><span class="comment">// 获取项目的实际路径  C:\apache-tomcat-8.5.55\webapps\lagou_edu_home</span></span><br><span class="line">String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">// 将 lagou_edu_home截取掉，获取 C:\apache-tomcat-8.5.55\webapps\</span></span><br><span class="line">String path = realPath.substring(<span class="number">0</span>, realPath.indexOf(<span class="string">&quot;lagou_edu_home&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>页面加载图片</strong></p>
<p>将tomcat作为图片服务器使用时，存储上传的图片后,如果想要图片可以访问,需要在idea中进行配置:</p>
<p>1）打开tomcat配置 —&gt;  在Deployment中添加 —&gt; 选择external source —&gt; 找到webapps目录下的的upload文件夹</p>
<p><a href="https://imgtu.com/i/WVg3KU"><img src="https://z3.ax1x.com/2021/07/14/WVg3KU.jpg" alt="WVg3KU.jpg"></a></p>
<p><a href="https://imgtu.com/i/WVgaP1"><img src="https://z3.ax1x.com/2021/07/14/WVgaP1.jpg" alt="WVgaP1.jpg"></a></p>
<p>2）在项目内部页面加载图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/upload/xxxxxx.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li> 也可以通过HTTP方式访问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;upload&#x2F;xxxxxx.jpg</span><br></pre></td></tr></table></figure>
<h1 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h1><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协 议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。</p>
<p>前后端分离项目，前端向后端发送请求，会出现跨域问题</p>
<ul>
<li>已被CORS策略阻止：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</li>
</ul>
<p><strong>解决</strong></p>
<p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置 Access-Control-AllowOrigin 及相关一系列参数，提供跨域访问的允许策略。</p>
<ol>
<li>在POM文件中引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决跨域问题所需依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thetransactioncompany<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cors-filter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在web.xml中 配置跨域 filter</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置跨域过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.thetransactioncompany.cors.CORSFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>






<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本用法</title>
    <url>/2021/06/26/Linux%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>目录结构</p>
<p><a href="https://imgtu.com/i/R8yC0e"><img src="https://z3.ax1x.com/2021/06/26/R8yC0e.png" alt="R8yC0e.png"></a></p>
<a id="more"></a>

<p><strong>目录详情</strong></p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>binarie:存放二进制可执行文件 (例如tomcat的bin目录)</td>
</tr>
<tr>
<td>/sbin</td>
<td>super binaries:存放二进制文件,只有root用户才能访问</td>
</tr>
<tr>
<td>/boot</td>
<td>系统启动核心目录,存放系统启动程序文件，例:查看启动文件的大小</td>
</tr>
<tr>
<td>/dev</td>
<td>devices:用于存放硬件设备文件</td>
</tr>
<tr>
<td>/etc</td>
<td>etcetera:存放系统配置文件(字体文件等)</td>
</tr>
<tr>
<td>/home</td>
<td>家目录,每一个用户都有一个”家”，用户的起始目录,创建用户跟随创建相应的家目录</td>
</tr>
<tr>
<td>/lib</td>
<td>library:系统资源文件类库</td>
</tr>
<tr>
<td>/proc</td>
<td>内存映射目录,可以查看系统相关硬件的信息</td>
</tr>
<tr>
<td>/var</td>
<td>variable:可变的,变量. 部署项目用的</td>
</tr>
<tr>
<td>/tmp</td>
<td>temporary:用来存放临时文件</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户root的家目录</td>
</tr>
<tr>
<td>/usr</td>
<td>unix shared resouce: 存放unix共享系统资源，类似于” C:/ Program Files”,用于安装各种软件</td>
</tr>
</tbody></table>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><strong>命令的格式</strong> </p>
<p>命令 [-选项] [参数] </p>
<p>命令区分大小写，其中选项和参数是可选的，中间采用空格隔开。</p>
<p><strong>查看当前目录下的信息</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>pwd</td>
<td>插卡当前位置</td>
</tr>
<tr>
<td>ls</td>
<td>list显示文件</td>
</tr>
<tr>
<td>ls -l</td>
<td>或 ll list -list  显示详细信息</td>
</tr>
<tr>
<td>ls -a</td>
<td>list -all  显示全部(包含隐藏文件)文件</td>
</tr>
<tr>
<td>ls -al</td>
<td>list -all list  上两个合体，看直接使用 ll 代替</td>
</tr>
<tr>
<td>ls 目录名</td>
<td>查看目录下有什么东西</td>
</tr>
</tbody></table>
<p><strong>用户相关操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>whoami</td>
<td>查看当前用户的名称</td>
</tr>
<tr>
<td>su</td>
<td>普通用户切换到root用户</td>
</tr>
<tr>
<td>su 用户名</td>
<td>切换到普通用户</td>
</tr>
<tr>
<td>exit</td>
<td>退回到原来用户,最好使用su和exit搭配使用，否则多次使用su指令会导致用户的”叠加”</td>
</tr>
<tr>
<td>useradd xxx</td>
<td>创建用户</td>
</tr>
<tr>
<td>passwd xxx</td>
<td>为创建的用户设置密码</td>
</tr>
<tr>
<td>userdel xxx</td>
<td>删除用户</td>
</tr>
</tbody></table>
<p><strong>文件操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>touch fileName</td>
<td>创建名字为fileName的文件</td>
</tr>
<tr>
<td>touch dir/fileName</td>
<td>在dir目录下创建名字为fileName的文件</td>
</tr>
<tr>
<td>echo 内容 &gt; fileName</td>
<td>把内容覆盖写到文件中，若文件不存在则创建</td>
</tr>
<tr>
<td>echo 内容 &gt;&gt; fileName</td>
<td>把内容追加到文件中</td>
</tr>
<tr>
<td>cat fileName</td>
<td>打印文件内容到终端</td>
</tr>
<tr>
<td>more fileName</td>
<td>分屏查看文件各行内容，不支持回看</td>
</tr>
<tr>
<td>less fileName</td>
<td>查看文件各部分内容，支持回看</td>
</tr>
<tr>
<td>head -n fileName</td>
<td>查看文件的前n行内容</td>
</tr>
<tr>
<td>tail -n fileName</td>
<td>查看文件末尾n行内容</td>
</tr>
<tr>
<td>wc fileName</td>
<td>查看文件的行数</td>
</tr>
</tbody></table>
<p><strong>目录操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir 目录名</td>
<td>创建普通文件夹</td>
</tr>
<tr>
<td>mkdir -p 目录/目录/目录</td>
<td>递归方式创建多级父子文件夹</td>
</tr>
<tr>
<td>mv dir1 dir2</td>
<td>将dir1移动到dir2中</td>
</tr>
<tr>
<td>mv dir1 name</td>
<td>将dir1改名为name</td>
</tr>
<tr>
<td>cp dir1 name</td>
<td>将dir1拷贝为name</td>
</tr>
<tr>
<td>cp -r dir1 dir2</td>
<td>需要设置参数 -r (recursive递归) 无视目录层次</td>
</tr>
<tr>
<td>rm 文件</td>
<td>删除文件</td>
</tr>
<tr>
<td>rm -r 目录</td>
<td>递归删除目录(无视目录层次)</td>
</tr>
<tr>
<td>rm -rf 文件/目录</td>
<td>-r force(强制) 删除文件/目录</td>
</tr>
</tbody></table>
<p><strong>查找操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>find / -name passwd[完整名称]</td>
<td>查找passwd文件</td>
</tr>
<tr>
<td>find ./ -name “p*”</td>
<td>查找带”p”的文件</td>
</tr>
<tr>
<td>find ./ -type f</td>
<td>查找所有文件</td>
</tr>
<tr>
<td>find ./ -type d</td>
<td>查找所有目录</td>
</tr>
<tr>
<td>grep 内容 fileName</td>
<td>从指定文件中查找指定的内容</td>
</tr>
</tbody></table>
<hr>
<p><strong>权限管理</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>chmod 权限 文件/目录名</td>
<td>管理指定文件的权限信息，r读:4 w写:2 x执行:1</td>
</tr>
</tbody></table>
<p>权限分3类，分别是   <strong>u自己、g同组、o其他组</strong>    的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> a.txt添加所有权限</span></span><br><span class="line">chmod 777 a.txt  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 给自己添加对a.txt文件可执行权限</span></span><br><span class="line">chmod u+x a.txt</span><br></pre></td></tr></table></figure>
<p><strong>进程管理</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>查看当前终端窗口里的进程</td>
</tr>
<tr>
<td>ps -aux</td>
<td>查看系统中的所有进程</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看进程列表</td>
</tr>
<tr>
<td>kill 进程号</td>
<td>杀死指定的进程</td>
</tr>
<tr>
<td>kill -9 进程号</td>
<td>强制杀死指定的进程</td>
</tr>
</tbody></table>
<p><strong>防火墙</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对外开放3306端口，供外部的计算机访问</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line"># 重启防火墙才生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 或</span><br><span class="line">service firewalld restart</span><br></pre></td></tr></table></figure>
<ul>
<li>firewall-cmd：Linux中提供的操作firewall的工具。</li>
<li>–zone：指定作用域。</li>
<li>–add-port=3306/tcp：添加的端口，格式为：端口/通讯协议。</li>
<li>–permanent：表示永久生效，没有此参数重启后会失效。</li>
</ul>
<p>也可直接修改 <strong>/etc/firewalld/zones/public.xml</strong>  文件内容来配置防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 zone 标签下添加</span><br><span class="line">&lt;port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;3306&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>firewall其他一些操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line">service firewalld status</span><br><span class="line">或</span><br><span class="line">systemctl status firewalld</span><br><span class="line">或</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">service firewalld start</span><br><span class="line">或</span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line">service firewalld stop</span><br><span class="line">或</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p><strong>其他命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>tar -zcvf 压缩文件名.tar.gz 路径1 路径2 …</td>
<td>压缩，实现一组文件或文件夹的打包</td>
</tr>
<tr>
<td>tar -zxvf 压缩文件名.tar.gz</td>
<td>解压， 实现解压缩解包</td>
</tr>
<tr>
<td>unzip  xxx.zip</td>
<td>解压zip压缩文件</td>
</tr>
<tr>
<td>ifconfig</td>
<td>查看当前系统的IP地址等信息</td>
</tr>
<tr>
<td>man [章节号] 命令/函数名</td>
<td>查询指定的命令或函数</td>
</tr>
</tbody></table>
<h1 id="vi工具的使用"><a href="#vi工具的使用" class="headerlink" title="vi工具的使用"></a>vi工具的使用</h1><p>vi和vim是Linux系统命令行下的文本编辑器，通常格式为：vi 文件名 或 vim 文件名。</p>
<p><strong>三种模式之间的切换</strong></p>
<p><a href="https://imgtu.com/i/R84MHP"><img src="https://z3.ax1x.com/2021/06/26/R84MHP.png" alt="R84MHP.png" style="zoom:67%;" /></a></p>
<p><strong>命令模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切换编辑模式</span><br><span class="line">i   在当前位置之前插入</span><br><span class="line">a   在当前位置之后插入</span><br><span class="line">o   在当前行下插入</span><br><span class="line">其他操作</span><br><span class="line">dd 剪切行</span><br><span class="line">p 当前行下粘贴</span><br><span class="line">u 撤销</span><br><span class="line">ctrl+r 取消撤销</span><br></pre></td></tr></table></figure>
<p><strong>底行模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w  			存盘</span><br><span class="line">:w newfile 		存成新文件</span><br><span class="line">:wq 			存盘退出Vi(或ZZ，或:x)</span><br><span class="line">:q! 			强行退出不存盘</span><br><span class="line">:set nu			显示行号</span><br><span class="line">:set nonu   	不显示行号</span><br><span class="line">:&#x2F;xx			搜索 xx</span><br><span class="line">:set hlsearch  	高亮显示搜索内容</span><br><span class="line">:set nohlsearch 取消高亮显示</span><br><span class="line">:1,2co3 		拷贝行1，行2在行3之后</span><br><span class="line">:4,5mo6 		移动行4，行5在行6之后</span><br><span class="line">:%s &#x2F;源字符串&#x2F;目标字符串   替换改行第一个</span><br><span class="line">:%s &#x2F;源字符串&#x2F;目标字符串&#x2F;g 替换每一行中的所有</span><br></pre></td></tr></table></figure>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="jdk下载与安装"><a href="#jdk下载与安装" class="headerlink" title="jdk下载与安装"></a>jdk下载与安装</h2><p><strong>下载和安装</strong></p>
<p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a> </p>
<p>安装方式：将下载好的jdk安装包通过Xftp工具传输到CentOS7系统中，使用tar命令解压即可。</p>
<p><strong>配置环境变量</strong></p>
<ul>
<li>使用root用户打开配置文件/etc/profile，向文件末尾追加内容如下：(这里将jdk改名了，并且放在了 /usr目录下)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;jkd11</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<ul>
<li>保存退出后让文件生效并验证是否配置成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>
<h2 id="Tomcat的下载与安装"><a href="#Tomcat的下载与安装" class="headerlink" title="Tomcat的下载与安装"></a>Tomcat的下载与安装</h2><p><strong>下载和安装</strong></p>
<p>下载地址：<a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a> </p>
<p>安装方式：将下载好的Tomcat安装包通过Xftp工具传输到CentOS系统中，使用tar命令解压即 可</p>
<p><strong>启动和关闭</strong></p>
<p>进入 Tomcat 的bin目录 使用 startup.sh 命令 与  shutdown.sh命令</p>
<p><strong>开启8080端口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 8080 -j ACCEPT 开启8080端口（暂时开通）</span><br></pre></td></tr></table></figure>
<p>如果是购买的阿里云上的服务器，需要手动配置安全组</p>
<p><strong>配置环境变量</strong></p>
<p>使用root用户打开配置文件/etc/profile，向文件末尾追加内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;tomcat</span><br><span class="line">export PATH&#x3D;$CATALINA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>保存退出后让文件生效并验证是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">.&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>   一般Tomcat服务器不配置环境变量</p>
<p><strong>发布Web项目</strong></p>
<p>将Web项目打成war包，通过Xftp工具将war包放在tomcat/webapp目录并启动</p>
<h2 id="Mysql的下载与安装"><a href="#Mysql的下载与安装" class="headerlink" title="Mysql的下载与安装"></a>Mysql的下载与安装</h2><p><strong>下载Mysql的repo源</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>安装rpm包</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>安装Mysql</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p><strong>启动服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p><strong>查看服务状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>
<p><strong>查看临时密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<p><strong>登入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p 密码</span><br></pre></td></tr></table></figure>
<p><strong>修改临时密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;QiDian@666&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>这时不支持远程连接登入,需修改mysql库中的user表的中的host字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看root用户允许哪个ip能够连接,默认localhost</span><br><span class="line">select host from user where user&#x3D;&#39;root&#39;;</span><br><span class="line">## 允许所有ip地址连接root用户</span><br><span class="line">update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;; </span><br><span class="line">## 刷新</span><br><span class="line">flush privileges;  </span><br></pre></td></tr></table></figure>
<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><p><strong>基本概念</strong> </p>
<ul>
<li>Shell是一个命令行解释器，可以接收应用程序或用户命令，然后访问操作系统内核。 </li>
<li>Shell是一个功能相当强大的编程语言，易编写、易调试、灵活性强；</li>
</ul>
<p> <strong>简单编写</strong></p>
<p>创建以 .sh 为后缀的文件。 以#!/bin/bash开头并编写代码后续代码</p>
<p><strong>执行Shell程序</strong></p>
<ul>
<li>方式一：./文件名，此方式需要执行权限。 </li>
<li>方式二：/bin/bash 文件名，此方式不需要执行权限。或 bash 文件名    或    sh 文件名</li>
</ul>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p><strong>语法格式</strong> </p>
<ul>
<li><p>定义变量：变量=值 </p>
</li>
<li><p>撤销变量：unset 变量 </p>
</li>
</ul>
<p><strong>定义规则</strong></p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。 </li>
<li>不能使用bash里的关键字。 </li>
<li>中间不能有空格，可以有下划线。 </li>
<li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。 </li>
<li>变量的值如果有空格，需要使用双引号或单引号括起来。</li>
</ul>
<h2 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h2><p><strong>算术运算符</strong> : 与java中的一模一样，+  -  *   /   %   =   ==   !=</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算数运算符的用法</span></span><br><span class="line">a=5</span><br><span class="line">b=10</span><br><span class="line"><span class="comment"># 方式一,注意：在expr中使用乘法*，需要转义</span></span><br><span class="line"><span class="built_in">echo</span> `expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</span><br><span class="line"><span class="comment"># 方式二，通过中括号</span></span><br><span class="line"><span class="built_in">echo</span> $[<span class="variable">$a</span>-<span class="variable">$b</span>]</span><br><span class="line"><span class="comment"># 方式三，通过小括号</span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>*<span class="variable">$b</span>))</span><br></pre></td></tr></table></figure>
<p><strong>关系运算符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-eq		是否等于</span><br><span class="line">-ne		是否不等于</span><br><span class="line">-gt		是否大于</span><br><span class="line">-lt		是否小于</span><br><span class="line">-ge		是否大于等于</span><br><span class="line">-le		是否小于等于</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">score=66</span><br><span class="line"></span><br><span class="line">if [ $score -gt 60 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;恭喜你，及格了&quot;</span><br><span class="line">elif [ $score -eq 60 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;60分万岁，多一分浪费！&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;等着补考把&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="case判断"><a href="#case判断" class="headerlink" title="case判断"></a>case判断</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">  &quot;值1&quot;）</span><br><span class="line">	 如果变量的值等于值1，则执行程序1</span><br><span class="line">  ;;</span><br><span class="line">  &quot;值2&quot;）</span><br><span class="line">	 如果变量的值等于值2，则执行程序2</span><br><span class="line">  ;;</span><br><span class="line">  *）</span><br><span class="line">  	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;请输入命令&quot;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">case $num in</span><br><span class="line">  1)</span><br><span class="line">    echo &quot;1号命令&quot;</span><br><span class="line">  ;;      </span><br><span class="line">  2)     </span><br><span class="line">    echo &quot;2号命令&quot;</span><br><span class="line">  ;;     </span><br><span class="line">  3)    </span><br><span class="line">    echo &quot;3号命令&quot; </span><br><span class="line">  ;;         </span><br><span class="line">  *)  </span><br><span class="line">    echo &quot;无该命令&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 累加1-100</span></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for (( i=0;i&lt;=100;i++ ))</span><br><span class="line">do</span><br><span class="line">  sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 累加1-100</span></span><br><span class="line">sum=0</span><br><span class="line">i=0</span><br><span class="line"></span><br><span class="line">while (( i&lt;=100 ))</span><br><span class="line">do</span><br><span class="line">   sum=$[$sum+$i]</span><br><span class="line">   i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">	Action;</span><br><span class="line">	[return int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个函数，对两个形参相乘</span></span><br><span class="line">function mul()</span><br><span class="line">&#123;</span><br><span class="line">    s=$[$1*$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示用户输入两个实参</span></span><br><span class="line">read -p &quot;请输入第一个参数&quot; num1</span><br><span class="line">read -p &quot;请输入第二个参数&quot; num2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用函数</span></span><br><span class="line">mul num1 num2</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>maven笔记</title>
    <url>/2021/07/14/maven%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Maven是一个跨平台的项目管理工具。作为Apache组织的一个颇为成功的开源项目，其主要服务于基于Java平台的项目创建，依赖管理和项目信息管理。<a id="more"></a>maven是Apache的顶级项目，解释为“专家，内行”，它是一个项目管理的工具，maven自身是纯java开发的，可以使用maven对java项目进行构建、依赖管理。</p>
<p><strong>Maven的作用</strong></p>
<ul>
<li>依赖管理<ul>
<li>依赖指的就是是 我们项目中需要使用的第三方Jar包, 一个大一点的工程往往需要几十上百个Jar包,按照我们之前的方式,每使用一种Jar,就需要导入到工程中,还要解决各种Jar冲突的问题.</li>
<li>Maven可以对Jar包进行统一的管理,包括快速引入Jar包,以及对使用的 Jar包进行统一的版本控制</li>
</ul>
</li>
<li>一键构建项目<ul>
<li>之前我们创建项目,需要确定项目的目录结构,比如<code>src</code> 存放Java源码, <code>resources</code>存放配置文件,还要配置环境比如JDK的版本等等,如果有多个项目 那么就需要每次自己搞一套配置,十分麻烦</li>
<li>Maven为我们提供了一个标准化的Java项目结构,我们可以通过Maven快速创建一个标准的Java项目.</li>
</ul>
</li>
</ul>
<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><p> <strong>到官网去下载它的安装软件</strong></p>
<p><a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a>    ,例如找到 apache-maven-3.6.3-bin.zip,直接下载即可。</p>
<p><strong>将下载好的Maven压缩包 直接解压，放到一个没有中文没有空格的路径下</strong></p>
<p>如 C:\study\softwareInstall\maven</p>
<p><strong>maven下的文件说明</strong></p>
<ul>
<li>bin:存放了 maven 的命令</li>
<li>boot:存放了一些 maven 本身的引导程序，如类加载器等</li>
<li>conf:存放了 maven 的一些配置文件，如 setting.xml 文件 </li>
<li>lib:存放了 maven 本身运行所需的一些 jar 包 </li>
</ul>
<p><strong>Maven环境变量配置</strong></p>
<ul>
<li>配置系统变量 MAVEN_HOME ，变量值就是你的 maven 安装的路径（bin 目录之前一级目录）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量名 : MAVEN_HOME</span><br><span class="line">变量值 : C:\study\softwareInstall\maven\apache-maven-3.6.3</span><br></pre></td></tr></table></figure>
<ul>
<li>将MAVEN_HOME 添加到Path系统变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%MAVEN_HOME%\bin</span><br></pre></td></tr></table></figure>
<p><strong>软件版本测试</strong></p>
<p>再cmd窗口输入  mvn-v 命令检查 maven 是是否安装成功，如果看到maven版本与java版本则安装成功。</p>
<h1 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h1><p>Maven中的仓库是用来存放maven构建的项目和各种依赖的(Jar包)</p>
<p><strong>Maven的仓库分类</strong></p>
<ul>
<li><strong>本地仓库</strong>:    位于自己计算机中的仓库, 用来存储从远程仓库或中央仓库下载的插件和 jar 包，</li>
<li><strong>远程仓库</strong>:    需要联网才可以使用的仓库。如阿里提供了一个免费的maven 远程仓库  <a href="https://maven.aliyun.com/mvn/search%E3%80%82">https://maven.aliyun.com/mvn/search。</a></li>
<li><strong>中央仓库</strong>:    在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件</li>
</ul>
<p><a href="https://imgtu.com/i/WVid4H"><img src="https://z3.ax1x.com/2021/07/14/WVid4H.jpg" alt="WVid4H.jpg"></a></p>
<p><strong>Maven 本地仓库的配置</strong></p>
<p>1.maven仓库默认是在 C盘  .m2 目录下</p>
<p>2.一般会把maven仓库放到别的地方，如C:\study\softwareInstall\repository。</p>
<p>3.需在 maven/conf/settings.xml 配置文件中设置仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置本地仓库位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\study\softwareInstall\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便使用仓库，可以先引入别人的仓库，这样就不用自己浪费时间去下载了</p>
<p>链接：<a href="https://pan.baidu.com/s/18OGIHpkpOlpWvYRKyfoKdA">https://pan.baidu.com/s/18OGIHpkpOlpWvYRKyfoKdA</a><br>提取码：gvbp </p>
<p><strong>配置阿里云远程仓库</strong></p>
<p>Maven默认的远程仓库是在国外, 所以下载jar包时速度会非常慢, 这里推荐使用阿里云仓库</p>
<p>打开 settings.xml 文件 ， 在 mirrors 标签下添加 ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置本地仓库位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven项目"><a href="#maven项目" class="headerlink" title="maven项目"></a>maven项目</h1><p>在idea中创建一个maven的项目，不使用模板，创建好的默认工程长这样：</p>
<p><a href="https://imgtu.com/i/WVAF9H"><img src="https://z3.ax1x.com/2021/07/14/WVAF9H.jpg" alt="WVAF9H.jpg"></a></p>
<p>如果编译后还会出现一个  <strong>target</strong> 目录 ： 项目输出位置，编译后的class 文件会输出到此目录 </p>
<h2 id="将maven工程改造成-web项目"><a href="#将maven工程改造成-web项目" class="headerlink" title="将maven工程改造成 web项目"></a>将maven工程改造成 web项目</h2><ul>
<li>在main目录下创建一个webapp文件夹</li>
<li>选中  project Structure —&gt; facets—&gt; 点击+号 添加web —&gt; 选择当前工程hello_maven</li>
</ul>
<p><a href="https://imgtu.com/i/WVEFaT"><img src="https://z3.ax1x.com/2021/07/14/WVEFaT.jpg" alt="WVEFaT.jpg" style="zoom: 50%;" /></a></p>
<ul>
<li>修改路径信息 </li>
</ul>
<p><a href="https://imgtu.com/i/WVEkIU"><img src="https://z3.ax1x.com/2021/07/14/WVEkIU.jpg" alt="WVEkIU.jpg"></a></p>
<p><a href="https://imgtu.com/i/WVE1IO"><img src="https://z3.ax1x.com/2021/07/14/WVE1IO.jpg" alt="WVE1IO.jpg"></a></p>
<h2 id="pom核心配置文件"><a href="#pom核心配置文件" class="headerlink" title="pom核心配置文件"></a>pom核心配置文件</h2><p>一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的信息、项目依赖、引入插件等</p>
<p>1） 一个Maven工程就是由<code>groupId</code>，<code>artifactId </code>和 <code>version</code> 作为唯一标识, 我们在引用其他第三方库的时候，也是通过这3个变量确定</p>
<p>Maven坐标主要组成(GAV) - 确定一个jar在互联网位置 </p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupId</strong></td>
<td>定义当前Maven组织名称,通常是公司名</td>
</tr>
<tr>
<td><strong>artifactId</strong></td>
<td>定义实际项目名称</td>
</tr>
<tr>
<td><strong>version</strong></td>
<td>定义当前项目的当前版本</td>
</tr>
<tr>
<td><strong>packaging</strong></td>
<td>打包类型<br />jar：执行 package 会打成 jar 包       war：执行 package 会打成 war 包</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello_maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>引入其他jar包</li>
</ol>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>dependencies</strong></td>
<td>表示依赖关系</td>
</tr>
<tr>
<td><strong>dependency</strong></td>
<td>使用 <code>&lt;dependency&gt; </code>声明一个依赖后，Maven就会自动下载这个依赖包</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>添加插件</li>
</ol>
<p>添加编译插件,  设置 jdk 编译版本 </p>
<p>本教程使用 jdk11，需要设置编译版本为 11，这里需要使用 maven 的插件来设置</p>
<p>在pom中加入如下配置: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- properties 是全局设置,可以设置整个maven项目的编译器 JDK版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 重点  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在build中 我们需要指定一下项目的JDK编译版本,maven默认使用1.5版本进行编译</span></span><br><span class="line"><span class="comment">    注意 build 与 dependencies是平级关系,标签不要写错位置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">release</span>&gt;</span>11<span class="tag">&lt;/<span class="name">release</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven的常用命令"><a href="#maven的常用命令" class="headerlink" title="maven的常用命令"></a>maven的常用命令</h2><p><strong>maven项目生命周期</strong></p>
<p><a href="https://imgtu.com/i/WVmDns"><img src="https://z3.ax1x.com/2021/07/14/WVmDns.jpg" alt="WVmDns.jpg"></a></p>
<p>maven 通过执行一些简单命令即可实现上边生命周期的各个过程</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>mvn clean</strong></td>
<td>执行完毕后，会将target目录删除.</td>
</tr>
<tr>
<td><strong>mvn compile</strong></td>
<td>完成编译操作 , 执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</td>
</tr>
<tr>
<td><strong>mvn test</strong></td>
<td>执行完毕后，会在target目录中生成三个文件夹：<br />surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）</td>
</tr>
<tr>
<td><strong>mvn package</strong></td>
<td>完成打包操作, 执行完毕后，会在target目录中生成一个文件，该文件可能是 jar、war</td>
</tr>
<tr>
<td><strong>mvn install</strong></td>
<td>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作 ,<br /> 执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用</td>
</tr>
</tbody></table>
<p> <strong>idea中maven视图介绍</strong></p>
<p><a href="https://imgtu.com/i/WVmfc4"><img src="https://z3.ax1x.com/2021/07/14/WVmfc4.jpg" alt="WVmfc4.jpg"></a></p>
<p><strong>工具栏介绍</strong></p>
<p><a href="https://imgtu.com/i/WVn9Et"><img src="https://z3.ax1x.com/2021/07/14/WVn9Et.jpg" alt="WVn9Et.jpg"></a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.根据pom.xml文件重新导入所有Maven项目和依赖,刷新</span><br><span class="line">2.创建源码（重新编译）并更新目录</span><br><span class="line">3.下载源码或文档</span><br><span class="line">4.添加Maven项目</span><br><span class="line">5.执行生命周期中的阶段，选中lifecycle选项中生命周期中的一个阶段（phase），才能点击执行。</span><br><span class="line">6.运行Maven生命周期或插件</span><br><span class="line">7.切换离线模式，就是关闭和远程仓库的链接，从本地仓库中获取，也不能将jar包提交到远程仓库</span><br><span class="line">8.是否跳过测试，点击选中就可以跳过测试，在点击选择取消跳过测试</span><br><span class="line">9.展示当前选中的maven项目jar包的依赖，并且可以直接在图形化依赖图上进行排除依赖操作</span><br><span class="line">10.收起下面展开的视图</span><br><span class="line">11.跳转到maven的Setting页面</span><br></pre></td></tr></table></figure>
<h2 id="依赖范围介绍"><a href="#依赖范围介绍" class="headerlink" title="依赖范围介绍"></a>依赖范围介绍</h2><p>A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包 括： </p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译范围，指 A在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。</td>
</tr>
<tr>
<td>provided</td>
<td>provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依 赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。</td>
</tr>
<tr>
<td>test</td>
<td>test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如：junit。由于运行时不需要所以test范围依赖不会被打包。</td>
</tr>
<tr>
<td>system</td>
<td>system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 模块名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖范围, 指定依赖范围是编译与测试时有效,运行时无效,运行时使用tomcat中的依赖,避免冲突 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven的依赖传递"><a href="#maven的依赖传递" class="headerlink" title="maven的依赖传递"></a>maven的依赖传递</h1><p>在maven中，依赖是可以传递的，假设存在三个项目，分别是项目A，项目B以及项目C。假设C依赖 B，B依赖A，那么我们可以根据maven项目依赖的特征不难推出项目C也依赖A。</p>
<p><a href="https://imgtu.com/i/fnMlBd"><img src="https://z3.ax1x.com/2021/08/06/fnMlBd.png" alt="fnMlBd.png"></a></p>
<p><strong>依赖冲突</strong></p>
<p>由于依赖传递现象的存在，例如: spring-webmvc 依赖 spirng-beans-5.1.5，spring-aop 依赖 springbeans-5.1.6，但是发现 spirng-beans-5.1.5 加入到了工程中，而我们希望 spring-beans-5.1.6 加入工 程。这就造成了依赖冲突。</p>
<h2 id="如何解决依赖冲突"><a href="#如何解决依赖冲突" class="headerlink" title="如何解决依赖冲突"></a>如何解决依赖冲突</h2><h3 id="使用maven提供的依赖调解原则"><a href="#使用maven提供的依赖调解原则" class="headerlink" title="使用maven提供的依赖调解原则"></a>使用maven提供的依赖调解原则</h3><p><strong>第一声明者优先原则</strong> </p>
<p>在 pom 文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传 递过来的依赖。</p>
<p><strong>路径近者优先原则</strong> </p>
<p>直接引入需要的依赖的坐标——–直接依赖大于依赖传递</p>
<h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>使用<strong>exclusions</strong>标签将传递过来的依赖排除出去。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--依赖排除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="锁定版本"><a href="#锁定版本" class="headerlink" title="锁定版本"></a>锁定版本</h3><p>采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以 锁定的版本为准添加到工程中，此方法在企业开发中经常使用。</p>
<p>在<strong>dependencyManagement</strong>标签中锁定依赖的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>   这里只是锁定了版本，并没有导入依赖，还需再<strong>dependencies</strong>标签中导入依赖，可以不用再指定<strong>version</strong></p>
<p><strong>properties标签的使用</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将版本提取出来，properties里的标签是自定义的，随便怎么写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springmvc.version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">springmvc.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--锁定jar版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springMVC --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springmvc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven的聚合工程"><a href="#maven的聚合工程" class="headerlink" title="maven的聚合工程"></a>maven的聚合工程</h1><p>在企业项目开发中，由于项目规模大，业务复杂，参与的人员比较多，一般会通过合理的模块拆分将一 个大型的项目拆分为N多个小模块，分别进行开发。而且拆分出的模块可以非常容易的被其他模块复用 常见的拆分方式有两种： </p>
<p><strong>第一种</strong>  按照业务模块进行拆分，每个模块拆分成一个maven工程，例如将一个项目分为用户模块，订 单模块，购物车模块等，每个模块对应就是一个maven工程 </p>
<p><strong>第二种</strong>   按照层进行拆分，例如持久层、业务层、表现层等，每个层对应就是一个maven工程 不管上面那种拆分方式，通常都会提供一个父工程，将一些公共的代码和配置提取到父工程中进行统一 管理和配置。</p>
<p><a href="https://imgtu.com/i/fn8Jl6"><img src="https://z3.ax1x.com/2021/08/06/fn8Jl6.png" alt="fn8Jl6.png"></a></p>
<h2 id="maven工程的继承"><a href="#maven工程的继承" class="headerlink" title="maven工程的继承"></a>maven工程的继承</h2><p>在Java语言中，类之间是可以继承的，通过继承，子类就可以引用父类中非private的属性和方法。同 样，在maven工程之间也可以继承，子工程继承父工程后，就可以使用在父工程中引入的依赖。继承的 目的是为了消除重复代码。</p>
<p><strong>父工程pom部分定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意打包方式一定是pom--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子工程pom部分定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意打包方式一定是pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-children<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven工程的聚合"><a href="#maven工程的聚合" class="headerlink" title="maven工程的聚合"></a>maven工程的聚合</h2><p>在maven工程的pom.xml文件中可以使用标签将其他maven工程聚合到一起，聚合的目的是为了进行 统一操作.</p>
<p>例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来 非常繁琐。这时就可以使用标签将这些工程统一聚合到maven父工程中，需要打包的时候，只需要在此 工程中执行一次打包命令，其下被聚合的工程就都会被打包了。</p>
<p><strong>父工程中pom定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-4<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>vue笔记</title>
    <url>/2021/07/19/vue%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是， Vue 被设计 为可以自底向上逐层应用. </p>
<p>Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。<a id="more"></a>另一 方面，当与 现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 </p>
<p>自底向上逐层应用：作为渐进式框架要实现的目标就是方便项目增量开发(即插即用)</p>
<p><strong>官网</strong>  <a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p>
<h1 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h1><h2 id="vue入门"><a href="#vue入门" class="headerlink" title="vue入门"></a>vue入门</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul>
<li><p>定义html，引入vue.js </p>
</li>
<li><p>定义app div，此区域作为vue的接管区域 </p>
</li>
<li><p>定义Vue实例，接管app区域。 </p>
</li>
<li><p>定义model（数据对象） </p>
</li>
<li><p>在app中展示数据</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一种 引入 vue.js的CDN地址 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;/script&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二种 本地导入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 定义app div，此区域作为vue的接管区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//3. 创建vue实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//定义 Vue实例挂载的元素节点,表示vue接管该div</span></span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">//4.定义model模型数据对象</span></span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                name:<span class="string">&quot;怪狗狗&quot;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Vue基本属性"><a href="#Vue基本属性" class="headerlink" title="Vue基本属性"></a>Vue基本属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>el</td>
<td>Vue实例挂载的元素节点,表示vue接管该区域，建议用div标签，不能使用HTML和Body标签</td>
</tr>
<tr>
<td>data</td>
<td>Vue中用到的数据定义在data中 。data中可以写复杂类型 ，相当于js中的对象</td>
</tr>
<tr>
<td>methods</td>
<td>定义方法</td>
</tr>
<tr>
<td>computed</td>
<td>计算属性。效果与方法一样，但是数据是基于它们的响应式依赖进行缓存的 。一般重复的计算或格式化等方法 会定义到计算属性中</td>
</tr>
</tbody></table>
<h3 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h3><p><strong>插值表达式（两个大括号）</strong></p>
<p> 通常用来获取Vue实例中定义的数据(data) ，属性节点中 不能够使用插值表达式</p>
<p> <strong>v-text 指令</strong> </p>
<p>获取data数据, 设置标签的内容. </p>
<p>注意: 默认写法会替换全部内容,使用<strong>插值表达式</strong>(两个大括号)可以替换指定内容.</p>
<p> <strong>v-html 指令</strong> </p>
<p>设置元素的 innerHTML (可以向元素中写入新的标签)</p>
<p> <strong>v-on 指令</strong></p>
<p>为元素绑定事件, 比如: v-on:click,可以简写为 @click=”方法” </p>
<p>绑定的方法定义在 VUE实例的, method属性中,可通过  .  添加修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-on 绑定click 点击事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 @符号也可以绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 绑定键盘按下事件，添加了enter修饰符，表示按下enter键才会触发事件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单击事件，添加stop修饰符，阻止事件冒泡 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>v-show 指令</strong> </p>
<p>v-show指令, 根据真假值,切换元素的显示状态</p>
<p>原理是修改元素的display,实现显示或者隐藏 。表达式为 true 显示, 为false 则隐藏 数据改变之后,显示的状态会同步更新</p>
<p> <strong>v-if 指令</strong> </p>
<p> 根据表达式的真假切换元素的显示状态 </p>
<p>本质是通过操作dom元素,来切换显示状态  表达式为true 元素存在与dom树,为false从dom树中移除</p>
<p>频繁切换使用 v-show 指令 ,反之使用v-if 指令</p>
<p><strong>v-bind 指令</strong></p>
<p>为元素绑定属性 完整写法 v-bind:属性名，可以简写为 :属性名</p>
<p> <strong>v-for 指令</strong></p>
<p>根据数据生成列表结构 ，数组经常和 v-for结合使用</p>
<p>数组有两个常用方法: push() 向数组末尾添加一个或多个元素 ，shift() 把数组中的第一个元素删除</p>
<p> 语法是: (item,index) in 数据 item和index </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以结合其他指令一起使用 数组的长度变化,会同步更新到页面上,是响应式的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- p 为persons中的每一个元素，index为下标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) in persons&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;p.name&quot;</span>&gt;</span></span><br><span class="line">	&#123;&#123;p.index&#125;&#125; : &#123;&#123;p.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>v-mode 指令</strong></p>
<p>获取和设置表单元素的值(实现双向数据绑定)</p>
<ul>
<li>单向绑定: 就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动 更新。 </li>
<li>双向绑定: 用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。</li>
</ul>
<p><strong>v-cloak指令</strong></p>
<p>解决插值表达式闪烁问题，当网络比较慢时，Vue来不及渲染页面中的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在id为app的div（挂载点）中添加 v-cloak  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 添加样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 通过属性选择器,设置 添加了v-cloak */</span></span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h3><p> MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式. MVVM模式将页面,分层了 M 、V、和VM。 </p>
<p><strong>Model</strong>    负责数据存储</p>
<p><strong>View</strong>      负责页面展示 </p>
<p><strong>View Model</strong>    负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- View 视图部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建的vue实例,就是 VM ViewModel</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//data就是MVVM模式中的 model</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">&quot;hello&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/WGq3Bn"><img src="https://z3.ax1x.com/2021/07/19/WGq3Bn.jpg" alt="WGq3Bn.jpg"></a></p>
<p>我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关 键。 </p>
<ul>
<li>从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如 果有变化，则更改Model中的数据</li>
<li>从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的 DOM元素。</li>
</ul>
<h2 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter 过滤器"></a>filter 过滤器</h2><p>过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原 来的数据，只是在原数据的基础上产生新的数据。</p>
<h3 id="过滤器使用位置"><a href="#过滤器使用位置" class="headerlink" title="过滤器使用位置"></a>过滤器使用位置</h3><p><strong>双括号插值内</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg是需要处理的数据, filter是过滤器, | 这个竖线是管道,通过这个管道将数据传输给过滤器进行过滤 加工操作</span><br><span class="line">&#123;&#123; msg | filter &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>v-bind绑定的值的地方</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-bind:id&#x3D;&quot; msg | filter&quot;&gt; &#123;&#123; msg &#125;&#125; &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><p><strong>需求</strong>   给价格前面 添加一个符号¥</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;price | my&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">            data:&#123; <span class="attr">price</span>:<span class="number">199</span> &#125;,</span><br><span class="line">            <span class="comment">// 局部过滤器</span></span><br><span class="line">            filters:&#123;</span><br><span class="line">                my:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span> + value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body</span><br></pre></td></tr></table></figure>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p><strong>需求</strong>   将第一个单词转大写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name | my&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name | changeName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局过滤器  一定要在在创建Vue实例之前定义</span></span></span><br><span class="line"><span class="javascript">        Vue.filter(<span class="string">&quot;changeName&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            data:&#123;<span class="attr">name</span>:<span class="string">&quot;hui&quot;</span>&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h2><p>当一些数据需要随着其它数据变动而变动时，可以使用侦听属性</p>
<p><strong>需求</strong>: 监听姓与名变化,实时显示姓名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        姓 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        名 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;last_name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123;full_name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                first_name:<span class="string">&quot;&quot;</span>, </span></span><br><span class="line"><span class="javascript">                last_name:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                full_name:<span class="string">&quot;&quot;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 监听的值只能是data中的数据</span></span></span><br><span class="line">            watch:&#123;</span><br><span class="line"><span class="javascript">                first_name:<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.full_name = newVal +<span class="string">&quot; &quot;</span>+ <span class="built_in">this</span>.last_name</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                last_name:<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.full_name =  <span class="built_in">this</span>.first_name +<span class="string">&quot; &quot;</span>+ newVal</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="component-组件"><a href="#component-组件" class="headerlink" title="component 组件"></a>component 组件</h2><p>组件（Component）是自定义封装的功能。在前端开发过程中，经常出现多个网页的功能是重复 的，而且很多不同的页面之间，也存在同样的功能。 </p>
<p>我们将相同的功能进行抽取,封装为组件,这样，前端人员就可以在组件化开发时，只需要书写一次代 码，随处引入即可使用。 </p>
<p><strong>注意</strong></p>
<ul>
<li>组件名以小写开头，采用短横线分割命名: 例如 hello-Word </li>
<li>组件中的data 必须是一个函数,注意与Vue实例中的data区分 </li>
<li>在template模板中, 只能有一个根元素</li>
</ul>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用全局组件，可以使用多次 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;my-component&quot;</span>,&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            template:&quot;<span class="tag">&lt;<span class="name">h4</span> @<span class="attr">click</span>=<span class="string">&#x27;kk&#x27;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//组件中的data是一个函数</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    message:<span class="string">&quot;这是一个全局组件哦&quot;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 组件的相关的js方法，与vue写法相同</span></span></span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                kk:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.alert(<span class="string">&quot;hello kk&quot;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">		<span class="comment">// 创建vue实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 定义局部组件</span></span></span><br><span class="line">            components:&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&quot;my-component&quot;</span>:&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">                    template:&quot;<span class="tag">&lt;<span class="name">h5</span> &gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="xml">&lt;/h5&#125;&quot;,</span></span></span><br><span class="line"><span class="javascript">                    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;<span class="attr">message</span>:<span class="string">&quot;这是一个局部组件哦&quot;</span>&#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件与模板分离"><a href="#组件与模板分离" class="headerlink" title="组件与模板分离"></a>组件与模板分离</h3><p>把html语言写在组件里面很不方便，也不太好看所以将它们分开写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件模板，不会被页面加载显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hui&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            components:&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&quot;my-component&quot;</span>:&#123;</span></span><br><span class="line"><span class="javascript">                    template:<span class="string">&quot;#hui&quot;</span>,<span class="comment">// 通过id选择器找到对应html代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            message:<span class="string">&quot;吼吼吼吼&quot;</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h2><p>每个Vue实例在被创建之前都要经过一系列的初始化过程,这个过程就是vue的生命周期</p>
<p><a href="https://imgtu.com/i/WJSzN9"><img src="https://z3.ax1x.com/2021/07/19/WJSzN9.png" alt="WJSzN9.png" style="zoom: 50%;" /></a></p>
<p><strong>钩子函数</strong>  在一个事件触发的时候，在系统级捕获到了他，然后做一些操作</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate()</td>
<td>在创建Vue实例之前,可以执行这个方法. 例如 加载动画操作</td>
</tr>
<tr>
<td>created()</td>
<td>实例创建完成,属性绑定好了,但是DOM还没有生成.</td>
</tr>
<tr>
<td>beforeMount()</td>
<td>模板已经在内存中编辑完成了，尚未被渲染到页面中.</td>
</tr>
<tr>
<td>mounted()</td>
<td>内存中的模板已经渲染到页面，用户已经可以看见内容.</td>
</tr>
<tr>
<td>beforeUpdate()</td>
<td>数据更新的前一刻 , 组件在发生更新之前,调用的函数</td>
</tr>
<tr>
<td>updated()</td>
<td>updated执行时，内存中的数据已更新，并且页面已经被渲染</td>
</tr>
<tr>
<td>beforeDestroy ()</td>
<td>钩子函数在实例销毁之前调用</td>
</tr>
<tr>
<td>destroyed ()</td>
<td>钩子函数在Vue 实例销毁后调用</td>
</tr>
</tbody></table>
<h2 id="Vue-Router-路由"><a href="#Vue-Router-路由" class="headerlink" title="Vue Router 路由"></a>Vue Router 路由</h2><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>单页面Web应用（single page web application），就是只有一张Web页面的应用， 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序</p>
<p><strong>特点</strong></p>
<ul>
<li>用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。</li>
<li>适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲 染。</li>
</ul>
<h3 id="路由相关概念"><a href="#路由相关概念" class="headerlink" title="路由相关概念"></a>路由相关概念</h3><p><strong>router</strong> </p>
<p>​        是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用（SPA）变得易 如反掌 ,router 就相当于一个管理者，它来管理路由。 </p>
<p><strong>route</strong> </p>
<p>​        route相当于路由器, route就相当于一条路由.比如: Home按钮 =&gt; home内容， 这是一条route; news按钮 =&gt; news内容， 这是另一条路由。 </p>
<p><strong>routes</strong></p>
<p>​        一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}] </p>
<p><strong>router-link组件</strong> </p>
<p>​        router-link 是一个组件，是对 a 标签的一个封装. 该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容 </p>
<p><strong>router-view 组件</strong></p>
<p>​        路由导航到指定组件后,进行渲染显示页面。路由显示的出口。</p>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>1.Vue.js 路由需要载入 vue-router 库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1: 本地导入</span></span><br><span class="line">&lt;script src=<span class="string">&quot;vue-router.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">//方式2: CDN</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.定义路由所需的组件</p>
<p>3.创建router路由器实例 ,配置路由<strong>routes</strong>。每个路由都由两部分 <strong>path</strong> (路径) 和<strong>component</strong> (组件) </p>
<p>4.创建Vue实例, 注入路由对象, 使用$mount() 指定挂载点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择需要跳转的路由 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>to home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news&quot;</span>&gt;</span>to news<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 载入vue-router库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定义多个组件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> home = &#123;<span class="attr">template</span>:<span class="string">&quot;&lt;h2&gt;这是首页&lt;/h2&gt;&quot;</span>&#125;;  <span class="comment">// 首页</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> news = &#123;<span class="attr">template</span>:<span class="string">&quot;&lt;h2&gt;这是新闻页&lt;/h2&gt;&quot;</span>&#125;;  <span class="comment">// 新闻页</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建路由实例，并配置路由</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="javascript">                &#123;<span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>:home&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="attr">path</span>:<span class="string">&quot;/news&quot;</span>, <span class="attr">component</span>:news&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 创建vue实例，挂载路由</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">            router:router</span><br><span class="line"><span class="javascript">        &#125;).$mount(<span class="string">&quot;#app&quot;</span>) <span class="comment">// $mount是手动挂载，代替 el，两者没区别</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue cli是基于Vue的应用开发提供的一个标准的脚手架工具.为应用搭建基础的框架结构,提供插 件、开发服务、Preset、构建打包功能 </p>
<p>Vue cli 背后集成了现代化开发的诸多功能,通过简单的命令就可以完成 “零配置”的项目环境搭建</p>
<p><strong>安装 Vue-cli</strong></p>
<p>先确保安装了 node 与 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>安装完成后，输入 Vue -v  查看版本</p>
<h2 id="构建Vue项目"><a href="#构建Vue项目" class="headerlink" title="构建Vue项目"></a>构建Vue项目</h2><p>1.打开cmd命令行，切换到对应的文件夹，输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create 项目名</span><br></pre></td></tr></table></figure>
<p>2.会出现相应的选项，配置完后，开始下载Vue项目</p>
<p>3.进入项目目录，输入  <strong>npm run serve</strong> 启动项目</p>
<p>4.访问项目    <a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p><strong>项目结构介绍</strong></p>
<p><a href="https://imgtu.com/i/WJZBWD"><img src="https://z3.ax1x.com/2021/07/19/WJZBWD.jpg" alt="WJZBWD.jpg" style="zoom:50%;" /></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-project 项目名称</span><br><span class="line">    node_modules 存放依赖包的目录</span><br><span class="line">    public 静态资源管理目录</span><br><span class="line">    src 组件源码目录(我们写的代码)</span><br><span class="line">        assets 存放静态图片资源(CSS也可以放在这里)</span><br><span class="line">        components 存放各种组件(一个页面可以看做一个组件)，各个组件联系在一起组成一个</span><br><span class="line">        完整的项目</span><br><span class="line">        router 存放了项目路由文件</span><br><span class="line">        views 放置的为公共组件(主要还是各个主要页面)</span><br><span class="line">        App.vue 网站首页，是一个vue项目的主组件，页面入口文件</span><br><span class="line">    	main.js 打包运行的入口文件，引入了vue模块和app.vue组件以及路由route</span><br><span class="line">    abel.config.js babel配置文件, 对源代码进行转码(把es6&#x3D;&gt;es5)</span><br><span class="line">    package.json 项目及工具的依赖配置文件</span><br><span class="line">    paxkage-lock.json 依赖配置文件</span><br><span class="line">    README.md 项目说明</span><br></pre></td></tr></table></figure>
<p><strong>package.js 配置文件</strong></p>
<p> package.json 文件定义了这个项目所需要的各种模 块，以及项目的配置信息（比如名称、版本、许可证等元数据）。 npm install 命令根据这个配置文 件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.项目基本信息</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;project3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//2.指定运行脚本命令</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//4.生产环境所依赖模块的版本</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^3.6.5&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.11&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//5.本地环境开发所依赖的版本</span></span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-babel&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-router&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-service&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.6.11&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在最末端添加如下配置: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;vue&quot;:&#123;</span><br><span class="line">    &quot;devServer&quot;:&#123;</span><br><span class="line">        &quot;port&quot;:&quot;8888&quot;, // 访问端口</span><br><span class="line">        &quot;open&quot;:true   //  打包完成自动打开浏览器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>单独的配置文件配置项目</strong></p>
<p>在项目的根目录创建 vue.config.js 文件 ，在该文件进行相关配置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        open:true</span><br><span class="line">        port:8889</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-组件化开发"><a href="#Vue-组件化开发" class="headerlink" title="Vue 组件化开发"></a>Vue 组件化开发</h2><p>组件化是Vue的精髓，Vue项目就是由一个一个的组件构成的。 </p>
<p>我们主要的工作就是开发的组件,每一个*.vue 文件都是一个组件 。</p>
<p><strong>组件分类</strong></p>
<ul>
<li>页面级别的组件 <ul>
<li>页面级别的组件，通常是 views 目录下的.vue组件，是组成整个项目的各个主要</li>
</ul>
</li>
<li>业务上可复用的基础组件<ul>
<li>这一类组件通常是在业务中被各个页面复用的组件，这一类组件通常都写到 components 目 录下，然后通过import在各个页面中使用</li>
</ul>
</li>
</ul>
<p><strong>组件的组成部分</strong></p>
<ul>
<li>template : 组件的HTML部分 </li>
<li>script: 组件的JS脚本 (使用ES6语法编写) </li>
<li>style: 组件的CSS样式</li>
</ul>
<p><strong>组件的使用</strong></p>
<p>创建 Hui.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div &gt;&#123;&#123;msg&#125;&#125;&#x3D;&#x3D;&#123;&#123;flag&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;JS 部分</span><br><span class="line">    export default &#123;</span><br><span class="line">        name:&quot;Hui&quot;, &#x2F;&#x2F;组件的名称</span><br><span class="line">        props:[&#39;flag&#39;], &#x2F;&#x2F; 组件中的属性, 表示组件可以接受参数</span><br><span class="line">        data() &#123; &#x2F;&#x2F;data函数</span><br><span class="line">            return &#123;</span><br><span class="line">                msg:&quot;这是一个hui组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>在别的页面中引入 hui 组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Hui flag&#x3D;&quot;吼吼吼吼&quot;&gt;&lt;&#x2F;Hui&gt; &lt;!--使用Hui组件，给fag属性传递参数--&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 引入 Hui.vue 文件</span><br><span class="line">    import Hui from &#39;@&#x2F;components&#x2F;Hui.vue&#39;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;Home&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            Hui  &#x2F;&#x2F; 注册组件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="项目运行流程"><a href="#项目运行流程" class="headerlink" title="项目运行流程"></a>项目运行流程</h2><p><strong>首先载入口文件 main.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//关闭启动提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">//创建Vue实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router, <span class="comment">//为整个项目添加路由</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//这是一个函数ES6语法,作用是生成模板: App = App.vue</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">//挂载的是App.vue组件中的id为app的区域</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>App.vue</strong></p>
<p>页面入口文件 ，所有页面都是在App.vue下进行切换的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App.vue 中的模板(HTML代码)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt; 挂载的是这个div</span><br><span class="line">    &lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">        这里是两个路由导航链接</span><br><span class="line">        1. to&#x3D;&quot;&#x2F;&quot; 项目根路径 跳转的是首页</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt; |</span><br><span class="line">        2. to&#x3D;&quot;&#x2F;about&quot; 点击About按钮,跳转到about组件</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    router-view 的作用是 根据访问的路径,渲染路径匹配到的视图组件</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>router 路由</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入所需文件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">//vue库</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span> <span class="comment">//vue-router库</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span> <span class="comment">//首页</span></span><br><span class="line"><span class="comment">//使用路由功能</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">//创建路由规则</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>, <span class="comment">//路径</span></span><br><span class="line">        name: <span class="string">&#x27;Home&#x27;</span>, <span class="comment">//名称</span></span><br><span class="line">        component: Home <span class="comment">//组件 Home.vue</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">        component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span></span><br><span class="line">            <span class="string">&#x27;../views/About.vue&#x27;</span>) <span class="comment">// 动态导入About.vue组件</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//创建路由管理器,管理routes</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//export 用来导出模块 router就代表了整个路由文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p> <strong>npm安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
<p><strong>打开 main.js , 导入Element-UI 相关资源</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入组件库</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">//导入组件相关样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"><span class="comment">//配置Vue插件 将El安装到Vue上</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p><strong>npm安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure>
<p><strong>在main.js文件中导入axios 相关资源</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">//Vue对象使用axios</span></span><br><span class="line">Vue.prototype.axios = axios;</span><br></pre></td></tr></table></figure>


<h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><p><strong>修改配置文件</strong></p>
<ul>
<li><p>.env.development     开发环境的配置文件</p>
</li>
<li><p>.env.production    生产环境的配置文件</p>
</li>
</ul>
<p>修改生产环境的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 后端项目的路径</span><br><span class="line">VUE_APP_API_BASE &#x3D; http:&#x2F;&#x2F;192.168.52.100:8080&#x2F;lagou_edu_home</span><br></pre></td></tr></table></figure>
<p><strong>修改 vue.config.js 配置文件</strong></p>
<p>直接复制即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// relative path for dev</span></span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;/edu-boss/&quot;</span> : <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="comment">// for gh-pages</span></span><br><span class="line">    indexPath: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    lintOnSave: process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    css: &#123;</span><br><span class="line">        <span class="comment">// sourceMap: process.env.NODE_ENV !== &#x27;production&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8081</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>前端项目打包</strong></p>
<p>执行  <strong>npm run build</strong>   命令经行打包</p>
<p>生产 dist 目录，dist文件就是vue项目的线上发布文件</p>
<p><strong>运行tomcat</strong></p>
<p>将 dist 文件放入tomcat中的webapps目录下。</p>
<p>开启tomcat服务器，可通过 <a href="http://localhost:8080/dist/">http://localhost:8080/dist/</a>  访问到Vue项目</p>
<p>不过一般建议把dist名称改一下，并且tomcat的端口号改一改，避免与后端项目起冲突。</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2021/07/24/mybatis/</url>
    <content><![CDATA[<p>​        MyBatis是一个优秀的基于ORM的半自动轻量级持久层框架，它对jdbc的操作数据库的过程进行封装， 使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建 statement、手动设置参数、结果集检索等jdbc繁杂的过程代码<a id="more"></a></p>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移 到了google code，随着开发团队转投到Google Code旗下，iBatis正式改名为MyBatis ，代码于2013 年11月迁移到Github </p>
<p><strong>Github地址</strong>：<a href="https://github.com/mybatis/mybatis-3/">https://github.com/mybatis/mybatis-3/</a></p>
<p> <strong>ORM（Object Relational Mapping）对象关系映射</strong></p>
<ul>
<li>O（对象模型）： 实体对象，即我们在程序中根据数据库表结构建立的一个个实体javaBean </li>
<li>R（关系型数据库的数据结构）： 关系数据库领域的Relational（建立的数据库表） </li>
<li>M（映射）： 从R（数据库）到O（对象模型）的映射，可通过XML文件映射</li>
</ul>
<p>ORM作为是一种思想 帮助我们跟踪实体的变化,并将实体的变化翻译成sql脚本,执行到数据库中去,也就是将实体的变化映射到 了表的变化。 mybatis采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问 细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作 。</p>
<h1 id="Mybatis基本使用"><a href="#Mybatis基本使用" class="headerlink" title="Mybatis基本使用"></a>Mybatis基本使用</h1><p>MyBatis官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p>
<p><strong>需求</strong>   通过mybatis查询数据库user表的所有记录，封装到User对象中，打印到控制台上</p>
<ol>
<li><p>创建数据库及user表</p>
</li>
<li><p>创建maven工程，导入依赖（MySQL驱动、mybatis、junit）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建User实体类</p>
</li>
<li><p>编写UserMapper.xml映射配置文件（ORM思想）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace与id 是唯一表示，可通过这两个元素获取sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有，resultType为返回的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hui.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写SqlMapConfig.xml核心配置文件 </p>
<p>​    数据库环境配置 </p>
<p>​    映射关系配置的引入(引入映射配置文件的路径)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用MySQL环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用JDBC类型事务管理器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis_db&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载映射配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.加载核心配置文件</span></span><br><span class="line">    <span class="comment">// Resources.class.getClassLoader().getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span></span><br><span class="line">    InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.获取sqlSessionFactory工厂对象</span></span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(stream);</span><br><span class="line">    <span class="comment">// 3.获取sqlSession会话对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 4.执行sql，传递的参数是xml映射中namespace与id组成的唯一标识</span></span><br><span class="line">    List&lt;User&gt; userList = session.selectList(<span class="string">&quot;userMapper.selectUser&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增删改操作分别使用 <strong>insert</strong> 、<strong>delete</strong>、<strong>update</strong> 标签与方法</p>
</li>
</ol>
<p>如果要传递参数，xml映射需使用 <strong>parameterType</strong>属性指定要插入的数据类型</p>
<p>Sql语句中使用 <strong>#{xxx}</strong> 方式引用实体中的属性值</p>
<p>另外，增删改操作要使用sqlSession对象提交事务，即 sqlSession.commit()</p>
<p><strong>log4j的使用</strong></p>
<ul>
<li>1)导入配置依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   log4j日志     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2)导入配置文件  log4j.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### direct messages to file mylog.log ###</span></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">c:/mylog.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### set log levels - for more verbose logging change &#x27;info&#x27; to &#x27;debug&#x27; ###</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout</span></span><br></pre></td></tr></table></figure>
<h1 id="Mybatis核心配置文件"><a href="#Mybatis核心配置文件" class="headerlink" title="Mybatis核心配置文件"></a>Mybatis核心配置文件</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p>
<p> 配置文档的顶层结构如下：</p>
<ul>
<li>configuration（配置）<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<h2 id="MyBatis常用配置解析"><a href="#MyBatis常用配置解析" class="headerlink" title="MyBatis常用配置解析"></a>MyBatis常用配置解析</h2><h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><p><a href="https://imgtu.com/i/WcRs54"><img src="https://z3.ax1x.com/2021/07/24/WcRs54.png" alt="WcRs54.png"></a></p>
<p><strong>transactionManager</strong>(事务管理器) , 类型有两种</p>
<p>​        JDBC： 这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 </p>
<p>​        MANAGED： 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。 例如：mybatis与spring整合后，事务交给spring容器管理。</p>
<p><strong>dataSource</strong> (数据源) ，类型有三种</p>
<p>​        POOLED： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>​        UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 </p>
<p>​        JNDI : 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据 源，然后放置一个 JNDI 上下文的数据源引用</p>
<h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的 properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///mybatis_db</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在mybatis核心配置文件中可以这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><p>为 Java 类型设置一个短的名字。为了简化映射文件 Java 类型设置，mybatis框架为我们设置好的一些常用的类型的别名：string 、long 、int 、double、boolean …</p>
<p>以查询为例，原来的类型名称配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询所有，resultType为返回的类型，需要填写全限定名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hui.domain.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用typeAliases标签起别名:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  起别名typeAlias单个起别名，package给包起别名,该包下的所有实体类不区分大小写  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.hui.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 使用相对于类路径的资源引用，例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">2. 使用完全限定资源定位符（URL），例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">《下面两种mapper代理开发中使用》</span><br><span class="line">3. 使用映射器接口实现类的完全限定类名，例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.userMapper&quot;</span>/&gt;</span></span><br><span class="line">4. 将包内的映射器接口实现全部注册为映射器，例如：(常用)</span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><p>配置各种设置，如  支持驼峰命名、延迟加载设置、缓存设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  数据库字段转驼峰命名法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>settings</strong> 与 <strong>plugins</strong> 在后面还会了解到</p>
<h1 id="Mybatis的基本API"><a href="#Mybatis的基本API" class="headerlink" title="Mybatis的基本API"></a>Mybatis的基本API</h1><p><strong>SqlSessionFactoryBuilder</strong></p>
<p>SqlSession工厂构建器，通过加载mybatis的配置文件的输入流，构建一个SqlSessionFactory对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resources工具类只是加载资源文件,在org.apache.ibatis.io 包中</span></span><br><span class="line">InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xmo&quot;</span>);</span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(stream);</span><br></pre></td></tr></table></figure>
<p><strong>SqlSessionFactory</strong></p>
<p> SqlSession工厂对象，用来构建SqlSession实例。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SqlSession openSession()</td>
<td>会默认开启一个事务，但事务不会自动提交。</td>
</tr>
<tr>
<td>SqlSession openSession(boolean autoCommit)</td>
<td>参数为true表示事务自动提交</td>
</tr>
</tbody></table>
<p> <strong>SqlSession会话对象</strong></p>
<p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务 和获取映射器实例的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 执行sql语句主要方法</span><br><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> T selectOne(String statement, Object parameter)</span><br><span class="line"><span class="tag">&lt;<span class="name">E</span>&gt;</span> List<span class="tag">&lt;<span class="name">E</span>&gt;</span> selectList(String statement, Object parameter)</span><br><span class="line">int insert(String statement, Object parameter)</span><br><span class="line">int update(String statement, Object parameter)</span><br><span class="line">int delete(String statement, Object parameter)</span><br><span class="line">// 事务相关方法</span><br><span class="line">void commit()</span><br><span class="line">void rollback()</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong></p>
<p><a href="https://imgtu.com/i/Wc4ZeP"><img src="https://z3.ax1x.com/2021/07/24/Wc4ZeP.png" alt="Wc4ZeP.png"></a></p>
<h1 id="代理开发模式"><a href="#代理开发模式" class="headerlink" title="代理开发模式"></a>代理开发模式</h1><p><strong>传统开发方式</strong></p>
<p>编写UserMapper接口=》编写UserMapper实现类=》编写UserMapper.xml映射文件</p>
<p><strong>缺点</strong></p>
<p>​        实现类中，存在mybatis模板代码重复；</p>
<p>​        实现类调用方法时，xml中的sql statement (namespace+id) 硬编码到java代码中</p>
<p><strong>代理开发模式介绍</strong></p>
<p>采用 Mybatis 的基于接口代理方式实现 持久层 的开发，这种方式是我们后面进入企业的主流。 基于接口代理方式的开发只需要程序员编写 Mapper 接口Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p><strong>这种模式需要遵循一定规范</strong></p>
<ul>
<li>Mapper.xml映射文件中的namespace与mapper接口的全限定名相同 </li>
<li>Mapper接口方法名和Mapper.xml映射文件中定义的每个statement的id相同 </li>
<li>Mapper接口方法的输入参数类型和mapper.xml映射文件中定义的每个sql的parameterType的类 型相同 </li>
<li>Mapper接口方法的输出参数类型和mapper.xml映射文件中定义的每个sql的resultType的类型相 同</li>
</ul>
<p><a href="https://imgtu.com/i/Wc5YjA"><img src="https://z3.ax1x.com/2021/07/24/Wc5YjA.png" alt="Wc5YjA.png"></a></p>
<ol>
<li><p>编写UserMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载核心配置文件</span></span><br><span class="line">    InputStream is = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得SqlSessionFactory工厂对象</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span></span><br><span class="line">        SqlSessionFactoryBuilder().build(is);</span><br><span class="line">    <span class="comment">// 获得SqlSession会话对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 获得Mapper代理对象</span></span><br><span class="line">    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    List&lt;User&gt; list = userMapper.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h1></li>
</ol>
<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p><strong>需求</strong>   根据id和username查询user表</p>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>使用 #{arg0}-#{argn} 或者 #{param1}-#{paramn} 获取参数</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(Integer id, String username)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;arg0&#125; and username = #&#123;arg1&#125;</span><br><span class="line">    <span class="comment">&lt;!-- select * from user where id=#&#123;param1&#125; and username = #&#123;param2&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：多个参数就不需要填写 parameterType </p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用注解，引入 @Param() 注解获取参数，#{} 中填写的值要与@Param中的值一样</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id, <span class="meta">@Param(&quot;username&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    select  * from user where id=#&#123;id&#125; and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用pojo对象传递参数</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName3&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select  * from user where id=#&#123;id&#125; and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="与-区别"><a href="#与-区别" class="headerlink" title="${} 与 #{} 区别"></a>${} 与 #{} 区别</h3><p><strong>#{} :表示一个占位符号，连接sql时不需要手动加引号</strong></p>
<ul>
<li>通过 #{} 可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，# {}可以有效防止sql注入。</li>
<li>如果parameterType传输单个简单类型值， #{} 括号中名称随便写。</li>
</ul>
<p><strong>${} :表示拼接sql串，连接sql时需要手动加引号</strong></p>
<ul>
<li>通过 ${} 可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，会出现sql注入 问题。</li>
<li>如果parameterType传输单个简单类型值， ${} 括号中只能是value。</li>
</ul>
<h2 id="返回主键"><a href="#返回主键" class="headerlink" title="返回主键"></a>返回主键</h2><p>向数据库插入一条记录后，希望能立即拿到这条记录在数据库中的主键值。</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="方法一-useGeneratedKeys"><a href="#方法一-useGeneratedKeys" class="headerlink" title="方法一:useGeneratedKeys"></a>方法一:useGeneratedKeys</h3><p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>useGeneratedKeys=”true”    声明返回主键 </p>
<p>keyProperty=”id”   把返回主键的值，封装到实体的id属性中</p>
<p><strong>注意</strong>  只适用于主键自增的数据库，mysql和sqlserver支持，oracle不行。</p>
<h3 id="方法二-selectKey"><a href="#方法二-selectKey" class="headerlink" title="方法二:selectKey"></a>方法二:selectKey</h3><p>selectKey 适用范围广，支持所有类型数据库</p>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>keyColumn=”id” 指定主键列名 </p>
<p>keyProperty=”id” 指定主键封装到实体的id属性中 </p>
<p>resultType=”int” 指定主键类型 </p>
<p>order=”AFTER” 设置在sql语句执行前（后），执行此语句,也可以写 “BEFORE” 值</p>
<p> SELECT LAST_INSERT_ID()  该sql语句表示查询最后插入的主键id</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 代理对象</span></span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">&quot;oddDog&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;男&quot;</span>, <span class="string">&quot;土耳其&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;插入前&quot;</span>+user);</span><br><span class="line">mapper.insertUser2(user);</span><br><span class="line">System.out.println(<span class="string">&quot;插入后&quot;</span>+user);</span><br></pre></td></tr></table></figure>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>当我们要根据不同的条件，来执行不同的sql语句的时候，需要用到动态sql</p>
<h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p><strong>查询时与Where搭配</strong></p>
<p>where标签相当于 where 1=1，但是如果没有条件，就不会拼接where关键字</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            and username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改时与set搭配</strong></p>
<p>set标签在更新的时候，自动加上set关键字，然后去掉最后一个条件的逗号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday!=null&quot;</span>&gt;</span></span><br><span class="line">            birthday = #&#123;birthday&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!=null&quot;</span>&gt;</span></span><br><span class="line">            sex = #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address!=null&quot;</span>&gt;</span></span><br><span class="line">            address = #&#123;address&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>用来循环遍历，属性介绍：</p>
<ul>
<li>collection：代表要遍历的集合元素 </li>
<li>open：代表语句的开始部分 </li>
<li>close：代表结束部分 </li>
<li>item：代表遍历集合的每个元素，生成的变量名 </li>
<li>sperator：代表分隔符</li>
</ul>
<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getByIds</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<p>collection属性值为：collection 或者 list</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;collection&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getByIds</span><span class="params">(<span class="keyword">int</span>[] ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<p>collection属性值为：array</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByIds2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他地方引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p><strong>plugins标签</strong> </p>
<p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封 装，使用简单的方式即可获得分页的相关数据</p>
<p><strong>①导入通用PageHelper的坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>②在mybatis核心配置文件中配置PageHelper插件</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>③测试分页数据获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(stream);</span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 获取 代理对象</span></span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 设置分页</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行分页查询</span></span><br><span class="line">    List&lt;User&gt; userList = mapper.getAllUser();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取分页相关信息，</span></span><br><span class="line">    PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo(userList);</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示长度：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否最后一页：&quot;</span>+pageInfo.isIsLastPage());</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><strong>ResutlMap属性 : 建立对象关系映射</strong></p>
<ul>
<li>resultType 如果实体的属性名与表中字段名一致，将查询结果自动封装到实体类中 </li>
<li> ResutlMap 如果实体的属性名与表中字段名不一致，可以使用ResutlMap实现手动封装到实体类中</li>
</ul>
<p><strong>实现手动映射封装</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一般把多对一看成是一对一。</p>
<p><strong>需求</strong>   查询所有订单，与此同时查询出每个订单所属的用户</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders o <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">USER</span> u <span class="keyword">ON</span> o.uid <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure>
<p><strong>Order实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> User user; <span class="comment">// 添加字段，表示当前订单属于哪个用户</span></span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  多表查询:一对一  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ordersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property=&quot;user&quot; 封装实体的属性名</span></span><br><span class="line"><span class="comment">            javaType=&quot;user&quot; 封装实体的属性类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersWithUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ordersMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM orders o</span><br><span class="line">    LEFT JOIN USER u ON o.uid = u.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>  查询所有用户，与此同时查询出该用户具有的订单</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, o.id <span class="keyword">AS</span> oid, o.ordertime, o.total</span><br><span class="line">        <span class="keyword">FROM</span> <span class="keyword">USER</span> u</span><br><span class="line">                 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> u.id <span class="operator">=</span> o.uid</span><br></pre></td></tr></table></figure>
<p><strong>User实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Orders&gt; ordersList;<span class="comment">// 添加字段，表示当前用户的所有订单</span></span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多表查询 : 一对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                property=&quot;ordersList&quot; 封装到集合的属性名</span></span><br><span class="line"><span class="comment">                ofType=&quot;order&quot; 封装集合的泛型类型</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;ordersList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*, o.id AS oid, o.ordertime, o.total</span><br><span class="line">    FROM USER u</span><br><span class="line">    LEFT JOIN orders o ON u.id = o.uid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用。在任一一方其实都可以看成是一对多。多对多一般有一张中间表，如:</p>
<p><a href="https://imgtu.com/i/WgZHb9"><img src="https://z3.ax1x.com/2021/07/25/WgZHb9.png" alt="WgZHb9.png"></a></p>
<p><strong>需求</strong>    查询所有用户同时查询出该用户的所有角色</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, r.id <span class="keyword">AS</span> rid, r.rolename, r.roleDesc</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">USER</span> u</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys_user_role ur <span class="keyword">ON</span> u.id <span class="operator">=</span> ur.userid</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys_role r <span class="keyword">ON</span> ur.roleid <span class="operator">=</span> r.id</span><br></pre></td></tr></table></figure>
<p><strong>Order实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Role&gt; roleList;<span class="comment">// 添加字段，表示当前用户的所有角色信息</span></span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  多表查询 : 多对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_role_map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;rid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;rolename&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_role_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*, r.id AS rid, r.rolename, r.roleDesc</span><br><span class="line">    FROM USER u</span><br><span class="line">    LEFT JOIN sys_user_role ur ON u.id = ur.userid</span><br><span class="line">    LEFT JOIN sys_role r ON ur.roleid = r.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<ul>
<li>多对一（一对一）配置：使用resultMap+association做配置 </li>
<li>一对多配置：使用resultMap+collection做配置 </li>
<li>多对多配置：使用resultMap+collection做配置 </li>
<li>多对多的配置跟一对多很相似，难度在于SQL语句的编写。</li>
</ul>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>嵌套查询就是将原来多表查询中的联合查询语句拆成单个表的查询，再使用mybatis的语法嵌套在一 起。</p>
<h3 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h3><p><strong>需求</strong>   查询一个订单，与此同时查询出该订单所属的用户</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询订单</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- 再根据订单uid外键，查询用户</span></span><br><span class="line">SELECT * FROM `user` WHERE id = #&#123;订单的uid&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  嵌套查询:一对一  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderWithUser&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			根据订单中uid外键，查询用户表</span></span><br><span class="line"><span class="comment">			select:	调用 namespace+id 处sql</span></span><br><span class="line"><span class="comment">			column: 将当前查询结果的某个值传递给 select 处的sql</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.hui.entity.User&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.UserMapper.getUserById&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersWithUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderWithUser&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM orders</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过id查询</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  通过id查询  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> &gt;</span> </span><br><span class="line">    SELECT * FROM USER WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>   查询所有用户，与此同时查询出该用户具有的订单</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">-- 再根据用户id主键，查询订单列表</span></span><br><span class="line">SELECT * FROM orders where uid = #&#123;用户id&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   嵌套查询 : 一对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_order_map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据用户id，查询订单表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;ordersList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.OrderMapper.getOrdersByUid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_order_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据uid查询</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersByUid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  根据uid查询  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersByUid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM orders WHERE uid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h3><p><strong>需求</strong>  查询用户 同时查询出该用户的所有角色</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">-- 再根据用户id主键，查询角色列表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> role r <span class="keyword">INNER</span> <span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> r.`id` <span class="operator">=</span> ur.`rid`</span><br><span class="line">WHERE ur.`uid` = #&#123;用户id&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  嵌套查询 : 多对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_role_map2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据用户id，查询角色列表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Role&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.RoleMapper.getRoleByUserid&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_role_map2&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户id获取角色信息</span></span><br><span class="line"><span class="function">List&lt;Role&gt; <span class="title">getRoleByUserid</span><span class="params">(<span class="keyword">int</span> userid)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRoleByUserid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM sys_role r INNER JOIN sys_user_role ur ON r.id = ur.roleid WHERE ur.userid = #&#123;userid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<ul>
<li>一对一配置：使用resultMap+association做配置，通过column条件，执行select查询</li>
<li>一对多配置：使用resultMap+collection做配置，通过column条件，执行select查询 </li>
<li>多对多配置：使用resultMap+collection做配置，通过column条件，执行select查询 </li>
</ul>
<p><strong>优点</strong>：简化多表查询操作</p>
<p><strong>缺点</strong>：执行多次sql语句，浪费数据库性能</p>
<h1 id="加载策略"><a href="#加载策略" class="headerlink" title="加载策略"></a>加载策略</h1><p><strong>延迟加载</strong>   在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。</p>
<p><strong>优点</strong>  先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表 速度要快。 </p>
<p><strong>缺点</strong>   因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时 间，所以可能造成用户等待时间变长，造成用户体验下降。</p>
<p> 一对多，多对多：通常情况下采用延迟加载 </p>
<p>一对一（多对一）：通常情况下采用立即加载 </p>
<p><strong>注意</strong>      延迟加载是基于嵌套查询来实现的</p>
<h2 id="局部延迟加载"><a href="#局部延迟加载" class="headerlink" title="局部延迟加载"></a>局部延迟加载</h2><p>在association和collection标签中都有一个fetchType属性，通过修改它的值，可以修改局部的加载策 略。例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	fetchType</span></span><br><span class="line"><span class="comment">		lazy : 延迟加载(懒加载)</span></span><br><span class="line"><span class="comment">		eager: 立即加载</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;com.lagou.dao.OrderMapper.findByUid&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局延迟加载"><a href="#全局延迟加载" class="headerlink" title="全局延迟加载"></a>全局延迟加载</h2><p>在Mybatis的核心配置文件中可以使用setting标签修改全局的加载策略。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>局部的加载策略优先级高于全局的加载策略</p>
<h2 id="设置触发延迟加载的方法"><a href="#设置触发延迟加载的方法" class="headerlink" title="设置触发延迟加载的方法"></a>设置触发延迟加载的方法</h2><p>调用当前对象的 equals、clone、hashCode、toString方法时也会触发关联对象的查询。可以在配置文件中使用lazyLoadTriggerMethods配置项覆盖掉上面四个方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有方法都会延迟加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;toString()&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数， 从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是SqlSession级别的缓存，是默认开启的。</p>
<p>参数和Sql语句完全一样的情况下，使用SelSession第一次查询后，MyBatis会将其放在缓存中，之后再次查询时，如果缓存没有刷新且没有超时，SqlSession会取缓存中的数据，而不是查询数据库。</p>
<p>可以通过log4j打印日志查看sql语句是否执行了。</p>
<p><strong>刷新缓存</strong></p>
<p>一级缓存是SqlSession范围的缓存，执行SqlSession的C（增加）U（更新）D（删除）操作，或者调 用clearCache()、commit()、close()方法，都会清空缓存。</p>
<p><strong>关闭一级缓存</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 每次查询时，都会清除缓存 --&gt;</span></span><br><span class="line">&lt; select flushCache=&quot;true&quot;&gt;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>   单条语句关闭以及缓存</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存是namspace级别（跨sqlSession）的缓存，是默认不开启的 二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的</p>
<ul>
<li>配置核心配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。</span></span><br><span class="line"><span class="comment">        为true代表开启二级缓存；为false代表不开启二级缓存。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--当前映射文件开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		useCache=”true”代表当前这个statement要使用二级缓存.</span></span><br><span class="line"><span class="comment">		如果不用就设置成 useCache=”false”</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>刷新缓存</strong></p>
<ul>
<li><p>只有SqlSession对象调用close()或commit()方法后，一级缓存中的数据会刷新到二级缓存中</p>
</li>
<li><p>映射语句文件中的所有select语句将会被缓存。  </p>
</li>
<li><p>映射语句文件中的所有insert、update和delete语句会刷新缓存。</p>
</li>
</ul>
<p><strong>注意问题（脏读）</strong> </p>
<p>mybatis的二级缓存因为是namespace级别，所以在进行多表查询时会产生脏读问题。</p>
<p><strong>小结</strong></p>
<ul>
<li> mybatis的缓存，都不需要我们手动存储和获取数据。mybatis自动维护的</li>
<li>mybatis开启了二级缓存后，那么查询顺序：二级缓存–》一级缓存–》数据库</li>
<li>mybatis的二级缓存会存在脏读问题，需要使用第三方的缓存技术解决问题。如  redis</li>
</ul>
<h1 id="Mybatis注解"><a href="#Mybatis注解" class="headerlink" title="Mybatis注解"></a>Mybatis注解</h1><p>Mybatis也可以使用注解开发方式，这样我们就可以减少编写 Mapper映射文件了。</p>
<p>只需要把代码写到Mapper接口中</p>
<h2 id="简单CRUD操作"><a href="#简单CRUD操作" class="headerlink" title="简单CRUD操作"></a>简单CRUD操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;insert into user (username,birthday,sex,address)values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用注解实现复杂映射开发"><a href="#使用注解实现复杂映射开发" class="headerlink" title="使用注解实现复杂映射开发"></a>使用注解实现复杂映射开发</h2><ul>
<li><p>@Results：可以与@Result 一起使用，封装多个结果集，代替了 resultMap</p>
</li>
<li><p>@Result：实现结果集封装，代替了   result  与  id</p>
</li>
<li><p>@One：实现一对一结果集封装，代替了   association</p>
</li>
<li><p>@Many：实现一对多结果集封装，代替了  collection</p>
</li>
</ul>
<h3 id="一对一（多对一）"><a href="#一对一（多对一）" class="headerlink" title="一对一（多对一）"></a>一对一（多对一）</h3><p><strong>需求</strong>     查询订单数据，并 将对应的用户信息查询出来</p>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    注解:一对一</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from orders&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id = true, property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;ordertime&quot;, column = &quot;ordertime&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;total&quot;, column = &quot;total&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;uid&quot;, column = &quot;uid&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.hui.mapper.UserMapper.getUserById&quot;, fetchType = FetchType.EAGER)),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="一对多-2"><a href="#一对多-2" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>  查询用户数据，并将对应的订单数据查询出来</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解:一对多</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id = true,property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;username&quot;,column = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;birthday&quot;,column = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;sex&quot;,column = &quot;sex&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;address&quot;,column = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;ordersList&quot;,javaType = List.class,column = &quot;id&quot;,many = @Many(select = &quot;com.hui.mapper.OrderMapper.getOrderByUserid&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    根据userid查询</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from orders where uid = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrderByUserid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="多对多-2"><a href="#多对多-2" class="headerlink" title="多对多"></a>多对多</h3><p><strong>需求</strong>  查询用户时，将用户对应的角色信息查询出来</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解: 多对多</span></span><br><span class="line"><span class="meta">@Select(value=&quot;select * from user&quot; )</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id=true,property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;username&quot;,column = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;birthday&quot;,column = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;sex&quot;,column = &quot;sex&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;address&quot;,column = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;roleList&quot;,javaType = List.class,column = &quot;id&quot;,many = @Many(select = &quot;com.hui.mapper.RoleMapper.getRoleByUserid&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据userid获取角色信息</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM sys_role r INNER JOIN sys_user_role ur ON r.id = ur.roleid WHERE userid = #&#123;userid&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Role&gt; <span class="title">getRoleByUserid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="注解的二级缓存"><a href="#注解的二级缓存" class="headerlink" title="注解的二级缓存"></a>注解的二级缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Mapper接口中使用注解配置二级缓存</span></span><br><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解的延迟加载"><a href="#注解的延迟加载" class="headerlink" title="注解的延迟加载"></a>注解的延迟加载</h3><p>在 @One 与 @Many 注解中有 fetchType属性</p>
<ul>
<li><p>fetchType = FetchType.LAZY   表示懒加载</p>
</li>
<li><p>fetchType = FetchType.EAGER   表示立即加载 </p>
</li>
<li><p>fetchType = FetchType.DEFAULT  表示使用全局配置</p>
</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。 </li>
<li>从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。</li>
</ul>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2021/07/27/spring/</url>
    <content><![CDATA[<p>Spring是分层的 Java SE/EE应用  full-stack(全栈式) 轻量级开源框架。 提供了表现层 SpringMVC和持久层 Spring JDBC Template以及 业务层 事务管理等众多的企业级应用 技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框 架。<a id="more"></a> </p>
<p><strong>两大核心</strong>      IOC（Inverse Of Control：控制反转）     AOP（Aspect Oriented Programming：面向 切面编程）   </p>
<p><strong>spring优势</strong></p>
<p>1）方便解耦，简化开发 </p>
<p>​        Spring就是一个容器，可以将所有对象创建和关系维护交给Spring管理 什么是耦合度？对象之间的关系，通常说当一个模块(对象)更改时也需要更改其他模块(对象)，这就是 耦合，耦合度过高会使代码的维护成本增加。要尽量解耦 </p>
<p>2）AOP编程的支持 </p>
<p>​        Spring提供面向切面编程，方便实现程序进行权限拦截，运行监控等功能。 </p>
<p>3）声明式事务的支持 </p>
<p>​        通过配置完成事务的管理，无需手动编程 </p>
<p>4）方便测试，降低JavaEE API的使用</p>
<p>​         Spring对Junit4支持，可以使用注解测试 </p>
<p>5）方便集成各种优秀框架 </p>
<p>​        不排除各种优秀的开源框架，内部提供了对各种优秀框架的直接支持</p>
<p><strong>Spring体系结构</strong></p>
<p><a href="https://imgtu.com/i/WhbcaF"><img src="https://z3.ax1x.com/2021/07/27/WhbcaF.png" alt="WhbcaF.png"></a></p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC概述"><a href="#IOC概述" class="headerlink" title="IOC概述"></a>IOC概述</h3><p><strong>控制反转</strong>（Inverse Of Control）不是什么技术，而是一种设计思想。它的目的是指导我们设计出更 加松耦合的程序。 </p>
<ul>
<li><strong>控制</strong>：在java中指的是对象的控制权限（创建、销毁） </li>
<li><strong>反转</strong>：指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 传统方式</span><br><span class="line">	之前我们需要一个userDao实例，需要开发者自己手动创建 new UserDao();</span><br><span class="line">* IOC方式</span><br><span class="line">	现在我们需要一个userDao实例，直接从spring的IOC容器获得，对象的创建权交给了spring控制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="自定义IOC容器"><a href="#自定义IOC容器" class="headerlink" title="自定义IOC容器"></a>自定义IOC容器</h3><p><strong>需求</strong>    实现service层与dao层代码解耦合</p>
<p><strong>步骤</strong></p>
<ol>
<li><p>创建java项目，导入自定义IOC相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Dao接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDaoImpl:保存成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写Service接口和实现类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		UserDao userDao = <span class="keyword">new</span> UserDaoImpl();  <span class="comment">// 创建dao层接口</span></span><br><span class="line">        userDao.save();  <span class="comment">// 调用dao层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 直接new创建对象</span></span><br><span class="line">      UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">      userService.save();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>问题</strong> </p>
<p>当前service对象和dao对象耦合度太高，而且每次new的都是一个新的对象，导致服务器压力过大。</p>
<p><code>解耦合的原则是编译期不依赖，而运行期依赖就行了。</code></p>
<p><strong>解决思路</strong></p>
<p>我们可以通过反射创建对象，这样可以一定程度降低哦和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService userService = (UserService) Class.forName(<span class="string">&quot;com.com.hui.service.impl.UserServiceImpl&quot;</span>).getConstructor().newInstance();</span><br></pre></td></tr></table></figure>
<p>但是这样依旧会每次都创建对象，并且存在硬编码问题。</p>
<p>我们可以定义一个容器，用来保存需要用到的对象，需要用时就从容器中获取，有点像单例模式。</p>
<p>对于硬编码问题，我们可以定义配置文件。</p>
<p><strong>编写自定义beans.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义，将需要创建的对象编写到bean中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.com.hui.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.com.hui.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写MyBeanFactory工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存对象的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 静态代码块，只执行一次。</span></span><br><span class="line">    <span class="comment">// 读取配置文件,利用反射创建相关的对象，保存到容器中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            InputStream stream = MyBeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;Bean.xml&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建SAXReader对象，解析配置文件</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(stream);</span><br><span class="line">            <span class="comment">// 通过 xpath 获取所有的 bean 标签</span></span><br><span class="line">            List&lt;Element&gt; list = document.selectNodes(<span class="string">&quot;//bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Element element : list) &#123;</span><br><span class="line">                String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String className = element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                <span class="comment">// 利用反射创建对象,并放入 IOC容器 种</span></span><br><span class="line">                Object o = Class.forName(className).getConstructor().newInstance();</span><br><span class="line">                ioc.put(id, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从ioc容器中获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ioc.get(beanId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改UserServiceImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 从容器中获取</span></span><br><span class="line">        userDao = (UserDao) BeanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 使用自定义IOC容器获取对象</span></span><br><span class="line">      UserService userService = (UserService) MyBeanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">      userService.save();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring基本使用"><a href="#Spring基本使用" class="headerlink" title="Spring基本使用"></a>Spring基本使用</h2><p><strong>需求</strong>   借助spring的IOC实现service层与dao层代码解耦合</p>
<p><strong>1）创建项目，导入spring依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2) 编写service层 与 dao层的接口与实现类</strong>  (省略，上面有)</p>
<p><strong>3）创建spring核心配置文件,并配置需要容器管理的对象</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>4)测试，使用spring相关API获得Bean实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    UserDao userDao = (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring相关API"><a href="#Spring相关API" class="headerlink" title="Spring相关API"></a>Spring相关API</h2><p><strong>API继承体系介绍</strong></p>
<p>Spring的API体系异常庞大，我们现在只关注两个BeanFactory和ApplicationContext</p>
<p><a href="https://imgtu.com/i/W4AhDO"><img src="https://z3.ax1x.com/2021/07/27/W4AhDO.png" alt="W4AhDO.png"></a></p>
<h3 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h3><p>BeanFactory是 IOC 容器的核心接口，它定义了IOC的基本功能。</p>
<p><strong>特点</strong>     在第一次调用getBean()方法时，创建指定对象的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    UserService userService = (UserService) factory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h3><p>代表应用上下文对象，可以获得spring中IOC容器的Bean对象。 </p>
<p><strong>特点</strong>    在spring容器启动时，加载并创建所有对象的实例</p>
<p><strong>常用实现类</strong></p>
<ol>
<li>ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种。 </li>
<li> FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 </li>
<li> AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</li>
</ol>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;C:\\applicationContext.xml&quot;</span>);</span><br><span class="line">UserService userService = (UserService)context.getBean(<span class="string">&quot;useService&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object getBean(String name)</td>
<td>根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</td>
</tr>
<tr>
<td>T getBean(Class requiredType)</td>
<td>根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</td>
</tr>
<tr>
<td>T getBean(String name,Class requiredType)</td>
<td>根据Bean的id和类型获得Bean实例，解决容器中相同类型Bean有多个情况。</td>
</tr>
</tbody></table>
<h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><h3 id="Bean标签基本属性"><a href="#Bean标签基本属性" class="headerlink" title="Bean标签基本属性"></a>Bean标签基本属性</h3><p><strong>id</strong>             Bean实例在Spring容器中的唯一标识 </p>
<p><strong>class</strong>        Bean的全限定名</p>
<p><strong>scope</strong>      属性指对象的作用范围，取值如下：</p>
<table>
<thead>
<tr>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认值，单例。当应用加载，创建容器时，对象就被创建了；销毁容器时，对象就被销毁了</td>
</tr>
<tr>
<td>prototype</td>
<td>多例。当对象被使用时，创建新对象实例。当对象长时间不用时，被 Java 的垃圾回收器回收了</td>
</tr>
<tr>
<td>request</td>
<td>WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td>session</td>
<td>WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td>global</td>
<td>sessionWEB项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession 相当于 session</td>
</tr>
</tbody></table>
<p><strong>init-method</strong>          指定类中的初始化方法名称</p>
<p><strong>destroy-method</strong>    指定类中销毁方法名称</p>
<h3 id="Bean实例化三种方式"><a href="#Bean实例化三种方式" class="headerlink" title="Bean实例化三种方式"></a>Bean实例化三种方式</h3><p><strong>无参构造方法实例化</strong> </p>
<p>它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>工厂静态方法实例化</strong> </p>
<p>应用场景 ：依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁使用 B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类 中的m1方法，直接从IOC容器获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.A&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;m1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>工厂普通方法实例化</strong></p>
<p>应用场景 ： 依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁使用 B对象， 此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1 方法，直接从IOC容器获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.A&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;a&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;m1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Bean依赖注入"><a href="#Bean依赖注入" class="headerlink" title="Bean依赖注入"></a>Bean依赖注入</h3><p><strong>依赖注入 DI（Dependency Injection）</strong>    它是 Spring 框架核心 IOC 的具体实现。</p>
<p>通过框架把一个对象传入到另一个对象中，程序之间的依赖交给Spring来维护。</p>
<h4 id="构造方法依赖注入"><a href="#构造方法依赖注入" class="headerlink" title="构造方法依赖注入"></a>构造方法依赖注入</h4><p><strong>在UserServiceImpl中创建有参构造</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要注入的对象</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DI 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();<span class="comment">// 调用dao层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置Spring容器调用有参构造时进行注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  DI 构造方法注入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过参数的顺序注入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;constructor-arg index=&quot;0&quot; type=&quot;com.hui.dao.UserDao&quot; ref=&quot;userDao&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--直接通过名称注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="set方法依赖注入"><a href="#set方法依赖注入" class="headerlink" title="set方法依赖注入"></a>set方法依赖注入</h4><p><strong>在UserServiceImpl中创建set方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置Spring容器调用set方法进行注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  DI set方法注入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>set方法还有一种方式：P命名空间注入</strong></p>
<p>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件 中，如下：</p>
<ol>
<li><p>首先，需要引入P命名空间</p>
<p><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
</li>
<li><p>其次，需要修改注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Bean依赖注入的数据类型"><a href="#Bean依赖注入的数据类型" class="headerlink" title="Bean依赖注入的数据类型"></a>Bean依赖注入的数据类型</h4></li>
</ol>
<p>注入数据的三种数据类型</p>
<p><strong>引用数据类型</strong> </p>
<p>上面操作，注入bean对象都是引用数据类型，也是最常用的</p>
<p><strong>普通数据类型</strong> </p>
<p>直接给property标签中的value赋值即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lagou.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>集合数据类型</strong></p>
<ul>
<li>List集合</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--    List    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;aaaaaa&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Set集合</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--    Set   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;bbbbb&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Array数组</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--    Array    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;ccc&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Map集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--    map    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>properties配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    properties    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置文件模块化"><a href="#配置文件模块化" class="headerlink" title="配置文件模块化"></a>配置文件模块化</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分 配置拆解到其他配置文件中，也就是所谓的配置文件模块化。</p>
<p><strong>并列的多个配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载配置文件时读取多个</span></span><br><span class="line">ApplicationContext act = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;beans1.xml&quot;</span>,<span class="string">&quot;beans2.xml&quot;</span>,<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>主从配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--主配置文件中引入从配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  </p>
<ul>
<li><p>同一个xml中不能出现相同名称的bean,如果出现会报错 </p>
</li>
<li><p>多个xml如果出现相同名称的bean，不会报错，但是后加载的会覆盖前加载的bean</p>
</li>
</ul>
<h2 id="Spring整合DbUtils"><a href="#Spring整合DbUtils" class="headerlink" title="Spring整合DbUtils"></a>Spring整合DbUtils</h2><p><strong>需求</strong>   基于Spring的xml配置实现账户的查询案例</p>
<p><strong>1.准备数据库环境</strong>    省略</p>
<p><strong>2.创建java项目，导入坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.编写Account实体类</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner; <span class="comment">// 需要注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueryRunner</span><span class="params">(QueryRunner queryRunner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queryRunner = queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;select * from account where id = ?&quot;</span>;</span><br><span class="line">            Account query = queryRunner.query(sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), id);</span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao; <span class="comment">// 需要注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.getAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.编写spring核心配置文件</strong> </p>
<p>applicationContext.xm</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_db&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  queryRunner,使用构造方法注入 DataSource对象  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  accountDao  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queryRunner&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  accountService  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>7.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载spring 配置文件</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对象</span></span><br><span class="line">    Account  accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">   	<span class="comment">// 执行查询操作，并输出</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8.抽取jdbc配置文件</strong></p>
<p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。 </p>
<p>首先，需要引入context命名空间和约束路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命名空间：</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">约束路径：</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context	</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改主配置文件，使用  <strong>context:property-placeholder</strong> 标签引入JDBC数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  导入 JDBC 数据源，建议加上  classpath:  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代 替xml配置文件可以简化配置，提高开发效率。</p>
<h3 id="Spring常用注解"><a href="#Spring常用注解" class="headerlink" title="Spring常用注解"></a>Spring常用注解</h3><p>Spring常用注解主要是替代 Bean 的配置</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Controller</td>
<td>使用在web层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Service</td>
<td>使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Repository</td>
<td>使用在dao层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用,根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Resource</td>
<td>相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td>@Value</td>
<td>注入普通属性</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>使用在方法上标注该方法是Bean的初始化方法</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody></table>
<p><strong>说明</strong>      JDK11以后完全移除了javax扩展导致不能使用@resource注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要maven引入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包 下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring常用注解整合DBUtils"><a href="#Spring常用注解整合DBUtils" class="headerlink" title="Spring常用注解整合DBUtils"></a>Spring常用注解整合DBUtils</h3><p><strong>修改AccountDaoImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Qualifier(&quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;select * from account where id = ?&quot;</span>;</span><br><span class="line">            Account query = queryRunner.query(sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), id);</span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改AccountServiceImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Qualifier(&quot;accountDao&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.getAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--删除accountDao与accountService的bean标签--&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解方式加载配置</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对下个</span></span><br><span class="line">    AccountService accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询操作，并输出结果</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h3><p>使用上面的注解还不能全部替代xml配置文件，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 非自定义的Bean的配置：&lt;bean&gt;</span><br><span class="line">* 加载properties文件的配置：&lt;context:property-placeholder&gt;</span><br><span class="line">* 组件扫描的配置：&lt;context:component-scan&gt;</span><br><span class="line">* 引入其他文件：&lt;import&gt;</span><br></pre></td></tr></table></figure>
<p>这时要用到新的注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Configuration</td>
<td>用于指定当前类是一个Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>用于加载 properties 文件中的配置</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring 在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Import</td>
<td>用于导入其他配置类</td>
</tr>
</tbody></table>
<h3 id="Spring纯注解整合DBUtils"><a href="#Spring纯注解整合DBUtils" class="headerlink" title="Spring纯注解整合DBUtils"></a>Spring纯注解整合DBUtils</h3><p><strong>编写Spring核心配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 标记为spring配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hui&quot;)</span> <span class="comment">// context:component-scan 标签，用于扫描注解包</span></span><br><span class="line"><span class="meta">@Import(DataSourceConfig.class)</span>  <span class="comment">// 引入数据库配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;queryRunner&quot;)</span> <span class="comment">//id属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">getQueryRunner</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写数据库配置信息类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:JDBC.properties&quot;)</span>  <span class="comment">// context:property-placeholder 标签，引入外部资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>纯注解测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解方式加载配置</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationContext.class);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对下个</span></span><br><span class="line">    AccountService accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询操作，并输出结果</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><p>在普通的测试类中，需要开发者手动加载配置文件并创建Spring容器，然后通过Spring相关API获得 Bean实例；如果不这么做，那么无法从容器中获得对象。</p>
<p>我们可以让SpringJunit负责创建Spring容器来简化这个操作，开发者可以直接在测试类注入Bean实 例；但是需要将配置文件的名称告诉它。</p>
<p><strong>1.导入spring集成Junit的坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.创建测试类</strong></p>
<ul>
<li><p>使用@Runwith注解替换原来的运行器</p>
</li>
<li><p>使用@ContextConfiguration指定配置文件或配置类</p>
</li>
<li><p>使用@Autowired注入需要测试的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换原来的运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;) </span></span><br><span class="line"><span class="comment">// 引入配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;ApplicationContext.class&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService; <span class="comment">// 可以直接从IOC容器中获取</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = accountService.getAccountById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="实现传统的转账案例"><a href="#实现传统的转账案例" class="headerlink" title="实现传统的转账案例"></a>实现传统的转账案例</h2><p><strong>需求</strong>  使用spring框架整合DBUtils技术，实现用户转账功能</p>
<h3 id="实现基础功能"><a href="#实现基础功能" class="headerlink" title="实现基础功能"></a>实现基础功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建java项目，导入坐标</span><br><span class="line">2. 编写Account实体类</span><br><span class="line">3. 编写AccountDao接口和实现类</span><br><span class="line">4. 编写AccountService接口和实现类</span><br><span class="line">5. 编写spring核心配置文件</span><br><span class="line">6. 编写测试代码</span><br></pre></td></tr></table></figure>
<p><strong>1.创建java项目，导入坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.编写Account实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">// setter getter....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">            queryRunner.update(sql, money, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;update account set money=money-? where name=?&quot;</span>;</span><br><span class="line">            queryRunner.update(sql, money, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName,String inName,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载jdbc配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--把数据库连接池交给IOC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--把QueryRunner交给IOC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>6.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100d</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>上面的代码事务在dao层，转出转入操作都是一个独立的事务，但实际开发，应该把业务逻辑控制在 一个事务中，所以应该将事务挪到service层。</p>
<h3 id="实现传统事务"><a href="#实现传统事务" class="headerlink" title="实现传统事务"></a>实现传统事务</h3><p><strong>给上面业务层的转账操作添加事务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 编写线程绑定工具类</span><br><span class="line">2. 编写事务管理器</span><br><span class="line">3. 修改service层代码</span><br><span class="line">4. 修改dao层代码</span><br></pre></td></tr></table></figure>
<p><strong>1.编写线程绑定工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接工具类，从数据源中获取一个连接，并将实现和当前线程的绑定</span></span><br><span class="line"><span class="meta">@Component(&quot;connectionUtils&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal是当前线程上的本地存储，也能把它当作一个Map集合，只不过key值是当前线程</span></span><br><span class="line">    <span class="comment">// ThreadLocal类有get() 、set(Object obj) 、remove()方法</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程上的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = threadLocal.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次获取该值为空，要从连接池中获取，并放入 threadLocal 中以便后续使用</span></span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection = dataSource.getConnection();</span><br><span class="line">                threadLocal.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除当前线程上的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.编写事务管理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务管理器工具类，包含：开启事务、提交事务、回滚事务、释放资源</span></span><br><span class="line"><span class="comment">// connectionUtils.getThreadConnection();  方法都是在同一个线程中调用，所以获取的连接都是同一个</span></span><br><span class="line"><span class="meta">@Component(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 从IOC容器中获取连接工具类</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取消自动提交</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启自动提交，把原先的手动提交改回自动提交</span></span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 当前线程绑定的连接返还给连接池</span></span><br><span class="line">            connectionUtils.getThreadConnection().close();</span><br><span class="line">            <span class="comment">// 解除当前线程的绑定</span></span><br><span class="line">            connectionUtils.removeThreadConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.修改service层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 从IOC容器中获取事务管理器工具类</span></span><br><span class="line"><span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转账</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        transactionManager.beginTransaction();</span><br><span class="line">        <span class="comment">// 执行原先的业务代码</span></span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        transactionManager.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 回滚事务</span></span><br><span class="line">        transactionManager.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        transactionManager.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.修改dao层代码</strong></p>
<p>queryRunner对象执行sql可以在第一个参数中传递一个连接，表示用该连接去执行sql，我们可以使用连接工具类connectionUtils获取当前线程的连接，这样就能保证两条sql使用的是同一条连接。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"><span class="comment">// 入账</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">        <span class="comment">// 第一个参数可传递一个 连接 ，从 connectionUtils 中获取，因为是同一条线程，这样就能获取同一条连接</span></span><br><span class="line">        queryRunner.update(connectionUtils.getThreadConnection(), sql, money, name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>上面代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了 一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦 合了，违背了面向对象的开发思想。</p>
<h2 id="Proxy优化转账案例"><a href="#Proxy优化转账案例" class="headerlink" title="Proxy优化转账案例"></a>Proxy优化转账案例</h2><p>我们可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样 就不会对业务层产生影响，解决了耦合性的问题</p>
<p><strong>常用的动态代理技术</strong></p>
<p><strong>JDK 代理</strong>  基于接口的动态代理技术：利用拦截器（必须实现invocationHandler）加上反射机制生成 一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理，从而实现方法增强 </p>
<p><strong>CGLIB代理</strong>  基于父类的动态代理技术：动态生成一个要代理的子类，子类重写要代理的类的所有不是 final的方法。在子类中采用方法拦截技术拦截所有的父类方法的调用，顺势织入横切逻辑，对方法进行 增强</p>
<p><a href="https://imgtu.com/i/WLwQ6U"><img src="https://z3.ax1x.com/2021/07/30/WLwQ6U.png" alt="WLwQ6U.png"></a></p>
<h3 id="JDK-代理"><a href="#JDK-代理" class="headerlink" title="JDK 代理"></a>JDK 代理</h3><p><strong>编写JDK动态代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;jDKProxyAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 AccountServiceImpl 的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceImplProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 开启事务</span></span><br><span class="line">                    transactionManager.beginTransaction();</span><br><span class="line">                    <span class="comment">// 调用原来的方法</span></span><br><span class="line">                    method.invoke(accountService, args);</span><br><span class="line">                    <span class="comment">// 提交事务</span></span><br><span class="line">                    transactionManager.commit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 回滚事务</span></span><br><span class="line">                    transactionManager.rollback();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    transactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JDKProxyFactory jdkProxyFactory;</span><br><span class="line"><span class="comment">// 测试JDK动态代理 事务控制</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountService proxy = jdkProxyFactory.createAccountServiceImplProxy();</span><br><span class="line">    proxy.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p><strong>编写CGLIB代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;cGLIBProxyFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountServiceImpl <span class="title">createAccountServiceImplProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数一：目标对象的字节码对象   参数二：动作类，实现增强功能</span></span><br><span class="line">        <span class="keyword">return</span> (AccountServiceImpl) Enhancer.create(accountService.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 开启事务</span></span><br><span class="line">                    transactionManager.beginTransaction();</span><br><span class="line">                    <span class="comment">// 调用原来的方法</span></span><br><span class="line">                    method.invoke(accountService, objects);</span><br><span class="line">                    <span class="comment">// 提交事务</span></span><br><span class="line">                    transactionManager.commit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 回滚事务</span></span><br><span class="line">                    transactionManager.rollback();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    transactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CGLIBProxyFactory cglibProxyFactory;</span><br><span class="line"><span class="comment">// 测试CGLIB动态代理 事务控制</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountServiceImpl proxy = cglibProxyFactory.createAccountServiceImplProxy();</span><br><span class="line">    proxy.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程 AOP 是 OOP（面向对象编程） 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内 容，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高 程序的可重用性，同时提高了开发的效率。</p>
<p><strong>优点</strong></p>
<ul>
<li>在程序运行期间，在不修改源码的情况下对方法进行功能增强 </li>
<li>逻辑清晰，开发核心业务的时候，不必关注增强业务的代码  </li>
<li>减少重复代码，提高开发效率，便于后期维护</li>
</ul>
<p><strong>AOP底层实现</strong> </p>
<p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<ul>
<li>当bean有实现接口时，会用JDK代理模式 </li>
<li>当bean没有实现接口，用cglib实现（ 可以强制使用cglib，在aop:aspectjautoproxy注解中加入 proxyt-target-class=”true“</li>
</ul>
<p><strong>AOP相关术语</strong></p>
<ul>
<li>Target（目标对象）：代理的目标对象 </li>
<li>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 </li>
<li>Joinpoint（连接点）：所谓连接点是指那些可以被拦截到的点。在spring中,这些点指的是方法，因为 spring只支持方法类型的连接点 </li>
<li>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 </li>
<li>Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 <ul>
<li>前置通知、后置通知、异常通知、最终通知、环绕通知 </li>
</ul>
</li>
<li>Aspect（切面）：是切入点和通知（引介）的结合 </li>
<li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织 入，而AspectJ采用编译期织入和类装载期织入</li>
</ul>
<p><strong>我们需要做的</strong></p>
<ol>
<li>编写核心业务代码（目标类的目标方法） 切入点 </li>
<li>把公用代码抽取出来，制作成通知（增强功能方法） 通知 </li>
<li>在配置文件中，声明切入点与通知间的关系，即切面</li>
</ol>
<h2 id="基于xml的AOP"><a href="#基于xml的AOP" class="headerlink" title="基于xml的AOP"></a>基于xml的AOP</h2><p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入（切点表达式需要用到该jar包） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写目标类与通知类</strong>（省略）</p>
<p><strong>在applicationContext.xml中配置aop（需导入aop命名空间）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  目标类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.advice.MyAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  通知类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.AccountServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  AOP配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    配置切面，引入通知类    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 符合切点表达式的方法执行时，使用同种类中的before方法经行前置增强 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* * com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>切点表达式</strong></p>
<p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.访问修饰符可以省略</span><br><span class="line">2.返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意</span><br><span class="line">3.包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</span><br><span class="line">4.参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</span><br><span class="line">如:</span><br><span class="line">execution(public void com.hui.service.impl.AccountServiceImpl.transfer())</span><br><span class="line">execution(void com.hui.service.impl.AccountServiceImpl.*(..))</span><br><span class="line">execution(* com.hui.service.impl.*.*(..))</span><br><span class="line">execution(* com.hui.service..*.*(..))  &#x2F;&#x2F; 最常用</span><br></pre></td></tr></table></figure>
<p><strong>切点表达式抽取</strong></p>
<p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--抽取的切点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>通知类型</strong></p>
<p><code>&lt;aop:通知类型 method=“通知类中方法名” pointcut=“切点表达式&quot; /&gt;</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>&lt;aop:before&gt;</td>
<td>指定增强的方法在切入点方法之前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td>&lt;aop:afterReturning&gt;</td>
<td>指定增强的方法在切入点方法之后执行</td>
</tr>
<tr>
<td>异常通知</td>
<td>&lt;aop:afterThrowing&gt;</td>
<td>指定增强的方法出现异常后执行</td>
</tr>
<tr>
<td>最终通知</td>
<td>&lt;aop:after&gt;</td>
<td>无论切入点方法执行时是否有异常，都会执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td>&lt;aop:around&gt;</td>
<td>开发者可以手动控制增强代码在什么时候执行</td>
</tr>
</tbody></table>
<p>注意：通常情况下，环绕通知都是独立使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环绕通知，开发者通过代码手动控制各种通知</span></span><br><span class="line"><span class="comment">// ProceedingJoinPoint jp   表示正在执行的连接点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">    Object proceed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行当前方法,要将返回对象返回出去</span></span><br><span class="line">        proceed = jp.proceed();</span><br><span class="line">        <span class="comment">//  int i =1/0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h2><p><strong>配置文件中不用编写&lt;aop.config&gt;标签，注解在通知类中使用注解配置织入关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAdvice&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 该类升级为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.hui.service.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在配置文件中开启组件扫描和 AOP 的自动代理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lagou&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  开启aop自动代理，其中 proxy-target-class=&quot;true&quot;表示都采用CGLIB代理模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>切点表达式抽取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAdvice&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 该类升级为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将切入点提取出来</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.hui.service.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyPointCut</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;MyAdvice.MyPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解通知类型</strong></p>
<p><code>@Before</code> <code>@AfterReturning </code>  <code>@AfterThrowing </code>   <code>@After</code>  <code>@Around</code> </p>
<p>  <strong>注意</strong>   </p>
<p>当前四个通知组合在一起时，执行顺序如下：（aop中的一个小bug） </p>
<p>@Before -&gt; @After -&gt; @AfterReturning（如果有异常：@AfterThrowing）</p>
<p>如果是采用注解配置环绕通知，就不会出现这样的状况。</p>
<p><strong>纯注解配置</strong></p>
<p>在 主配置类上添加**@EnableAspectJAutoProxy**  注解，代替  <strong>&lt;aop:aspectj-autoproxy/&gt;</strong></p>
<h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><p>JdbcTemplate是spring框架中提供的一个模板对象，是对原始繁琐的Jdbc API对象的简单封装。用法类似与DBUtils</p>
<p><strong>核心对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(DataSource dataSource);</span><br></pre></td></tr></table></figure>
<p><strong>核心方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int update()</td>
<td>执行增、删、改语句</td>
</tr>
<tr>
<td>List&lt;T&gt; query()</td>
<td>查询多个</td>
</tr>
<tr>
<td>T queryForObject()</td>
<td>查询一个</td>
</tr>
</tbody></table>
<p>查询时如果要对返回结果经行封装，可以传递一个BeanPropertyRowMapper对象，该对像类似于DBUtils中的ResultSetHandler接口，实现ORM映射封装,创建该对象时续传递要封装类型的字节码</p>
<p>如 <code>jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class));</code></p>
<h2 id="Spring整合JdbcTemplate"><a href="#Spring整合JdbcTemplate" class="headerlink" title="Spring整合JdbcTemplate"></a>Spring整合JdbcTemplate</h2><p><strong>需求</strong>  实现转账案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建java项目，导入坐标</span><br><span class="line">2. 编写Account实体类</span><br><span class="line">3. 编写AccountDao接口和实现类</span><br><span class="line">4. 编写AccountService接口和实现类</span><br><span class="line">5. 编写spring核心配置文件</span><br><span class="line">6. 编写测试代码</span><br></pre></td></tr></table></figure>
<p><strong>1.导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring中的事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.编写Account实体类</strong>(省略)</p>
<p><strong>3.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money-? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName,String inName,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line"><span class="comment">//        int i = 1 / 0;</span></span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  引入JDBC配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注解包扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>6.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jerry&quot;</span>,<span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring中的事务"><a href="#Spring中的事务" class="headerlink" title="Spring中的事务"></a>Spring中的事务</h1><p>Spring的事务控制可以分为编程式事务控制和声明式事务控制。 </p>
<p><strong>编程式</strong> 开发者直接把事务的代码和业务代码耦合到一起，在实际开发中不用。 </p>
<p><strong>声明式</strong> 开发者采用配置的方式来实现的事务控制，业务代码与事务代码实现解耦合，使用的AOP思想。</p>
<h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><h3 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h3><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>PlatformTransactionManager接口，是spring的事务管理器，里面提供了我们常用的操作事务的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransactionStatus getTransaction(TransactionDefinition definition)</td>
<td>获取事务的状态信息</td>
</tr>
<tr>
<td>void commit(TransactionStatus status)</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback(TransactionStatus status)</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<p><strong>PlatformTransactionManager接口实现类</strong></p>
<ul>
<li>Dao层技术是jdbcTemplate或mybatis时： DataSourceTransactionManager </li>
<li>Dao层技术是hibernate时： HibernateTransactionManager </li>
<li>Dao层技术是JPA时： JpaTransactionManager</li>
</ul>
<h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>TransactionDefinition接口提供事务的定义信息（事务隔离级别、事务传播行为等等）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int isolationLevel</td>
<td>事务的隔离级别</td>
</tr>
<tr>
<td>int propagationBehavior</td>
<td>事务的传播行为</td>
</tr>
<tr>
<td>int timeout</td>
<td>超时时间。默认值是-1,表示没有超时限制；如果有，以秒为单位进行设置</td>
</tr>
<tr>
<td>boolean readOnly</td>
<td>是否只读，建议查询时设置为只读 true</td>
</tr>
</tbody></table>
<p><strong>事务隔离级别</strong></p>
<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读（幻读）</p>
<ul>
<li>ISOLATION_DEFAULT   使用数据库默认级别</li>
<li>ISOLATION_READ_UNCOMMITTED   读未提交</li>
<li>ISOLATION_READ_COMMITTED   读已提交</li>
<li>ISOLATION_REPEATABLE_READ   可重复读</li>
<li>ISOLATION_SERIALIZABLE   串行化</li>
</ul>
<p><strong>事务传播行为</strong></p>
<p>事务传播行为指的就是当一个业务方法【被】另一个业务方法调用时，应该如何进行事务控制。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>REQUIRED</strong></td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</td>
</tr>
<tr>
<td><strong>SUPPORTS</strong></td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常</td>
</tr>
<tr>
<td>REQUERS_NEW</td>
<td>新建事务，如果当前在事务中，把当前事务挂起</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式运行，如果当前存在事务，抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作</td>
</tr>
</tbody></table>
<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>TransactionStatus 接口提供的是事务具体的运行状态。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNewTransaction()</td>
<td>是否是新事务</td>
</tr>
<tr>
<td>boolean hasSavepoint()</td>
<td>是否是回滚点</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>事务是否回滚</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>事务是否完成</td>
</tr>
</tbody></table>
<p>简单的理解三者的关系</p>
<p><strong>事务管理器（PlatformTransactionManager）</strong>通过读取<strong>事务定义参数（TransactionDefinition）</strong>进行事务管理，然后会产生一系列的<strong>事务状态（TransactionStatus ）</strong></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><strong>配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务管理器交给IOC，这里持久层是使用的是JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>业务层的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事务定义对象</span></span><br><span class="line">        DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        <span class="comment">// 设置是否只读，false支持事务</span></span><br><span class="line">        def.setReadOnly(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置事务隔离级别，可重复读mysql默认级别</span></span><br><span class="line">        def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);</span><br><span class="line">        <span class="comment">// 设置事务传播行为，必须有事务</span></span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        <span class="comment">// 配置事务管理器</span></span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转账</span></span><br><span class="line">            accountDao.out(outUser, money);</span><br><span class="line">            accountDao.in(inUser, money);</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于xml的声明式事务"><a href="#基于xml的声明式事务" class="headerlink" title="基于xml的声明式事务"></a>基于xml的声明式事务</h2><p><strong>需求</strong> 对上面的jdbcTemplate转账案例经行事务控制</p>
<p><strong>主配置文件，需引入tx命名空间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  引入JDBC配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注解包扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  事务管理器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  通知增强  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;MyAdvice&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  事务管理器AOP配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;MyAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>&lt;tx:method /&gt; 标签详情</strong></p>
<ul>
<li>name：切点方法名称 ，可以使用*通配符</li>
<li>isolation:事务的隔离级别 </li>
<li>propagation：事务的传播行为 </li>
<li>timeout：超时时间 </li>
<li>read-only：是否只读</li>
</ul>
<p><strong>CRUD常用配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h2><p><strong>修改service层，增加事务注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在方法或类上添加事务注解</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED, timeout = -1, readOnly = false)</span></span><br></pre></td></tr></table></figure>
<p><strong>修改spring核心配置文件，开启事务注解支持</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  注解方式配置声明式事务控制,需要开启事务注解支持  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>纯注解形式</strong></p>
<ul>
<li><p>数据源配置类(省略)</p>
</li>
<li><p>核心配置类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// spring主配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hui&quot;)</span>  <span class="comment">// 包扫描</span></span><br><span class="line"><span class="meta">@Import(DataSourceConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务支持注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;jdbcTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring集成JavaWeb"><a href="#Spring集成JavaWeb" class="headerlink" title="Spring集成JavaWeb"></a>Spring集成JavaWeb</h1><p>应用上下文对象<strong>ApplicationContext</strong>是通过 <strong>new ClasspathXmlApplicationContext(spring配置文件)</strong> 方式获取的，但是每次从容器中获得<strong>Bean</strong>时都要编写 new ClasspathXmlApplicationContext(spring配置文件) 来获取上下文， 这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p><strong>解决思路</strong></p>
<p>在Web项目中，可以使用<strong>ServletContextListener</strong>监听Web应用的启动，我们可以在Web应用启动 时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域 <strong>servletContext</strong>域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p>
<p><strong>Spring提供获取应用上下文的工具</strong></p>
<p>上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到<strong>ServletContext</strong>域中，提供 了一个客户端工具<strong>WebApplicationContextUtils</strong>供使用者获得应用上下文对象。</p>
<p>所以我们只需要导入相关的<strong>依赖</strong>，并在web.xml中配置<strong>ContextLoaderListener</strong>监听器，就可以使用<strong>WebApplicationContextUtils</strong>工具类在任意地方获取<strong>ApplicationContext</strong>上下文对象</p>
<p><strong>1.导入Spring集成web的坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.配置ContextLoaderListener监听器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数，固定写法，告诉监听器去哪里寻找配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.通过工具获得应用上下文对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">Object obj = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这也就是spring整合spring-mvc,spring会创建一个IOC容器，spring-mvc也会创建一个IOC容器，spring创建的为父容器，mvc创建的为子容器。子容器可以访问父容器中的bean，但父容器不能访问子容器中的bean，即Controller层可以调用service层，而service层不能调用controller层。</p>
<h1 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h1><p>将mybatis接口代理对象的创建权交给spring管理，我们就可以把dao的代理对象注入到service中， 此时也就完成了spring与mybatis的整合了。</p>
<p>因为SqlSessionFactory对象是安全的，所以把它交给spring管理。整合的过程其实是将mybatis主配置文件的内容全部移到spring配置文件中。如果需要用到mybatis主配置文件也是可以的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring整合mybatis--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入JDBC数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--SqlSessionFactory创建交给spring的IOC容器，mybatis中的所有配置可以在里面配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类型别名配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lagou.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果要引入mybatis主配置文件，可以通过如下配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置pageHelper分页，记得需导入依赖    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置方言   --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>helperDialect=mysql<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--映射接口扫描配置，由spring创建代理对象，交给IOC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lagou.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置好了，可以不用mybatis主配置文件，并且在service层注入dao层的接口其实是spring创建的代理对象。</p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="MD5-的使用"><a href="#MD5-的使用" class="headerlink" title="MD5 的使用"></a>MD5 的使用</h2><p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MD5依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>添加自定义工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 盐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String md5key = <span class="string">&quot;hui&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * MD5方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> text 明文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 密文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String text, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加密后的字符串</span></span><br><span class="line">        String encodeStr= DigestUtils.md5Hex(text+key);</span><br><span class="line">        System.out.println(<span class="string">&quot;MD5加密后的字符串为:encodeStr=&quot;</span>+encodeStr);</span><br><span class="line">        <span class="keyword">return</span> encodeStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * MD5验证方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> text 明文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> md5 密文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String text, String key, String md5)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据传入的密钥进行验证</span></span><br><span class="line">        String md5Text = md5(text, key);</span><br><span class="line">        <span class="keyword">if</span>(md5Text.equalsIgnoreCase(md5))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MD5验证通过&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-MVC</title>
    <url>/2021/08/02/spring-MVC/</url>
    <content><![CDATA[<p>SpringMVC 是一种基于 Java 的实现 MVC 设计模式的轻量级 Web 框架，属于SpringFrameWork 的 后续产品，已经融合在 Spring Web Flow 中。<a id="more"></a></p>
<p> SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2， 成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现 任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<h1 id="SpringMVC基本用法"><a href="#SpringMVC基本用法" class="headerlink" title="SpringMVC基本用法"></a>SpringMVC基本用法</h1><p><strong>MVC模式</strong></p>
<p>MVC是软件工程中的一种软件架构模式，它是一种分离业务逻辑与显示界面的开发思想。</p>
<ul>
<li>M（model）模型：处理业务逻辑，封装实体 </li>
<li>V（view） 视图：展示内容 </li>
<li>C（controller）控制器：负责调度分发（1.接收请求、2.调用模型、3.转发到视图）</li>
</ul>
<p><a href="https://imgtu.com/i/f9mk2F"><img src="https://z3.ax1x.com/2021/08/02/f9mk2F.png" alt="f9mk2F.png"></a></p>
<p>SpringMVC的框架就是封装了原来Servlet中的共有行为；例如：参数封装，视图转发等</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>1.创建web项目，导入SpringMVC相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置为web工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springMVC坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.在web.xml中配置前端控制器DispatcherServlet</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前端控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> 		</span><br><span class="line">        <span class="tag">&lt;<span class="name">servletclass</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载SpringMVc配置文件，固定写法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正数表示立即加载，而不是客户端访问了该sevlet就加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- /表示拦截所有，但是不包括*.jsp这样的url，/*才会拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.编写Controller类与视图</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quick running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;success&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h3&gt;请求成功！&lt;/h3&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>4.配置SpringMVC核心配置文件spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lagou.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动tomcat后访问 <a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/quick">http://localhost:8080/项目名/quick</a></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><strong>代码层面</strong>     所有的请求都给<strong>前端控制器</strong>管理，由<strong>前端控制器</strong>根据地址执行响应的controller代码</p>
<p><a href="https://imgtu.com/i/f9KUaR"><img src="https://z3.ax1x.com/2021/08/02/f9KUaR.png" alt="f9KUaR.png"></a></p>
<h1 id="SpringMVC组件"><a href="#SpringMVC组件" class="headerlink" title="SpringMVC组件"></a>SpringMVC组件</h1><h2 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h2><p><strong>组件层面</strong></p>
<p><a href="https://imgtu.com/i/f9M2XF"><img src="https://z3.ax1x.com/2021/08/02/f9M2XF.png" alt="f9M2XF.png"></a></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet。 </li>
<li> DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如 果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView。 </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li>
<li>ViewReslover解析后返回具体View。 </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet将渲染后的视图响应响应用户。</li>
</ol>
<h2 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h2><p><strong>1.前端控制器：DispatcherServlet</strong> </p>
<p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的 中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>2.处理器映射器：HandlerMapping</strong> </p>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器 实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </p>
<p><strong>3.处理器适配器：HandlerAdapter</strong> </p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型 的处理器进行执行。 </p>
<p><strong>4.处理器：Handler【开发者编写】</strong> </p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 </p>
<p><strong>5.视图解析器：ViewResolver</strong> </p>
<p>ViewResolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物 理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给 用户。 </p>
<p><strong>6.视图：View 【开发者编写】</strong> </p>
<p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、 pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展 示给用户，需要由程序员根据业务需求开发具体的页面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器映射器和处理器适配器配置，功能增强，对json格式的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器,配置前缀与后缀--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p><strong>@Controller</strong></p>
<p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器 中，如果使用@Controller注解标注的话，就需要使用注解扫描：</p>
<p><code>&lt;context:component-scan base-package=&quot;com.hui.controller&quot;/&gt;</code></p>
<p><strong>@RequestMapping</strong></p>
<p>用于建立请求 URL 和处理请求方法之间的对应关系，可放在类上与方法上。</p>
<ul>
<li>value属性：用于指定请求的URL。它和path属性的作用是一样的 </li>
<li>method属性：用来限定请求的方式 ，如RequestMethod.GET、RequestMethod.POST</li>
<li>params属性：用来限定请求参数的条件，如<ul>
<li>params={“accountName”} 表示请求参数中必须有accountName </li>
<li>pramss={“money!100”} 表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
<h1 id="SpringMVC请求"><a href="#SpringMVC请求" class="headerlink" title="SpringMVC请求"></a>SpringMVC请求</h1><h2 id="获取请求参数类型"><a href="#获取请求参数类型" class="headerlink" title="获取请求参数类型"></a>获取请求参数类型</h2><p>springMVC可以接受以下类型的参数</p>
<p><strong>基本类型参数</strong>     <strong>对象类型参数</strong>      <strong>数组类型参数</strong>      <strong>集合类型参数</strong></p>
<p>Controller中的业务方法的参数名要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换,还能对POJO对象自动映射封装。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pojoParam</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/queryParam&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    list集合,第一个元素&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].id&quot;</span> placeholder=<span class="string">&quot;编号&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].username&quot;</span> placeholder=<span class="string">&quot;姓名&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    map集合,第一个元素&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userMap[&#x27;u1&#x27;].id&quot;</span> placeholder=<span class="string">&quot;编号&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userMap[&#x27;u1&#x27;].username&quot;</span> placeholder=<span class="string">&quot;姓名&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;复杂类型&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; userMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/queryParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryParam</span><span class="params">(QueryVo queryVo)</span> </span>&#123;</span><br><span class="line">    System.out.println(queryVo);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中文乱码过滤器"><a href="#中文乱码过滤器" class="headerlink" title="中文乱码过滤器"></a>中文乱码过滤器</h2><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filterclass</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h2><p>SpringMVC 默认已经提供了一些常用的类型转换器，还提供了自 定义类型转换器，方便开发者自定义处理。如 日期格式类型要求为：yyyy/MM/dd，如果客户端传过来的是 yyyy-MM-dd格式，要把它转换成日期格式就会报错，这时需要使用自定义类型转换器。</p>
<p><strong>编写一个类，实现Converter&lt;?,?&gt;接口，重写convert方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将日期字符串转换成日期对象，并返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置pringMVC配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器映射器和适配器增强,并添加转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotationdriven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义转换器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可配置多个自定义转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lagou.converter.DateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="请求相关注解"><a href="#请求相关注解" class="headerlink" title="请求相关注解"></a>请求相关注解</h2><p><strong>@RequestParam</strong></p>
<p>当请求的参数name名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定</p>
<ul>
<li>name 匹配页面传递参数的名称 </li>
<li>defaultValue 设置参数默认值</li>
<li>required 设置是否必须传递该参数，默认值为true；如果设置了defaultValue ，值自动改为false</li>
</ul>
<p><strong>@RequestHeader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求头的数据,获取请求头中的所有cookie信息</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/requestHead&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestHead</span><span class="params">(<span class="meta">@RequestHeader(&quot;cookie&quot;)</span> String cookie)</span> </span>&#123;</span><br><span class="line">    System.out.println(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@CookieValue</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取cookie中的数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cookieValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cookieValue</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jesessionId)</span> </span>&#123;</span><br><span class="line">    System.out.println(jesessionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC响应"><a href="#SpringMVC响应" class="headerlink" title="SpringMVC响应"></a>SpringMVC响应</h1><p><strong>注意</strong>    在WEB-INF下的jsp页面不能直接访问，所以只能通过转发访问，重定向则不行</p>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><h3 id="void原始ServletAPI"><a href="#void原始ServletAPI" class="headerlink" title="void原始ServletAPI"></a>void原始ServletAPI</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过request、response对象实现响应</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/returnVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过request实现转发</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;怪狗狗&quot;</span>);</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="comment">// 通过response实现重定向，WEB-INF下的jsp页面不能重定向</span></span><br><span class="line">    response.sendRedirect(request.getContextPath() + <span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回字符串逻辑视图"><a href="#返回字符串逻辑视图" class="headerlink" title="返回字符串逻辑视图"></a>返回字符串逻辑视图</h3><p><strong>直接返回字符串</strong></p>
<p>此种方式会将返回的<strong>字符串</strong>与<strong>视图解析器</strong>的前后缀拼接后跳转到指定页面，这种方式本质是<strong>转发</strong>。</p>
<p><strong>forward转发</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 则路径必须写成实际视图url，不能写逻辑视图</span></span><br><span class="line"><span class="comment">// model是用来传递数据给前端，相当于 request 域</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;拉勾招聘&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>redirect重定向</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WEB-INF下的jsp页面不能重定向经行访问</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;拉勾教育&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p><strong>Model</strong>    模型 作用封装数据<br><strong>View</strong>       视图 作用展示数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/returnModelAndView1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">returnModelAndView1</span><span class="params">(ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  直接声明或则直接创建ModelAndView都一样</span></span><br><span class="line">    <span class="comment">//  ModelAndView modelAndView = new ModelAndView();</span></span><br><span class="line">    <span class="comment">//设置模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>, <span class="string">&quot; lagou&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称，逻辑视图，转发</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@SessionAttributes注解</strong></p>
<p>定义在类上，会将request域范围的数据提升到session范围，这样多个请求就能共享数据了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//向request域存入的key为username时，同步到session域中</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;username&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;怪狗狗&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><p><strong>1.直接返回字符串数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过response直接响应数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/returnVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;拉勾网&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.将对象或集合转为json返回</strong>(AJAX异步交互中会介绍)</p>
<h1 id="静态资源访问的开启"><a href="#静态资源访问的开启" class="headerlink" title="静态资源访问的开启"></a>静态资源访问的开启</h1><p>当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文 件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是 /   ,代表对所有的 静态资源都进行处理操作，这样就不会执行Tomcat内置的DefaultServlet处理，而是DispatcherServlet把该路径当作我们自己写的一个方法(RequestMapping)。我们可以在springMVC配置文件中配置指定放行静态资源：</p>
<p><strong>方式一</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定放行资源，mapping:放行的映射路径，location:静态资源所在的目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>方式二</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--放行全部的静态资源，开启DefaultServlet处理静态资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="AJAX异步交互"><a href="#AJAX异步交互" class="headerlink" title="AJAX异步交互"></a>AJAX异步交互</h1><p>Springmvc默认用MappingJackson2HttpMessageConverter对json数据进行转换，需要加入 jackson的包；同时还需使用<strong>&lt;mvc:annotation-driven /&gt;</strong> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@RequestBody与@ResponseBody</strong></p>
<ul>
<li><p>RequestBody  用于Controller的方法的形参声明，当使用ajax提交并指定contentType为json形式时，通过 HttpMessageConverter接口转换为对应的POJO对象。</p>
</li>
<li><p>ResponseBody  用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数 据如：json,xml等，通过Response响应给客户端。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@RequestMapping(produces = &quot;application/json;charset=utf-8&quot;) </span></span><br><span class="line"><span class="comment">	响应返回数据的mime类型和编码，默认为json</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 处理ajax的json数据</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test6&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//返回的对象转换成JSON格式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">test6</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h1><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用 于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机 制等。</p>
<p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动 词如下： </p>
<p><strong>GET</strong>：读取（Read）     <strong>POST</strong>：新建（Create）     <strong>PUT</strong>：更新（Update）    <strong>DELETE</strong>：删除（Delete）</p>
<table>
<thead>
<tr>
<th>客户端请求</th>
<th>原来风格URL地址</th>
<th>RESTful风格URL地址</th>
</tr>
</thead>
<tbody><tr>
<td>查询所有</td>
<td>/user/findAll</td>
<td>GET /user</td>
</tr>
<tr>
<td>根据ID查询</td>
<td>/user/findById?id=1</td>
<td>GET /user/{1}</td>
</tr>
<tr>
<td>新增</td>
<td>/user/save POST</td>
<td>/user</td>
</tr>
<tr>
<td>修改</td>
<td>/user/update PUT</td>
<td>/user</td>
</tr>
<tr>
<td>删除</td>
<td>/user/delete?id=1</td>
<td>DELETE /user/{1}</td>
</tr>
</tbody></table>
<p><strong>@PathVariable</strong> 用来接收RESTful风格请求地址中占位符的值 </p>
<p><strong>@RestController</strong> RESTful风格多用于前后端分离项目开发，前端通过ajax与服务器进行异步交互，我们处理器通常返 回的是json数据,所以使用@RestController来替代@Controller和@ResponseBody两个注解。</p>
<p>其中@RequestMapping中的method属性可以设置不同的请求方式,可以简写成</p>
<p>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;user&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getAllUser&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据Id查询</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserById&quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><strong>文件上传三要素</strong> </p>
<ul>
<li>表单项 type=”file” </li>
<li>表单的提交方式 method=”POST” </li>
<li>表单的enctype属性是多部分表单形式 enctype=“multipart/form-data”</li>
</ul>
<h2 id="1-导入fileupload和io坐标"><a href="#1-导入fileupload和io坐标" class="headerlink" title="1.导入fileupload和io坐标"></a>1.导入fileupload和io坐标</h2><p>springMVC文件上传就是对fileupload的封装</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-配置文件上传解析器"><a href="#2-配置文件上传解析器" class="headerlink" title="2.配置文件上传解析器"></a>2.配置文件上传解析器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定文件上传的最大值为5MB，5*1024*1024 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242880&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编写文件上传代码"><a href="#3-编写文件上传代码" class="headerlink" title="3.编写文件上传代码"></a>3.编写文件上传代码</h2><p><strong>单文件上传</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/fileUpload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;单文件上传&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单文件上传</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fileUpload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(String username, MultipartFile filePic)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    String filename = filePic.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 保存文件</span></span><br><span class="line">    filePic.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;c://upload/&quot;</span> + filename));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多文件上传</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/filesUpload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件一:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件二:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;多文件上传&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件上传</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/filesUpload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filesUpload</span><span class="params">(String username, MultipartFile[] filePic)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 遍历文件类型数组</span></span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : filePic) &#123;</span><br><span class="line">        <span class="comment">// 获取文件名，并保存</span></span><br><span class="line">        String filename = file.getOriginalFilename();</span><br><span class="line">        file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;c://upload/&quot;</span> + filename));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>SpringMVC的异常处理机制，dao、service、controller出现异常都通过<strong>throws Exception</strong>向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p>
<p><a href="https://imgtu.com/i/fCemGT"><img src="https://z3.ax1x.com/2021/08/02/fCemGT.png" alt="fCemGT.png"></a></p>
<h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><p><strong>创建异常处理器类实现HandlerExceptionResolver接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Exception e表示当前的异常</span></span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;error&quot;</span>,e.getMessage());</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringMVC.xml配置异常处理器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myException&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.exception.MyException&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写异常页面</strong>(省略)</p>
<h2 id="web的处理异常机制"><a href="#web的处理异常机制" class="headerlink" title="web的处理异常机制"></a>web的处理异常机制</h2><p>web.xml文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理500异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--处理404异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p>
<p><strong>拦截器interceptor和过滤器filter区别</strong></p>
<p><a href="https://imgtu.com/i/fCmIje"><img src="https://z3.ax1x.com/2021/08/02/fCmIje.png" alt="fCmIje.png"></a></p>
<p><strong>拦截器使用步骤</strong></p>
<ul>
<li>创建拦截器类实现HandlerInterceptor接口,根据需求重写方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行之前 拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandler。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在目标方法执行之后,视图对象返回之前 执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandler。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>springMVC.xml中配置拦截器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  拦截器  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span>  <span class="comment">&lt;!--拦截所有handler--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>拦截器中的方法说明如下</strong></p>
<p><a href="https://imgtu.com/i/fCnevF"><img src="https://z3.ax1x.com/2021/08/02/fCnevF.png" alt="fCnevF.png"></a></p>
<p><strong>拦截器链</strong> </p>
<p>开发中拦截器可以单独使用，也可以同时使用多个拦截器形成一条拦截器链，与过滤器链类似。开发步骤和单个拦截器 是一样的，只不过注册的时候注册多个，注意这里注册的顺序就代表拦截器执行的顺序。</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2021/08/13/nginx/</url>
    <content><![CDATA[<p>Nginx（发音同 engine x）是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。<a id="more"></a>由俄罗斯的程序设计师Igor Sysoev(伊戈尔·西索夫)所开发，供俄国大型的入口网站及搜索引擎Rambler(漫步者)（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、 腾讯等。</p>
<p><strong>优点</strong></p>
<ol>
<li>占用内存少，并发能力强</li>
<li>Nginx专为性能优化而开发, 在高连接并发的情况下，能够支持高达 50,000 个并发连接数的响应.</li>
<li>Nginx支持热部署, 可以在不间断服务的情况下,对软件版本进行升级.</li>
</ol>
<p><strong>应用场景</strong></p>
<ol>
<li><p><strong>http服务器</strong>: Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</p>
</li>
<li><p><strong>虚拟主机</strong>: 可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</p>
</li>
<li><p><strong>反向代理，负载均衡</strong> :  当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况</p>
</li>
</ol>
<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><p>下载nginx, 官方网站：<a href="http://nginx.org/">http://nginx.org/</a></p>
<p>这里使用的版本是1.17.8版本。</p>
<p>Nginx在Linux下安装,只提供了源代码,所以我们需要进行编译.</p>
<h2 id="安装环境配置"><a href="#安装环境配置" class="headerlink" title="安装环境配置"></a>安装环境配置</h2><ol>
<li>因为Nginx是C语言编写的,所以需要配置C语言编译环境 (一定要在联网状态下安装)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要安装gcc的环境。执行命令: </span><br><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>注意: 如果执行命令出现这样的提示:</p>
<p><a href="https://imgtu.com/i/fDwRiR"><img src="https://z3.ax1x.com/2021/08/13/fDwRiR.jpg" alt="fDwRiR.jpg"></a></p>
<p>解决办法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题是 yum在锁定状态中,强制关掉yum进程即可</span><br><span class="line">rm -f &#x2F;var&#x2F;run&#x2F;yum.pid</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>第三方的开发包, 在编译之前需要安装这些第三方包。</li>
</ol>
<ul>
<li><p><code>PCRE</code></p>
<ul>
<li>nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure></li>
<li><p><code>zlib</code></p>
<ul>
<li>nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li>
<li><p><code>openssl</code></p>
<ul>
<li>OpenSSL 是一个强大的安全套接字层密码库,nginx不仅支持http协议，还支持https,所以需要在linux安装openssl库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<h2 id="安装Nginx-步骤"><a href="#安装Nginx-步骤" class="headerlink" title="安装Nginx 步骤"></a>安装Nginx 步骤</h2></li>
</ul>
<ol>
<li><p>将Nginx的源码包上传到 Linux</p>
</li>
<li><p>解压Nginx</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.17.8.tar </span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>进入到解压之后的目录 nginx-1.17.8</p>
</li>
<li><p>执行命令下方的 configure,生成 Mikefile 文件 </p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<p>执行命令后, 生成了MakeFile文件 </p>
<ol start="5">
<li>创建临时文件目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>执行make命令,进行编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完毕后，nginx在 /usr/loacl/ 目录下</p>
<h2 id="启动并访问-Nginx"><a href="#启动并访问-Nginx" class="headerlink" title="启动并访问 Nginx"></a>启动并访问 Nginx</h2><ol>
<li>进入到nginx 安装目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入到 sbin目录,执行 <code>nginx</code> 命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx 启动</span><br><span class="line">.&#x2F;nginx -s reload 重启</span><br><span class="line">.&#x2F;nginx -s stop 关闭</span><br><span class="line">ps aux | grep nginx 查看进程</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>通过浏览器进行访问  ,默认端口 80  (注意：是否关闭防火墙。)</li>
</ol>
<h2 id="nginx核心配置文件"><a href="#nginx核心配置文件" class="headerlink" title="nginx核心配置文件"></a>nginx核心配置文件</h2><p>/usr/local/nginx/conf/nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes  1; #work的进程数，默认为1</span><br><span class="line"><span class="meta">#</span><span class="bash">配置 影响nginx服务器与用户的网络连接</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; #单个work 最大并发连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> http块是配置最频繁的部分 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能</span></span><br><span class="line">http &#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 引入mime类型定义文件</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65; # 超时时间</span><br><span class="line">	</span><br><span class="line"><span class="meta">	#</span><span class="bash">server 配置虚拟主机的相关参数 可以有多个,一个server就是一个虚拟主机</span></span><br><span class="line">    server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash"> 监听的端口</span></span><br><span class="line">        listen       80; </span><br><span class="line"><span class="meta">		#</span><span class="bash">监听地址</span></span><br><span class="line">        server_name  localhost;         </span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 默认请求配置</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # 默认网站根目录</span><br><span class="line">            index  index.html index.htm; # 欢迎页</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 错误提示页面</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h1><p>虚拟主机指的是,在一台服务器中,我们使用Nginx,来配置多个网站.</p>
<p>如何区分不同的网站:</p>
<ol>
<li>端口不同</li>
<li>域名不同</li>
</ol>
<h2 id="通过端口区分不同的虚拟主机"><a href="#通过端口区分不同的虚拟主机" class="headerlink" title="通过端口区分不同的虚拟主机"></a>通过端口区分不同的虚拟主机</h2><p>1.配置nginx.conf,  在配置文件中添加一个 新的server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原来的server</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    # 配置新的server,主要需改 listen</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       81; # 修改端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html2; # 重新制定一个目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2.复制一份 html目录，来观察不同的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r html html2</span><br></pre></td></tr></table></figure>
<p>3.重新加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s relaod </span><br></pre></td></tr></table></figure>
<p>4.访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1   访问第一个server</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:81&#x2F;  访问第二个server</span><br></pre></td></tr></table></figure>
<h2 id="通过域名区分不同的虚拟主机"><a href="#通过域名区分不同的虚拟主机" class="headerlink" title="通过域名区分不同的虚拟主机"></a>通过域名区分不同的虚拟主机</h2><p><strong>域名绑定</strong></p>
<ul>
<li>一个域名对应一个ip地址，一个ip地址可以被多个域名绑定。</li>
<li>通过 DNS服务器去解析域名</li>
</ul>
<p><strong>配置域名映射</strong></p>
<ul>
<li>本地测试可以修改hosts文件。修改window的hosts文件：（C:\Windows\System32\drivers\etc）</li>
</ul>
<ul>
<li>可以配置域名和ip的映射关系，如果hosts文件中配置了域名和ip的对应关系，不需要走dns服务器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1  www.hui1.com</span><br><span class="line">127.0.0.1  www.hui2.com</span><br></pre></td></tr></table></figure>
<p><strong>配置 nginx.xml</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过域名区分虚拟主机,主要修改 server_name</span></span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui1.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui2.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html2;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.hui1.com</span><br><span class="line">www.hui2.com</span><br></pre></td></tr></table></figure>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据再发送给客户机。</p>
<p><strong>正向代理</strong></p>
<p>正向代理代理的是客户端, 服务端不知道实际发起请求的客户端。例如翻墙就是正向代理用的最广泛的地方</p>
<p><a href="https://imgtu.com/i/fDIhse"><img src="https://z3.ax1x.com/2021/08/13/fDIhse.jpg" alt="fDIhse.jpg"></a></p>
<p><strong>反向代理</strong></p>
<p>反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器。</strong></p>
<p><a href="https://imgtu.com/i/fDIqRf"><img src="https://z3.ax1x.com/2021/08/13/fDIqRf.jpg" alt="fDIqRf.jpg"></a></p>
<p><strong>Nginx实现反向代理</strong></p>
<p>Nginx作为反向代理服务器安装在服务端，Nginx的功能就是把请求转发给后面的应用服务器.</p>
<p><a href="https://imgtu.com/i/fDonoR"><img src="https://z3.ax1x.com/2021/08/13/fDonoR.jpg" alt="fDonoR.jpg"></a></p>
<p>1.启动两个tomcat，端口号分别是8080、8081，模拟两个网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;115.45.129.213:8080&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;115.45.129.213:8081&#x2F;</span><br></pre></td></tr></table></figure>
<p>2.反向代理服务器的配置  nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">反向代理配置</span> </span><br><span class="line"><span class="meta">	#</span><span class="bash">upstream中的server是真正处理请求的应用服务器地址</span></span><br><span class="line">	upstream hui01&#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">		server 115.45.129.213:8080;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui1.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        	# 利用 proxy_ pass可以将请求代理到upstream命名的HTTP服务</span><br><span class="line">            proxy_pass http://hui01;  #转发到的地址</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	upstream hui02&#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">		server 115.45.129.213:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui2.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://hui02; </span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>记得在host文件中添加域名和ip的映射关系</p>
<ul>
<li>在浏览器输入域名, 访问Nginx代理服务器, Nginx根据域名将请求转发给对应的目标服务器。</li>
<li>作为用户的我们看到的是服务器的响应结果页面,在整个过程中目标服务器相对于客户端是不可见的,服务端向外暴露的就是Nginx的地址.</li>
</ul>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>反向代理服务器，合理分配请求到目标服务器的过程就叫做负载均衡</p>
<p>负载均衡主要是为了分担访问量，将请求合理分发给不同的服务器, 避免临时的网络堵塞</p>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p><strong>轮询</strong></p>
<ul>
<li><p>默认策略, 每个请求按照时间顺序逐一分配到不同的服务器,如果某一个服务器下线,能自动剔除</p>
</li>
<li><p>配置nginx.conf</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream hui&#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">	server 115.45.129.213:8080;</span><br><span class="line">	server 115.45.129.213:8081;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  www.hui.com; #当前访问的域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://hui;  #转发到的地址</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样访问 <a href="http://www.hui.com/">www.hui.com</a> 时，有时会访问 8080 端口的tomcat，有时会访问到8081端口的tomcat</p>
<p><strong>weight</strong></p>
<ul>
<li>可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1。</li>
<li>配置nginx.conf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在后面加 weight 即可</span></span><br><span class="line">upstream hui&#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">	server 115.45.129.213:8080 weight=1;</span><br><span class="line">	server 115.45.129.213:8081 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目的部署与发布"><a href="#项目的部署与发布" class="headerlink" title="项目的部署与发布"></a>项目的部署与发布</h1><h2 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1.需要安装的软件</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JDK</strong></td>
<td>11</td>
</tr>
<tr>
<td><strong>Tomcat</strong></td>
<td>8.5</td>
</tr>
<tr>
<td><strong>MySQL</strong></td>
<td>5.7</td>
</tr>
<tr>
<td><strong>Nginx</strong></td>
<td>1.17.8</td>
</tr>
</tbody></table>
<p>2.开启8080端口</p>
<p>3.使用SQLYoga连接Linux上的数据库，导入SQL脚本</p>
<h3 id="项目打包发布"><a href="#项目打包发布" class="headerlink" title="项目打包发布"></a>项目打包发布</h3><p>在平常开发的过程中，不同的环境中项目的相关配置也会有相关的不同，我们在不同的环境中部署就要手动修改为对应环境的配置，这样太麻烦了以及这样也会很容易出错。 接下来我们就通过maven的相关配置来在打包时指定各个环境对应配置文件</p>
<h4 id="dao模块创建配置文件"><a href="#dao模块创建配置文件" class="headerlink" title="dao模块创建配置文件"></a>dao模块创建配置文件</h4><p>在ssm-dao项目的src/main/resources 下面创建<strong>filter</strong>目录, 再创建 <strong>development.properties</strong> ,  <strong>product.properties</strong> 两个文件</p>
<ul>
<li>development是开发配置内容，配置本地的Mysql</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JDBC.driver=com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url=jdbc:mysql:<span class="comment">///ssm_lagou_edu?characterEncoding=UTF-8</span></span><br><span class="line">JDBC.username=root</span><br><span class="line">JDBC.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>product是正式配置内容，配置远程服务器的Mysql</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JDBC.driver=com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url=jdbc:mysql:<span class="comment">//*.*.*.*:3306/ssm_lagou_edu?characterEncoding=UTF-8</span></span><br><span class="line">JDBC.username=root</span><br><span class="line">JDBC.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h4 id="配置jdbc-properties-文件"><a href="#配置jdbc-properties-文件" class="headerlink" title="配置jdbc.properties 文件"></a>配置jdbc.properties 文件</h4><p>jdbc.properties中的内容不再写死,而是从上面两个文件中获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url&#x3D;$&#123;JDBC.url&#125;</span><br><span class="line">JDBC.username&#x3D;$&#123;JDBC.username&#125;</span><br><span class="line">JDBC.password&#x3D;$&#123;JDBC.password&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：${jdbc.url} 等需要直接对应上面配置的development.properties或product.properties文件中的名称</p>
</blockquote>
<h4 id="配置dao模块的的-pom-xml文件"><a href="#配置dao模块的的-pom-xml文件" class="headerlink" title="配置dao模块的的 pom.xml文件"></a>配置dao模块的的 pom.xml文件</h4><p>添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>development<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 正式环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>product<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>web<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/resources/filter/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>filter/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>profile说明</strong></p>
<ul>
<li>profile可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果</li>
<li>默认启用的是dev环境配置:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>development<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 正式环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>product<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定数据库配置文件路径，此路径可以自定义:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/resources/filter/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定资源目录路径</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 资源根目录排除各环境的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>filter/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ul>
<li>命令打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打本地包 mvn -Pdev install 或者mvn install(因为本例activeByDefault配的为true)</span><br><span class="line">打产品包 mvn -Pprod install</span><br><span class="line"></span><br><span class="line">结果：src&#x2F;main&#x2F;resources&#x2F;config&#x2F;jdbc.properties根据 mvn -P 参数决定值</span><br></pre></td></tr></table></figure>
<ul>
<li>使用idea打包</li>
</ul>
<p><a href="https://imgtu.com/i/fraYKU"><img src="https://z3.ax1x.com/2021/08/13/fraYKU.jpg" alt="fraYKU.jpg"></a></p>
<p><strong>打包后的文件</strong></p>
<ul>
<li><p>war包在web模块中的target目录中，我们就是需要该war包</p>
</li>
<li><p>打开这个war包,我们会发现 其他子模块都已经被打成jar包,放到了lib文件夹下</p>
</li>
</ul>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ul>
<li><p>修改一下项目名称 ssm-web.war</p>
</li>
<li><p>上传到Linux中tomcat的webapp目录下,启动测试 <code>./startup.sh</code></p>
</li>
<li><p>在部署tomcat的 webapps目录下创建一个 upload文件夹,用于保存图片 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir upload</span><br></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;*.*.*.*:8080&#x2F;ssm-web&#x2F;user&#x2F;login?phone&#x3D;18211111111&amp;password&#x3D;123456</span><br></pre></td></tr></table></figure>
<h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li>生产环境配置文件,配置后台URL</li>
</ul>
<p><code>.env.production</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_NAME &#x3D; Edu Boss</span><br><span class="line">VUE_APP_TITLE &#x3D; Lagou Edu Boss (Dev)</span><br><span class="line"></span><br><span class="line">VUE_APP_STORAGE_PREFIX &#x3D; lagou_edu_boss_dev</span><br><span class="line"></span><br><span class="line">#VUE_APP_API_FAKE &#x3D; &#x2F;front</span><br><span class="line">VUE_APP_API_FAKE &#x3D; http:&#x2F;&#x2F;47.115.139.213:8080&#x2F;ssm-web</span><br><span class="line"></span><br><span class="line">#VUE_APP_API_BASE &#x3D; &#x2F;boss</span><br><span class="line">VUE_APP_API_BASE &#x3D; http:&#x2F;&#x2F;47.115.139.213:8080&#x2F;ssm-web</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义配置文件,配置打包相关信息 </li>
</ul>
<p>将下面内容拷贝到 <strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;/edu-boss/&quot;</span> : <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    indexPath: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    lintOnSave: process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8081</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打包操作"><a href="#打包操作" class="headerlink" title="打包操作"></a>打包操作</h3><ul>
<li>打包命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<ul>
<li>在项目下会生成一个 dist 目录 ,该目录就是我们所需的文件</li>
</ul>
<h3 id="发布前端项目"><a href="#发布前端项目" class="headerlink" title="发布前端项目"></a>发布前端项目</h3><ul>
<li>在Linux系统上复制一个新的tomcat，端口号改为 8081</li>
<li>将dist目录放到tomcat的webapp下</li>
<li>运行tomcat，即可访问前端项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;startup.sh </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态查看日志</span><br><span class="line">tail -f logs&#x2F;catalina.out </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问</span><br><span class="line">http:&#x2F;&#x2F;47.115.139.213:8081&#x2F;edu-boss&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="修改tomcat默认访问项目"><a href="#修改tomcat默认访问项目" class="headerlink" title="修改tomcat默认访问项目"></a>修改tomcat默认访问项目</h2><p>打开tomcat中的server.xml配置文件，找到 <code>host</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入以下内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;edu-boss&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attr">privileged</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启tomcat即可，只需要直接访问 8081即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;47.115.139.213:8081&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="配置nginx反向代理"><a href="#配置nginx反向代理" class="headerlink" title="配置nginx反向代理"></a>配置nginx反向代理</h2><p>1.修改本地hosts, 配置域名映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">47.115.139.213  www.edu-boss.com</span><br></pre></td></tr></table></figure>
<p>2.配置nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置ssm项目 反向代理</span></span><br><span class="line">	upstream lagouedu&#123;</span><br><span class="line">		server 47.115.139.213:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.edu-boss.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://lagouedu;  #转发的地址</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3.访问 <a href="http://www.edu-boss.com/">www.edu-boss.com</a> 即可</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2021/08/15/zookeeper/</url>
    <content><![CDATA[<p>在大数据技术生态圈中，有 zookeeper（动物管理员），Hadoop（大象），Hive（蜜蜂）， Pig（猪）等技术。Zookeeper是一个开源的分布式（多台服务器干一件事）的，为分布式应用提供协调服务的 Apache项目。<a id="more"></a></p>
<p><strong>工作机制</strong></p>
<ul>
<li>Zookeeper从设计模式角度来理解：是一个基于观察者模式（一个人干活，有人盯着他）设计的分 布式服务管理框架 </li>
<li>它负责 存储 和 管理 大家都关心的数据 <ul>
<li>然后接受观察者的<strong>注册</strong>，一旦这些数据的发生变化 </li>
<li>Zookeeper就将负责<strong>通知</strong>已经注册的那些观察者做出相应的反应 </li>
<li>从而实现集群中类似Master/Slave管理模式 </li>
</ul>
</li>
<li>Zookeeper = 文件系统 + 通知机制</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li>是一个leader和多个follower来组成的集群（狮群中，一头雄狮，N头母狮） </li>
<li>集群中只要有半数以上的节点存活，Zookeeper就能正常工作（5台服务器挂2台，没问题；4台服 务器挂2台，就停止） </li>
<li>全局数据一致性，每台服务器都保存一份相同的数据副本，无论client连接哪台server，数据都是 一致的 </li>
<li>数据更新原子性，一次数据要么成功，要么失败（不成功便成仁） </li>
<li>实时性，在一定时间范围内，client能读取到最新数据 </li>
<li>更新的请求按照顺序执行，会按照发送过来的顺序，逐一执行（发来123，执行123，而不是321 或者别的）</li>
</ol>
<p><strong>数据结构</strong></p>
<ul>
<li>ZooKeeper数据模型的结构与linux文件系统很类似，有一个根节点 / ,整体上可以看作是一棵树，每个节点称做一 个ZNode（ZookeeperNode）。 </li>
<li>每一个ZNode默认能够存储1MB的数据（元数据），每个ZNode的路径都是唯一的 <ul>
<li>元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、 资源查找、文件记录等功能</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等</p>
<h1 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h1><p>镜像库地址：<a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a></p>
<p>这里使用的是 apache-zookeeper-3.6.0-bin.tar.gz 版本，已经自带所需要的各种jar包</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.需要jdk环境</p>
<p>2.拷贝apache-zookeeper-3.6.0-bin.tar.gz到opt目录，并解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.重命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-zookeeper-3.6.0-bin zookeeper</span><br></pre></td></tr></table></figure>
<p>4.在/opt/zookeeper/这个目录上创建zkData和zkLog目录</p>
<p>5.在 /opt/zookeeper/conf 路径下，复制一份zoo_sample.cfg配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>6.编辑 zoo.cfg 配置文件，以后就用该配置，修改 dataDir 与 dataLogDir 路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkData</span><br><span class="line">dataLogDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkLog</span><br></pre></td></tr></table></figure>
<h2 id="zoo-cfg配置参数解读"><a href="#zoo-cfg配置参数解读" class="headerlink" title="zoo.cfg配置参数解读"></a>zoo.cfg配置参数解读</h2><ul>
<li>tickTime =2000：通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒 <ul>
<li>Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就 是每个tickTime时间就会发送一个心跳，时间单位为毫秒。 </li>
</ul>
</li>
<li>initLimit =10：LF初始通信时限 <ul>
<li>集群中的Follower跟随者服务器与Leader领导者服务器之间，启动时能容忍的最多心跳数 </li>
<li>10*2000（10个心跳时间）如果领导和跟随者没有发出心跳通信，就视为失效的连接，领导 和跟随者彻底断开 </li>
</ul>
</li>
<li>syncLimit =5：LF同步通信时限 <ul>
<li>集群启动后，Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime-&gt;10秒，Leader就认为Follwer已经死掉，会将Follwer从服务器列表中删除 </li>
</ul>
</li>
<li>dataDir：数据文件目录+数据持久化路径 。主要用于保存Zookeeper中的数据。 </li>
<li>dataLogDir：日志文件目录 </li>
<li>clientPort =2181：客户端连接端口 </li>
</ul>
<h2 id="操作Zookeeper"><a href="#操作Zookeeper" class="headerlink" title="操作Zookeeper"></a>操作Zookeeper</h2><p>1.启动 zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>2.关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh stop</span><br></pre></td></tr></table></figure>
<p>3.查看进程是否启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>QuorumPeerMain：是zookeeper集群的启动入口类，是用来加载配置启动QuorumPeer线程的</p>
<p>4.查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>5.启动客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>6.退出客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper内部原理"><a href="#zookeeper内部原理" class="headerlink" title="zookeeper内部原理"></a>zookeeper内部原理</h1><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><ul>
<li><p><strong>半数机制</strong>：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</p>
</li>
<li><p>虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为 Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的</p>
</li>
</ul>
<p>如果这里有3台服务器，zookeeper集群启动后：</p>
<p>server1先给自己投票，发现票数没过半，就会 把自己的票投给server2;</p>
<p>server2也给自己投一票，此时server2有两票，如果票数过半了，server2就是Leader;</p>
<p>server3也给自己投，但是也只是一票，只好听天由命，承认Server3是 leader</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul>
<li>持久型（persistent）： <ul>
<li><strong>持久化目录节点</strong>（persistent）客户端与zookeeper断开连接后，该节点依旧存在 </li>
<li><strong>持久化顺序编号目录节点</strong>（persistent_sequential）客户端与zookeeper断开连接后，该节 点依旧存在，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调 递增的计数器，由父节点维护，例如：Znode001，Znode002… </li>
</ul>
</li>
<li>短暂型（ephemeral）： <ul>
<li><strong>临时目录节点</strong>（ephemeral）客户端和服务器端断开连接后，创建的节点自动删除 </li>
<li><strong>临时顺序编号目录节点</strong>（ephemeral_sequential）客户端与zookeeper断开连接后，该节点 被删除，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增 的计数器，由父节点维护，例如：Znode001，Znode002…</li>
</ul>
</li>
</ul>
<h2 id="监听原理"><a href="#监听原理" class="headerlink" title="监听原理"></a>监听原理</h2><p><a href="https://imgtu.com/i/fgZ8e0"><img src="https://z3.ax1x.com/2021/08/15/fgZ8e0.png" alt="fgZ8e0.png"></a></p>
<ol>
<li>在main方法中创建Zookeeper客户端的同时就会创建两个线程，一个负责网络连接通信，一个负 责监听 </li>
<li>监听事件就会通过网络通信发送给zookeeper </li>
<li>zookeeper获得注册的监听事件后，立刻将监听事件添加到监听列表里 </li>
<li>zookeeper监听到 数据变化 或 路径变化，就会将这个消息发送给监听线程<ul>
<li>常见的监听 <ol>
<li>监听节点数据的变化：get path [watch] </li>
<li>监听子节点增减的变化：ls path [watch] </li>
</ol>
</li>
</ul>
</li>
<li>监听线程就会在内部调用process方法（需要我们实现process方法内容）</li>
</ol>
<h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><p><a href="https://imgtu.com/i/fgZ9RH"><img src="https://z3.ax1x.com/2021/08/15/fgZ9RH.png" alt="fgZ9RH.png"></a></p>
<ol>
<li>Client 想向 ZooKeeper 的 Server1 上写数据，必须的先发送一个写的请求 </li>
<li>如果Server1不是Leader，那么Server1 会把接收到的请求进一步转发给Leader。 </li>
<li>这个Leader 会将写请求广播给各个Server，各个Server写成功后就会通知Leader。 </li>
<li>当Leader收到半数以上的 Server 数据写成功了，那么就说明数据写成功了。 </li>
<li>随后，Leader会告诉Server1数据写成功了。 </li>
<li>Server1会反馈通知 Client 数据写成功了，整个流结束</li>
</ol>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h2><p>准备好三台Linux服务器，都按照好 zookeeper</p>
<h3 id="配置服务器编号"><a href="#配置服务器编号" class="headerlink" title="配置服务器编号"></a>配置服务器编号</h3><p>1.在/opt/zookeeper/zkData创建myid文件</p>
<p>2.在文件中添加与server对应的编号：1 </p>
<p>3.其余两台服务器分别对应2和3</p>
<h3 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每台服务器上都添加如下配置</span></span><br><span class="line">server.1=192.168.204.141:2888:3888</span><br><span class="line">server.2=192.168.204.142:2888:3888</span><br><span class="line">server.3=192.168.204.143:2888:3888</span><br></pre></td></tr></table></figure>
<p><strong>配置参数解读 server.A=B:C:D</strong> </p>
<ul>
<li><strong>A</strong>：一个数字，表示第几号服务器 集群模式下配置的/opt/zookeeper/zkData/myid文件里面的数据就是A的值 </li>
<li><strong>B</strong>：服务器的ip地址 </li>
<li><strong>C</strong>：与集群中Leader服务器交换信息的端口 </li>
<li><strong>D</strong>：选举时专用端口，万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选 出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</li>
</ul>
<p>启动3台服务器，可通过   <code>./zkServer.sh status</code> 查看状态。</p>
<p><strong>注意</strong>  启动时没过半数以上，集群会失败。超过半数时才会成功，并且已经选举出了 leader</p>
<h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><ul>
<li>显示所有操作命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前znode中所包含的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看当前节点详细数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -s &#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li>cZxid：创建节点的事务 <ul>
<li>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。 </li>
<li>事务ID是ZooKeeper中所有修改总的次序。 </li>
<li>每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。 </li>
</ul>
</li>
<li>ctime：被创建的毫秒数(从1970年开始) </li>
<li>mZxid：最后更新的事务zxid </li>
<li>mtime：最后修改的毫秒数(从1970年开始) </li>
<li>pZxid：最后更新的子节点zxid </li>
<li>cversion：创建版本号，子节点修改次数 </li>
<li>dataVersion：数据变化版本号 </li>
<li>aclVersion：权限版本号 </li>
<li>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点 则是0。 </li>
<li>dataLength：数据长度 </li>
<li>numChildren：子节点数</li>
</ul>
</li>
<li><p>创建节点</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &#x2F;china   # 创建普通节点</span><br><span class="line">create &#x2F;usa &quot;pujing&quot;   # 创建节点并添加数据</span><br><span class="line">create -e &#x2F;hui		# 创建临时节点</span><br><span class="line">create -e -s &#x2F;dog	# 创建临时且带序号节点，序号从0开始递增。</span><br></pre></td></tr></table></figure>
<ul>
<li>修改节点数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set &#x2F;usa &quot;hhh&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>监听 节点的值变化 或 子节点变化（路径变化）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在server1添加监听</span><br><span class="line">addwatch &#x2F;china</span><br><span class="line"># 在server2中修改数据</span><br><span class="line">set &#x2F;china &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p> Server3会立刻响应 </p>
<p>WatchedEvent state:SyncConnected type:<strong>NodeDataChanged</strong> path:/china</p>
<p>如果在china下添加子节点，会响应</p>
<p>WatchedEvent state:SyncConnected type:<strong>NodeCreatedpath</strong>:/china/city</p>
<ul>
<li>删除节点(空节点)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &#x2F;china&#x2F;city</span><br></pre></td></tr></table></figure>
<ul>
<li>递归删除节点 （非空节点，节点下有子节点）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deleteall &#x2F;china</span><br></pre></td></tr></table></figure>
<h2 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建log4j.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO, stdout</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br><span class="line"></span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.File&#x3D;target&#x2F;zk.log</span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure>
<p><strong>创建ZooKeeper客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接zookeeper客户端的ip地址与端口</span></span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="comment">// 集群ip设置</span></span><br><span class="line">    <span class="comment">//    private String connectString = &quot;47.115.139.213:2181,47.115.139.214:2181,47.115.139.215:2181&quot;;</span></span><br><span class="line">    <span class="comment">// 超时时间，两分钟</span></span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper 客户端</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 监听器</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已监听。。。&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;监听类型:&quot;</span>+watchedEvent.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建 zookeeper实例</span></span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建节点</strong></p>
<ul>
<li>节点权限类似linux的文件权限，不同的是共有5种操作：CREATE、READ、WRITE、DELETE、 ADMIN(对应更改ACL的权限) <ul>
<li>OPEN_ACL_UNSAFE：创建开放节点，允许任意操作 （用的最少，其余的权限用的很 少） </li>
<li>READ_ACL_UNSAFE：创建只读节点 </li>
<li>CREATOR_ALL_ACL：创建者才有全部权限</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：要创建的节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：节点数据</span></span><br><span class="line">    <span class="comment">// 参数3：节点权限</span></span><br><span class="line">    <span class="comment">// 参数4：节点的类型</span></span><br><span class="line">    String s = zoo.create(<span class="string">&quot;/hui&quot;</span>, <span class="string">&quot;isMe&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    <span class="comment">// 返回的数据是该节点的一些状态信息</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查询节点的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNodeDate</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    <span class="comment">// 参数3：不知道</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = zoo.getData(<span class="string">&quot;/hui&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Stat());</span><br><span class="line">    System.out.println(<span class="string">&quot;数据为:&quot;</span>+ <span class="keyword">new</span> String(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改节点的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNodeDate</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：修改的数据</span></span><br><span class="line">    <span class="comment">// 参数3：当前节点的数据变化版本号 dataVersion</span></span><br><span class="line">    Stat stat = zoo.setData(<span class="string">&quot;/hui&quot;</span>, <span class="string">&quot;hhhhhh&quot;</span>.getBytes(), <span class="number">0</span>);</span><br><span class="line">    System.out.println(stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：当前节点的数据变化版本号 dataVersion</span></span><br><span class="line">    zoo.delete(<span class="string">&quot;/fuck&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取子节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>监听子节点变化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让程序暂停在此处，如果节点发生变化，就会执行 watcher监听器（初始化zookeeper时传递的）</span></span><br><span class="line">    Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判断节点是否存在</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exist</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    Stat stat = zoo.exists(<span class="string">&quot;/hui2&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat==<span class="keyword">null</span>?<span class="string">&quot;不存在&quot;</span>:<span class="string">&quot;存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例-模拟美团上下线"><a href="#案例-模拟美团上下线" class="headerlink" title="案例-模拟美团上下线"></a>案例-模拟美团上下线</h2><p><strong>需求</strong></p>
<ul>
<li><p>模拟美团服务平台，商家营业通知，商家打烊通知 </p>
</li>
<li><p>提前在根节点下，创建好 /meituan 节点</p>
</li>
</ul>
<p><strong>商家类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String shopName = <span class="string">&quot;FKC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop();</span><br><span class="line">        <span class="comment">// 连接zookeeper （联系美团）</span></span><br><span class="line">        shop.connect();</span><br><span class="line">        <span class="comment">// 创建节点  （入驻美团）</span></span><br><span class="line">        shop.createShop(shopName);</span><br><span class="line">        <span class="comment">// 执行业务逻辑 （营业）</span></span><br><span class="line">        shop.doing(shopName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点，节点为临时有序节点，都已 shop 命名，节点的数据就是商店的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createShop</span><span class="params">(String shopName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo.create(<span class="string">&quot;/meituan/shop&quot;</span>, shopName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+shopName+<span class="string">&quot;]已开张！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行业务逻辑 （营业）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(String shopName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+shopName+<span class="string">&quot;]火爆营业中。。。。&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        <span class="comment">// 连接zookeeper (用户打开美团)</span></span><br><span class="line">        customer.connect();</span><br><span class="line">        <span class="comment">// 获取所有节点数据 (获取所有已开张的商店)</span></span><br><span class="line">        customer.getAllShop();</span><br><span class="line">        <span class="comment">// 执行逻辑代码 (浏览商家)</span></span><br><span class="line">        customer.doing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 重新获取所有数据</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getAllShop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有节点数据 (获取所有已开张的商店)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllShop</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 /meituan 下的所有节点，并开启监听</span></span><br><span class="line">        List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/meituan&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 保存商店名</span></span><br><span class="line">        List&lt;String&gt; shopList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的数据，并放入shopList中</span></span><br><span class="line">            <span class="keyword">byte</span>[] shopName = zoo.getData(<span class="string">&quot;/meituan/&quot;</span>+child, <span class="keyword">false</span>, <span class="keyword">new</span> Stat());</span><br><span class="line">            shopList.add(<span class="keyword">new</span> String(shopName));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前营业商家:&quot;</span>+shopList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行逻辑代码 (浏览商家)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在浏览商家。。&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行客户类就会得到商家列表，如果某一个商家上线或下线，客户类的控制台上都会得到最新的商家列表。</p>
<h2 id="案例-分布式锁"><a href="#案例-分布式锁" class="headerlink" title="案例-分布式锁"></a>案例-分布式锁</h2><p>使用传统的锁引会发的 “羊群效应” ：1000个人创建节点，只有一个人能成功，999 人需要等待,当锁释放时，其余的999人都会去抢这个锁，这样会变得非常散乱。</p>
<p><a href="https://imgtu.com/i/fg8yJ1"><img src="https://z3.ax1x.com/2021/08/15/fg8yJ1.png" alt="fg8yJ1.png"></a></p>
<p><strong>避免“羊群效应”，zookeeper采用分布式锁</strong></p>
<p><a href="https://imgtu.com/i/fgG9Wq"><img src="https://z3.ax1x.com/2021/08/15/fgG9Wq.png" alt="fgG9Wq.png"></a></p>
<ol>
<li>所有请求进来，在/lock下创建 临时顺序节点 ，放心，zookeeper会帮你编号排序 </li>
<li>判断自己是不是/lock下最小的节点 <ol>
<li>是，获得锁（创建节点）</li>
<li> 否，对前面小我一级的节点进行监听</li>
</ol>
</li>
<li>获得锁请求，处理完业务逻辑，释放锁（删除节点），后一个节点得到通知（比你年轻的走了，你 成为最小的了）</li>
</ol>
<h3 id="搭建一个SSM工程"><a href="#搭建一个SSM工程" class="headerlink" title="搭建一个SSM工程"></a>搭建一个SSM工程</h3><p>对<strong>商品表</strong>和<strong>订单表</strong>操作，如果当前商品库存为0就不能继续购买了,如果大于0 就生成订单.</p>
<p><strong>业务层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductMapper productMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceStock</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取库存</span></span><br><span class="line">        Product product = productMapper.getProduct(id);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(product.getStock() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;已抢光！&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.减库存</span></span><br><span class="line">        <span class="keyword">int</span> i = productMapper.reduceStock(id);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 3.生成订单</span></span><br><span class="line">            Order order = <span class="keyword">new</span> Order();</span><br><span class="line">            order.setId(UUID.randomUUID().toString());</span><br><span class="line">            order.setPid(id);</span><br><span class="line">            order.setUserid(<span class="number">101</span>);</span><br><span class="line">            orderMapper.insert(order);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;减库存失败，请重试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>控制层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/reduce&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        orderService.reduceStock(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其余代码省略</strong></p>
<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p><strong>1.启动两个tomcat工程，端口号分别8001和8002</strong></p>
<p><strong>2.使用nginx做负载均衡</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream hui&#123;</span><br><span class="line">    server 192.168.204.1:8001;</span><br><span class="line">    server 192.168.204.1:8002;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://hui;</span><br><span class="line">		root html;</span><br><span class="line">		index index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.使用 JMeter 模拟1秒内发出10个http请求</strong></p>
<p>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p><a href="https://imgtu.com/i/fgYxTe"><img src="https://z3.ax1x.com/2021/08/15/fgYxTe.md.png" alt="fgYxTe.md.png"></a></p>
<p><a href="https://imgtu.com/i/fgt9fA"><img src="https://z3.ax1x.com/2021/08/15/fgt9fA.png" alt="fgt9fA.png"></a></p>
<ol>
<li>查看测试结果，10次请求全部成功 </li>
<li>查看数据库，stock库存从5变成 -5 （并发导致的数据结果错误）</li>
</ol>
<h3 id="使用分布式锁"><a href="#使用分布式锁" class="headerlink" title="使用分布式锁"></a>使用分布式锁</h3><p>基于zookeeper原生态的客户端类实现分布式是非常麻烦的，我们使用apahce提供了一个zookeeper客 户端来实现。Curator：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 网友投票最牛逼版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>在控制层加入分布式锁的逻辑代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String connectString =<span class="string">&quot;192.168.204.141:2181&quot;</span>;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/reduce&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduce</span><span class="params">( <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 重试策略 （1000毫秒试1次，最多试3次）</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//1.创建curator工具对象</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retryPolicy);</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//2.根据工具对象创建“内部互斥锁”</span></span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">&quot;/product_&quot;</span>+id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.加锁</span></span><br><span class="line">            lock.acquire();</span><br><span class="line">            <span class="comment">// 执行原来的业务逻辑操作</span></span><br><span class="line">            productService.reduceStock(id);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException)&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//4.释放锁</span></span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
</search>
