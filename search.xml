<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>urllib与requests库的基本使用</title>
    <url>/2021/04/04/urllib%E4%B8%8Erequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-urllib库-—内置"><a href="#1-urllib库-—内置" class="headerlink" title="1.urllib库   —内置"></a>1.urllib库   —内置</h2><h3 id="urlopen函数："><a href="#urlopen函数：" class="headerlink" title="urlopen函数："></a>urlopen函数：</h3><p>创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。</p>
<p>url：请求的url。<a id="more"></a><br>data：请求的data，如果设置了这个值，那么将变成post请求。<br>返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。</p>
<h3 id="urlretrieve函数："><a href="#urlretrieve函数：" class="headerlink" title="urlretrieve函数："></a>urlretrieve函数：</h3><p>这个函数可以方便的将网页上的一个文件保存到本地。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request.urlretrieve(url,文件名)</span><br></pre></td></tr></table></figure>
<h3 id="urlencode函数：编码"><a href="#urlencode函数：编码" class="headerlink" title="urlencode函数：编码"></a>urlencode函数：编码</h3><p>urlencode可以把字典数据转换为URL编码的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;老王&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line">print(qs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#name=%E8%80%81%E7%8E%8B&amp;age=18&amp;greet=hello+world</span></span><br></pre></td></tr></table></figure>


<h3 id="parse-qs函数：解码"><a href="#parse-qs函数：解码" class="headerlink" title="parse_qs函数：解码"></a>parse_qs函数：解码</h3><p>可以将经过编码后的url参数进行解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(parse.parse_qs(qs))</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: [&#x27;老王&#x27;], &#x27;age&#x27;: [&#x27;18&#x27;], &#x27;greet&#x27;: [&#x27;hello world&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="urlparse和urlsplit函数：解析url"><a href="#urlparse和urlsplit函数：解析url" class="headerlink" title="urlparse和urlsplit函数：解析url"></a>urlparse和urlsplit函数：解析url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/index.html;user?id=S#comment&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"><span class="comment"># result = parse.urlsplit(url)</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line">print(result.scheme)</span><br><span class="line">print(result.netloc)</span><br><span class="line">print(result.path)</span><br><span class="line"><span class="comment">#urlparse里有params属性，而urlsplit没有这个params属性。</span></span><br><span class="line">print(result.params)</span><br></pre></td></tr></table></figure>




<h3 id="request-Request类：网络请求-可以增加请求头"><a href="#request-Request类：网络请求-可以增加请求头" class="headerlink" title="request.Request类：网络请求  可以增加请求头"></a>request.Request类：网络请求  可以增加请求头</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 			(KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rq = request.Request(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(rq)</span><br><span class="line"></span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


<h3 id="ProxyHandler处理器（代理设置）：封ip问题"><a href="#ProxyHandler处理器（代理设置）：封ip问题" class="headerlink" title="ProxyHandler处理器（代理设置）：封ip问题"></a>ProxyHandler处理器（代理设置）：封ip问题</h3><ol>
<li><p>代理原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，代理服务器拿到目的网站的数据后，再转发给我们的代码。</p>
</li>
<li><p><a href="http://httpbin.org：这个网站可以方便的查看http请求的一些参数。">http://httpbin.org：这个网站可以方便的查看http请求的一些参数。</a></p>
</li>
<li><p>在代码中使用代理  示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用代理</span></span><br><span class="line"><span class="comment"># 步骤</span></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/ip&#x27;</span></span><br><span class="line"><span class="comment">#1. 使用ProxyHandler,传入代理构建一个handler</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;122.193.244.243:9999&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#2. 使用上面创建的handler构建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#3. 使用opener去发送一个请求</span></span><br><span class="line">resp = opener.<span class="built_in">open</span>(url)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="cookie-登录"><a href="#cookie-登录" class="headerlink" title="cookie:           登录"></a>cookie:           登录</h3><ol>
<li><p>什么是cookie：指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据</p>
</li>
<li><p>cookie的格式：<br>Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；         Domain=DOMAIN_NAME；SECURE<br>参数意义：<br>NAME：cookie的名字。<br>VALUE：cookie的值。<br>Expires：cookie的过期时间。<br>Path：cookie作用的路径。<br>Domain：cookie作用的域名。<br>SECURE：是否只在https协议下起作用。</p>
</li>
</ol>
<h3 id="http-cookiejar模块：提供用于存储cookie的对象"><a href="#http-cookiejar模块：提供用于存储cookie的对象" class="headerlink" title="http.cookiejar模块：提供用于存储cookie的对象"></a>http.cookiejar模块：提供用于存储cookie的对象</h3><ol>
<li><p>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</p>
</li>
<li><p>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</p>
</li>
<li><p>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</p>
</li>
<li><p>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</p>
</li>
</ol>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span>  CookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录：https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F</span></span><br><span class="line"><span class="comment">#个人网页https://i.meishi.cc/cook.php?id=13686422</span></span><br><span class="line"></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.登录</span></span><br><span class="line"><span class="comment">#1.1 创建cookiejar对象</span></span><br><span class="line">cookiejar = CookieJar()</span><br><span class="line"><span class="comment">#1.2 使用cookiejar创建一个HTTPCookieProcess对象</span></span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line"><span class="comment">#1.3 使用上一步的创建的handler创建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment">#1.4 使用opener发送登录请求  (账号和密码)</span></span><br><span class="line"></span><br><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">post_data = parse.urlencode(&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">req = request.Request(post_url,data=post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">opener.<span class="built_in">open</span>(req)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.访问个人网页</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">rq = request.Request(url,headers=headers)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(rq)</span><br><span class="line">print(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>cookie加载与保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="comment"># cookiejar = MozillaCookieJar(&#x27;cookie.txt&#x27;)</span></span><br><span class="line"><span class="comment"># handler = request.HTTPCookieProcessor(cookiejar)</span></span><br><span class="line"><span class="comment"># opener = request.build_opener(handler)</span></span><br><span class="line"><span class="comment"># resp = opener.open(&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cookiejar.save(ignore_discard=True,ignore_expires=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore_discard=True  即使cookies即将被丢弃也要保存下来</span></span><br><span class="line"><span class="comment"># ignore_expires=True  如果cookies已经过期也将它保存并且文件已存在时将覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookie.txt&#x27;</span>)</span><br><span class="line">cookiejar.load()</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.httpbin.org/cookies/set/course/abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure>


<h2 id="2-requests库-—第三方库"><a href="#2-requests库-—第三方库" class="headerlink" title="2.requests库   —第三方库"></a>2.requests库   —第三方库</h2><p>Requests：让HTTP服务人类</p>
<h3 id="安装和文档地址："><a href="#安装和文档地址：" class="headerlink" title="安装和文档地址："></a>安装和文档地址：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>


<h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加headers和查询参数</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">kw = &#123;<span class="string">&#x27;wd&#x27;</span>:<span class="string">&#x27;中国&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com/s&#x27;</span>,headers=headers,params=kw)</span><br><span class="line">print(response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性</span></span><br><span class="line"><span class="comment"># 查询响应内容</span></span><br><span class="line">print(response.text)  <span class="comment">#返回unicode格式的数据</span></span><br><span class="line">print(response.content) <span class="comment">#返回字节流数据</span></span><br><span class="line">print(response.url)  <span class="comment">#查看完整url地址</span></span><br><span class="line">print(response.encoding) <span class="comment"># 查看响应头部字符编码</span></span><br></pre></td></tr></table></figure>


<h4 id="response-text和response-content的区别："><a href="#response-text和response-content的区别：" class="headerlink" title="response.text和response.content的区别："></a>response.text和response.content的区别：</h4><ol>
<li><code>response.content</code> ：这个是直接从网络上抓取的数据，没有经过任何的编码，所以是一个bytes类型，其实在硬盘上和网络上传输的字符串都是bytes类型</li>
<li><code>response.text</code>：这个是str的数据类型，是requests库将response.content进行解码的字符串，解码需要指定一个编码方式，requests会根据自己的猜测来判断编码的方式，所以有时候可能会猜测错误，就会导致解码产生乱码，这时候就应该进行手动解码，比如使用<code>response.content.decode(&#39;utf-8&#39;)</code></li>
</ol>
<h3 id="发送POST请求："><a href="#发送POST请求：" class="headerlink" title="发送POST请求："></a>发送POST请求：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>,data=data)</span><br></pre></td></tr></table></figure>
<p>POST请求方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;https://www.meishij.net/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.post(url,headers=headers,data=data)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="使用代理："><a href="#使用代理：" class="headerlink" title="使用代理："></a>使用代理：</h3><p>只要在请求的方法中（比如get或者post）传递proxies参数就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;111.77.197.127:9999&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://www.httpbin.org/ip&#x27;</span></span><br><span class="line">resp = requests.get(url,proxies=proxy)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h3><p>基本使用：模拟登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://www.zhihu.com/hot&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_zap=59cde9c3-c5c0-4baa-b756-fa16b5e72b10; d_c0=&quot;APDi1NJcuQ6PTvP9qa1EKY6nlhVHc_zYWGM=|1545737641&quot;; __gads=ID=237616e597ec37ad:T=1546339385:S=ALNI_Mbo2JturZesh38v7GzEeKjlADtQ5Q; _xsrf=pOd30ApWQ2jihUIfq94gn2UXxc0zEeay; q_c1=1767e338c3ab416692e624763646fc07|1554209209000|1545743740000; tst=h; __utma=51854390.247721793.1554359436.1554359436.1554359436.1; __utmc=51854390; __utmz=51854390.1554359436.1.1.utmcsr=zhihu.com|utmccn=(referral)|utmcmd=referral|utmcct=/hot; __utmv=51854390.100-1|2=registration_date=20180515=1^3=entry_date=20180515=1; l_n_c=1; l_cap_id=&quot;OWRiYjI0NzJhYzYwNDM3MmE2ZmIxMGIzYmQwYzgzN2I=|1554365239|875ac141458a2ebc478680d99b9219c461947071&quot;; r_cap_id=&quot;MmZmNDFkYmIyM2YwNDAxZmJhNWU1NmFjOGRkNDNjYjc=|1554365239|54372ab1797cba8c4dd224ba1845dd7d3f851802&quot;; cap_id=&quot;YzQwNGFlYWNmNjY3NDFhNGI4MGMyYjZjYjRhMzQ1ZmE=|1554365239|385cc25e3c4e3b0b68ad5747f623cf3ad2955c9f&quot;; n_c=1; capsion_ticket=&quot;2|1:0|10:1554366287|14:capsion_ticket|44:MmE5YzNkYjgzODAyNDgzNzg5MTdjNmE3NjQyODllOGE=|40d3498bedab1b7ba1a247d9fc70dc0e4f9a4f394d095b0992a4c85e32fd29be&quot;; z_c0=&quot;2|1:0|10:1554366318|4:z_c0|92:Mi4xOWpCeUNRQUFBQUFBOE9MVTBseTVEaVlBQUFCZ0FsVk5iZzJUWFFEWi1JMkxnQXlVUXh2SlhYb3NmWks3d1VwMXRB|81b45e01da4bc235c2e7e535d580a8cc07679b50dac9e02de2711e66c65460c6&quot;; tgw_l7_route=578107ff0d4b4f191be329db6089ff48&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(url,headers=headers)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h4 id="session：共享cookie"><a href="#session：共享cookie" class="headerlink" title="session：共享cookie"></a>session：共享cookie</h4><p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post_url = <span class="string">&#x27;https://i.meishi.cc/login.php?redirect=https%3A%2F%2Fwww.meishij.net%2F&#x27;</span></span><br><span class="line"></span><br><span class="line">post_data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;1097566154@qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;wq15290884759.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(post_url,headers=headers,data=post_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问个人页面</span></span><br><span class="line">url = <span class="string">&#x27;https://i.meishi.cc/cook.php?id=13686422&#x27;</span></span><br><span class="line">resp = session.get(url)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>


<h3 id="处理不信任的SSL证书："><a href="#处理不信任的SSL证书：" class="headerlink" title="处理不信任的SSL证书："></a>处理不信任的SSL证书：</h3><p>对于那些已经被信任的SSL证书的网站，比如<a href="https://www.baidu.com/%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%BF%E7%94%A8requests%E7%9B%B4%E6%8E%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E3%80%82%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = requests.get(<span class="string">&#x27;https://inv-veri.chinatax.gov.cn/&#x27;</span>,verify=<span class="literal">False</span>)</span><br><span class="line">print(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫数据提取基础</title>
    <url>/2021/04/05/%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="XPath语法和lxml模块"><a href="#XPath语法和lxml模块" class="headerlink" title="XPath语法和lxml模块"></a>XPath语法和lxml模块</h1><p>xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p>
<h2 id="XPath节点"><a href="#XPath节点" class="headerlink" title="XPath节点"></a>XPath节点</h2><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p>
<a id="more"></a>

<h2 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h2><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>使用//获取整个页面当中的元素，然后写标签名，然后在写谓语进行提取，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[@lang=<span class="string">&#x27;en&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="需要注意的知识点："><a href="#需要注意的知识点：" class="headerlink" title="需要注意的知识点："></a>需要注意的知识点：</h3><ol>
<li><p>/和//的区别：/代表只获取子节点，//获取子孙节点，一般//用的比较多，当然也要视情况而定</p>
</li>
<li><p>contains：有时候某个属性中包含了多个值，那么可以使用contains函数，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//title[contains(@lang,<span class="string">&#x27;en&#x27;</span>)]</span><br></pre></td></tr></table></figure></li>
<li><p>谓词中下标是从1开始的，不是从0开始的</p>
</li>
</ol>
<h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 将字符串解析为html文档</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">print(html)</span><br><span class="line"><span class="comment"># 按字符串序列化html</span></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="从文件中读取html代码："><a href="#从文件中读取html代码：" class="headerlink" title="从文件中读取html代码："></a>从文件中读取html代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = etree.tostring(html).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="在lxml中使用xpath语法"><a href="#在lxml中使用xpath语法" class="headerlink" title="在lxml中使用xpath语法"></a>在lxml中使用xpath语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法练习</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取所有li标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># for i in result:</span></span><br><span class="line"><span class="comment">#     print(etree.tostring(i))</span></span><br><span class="line"><span class="comment"># 获取所有li元素下的所有class属性的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下href为www.baidu.com的a标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a[@href=&quot;www.baidu.com&quot;]&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下所有span标签：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li//span&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取li标签下的a标签里的所有class：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li/a//@class&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取最后一个li的a的href属性对应的值：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()]/a/@href&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容：</span></span><br><span class="line"><span class="comment"># result = html.xpath(&#x27;//li[last()-1]/a&#x27;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result[0].text)</span></span><br><span class="line"><span class="comment"># 获取倒数第二个li元素的内容的第二种方式：</span></span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="实战（瓜子二手车）"><a href="#实战（瓜子二手车）" class="headerlink" title="实战（瓜子二手车）"></a>实战（瓜子二手车）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;...&#x27;</span> <span class="comment">#自己网页查找</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 根据首页获取所有详情页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHrefs</span>(<span class="params">indexUrl</span>):</span></span><br><span class="line">    <span class="comment"># 获取首页内容</span></span><br><span class="line">    index_url = indexUrl</span><br><span class="line">    res = requests.get(index_url, headers=head)</span><br><span class="line">    text = res.content.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 解析首页内容</span></span><br><span class="line">    html = etree.HTML(text)</span><br><span class="line">    ul = html.xpath(<span class="string">&#x27;//ul[@class=&quot;carlist clearfix js-top&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    hrefs = ul.xpath(<span class="string">&#x27;./li/a/@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取详细页面所需内容，保存到字典中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDetail</span>(<span class="params">detail_url</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.guazi.com&#x27;</span> + detail_url</span><br><span class="line">    detail = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    html = etree.HTML(detail)</span><br><span class="line">    title = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    title = title.replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip()</span><br><span class="line">    info = html.xpath(<span class="string">&#x27;//div[@class=&quot;product-textbox&quot;]/ul/li/span/text()&#x27;</span>)</span><br><span class="line">    price_now = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/span/text()&#x27;</span>)</span><br><span class="line">    price_origin = html.xpath(<span class="string">&#x27;//div[@class=&quot;price-main&quot;]/div/text()&#x27;</span>)</span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    res[<span class="string">&#x27;标题&#x27;</span>] = title</span><br><span class="line">    res[<span class="string">&#x27;里程表&#x27;</span>] = info[<span class="number">2</span>]</span><br><span class="line">    res[<span class="string">&#x27;排量&#x27;</span>] = info[<span class="number">3</span>]</span><br><span class="line">    res[<span class="string">&#x27;变速箱&#x27;</span>] = info[<span class="number">4</span>]</span><br><span class="line">    res[<span class="string">&#x27;价格&#x27;</span>] = price_now</span><br><span class="line">    res[<span class="string">&#x27;原价&#x27;</span>] = price_origin</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guazhi.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入文件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 遍历一到六页</span></span><br><span class="line">            hrefs = getHrefs(url.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">                detail = getDetail(href)</span><br><span class="line">                <span class="comment"># 开始文件写入</span></span><br><span class="line">                f.write(</span><br><span class="line">                    <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(detail[<span class="string">&#x27;标题&#x27;</span>], detail[<span class="string">&#x27;里程表&#x27;</span>], detail[<span class="string">&#x27;排量&#x27;</span>], detail[<span class="string">&#x27;变速箱&#x27;</span>], detail[<span class="string">&#x27;价格&#x27;</span>],</span><br><span class="line">                                                 detail[<span class="string">&#x27;原价&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url=<span class="string">&#x27;https://www.guazi.com/nc/buy/o&#123;&#125;/#bread&#x27;</span></span><br><span class="line">    main(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="BeautifulSoup4库"><a href="#BeautifulSoup4库" class="headerlink" title="BeautifulSoup4库"></a>BeautifulSoup4库</h1><p>和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。</p>
<h2 id="安装和文档："><a href="#安装和文档：" class="headerlink" title="安装和文档："></a>安装和文档：</h2><p>安装：<br>pip install bs4</p>
<p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>
<h2 id="常见的四种对象："><a href="#常见的四种对象：" class="headerlink" title="常见的四种对象："></a>常见的四种对象：</h2><ol>
<li>Tag：BeautifulSoup中所有的标签都是Tag类型，并且BeautifulSoup的对象其实本质上也是一个Tag类型。所以其实一些方法比如find、find_all并不是BeautifulSoup的，而是Tag的。</li>
<li>NavigableString：继承自python中的str，用起来就跟使用python的str是一样的。</li>
<li>BeautifulSoup：继承自Tag。用来生成BeaufifulSoup树的。对于一些查找方法，比如find、select这些，其实还是Tag的。</li>
<li>Comment：这个也没什么好说，就是继承自NavigableString。</li>
</ol>
<h2 id="contents和children："><a href="#contents和children：" class="headerlink" title="contents和children："></a>contents和children：</h2><p>返回某个标签下的直接子元素，其中也包括字符串。他们两的区别是：contents返回来的是一个列表，children返回的是一个迭代器。</p>
<h2 id="string和strings、stripped-strings属性以及get-text方法"><a href="#string和strings、stripped-strings属性以及get-text方法" class="headerlink" title="string和strings、stripped_strings属性以及get_text方法"></a>string和strings、stripped_strings属性以及get_text方法</h2><ol>
<li>string：获取某个标签下的非标签字符串。返回来的是个字符串。如果这个标签下有多行字符，那么就不能获取到了。</li>
<li>strings：获取某个标签下的子孙非标签字符串。返回来的是个生成器。</li>
<li>stripped_strings：获取某个标签下的子孙非标签字符串，会去掉空白字符。返回来的是个生成器。</li>
<li>get_text：获取某个标签下的子孙非标签字符串，以普通字符串形式返回</li>
</ol>
<h2 id="find-all的使用："><a href="#find-all的使用：" class="headerlink" title="find_all的使用："></a>find_all的使用：</h2><ol>
<li>在提取标签的时候，第一个参数是标签的名字。然后如果在提取标签的时候想要使用标签属性进行过滤，那么可以在这个方法中通过关键字参数的形式，将属性的名字以及对应的值传进去。或者是使用<code>attrs</code>属性，将所有的属性以及对应的值放在一个字典中传给<code>attrs</code>属性。</li>
<li>有些时候，在提取标签的时候，不想提取那么多，那么可以使用<code>limit</code>参数。限制提取多少个。</li>
</ol>
<h2 id="find与find-all的区别："><a href="#find与find-all的区别：" class="headerlink" title="find与find_all的区别："></a>find与find_all的区别：</h2><ol>
<li>find：找到第一个满足条件的标签就返回。说白了，就是只会返回一个元素。</li>
<li>find_all:将所有满足条件的标签都返回。说白了，会返回很多标签（以列表的形式）。</li>
</ol>
<h2 id="使用find和find-all的过滤条件："><a href="#使用find和find-all的过滤条件：" class="headerlink" title="使用find和find_all的过滤条件："></a>使用find和find_all的过滤条件：</h2><ol>
<li>关键字参数：将属性的名字作为关键字参数的名字，以及属性的值作为关键字参数的值进行过滤。</li>
<li>attrs参数：将属性条件放到一个字典中，传给attrs参数。</li>
</ol>
<h2 id="获取标签的属性："><a href="#获取标签的属性：" class="headerlink" title="获取标签的属性："></a>获取标签的属性：</h2><ol>
<li><p>通过下标获取：通过标签的下标的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>通过attrs属性获取：示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">href = a.attrs[<span class="string">&#x27;href&#x27;</span>]</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="CSS选择器："><a href="#CSS选择器：" class="headerlink" title="CSS选择器："></a>CSS选择器：</h2><h3 id="select方法："><a href="#select方法：" class="headerlink" title="select方法："></a>select方法：</h3><p>使用以上方法可以方便的找出元素。但有时候使用<code>css</code>选择器的方式可以更加的方便。使用<code>css</code>选择器的语法，应该使用<code>select</code>方法。以下列出几种常用的<code>css</code>选择器方法：</p>
<h4 id="（1）通过标签名查找："><a href="#（1）通过标签名查找：" class="headerlink" title="（1）通过标签名查找："></a>（1）通过标签名查找：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（2）通过类名查找："><a href="#（2）通过类名查找：" class="headerlink" title="（2）通过类名查找："></a>（2）通过类名查找：</h4><p>通过类名，则应该在类的前面加一个<code>.</code>。比如要查找<code>class=sister</code>的标签。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（3）通过id查找："><a href="#（3）通过id查找：" class="headerlink" title="（3）通过id查找："></a>（3）通过id查找：</h4><p>通过id查找，应该在id的名字前面加一个＃号。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;#link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（4）组合查找："><a href="#（4）组合查找：" class="headerlink" title="（4）组合查找："></a>（4）组合查找：</h4><p>组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;p #link1&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>直接子标签查找，则使用 &gt; 分隔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（5）通过属性查找："><a href="#（5）通过属性查找：" class="headerlink" title="（5）通过属性查找："></a>（5）通过属性查找：</h4><p>查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="（6）获取内容"><a href="#（6）获取内容" class="headerlink" title="（6）获取内容"></a>（6）获取内容</h4><p>以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.select(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    print(title.get_text())</span><br></pre></td></tr></table></figure>
<h3 id="实战（豆瓣top250）"><a href="#实战（豆瓣top250）" class="headerlink" title="实战（豆瓣top250）"></a>实战（豆瓣top250）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据首页获取所有详细页的网址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    lis = soup.find(<span class="string">&#x27;ol&#x27;</span>, class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    hrefs = []</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">        href = li.find(<span class="string">&#x27;a&#x27;</span>)[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">        hrefs.append(href)</span><br><span class="line">    <span class="keyword">return</span> hrefs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据详情页获取相关信息并写入文件f中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_detail</span>(<span class="params">url, f</span>):</span></span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    div = soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">    <span class="comment"># 电影名</span></span><br><span class="line">    name = <span class="built_in">list</span>(div.find(<span class="string">&#x27;h1&#x27;</span>).stripped_strings)</span><br><span class="line">    div = div.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;subjectwrap clearfix&#x27;</span>)</span><br><span class="line">    info = div.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;info&#x27;</span>).find_all(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;attrs&#x27;</span>)</span><br><span class="line">    <span class="comment"># 导演</span></span><br><span class="line">    direct = <span class="built_in">list</span>(info[<span class="number">0</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 编剧</span></span><br><span class="line">    production = <span class="built_in">list</span>(info[<span class="number">1</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 演员</span></span><br><span class="line">    actor = <span class="built_in">list</span>(info[<span class="number">2</span>].stripped_strings)</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    score = div.find(<span class="string">&#x27;strong&#x27;</span>, class_=<span class="string">&#x27;ll rating_num&#x27;</span>).string</span><br><span class="line">    f.write(</span><br><span class="line">        <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>.join(name), <span class="string">&#x27;&#x27;</span>.join(direct), <span class="string">&#x27;&#x27;</span>.join(production), <span class="string">&#x27;&#x27;</span>.join(actor), <span class="string">&#x27;&#x27;</span>.join(score)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(name) + <span class="string">&#x27;写入完毕&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>, <span class="number">25</span>): <span class="comment"># 获取所有页数</span></span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        hrefs = get_detail_url(url) <span class="comment"># 获取所有详情页的url</span></span><br><span class="line">        <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                res = write_detail(href, f)</span><br><span class="line">                print(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><h2 id="单字符匹配："><a href="#单字符匹配：" class="headerlink" title="单字符匹配："></a>单字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配某个字符串：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;b&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点（.）：匹配任意的字符(除了&#x27;\n&#x27;)：</span></span><br><span class="line"><span class="comment"># text = &quot;\nabc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;.&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \d：匹配任意的数字：</span></span><br><span class="line"><span class="comment"># text = &quot;aab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\d&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \D：匹配任意的非数字：</span></span><br><span class="line"><span class="comment"># text = &quot;cab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\D&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \s：匹配的是空白字符（包括：\n，\t，\r和空格）：</span></span><br><span class="line"><span class="comment"># text = &quot; ab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\s&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \S：非空白字符：</span></span><br><span class="line"><span class="comment"># text = &quot;\nab&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\S&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \w：匹配的是a-z和A-Z以及数字和下划线：</span></span><br><span class="line"><span class="comment"># text = &quot;+bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\w&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \W：匹配的是和\w相反的：</span></span><br><span class="line"><span class="comment"># text = &quot;1bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;\W&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []组合的方式，只要满足中括号中的某一项都算匹配成功：</span></span><br><span class="line"><span class="comment"># text = &quot;bc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[1b]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式[0-9]\d：</span></span><br><span class="line"><span class="comment"># text = &quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ret = re.match(&#x27;[^0-9]&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br><span class="line"><span class="comment"># print(&quot;=&quot;*30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用组合的方式实现\w：</span></span><br><span class="line">text = <span class="string">&quot;+bc&quot;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;[^a-zA-Z0-9_]&#x27;</span>,text)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多字符匹配："><a href="#多字符匹配：" class="headerlink" title="多字符匹配："></a>多字符匹配：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *：匹配0个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\D*&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># +：匹配1个或者多个字符：</span></span><br><span class="line"><span class="comment"># text = &quot;1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ?：匹配前一个字符0个或者1个：</span></span><br><span class="line"><span class="comment"># text = &quot;+abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w?&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m&#125;：匹配m个字符:</span></span><br><span class="line"><span class="comment"># text = &quot;+1abc&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&#x27;\w&#123;2&#125;&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;m,n&#125;：匹配m-n之间的个数的字符：</span></span><br><span class="line">text = <span class="string">&quot;1abc+&quot;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;\w&#123;1,3&#125;&#x27;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="开始-结束-贪婪和非贪婪："><a href="#开始-结束-贪婪和非贪婪：" class="headerlink" title="开始/结束/贪婪和非贪婪："></a>开始/结束/贪婪和非贪婪：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ^：以...开头：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;world&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $：以...结尾：</span></span><br><span class="line"><span class="comment"># text = &quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;hello$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"><span class="comment"># text = &quot;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;^$&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># |：匹配多个字符串或者表达式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪婪和非贪婪：在后面加 ?</span></span><br><span class="line"><span class="comment"># text = &quot;12345&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;\d+?&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：提取html标签名称：</span></span><br><span class="line"><span class="comment"># text = &quot;&lt;h1&gt;这是标题&lt;/h1&gt;&quot;</span></span><br><span class="line"><span class="comment"># result = re.search(&quot;&lt;.+?&gt;&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：验证一个字符是不是0-100之间的数字：</span></span><br><span class="line"><span class="comment"># 0,1,99,100</span></span><br><span class="line"><span class="comment"># 01</span></span><br><span class="line">text = <span class="string">&quot;101&quot;</span></span><br><span class="line">result = re.match(<span class="string">&quot;0$|[1-9]\d?$|100$&quot;</span>,text)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<h2 id="转义字符和原生字符串："><a href="#转义字符和原生字符串：" class="headerlink" title="转义字符和原生字符串："></a>转义字符和原生字符串：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的转义字符：</span></span><br><span class="line"><span class="comment"># raw</span></span><br><span class="line"><span class="comment"># text = r&quot;hello\nworld&quot;</span></span><br><span class="line"><span class="comment"># print(text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式中的转义字符：</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,range price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(&quot;\$\d+&quot;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生字符串和正则表达式：</span></span><br><span class="line"><span class="comment"># 正则表达式的字符串解析规则：</span></span><br><span class="line"><span class="comment"># 1. 先把这个字符串放在Python语言层面进行解析。</span></span><br><span class="line"><span class="comment"># 2. 把Python语言层面解析的结果再放到正则表达式层间进行解析。</span></span><br><span class="line">text = <span class="string">&quot;\cba c&quot;</span></span><br><span class="line"><span class="comment"># result = re.match(&quot;\\\\c&quot;,text) # \\\\c =(Python语言层面)&gt; \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">result = re.match(<span class="string">r&quot;\\c&quot;</span>,text) <span class="comment"># \\c =(正则表达式层面)&gt; \c</span></span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<h2 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line">result = re.search(<span class="string">&#x27;.+(\$\d+).+(\$\d+)&#x27;</span>,text)</span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># group()/group(0)：匹配整个分组</span></span><br><span class="line"><span class="comment"># group(1)：匹配第一个分组</span></span><br><span class="line"><span class="comment"># group(2)：匹配第二个分组</span></span><br><span class="line"><span class="comment"># groups()：获取所有的分组</span></span><br></pre></td></tr></table></figure>

<h2 id="re中常用的函数："><a href="#re中常用的函数：" class="headerlink" title="re中常用的函数："></a>re中常用的函数：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># findall：查找所有满足条件的</span></span><br><span class="line"><span class="comment"># text = &quot;apple price is $99,orange price is $88&quot;</span></span><br><span class="line"><span class="comment"># result = re.findall(r&#x27;\$\d+&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub：根据规则替换其他字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># new_text = text.replace(&quot; &quot;,&quot;\n&quot;)</span></span><br><span class="line"><span class="comment"># new_text = re.sub(r&#x27; |,&#x27;,&#x27;\n&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(new_text)</span></span><br><span class="line"><span class="comment"># html = &quot;&lt;p&gt;4、有机会转为招商银行内部员工；&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="comment"># new_html = re.sub(r&#x27;&lt;.+?&gt;&#x27;,&quot;&quot;,html)</span></span><br><span class="line"><span class="comment"># print(new_html)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split：根据规则分割字符串</span></span><br><span class="line"><span class="comment"># text = &quot;nihao zhongguo,hello world&quot;</span></span><br><span class="line"><span class="comment"># result = re.split(r&#x27; |,&#x27;,text)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile：编译正则表达式</span></span><br><span class="line">text = <span class="string">&quot;apple price is 34.56&quot;</span></span><br><span class="line"><span class="comment"># r = re.compile(r&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># \d+ # 整数部分</span></span><br><span class="line"><span class="comment"># \.? # 小数点</span></span><br><span class="line"><span class="comment"># \d* # 小数部分</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;,re.VERBOSE)</span></span><br><span class="line"><span class="comment"># result = re.search(r,text)</span></span><br><span class="line">result = re.search(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">\d+ # 整数部分</span></span><br><span class="line"><span class="string">\.? # 小数点</span></span><br><span class="line"><span class="string">\d* # 小数部分</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>,text,re.VERBOSE)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<p>如果想要在正则表达式中加注释，那么需要在正则表达式的函数最后加一个<code>re.VERBOSE</code>。</p>
<h3 id="实战-糗事百科"><a href="#实战-糗事百科" class="headerlink" title="实战(糗事百科)"></a>实战(糗事百科)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span>&#125;</span><br><span class="line">    html = requests.get(url, headers=head).content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使用正则表达式直接切割</span></span><br><span class="line">    texts = re.findall(<span class="string">&#x27;&lt;div\sclass=&quot;content&quot;&gt;.+?&lt;span&gt;(.+?)&lt;/span&gt;&#x27;</span>, html, re.DOTALL)</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># 去除多余标签</span></span><br><span class="line">        text = re.sub(<span class="string">&#x27;&lt;br/&gt;+?&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        print(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.qiushibaike.com/text/page/&#123;&#125;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>):</span><br><span class="line">        url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        get_detail(url)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据提取</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程爬虫</title>
    <url>/2021/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="如何创建一个基本的多线程："><a href="#如何创建一个基本的多线程：" class="headerlink" title="如何创建一个基本的多线程："></a>如何创建一个基本的多线程：</h2><p>使用<code>threading</code>模块下的<code>Thread</code>类即可创建一个线程。这个类有一个<code>target</code>参数，需要指定一个函数，那么以后这个线程执行的时候，就会执行这个函数的代码。示例代码如下：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">code</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        thread = threading.current_thread()</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=code, name=<span class="string">&quot;胖虎&quot;</span>)</span><br><span class="line">    t2 = threading.Thread(target=dance, name=<span class="string">&quot;静香&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    multi_thread() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="查看当前线程："><a href="#查看当前线程：" class="headerlink" title="查看当前线程："></a>查看当前线程：</h2><ol>
<li>threading.current_thread：在线程中执行这个函数，会返回当前线程的对象,如上面例子可以给线程取名。</li>
<li>threading.enumerate：获取整个程序中所有的线程。</li>
</ol>
<h2 id="继承自threading-Thread类："><a href="#继承自threading-Thread类：" class="headerlink" title="继承自threading.Thread类："></a>继承自threading.Thread类：</h2><ol>
<li><p>自己写的类继承自<code>threading.Thread</code>类。</p>
</li>
<li><p>线程代码需要放在run方法中执行。</p>
</li>
<li><p>以后创建线程的时候，直接使用我们自己创建的类来创建线程就可以了。</p>
</li>
<li><p>为什么要使用类的方式创建线程呢？原因是因为类可以更加方便的管理我们的代码，可以让我们使用面向对象的方式进行编程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在写代码。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dance</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            thread = threading.current_thread()</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; &#123;&#125;在跳舞。。&quot;</span>.<span class="built_in">format</span>(i, thread.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread_plus</span>():</span></span><br><span class="line">    t1 = Code()</span><br><span class="line">    t2 = Dance()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="全局变量共享的问题："><a href="#全局变量共享的问题：" class="headerlink" title="全局变量共享的问题："></a>全局变量共享的问题：</h2><p>在多线程中，如果需要修改全局变量，那么需要在修改全局变量的地方使用锁锁起来，执行完成后再把锁释放掉。<br>使用锁的原则：</p>
<ol>
<li><strong>把尽量少的和不耗时的代码放到锁中执行。</strong></li>
<li><strong>代码执行完成后要记得释放锁。</strong><br>在Python中，可以使用<code>threading.Lock</code>来创建锁，<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作。</li>
</ol>
<h2 id="生产者和消费者模式："><a href="#生产者和消费者模式：" class="headerlink" title="生产者和消费者模式："></a>生产者和消费者模式：</h2><p>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。通过生产者和消费者模式，可以让代码达到高内聚低耦合的目标，程序分工更加明确，线程更加方便管理。</p>
<h3 id="Lock版本的生产者和消费者模式："><a href="#Lock版本的生产者和消费者模式：" class="headerlink" title="Lock版本的生产者和消费者模式："></a>Lock版本的生产者和消费者模式：</h3><p>通过<code>lock.acquire()</code>是上锁操作，<code>lock.release()</code>是释放锁的操作</p>
<h2 id="Condition版本的生产者和消费者模式："><a href="#Condition版本的生产者和消费者模式：" class="headerlink" title="Condition版本的生产者和消费者模式："></a>Condition版本的生产者和消费者模式：</h2><p>Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下是一些常用的函数：</p>
<ol>
<li>acquire：上锁。</li>
<li>release：解锁。</li>
<li>wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li>
<li>notify：通知某个正在等待的线程，默认是第1个等待的线程。</li>
<li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li>
</ol>
<h2 id="线程安全的队列Queue："><a href="#线程安全的队列Queue：" class="headerlink" title="线程安全的队列Queue："></a>线程安全的队列Queue：</h2><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：<br>初始化Queue(maxsize)：创建一个先进先出的队列。</p>
<ol>
<li>qsize()：返回队列的大小。</li>
<li>empty()：判断队列是否为空。</li>
<li>full()：判断队列是否满了。</li>
<li>get()：从队列中取最后一个数据。默认情况下是阻塞的，也就是说如果队列已经空了，那么再调用就会一直阻塞，直到有新的数据添加进来。也可以使用<code>block=False</code>，来关掉阻塞。如果关掉了阻塞，在队列为空的情况获取就会抛出异常。</li>
<li>put()：将一个数据放到队列中。跟get一样，在队列满了的时候也会一直阻塞，并且也可以通过block=False来关掉阻塞，同样也会抛出异常。</li>
</ol>
<h3 id="实战（下载王者荣耀壁纸）"><a href="#实战（下载王者荣耀壁纸）" class="headerlink" title="实战（下载王者荣耀壁纸）"></a>实战（下载王者荣耀壁纸）</h3><h4 id="版本一-不加线程"><a href="#版本一-不加线程" class="headerlink" title="版本一: 不加线程"></a>版本一: 不加线程</h4><p>壁纸的内容是通过后台数据渲染上去的，这些数据是通过</p>
<p>“workList_inc.cgi?activityId=2735&amp;sVerifyCode=ABCD&amp;…267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1618065287348”</p>
<p>该请求获取的，获取该请求的url，就可以获取json数据，json数据中有图片的地址及其他详细信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据主页获取所有详细照片的内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://pvp.qq.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;....&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将获取到的数据变成json格式，即dict个数</span></span><br><span class="line">    datas = requests.get(url, headers=head).json()</span><br><span class="line">    <span class="keyword">return</span> datas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析json详细照片内容,将照片的真实递增返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        url = parse.unquote(data[<span class="string">&#x27;sProdImgNo_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)])</span><br><span class="line">        url = url.replace(<span class="string">&quot;/200&quot;</span>, <span class="string">&quot;/0&quot;</span>)</span><br><span class="line">        urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=0&amp;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>): <span class="comment"># 获取25页全部内容</span></span><br><span class="line">        page_url = base_url.<span class="built_in">format</span>(page)</span><br><span class="line">        datas = get_detail(page_url)</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">            urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">            name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">            <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">            dir_name = os.path.join(<span class="string">&#x27;image01&#x27;</span>, name)</span><br><span class="line">            os.mkdir(dir_name)  <span class="comment"># 创建该文件</span></span><br><span class="line">            print(name)</span><br><span class="line">            <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                print(url)</span><br><span class="line">                <span class="comment"># 开始下载</span></span><br><span class="line">                request.urlretrieve(url, os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(index))))</span><br><span class="line">                print(dir_name + <span class="string">&quot;\\&quot;</span> + <span class="built_in">str</span>(index + <span class="number">1</span>) + <span class="string">&quot;保存完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="版本二：-加线程"><a href="#版本二：-加线程" class="headerlink" title="版本二： 加线程"></a>版本二： 加线程</h4><p>get_detail 与 get_data 两个后去数据的方法不变，其他的进行优化</p>
<p>1.把所有page页的url放入page_queen队列中，让多个生产者根据队列中url生产图片的地址，并保存到image_queen队列中；</p>
<p>2.多个消费者根据page_queen队列中的内容消费，即根据对应图片url下载图片</p>
<p>注: 继承threading.Thread类如果要传参数，就需要重写初始化（init） 方法 , 还需调用父类的init方法</p>
<p>super(Product, self).<strong>init</strong>(*args, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产图片地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, page_queen, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Product, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queen = page_queen</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.page_queen.empty():</span><br><span class="line">            datas = get_detail(self.page_queen.get())</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> datas[<span class="string">&#x27;List&#x27;</span>]:</span><br><span class="line">                name = parse.unquote(data[<span class="string">&#x27;sProdName&#x27;</span>])  <span class="comment"># 获取名字</span></span><br><span class="line">                print(name)</span><br><span class="line">                <span class="comment"># 根据名字与图片保存到image文件中</span></span><br><span class="line">                dir_name = os.path.join(<span class="string">&#x27;image02&#x27;</span>, name)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):  <span class="comment"># 创建该文件</span></span><br><span class="line">                    os.mkdir(dir_name)</span><br><span class="line">                urls = get_data(data)  <span class="comment"># 获取到真实图片地址</span></span><br><span class="line">                <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">                    image_detail = &#123;<span class="string">&#x27;image_url&#x27;</span>: url,</span><br><span class="line">                                    <span class="string">&#x27;image_path&#x27;</span>: os.path.join(dir_name, <span class="string">&#x27;&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(index+<span class="number">1</span>))&#125;</span><br><span class="line">                    self.image_queen.put(image_detail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费图片地址，下载到本地</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, image_queen, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.image_queen = image_queen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                image_detail = self.image_queen.get(timeout=<span class="number">10</span>)  <span class="comment"># 10秒超时就会报错</span></span><br><span class="line">                url = image_detail.get(<span class="string">&#x27;image_url&#x27;</span>)</span><br><span class="line">                path = image_detail.get(<span class="string">&#x27;image_path&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(url, path)</span><br><span class="line">                    print(path + <span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(path + <span class="string">&quot;下载失败&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    base_url = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    https://apps.game.qq.com/cgi-bin/ams/module/ishow/V1.0/query/workList_inc.cgi?</span></span><br><span class="line"><span class="string">    activityId=2735&amp;sVerifyCode=ABCD&amp;sDataType=JSON&amp;iListNum=20&amp;totalpage=0&amp;page=&#123;&#125;</span></span><br><span class="line"><span class="string">    iOrder=0&amp;iSortNumClose=1&amp;iAMSActivityId=51991&amp;</span></span><br><span class="line"><span class="string">    _everyRead=true&amp;iTypeId=2&amp;iFlowId=267733&amp;iActId=2735&amp;iModuleId=2735&amp;_=1617974182197</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    page_queen = queue.Queue(<span class="number">25</span>)  <span class="comment"># 保存基本页的安全队列</span></span><br><span class="line">    image_queen = queue.Queue(<span class="number">1000</span>)  <span class="comment"># 保存图片地址的安全队列</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):  <span class="comment"># 获取25页地址</span></span><br><span class="line">        page_queen.put(base_url.<span class="built_in">format</span>(page))</span><br><span class="line">        print(page_queen.get())</span><br><span class="line">    <span class="comment"># 3个生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        product = Product(page_queen, image_queen, name=<span class="string">&#x27;生产者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        product.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5个消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        consumer = Consumer(image_queen, name=<span class="string">&#x27;消费者&#123;&#125;号&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        consumer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>动态爬虫</title>
    <url>/2021/04/10/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="动态网页爬虫的解决方案："><a href="#动态网页爬虫的解决方案：" class="headerlink" title="动态网页爬虫的解决方案："></a>动态网页爬虫的解决方案：</h2><ol>
<li>直接分析ajax调用的接口。然后通过代码请求这个接口。</li>
<li>使用Selenium+chromedriver模拟浏览器行为获取数据。</li>
</ol>
<a id="more"></a>

<h2 id="selenium和chromedriver："><a href="#selenium和chromedriver：" class="headerlink" title="selenium和chromedriver："></a>selenium和chromedriver：</h2><p>基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># chromedriver在本地的地址</span></span><br><span class="line">path = <span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span></span><br><span class="line">driver = webdriver.Chrome(path)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用selenium关闭浏览器："><a href="#使用selenium关闭浏览器：" class="headerlink" title="使用selenium关闭浏览器："></a>使用selenium关闭浏览器：</h3><ol>
<li>driver.close():关闭当前的页面。</li>
<li>driver.quit()：关闭整个浏览器。</li>
</ol>
<h3 id="selenium定位元素："><a href="#selenium定位元素：" class="headerlink" title="selenium定位元素："></a>selenium定位元素：</h3><ol>
<li>find_element_by_id：根据id来查找某个元素。</li>
<li>find_element_by_class_name：根据类名查找元素。</li>
<li>find_element_by_name：根据name属性的值来查找元素。</li>
<li>find_element_by_tag_name：根据标签名来查找元素。</li>
<li>find_element_by_xpath：根据xpath语法来获取元素。</li>
<li>find_element_by_css_selector：根据css选择器选择元素。</li>
<li>find_element_by_link_text: 根据超链接的文本选中元素</li>
</ol>
<p>要注意，find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素，find_element_by_id除外</p>
<h3 id="selenium表单操作："><a href="#selenium表单操作：" class="headerlink" title="selenium表单操作："></a>selenium表单操作：</h3><ol>
<li><p>webelement.send_keys：给输入框填充内容。</p>
</li>
<li><p>webelement.click：点击。</p>
</li>
<li><p>操作select标签：需要首先用<code>from selenium.webdriver.support.ui import Select</code>来包装一下选中的对象，才能进行<code>select</code>选择：</p>
<ul>
<li>select_by_index：按索引进行选择。</li>
<li>select_by_value：按值进行选择。</li>
<li>select_by_visible_text：按照可见文本进行选择。</li>
</ul>
<h5 id="登入知乎小案例"><a href="#登入知乎小案例" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line">login = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">login.click()</span><br><span class="line">username = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">username.send_keys(<span class="string">&#x27;17379621235&#x27;</span>)</span><br><span class="line">password.send_keys(<span class="string">&#x27;12313&#x27;</span>)</span><br><span class="line">do_login = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line">do_login.click()</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="selenium行为链："><a href="#selenium行为链：" class="headerlink" title="selenium行为链："></a>selenium行为链：</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类selenium.webdriver.common.action_chains.ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。</p>
<h4 id="登入知乎小案例-1"><a href="#登入知乎小案例-1" class="headerlink" title="登入知乎小案例"></a>登入知乎小案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&#x27;C:\project\pyCode\chromedriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.zhihu.com/signin?next=%2F&#x27;</span>)</span><br><span class="line"><span class="comment"># 激活行为链</span></span><br><span class="line">chains = ActionChains(driver)</span><br><span class="line"><span class="comment"># 移动到密码登入，再单击,进入到密码登入</span></span><br><span class="line">loginTag = driver.find_elements_by_class_name(<span class="string">&#x27;SignFlow-tab&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">chains.move_to_element(loginTag)</span><br><span class="line">chains.click()</span><br><span class="line">chains.perform()</span><br><span class="line">usernameTag = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">passwordTag = driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">doLoginTag = driver.find_element_by_class_name(<span class="string">&#x27;SignFlow-submitButton&#x27;</span>)</span><br><span class="line"><span class="comment"># 移动到用户名表单，再输入</span></span><br><span class="line">chains.move_to_element(usernameTag)</span><br><span class="line">chains.send_keys_to_element(usernameTag,<span class="string">&quot;17379621235&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到密码表单，再输入</span></span><br><span class="line">chains.move_to_element(passwordTag)</span><br><span class="line">chains.send_keys_to_element(passwordTag,<span class="string">&quot;xxxxxxxx&quot;</span>)</span><br><span class="line"><span class="comment"># 移动到登入按钮，再单击</span></span><br><span class="line">chains.move_to_element(doLoginTag)</span><br><span class="line">chains.click()</span><br><span class="line"><span class="comment"># 执行上面操作</span></span><br><span class="line">chains.perform()</span><br></pre></td></tr></table></figure>
<p>还有更多的鼠标相关的操作。<br>click_and_hold(element)：点击但不松开鼠标。<br>context_click(element)：右键点击。<br>double_click(element)：双击。 </p>
<p>更多方法请参考：<a href="http://selenium-python.readthedocs.io/api.html">http://selenium-python.readthedocs.io/api.html</a></p>
<p><strong>为什么需要行为链条？</strong><br>因为有些网站可能会在浏览器端做一些验证行为是否符合人类的行为来做反爬虫。这时候我们就可以使用行为链来模拟人的操作。行为链有更多的复杂操作，比如双击，右键等，在自动化测试中非常有用。</p>
<h3 id="操作cookie："><a href="#操作cookie：" class="headerlink" title="操作cookie："></a>操作cookie：</h3><ol>
<li><p>获取所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure></li>
<li><p>根据cookie的key获取value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>删除所有的cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure></li>
<li><p>删除某个cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure></li>
<li><p>添加cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.add_cookie(&#123;“name”:”username”,”value”:”abc”&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="隐式等待和显式等待："><a href="#隐式等待和显式等待：" class="headerlink" title="隐式等待和显式等待："></a>隐式等待和显式等待：</h3></li>
<li><p>隐式等待：指定一个时间，在这个时间内一直会处于等待状态。隐式等待需要使用<code>driver.implicitly_wait</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"><span class="comment"># 隐式等待</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># 等待10秒</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;ksdjflksd&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>显式等待：指定在某个时间内，如果某个条件满足了，那么就不会再等待，如果在指定的时间内条件都不满足，那么就不会再等待了。显式等待用的方法是<code>from selenium.webdriver.support.ui import WebDriverWait</code>。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait  <span class="comment"># 显示等待</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC  <span class="comment"># 条件</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示等待(12306小案例)</span></span><br><span class="line">driver.get(<span class="string">&quot;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&quot;</span>)</span><br><span class="line"><span class="comment"># 满足以下两个条件或则等待10秒再向下执行</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">   	</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;fromStationText&#x27;</span>), <span class="string">&#x27;长沙&#x27;</span>),</span><br><span class="line">    EC.text_to_be_present_in_element_value((By.ID, <span class="string">&#x27;toStationText&#x27;</span>), <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">print(<span class="string">&quot;skdjflfhgjklksdjflk&quot;</span>)</span><br><span class="line">search = driver.find_element_by_id(<span class="string">&#x27;query_ticket&#x27;</span>)</span><br><span class="line">search.click()</span><br></pre></td></tr></table></figure>
<h3 id="打开新窗口和切换页面："><a href="#打开新窗口和切换页面：" class="headerlink" title="打开新窗口和切换页面："></a>打开新窗口和切换页面：</h3></li>
<li><p>selenium中没有专门的打开新窗口的方法，是通过<code>window.execute_script()</code>来执行<code>js</code>脚本的形式来打开新窗口的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.execute_script(<span class="string">&quot;window.open(&#x27;https://www.douban.com/&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>打开新的窗口后<code>driver</code>当前的页面依然还是之前的，如果想要获取新的窗口的源代码，那么就必须先切换过去。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.switch_to.window(driver.window_handlers[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3></li>
</ol>
<p>设置代理通过<code>ChromeOptions</code>来设置，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://110.52.235.176:9999&quot;</span>)</span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&quot;D:\ProgramApp\chromedriver\chromedriver73.exe&quot;</span>,chrome_options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;http://httpbin.org/ip&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li>webelement.get_property：获取html标签中官方写好的属性。</li>
<li>webelement.get_attribute：获取html标签中官方和非官方的属性。</li>
<li>driver.save_screenshoot（”curr.png”）：获取当前页面的截图，有时候请求失败了，那么可以把当前网页的截图保存下来，方便后期进行分析。</li>
<li>print(driver.page_source) ： 获取网页源代码</li>
</ol>
<h3 id="12306抢票实战"><a href="#12306抢票实战" class="headerlink" title="12306抢票实战"></a>12306抢票实战</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9：商务座 ，M：一等座，O：二等座，3：硬卧，4：软卧，1：硬座 ....</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    login_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/resources/login.html&#x27;</span></span><br><span class="line">    person_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/view/index.html&#x27;</span></span><br><span class="line">    select_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc&#x27;</span></span><br><span class="line">    sure_url = <span class="string">&#x27;https://kyfw.12306.cn/otn/confirmPassenger/initDc&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trains:&#123;&quot;G67&quot;: [&#x27;M&#x27;, &#x27;O&#x27;],&quot;G533&quot;: [&#x27;9&#x27;, &#x27;M&#x27;, &#x27;O&#x27;]&#125;   表示可以接受的列车与座位</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, from_station, to_station, date, trains, users</span>):</span></span><br><span class="line">        self.from_station = from_station</span><br><span class="line">        self.to_station = to_station</span><br><span class="line">        self.date = date</span><br><span class="line">        self.trains = trains</span><br><span class="line">        self.users = users</span><br><span class="line">        self.station_code = &#123;&#125;</span><br><span class="line">        self.initCode()</span><br><span class="line">        self.train_number = <span class="literal">None</span></span><br><span class="line">        self.train_place = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据地名获取该地名相关代号,文件内容在stations.csv中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initCode</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stations.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.DictReader(f)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">                name = line.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                code = line.get(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">                self.station_code[name] = code</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.login_url)</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.person_url)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选票</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        driver.get(self.select_url)</span><br><span class="line">        <span class="comment"># 关闭提示弹框</span></span><br><span class="line">        sure = driver.find_element_by_id(<span class="string">&quot;qd_closeDefaultWarningWindowDialog_id&quot;</span>)</span><br><span class="line">        sure.click()</span><br><span class="line">        <span class="comment"># 起始地 , 通过js脚本给隐藏的input标签赋值</span></span><br><span class="line">        from_input = driver.find_element_by_id(<span class="string">&quot;fromStation&quot;</span>)</span><br><span class="line">        from_code = self.station_code[self.from_station]  <span class="comment"># &#x27;BOP&#x27;, &#x27;北京&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % from_code, from_input)</span><br><span class="line">        <span class="comment"># 目的地</span></span><br><span class="line">        to_input = driver.find_element_by_id(<span class="string">&quot;toStation&quot;</span>)</span><br><span class="line">        to_code = self.station_code[self.to_station]  <span class="comment"># &#x27;长沙&#x27;: &#x27;CSQ&#x27;</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % to_code, to_input)</span><br><span class="line">        <span class="comment"># 时间</span></span><br><span class="line">        date_input = driver.find_element_by_id(<span class="string">&quot;train_date&quot;</span>)</span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].value=&#x27;%s&#x27;&quot;</span> % self.date, date_input)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        search = driver.find_element_by_id(<span class="string">&quot;query_ticket&quot;</span>)</span><br><span class="line">        search.click()</span><br><span class="line">        <span class="comment"># 等待加载完毕，再预定合适的票</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 获取所有列车信息，并遍历</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 一直循环查询，直到选中票</span></span><br><span class="line">            trains = driver.find_elements_by_xpath(<span class="string">&quot;//tbody[@id=&#x27;queryLeftTable&#x27;]/tr[not(@datatran)]&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> train <span class="keyword">in</span> trains:</span><br><span class="line">                train_list = train.text.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                print(train_list)</span><br><span class="line">                number = train_list[<span class="number">0</span>]  <span class="comment"># 车次</span></span><br><span class="line">                <span class="comment"># 如果当前列车是自己可以接受的列车，就进行选座位</span></span><br><span class="line">                <span class="keyword">if</span> number <span class="keyword">in</span> self.trains:</span><br><span class="line">                    is_selected = <span class="literal">False</span>  <span class="comment"># 标记是否选中了座位</span></span><br><span class="line">                    select_place = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 标记选中的座位</span></span><br><span class="line">                    places = self.trains[number]  <span class="comment"># 获取该车次可以接受的座位</span></span><br><span class="line">                    <span class="keyword">for</span> place <span class="keyword">in</span> places:</span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;9&quot;</span>:  <span class="comment"># 商务坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">7</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">7</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;M&quot;</span>:  <span class="comment"># 一等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">8</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">8</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;M&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> place == <span class="string">&quot;O&quot;</span>:  <span class="comment"># 二等坐</span></span><br><span class="line">                            <span class="keyword">if</span> train_list[<span class="number">9</span>] == <span class="string">&#x27;有&#x27;</span> <span class="keyword">or</span> train_list[<span class="number">9</span>].isdigit():</span><br><span class="line">                                select_place = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                                is_selected = <span class="literal">True</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                    <span class="comment"># 如果选中了座位，就结束循环，并预定</span></span><br><span class="line">                    <span class="keyword">if</span> is_selected:</span><br><span class="line">                        pre = train.find_element_by_xpath(<span class="string">&quot;.//a[@class=&#x27;btn72&#x27;]&quot;</span>)</span><br><span class="line">                        pre.click()</span><br><span class="line">                        self.train_number = number</span><br><span class="line">                        self.train_place = select_place</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确认乘客与座位，正式预定</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sure_ticket</span>(<span class="params">self</span>):</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.url_contains(self.sure_url)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 选中乘车人</span></span><br><span class="line">        users = driver.find_elements_by_xpath(<span class="string">&quot;//ul[@id=&#x27;normal_passenger_id&#x27;]/li/label&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">            <span class="keyword">if</span> user.text <span class="keyword">in</span> self.users:</span><br><span class="line">                user.click()</span><br><span class="line">        <span class="comment"># 选中座位类型</span></span><br><span class="line">        place_select = Select(driver.find_element_by_id(<span class="string">&quot;seatType_1&quot;</span>))</span><br><span class="line">        place_select.select_by_value(self.train_place)</span><br><span class="line">        <span class="comment"># 提交订单</span></span><br><span class="line">        sure_btn = driver.find_element_by_id(<span class="string">&quot;submitOrder_id&quot;</span>)</span><br><span class="line">        sure_btn.click()</span><br><span class="line">        <span class="comment"># 等待加载核对信息对话框,与确定按钮</span></span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">&quot;//div[@id=&#x27;content_checkticketinfo_id&#x27;]&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        WebDriverWait(driver, <span class="number">1000</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">&quot;qr_submit_id&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 单击确定按钮，正式生产订单,这里确定按钮不生效，一直循环暴力点击确定按钮，直到获取不到该按钮</span></span><br><span class="line">        sure_btn_final = driver.find_element_by_id(<span class="string">&quot;qr_submit_id&quot;</span>)</span><br><span class="line">        sure_btn_final.click()</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     try:</span></span><br><span class="line">        <span class="comment">#         sure_btn_final.click()</span></span><br><span class="line">        <span class="comment">#         # sure_btn_final = driver.find_element_by_id(&quot;qr_submit_id&quot;)</span></span><br><span class="line">        <span class="comment">#         sure_btn_final = driver.find_element_by_id(&quot;back_edit_id&quot;)</span></span><br><span class="line">        <span class="comment">#     except ElementNotInteractableException:</span></span><br><span class="line">        <span class="comment">#         print(&quot;抢票成功,车次:&quot; + self.train_number + &quot;,席位:&quot; + self.train_place)</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行该代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.select_ticket()</span><br><span class="line">        self.sure_ticket()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    spider = Spider(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;长沙&quot;</span>, <span class="string">&quot;2021-04-17&quot;</span>, &#123;<span class="string">&quot;K21&quot;</span>: [<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], <span class="string">&quot;G529&quot;</span>: [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]&#125;, [<span class="string">&#x27;李昭辉&#x27;</span>])</span><br><span class="line">    spider.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















































]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
        <tag>chromedriver</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬虫</title>
    <url>/2021/04/12/%E5%8F%8D%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h3 id="图片验证码识别"><a href="#图片验证码识别" class="headerlink" title="图片验证码识别"></a>图片验证码识别</h3><p>平台</p>
<p>1.云打码     2.斐斐打码 <a id="more"></a></p>
<p>这里主要介绍斐斐打码</p>
<p>官网 <a href="http://www.fateadm.com/login.html%E4%B8%AD%E6%89%BE%E5%88%B0python3">http://www.fateadm.com/login.html中找到python3</a> demo的下载链接</p>
<p><a href="http://www.fateadm.com/download/demo/python3.zip">http://www.fateadm.com/download/demo/python3.zip</a></p>
<p>下载该文件</p>
<p>该文件的使用案例在TestFunc方法中，可以复制该方法，模仿着写，并识别验证码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fateadm_api <span class="keyword">import</span> FateadmApi</span><br><span class="line"></span><br><span class="line">pd_id = <span class="string">&quot;129281&quot;</span>  <span class="comment"># 用户中心页可以查询到pd信息</span></span><br><span class="line">pd_key = <span class="string">&quot;GmNxNIU5XL4N+A49UFNtC7G0nsn456yQ&quot;</span></span><br><span class="line">app_id = <span class="string">&quot;329281&quot;</span>  <span class="comment"># 开发者分成用的账号，在开发者中心可以查询到</span></span><br><span class="line">app_key = <span class="string">&quot;Cawup44zVSJTGukiJaT3MysZs4ITe3xQ&quot;</span></span><br><span class="line">api = FateadmApi(app_id, app_key, pd_id, pd_key)</span><br><span class="line"><span class="comment"># 识别类型，</span></span><br><span class="line">pred_type = <span class="string">&quot;20500&quot;</span></span><br><span class="line"><span class="comment"># 通过文件形式识别：</span></span><br><span class="line">file_name = <span class="string">&quot;img.png&quot;</span></span><br><span class="line">res = api.PredictFromFileExtend(pred_type, file_name)</span><br><span class="line">print(<span class="string">&quot;识别后的内容为:&quot;</span>+res)</span><br></pre></td></tr></table></figure>
<h3 id="字体识别"><a href="#字体识别" class="headerlink" title="字体识别"></a>字体识别</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.网页开发者自己创造一种字体，因为在字体中每个文字都有其代号，那么以后在网页中不会 直接显示这个文字的最终的效果，而是显示他的代号，因此即使获取到了网页中的文本内 容，也只是获取到文字的代号，而不是文字本身。 </p>
<p>2.因为创造字体费时费力，并且如果把中国3000多常用汉字都实现，那么这个字体将达到几十 兆，也会影响网页的加载。一般情况下为了反爬虫，仅会针对0-9以及少数汉字进行自己单独 创建，其他的还是使用用户系统中自带的字体。</p>
<h4 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h4><p>1.一般情况下为了考虑网页渲染性能，通常网页开发者会把字体编码成base64的方式，因此我 们可以到网页中找到@font-face属性，然后获取里面的base64代码，再用Python代码进行 解码，然后再保存本地。</p>
<p>2.如果没有使用base64，还有另外一种方式，就是直接把字体文件放到服务器上，然后前端通 过@font-face中的url函数进行加载。</p>
<h4 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h4><p>1.分析字体需要将字体转换成xml文件，然后查看其中的cmap和glyf中的属性。其中cmap存储 的是code和name的映射，而glyf下存储的是每个name下的字体绘制规则。 </p>
<p>2.从第1步中我们知道了name对应的字体的绘制规则，但是还是不知道字体是长什么样子，那 么可以通过一款叫做FontCreator的软件来打开.tff的字体文件，这样就可以看到每个name对 应的字体最终的呈现效果。</p>
<p>3.在网页中，直接显示的是字体的code，而不是name。并且网页开发者为了增加爬虫的难 度，有可能在多次请求之间</p>
<p>code-&gt;name-&gt;最终字体的映射    会发生改变。但是最终字体的形 状是不会改变的，因此我们可以通过形状对比来进行判断。</p>
<p>4.我们可以通过分析字体，得出每个字体形状对应的文字，然后保存到一个字典中。以后再请 求网页的时候，就进行反向解析，先获取字体的形状，再通过字体形状反向获取代号所对应 的具体文字内容</p>
<p><a href="https://imgtu.com/i/cD7ZDA"><img src="https://z3.ax1x.com/2021/04/12/cD7ZDA.png" alt="cD7ZDA.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实习僧小案例 ，只爬取一个详情页的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================获取xml文件和ttf文件，先分析name与形状之间的关系，保存到base_font_map中=============================</span></span><br><span class="line"><span class="comment"># 保存font-face</span></span><br><span class="line">font_face = <span class="string">&#x27;。。。&#x27;</span></span><br><span class="line">binary = base64.b64decode(font_face)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 ttf 文件，以便后面的分析</span></span><br><span class="line"><span class="comment"># with open(&quot;实习僧.ttf&quot;, &#x27;wb&#x27;) as fb:</span></span><br><span class="line"><span class="comment">#     fb.write(binary)</span></span><br><span class="line">base_font = TTFont(<span class="string">&quot;实习僧.ttf&quot;</span>)</span><br><span class="line"><span class="comment"># 第一次执行该代码，保存 xml 文件，以便后面的分析保存为xml文件</span></span><br><span class="line"><span class="comment"># base_font.saveXML(&quot;实习僧.xml&quot;)</span></span><br><span class="line"><span class="comment"># 获取形状映射关系</span></span><br><span class="line">glyf = base_font[<span class="string">&#x27;glyf&#x27;</span>]</span><br><span class="line"><span class="comment"># 存放正确字体与形状</span></span><br><span class="line">shape_name_map = &#123;</span><br><span class="line">    <span class="number">0</span>: glyf[<span class="string">&quot;uni30&quot;</span>],</span><br><span class="line">    <span class="number">1</span>: glyf[<span class="string">&quot;uni31&quot;</span>],</span><br><span class="line">    <span class="number">2</span>: glyf[<span class="string">&quot;uni32&quot;</span>],</span><br><span class="line">    <span class="number">3</span>: glyf[<span class="string">&quot;uni33&quot;</span>],</span><br><span class="line">    <span class="number">4</span>: glyf[<span class="string">&quot;uni34&quot;</span>],</span><br><span class="line">    <span class="number">5</span>: glyf[<span class="string">&quot;uni35&quot;</span>],</span><br><span class="line">    <span class="number">6</span>: glyf[<span class="string">&quot;uni36&quot;</span>],</span><br><span class="line">    <span class="number">7</span>: glyf[<span class="string">&quot;uni37&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">8</span>: glyf[<span class="string">&quot;uni38&quot;</span>],</span><br><span class="line">    <span class="number">9</span>: glyf[<span class="string">&quot;uni39&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================开始爬取网页，目的:将网页的源代码中乱的字体替换成正确字体:=================================</span></span><br><span class="line">head = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">text = requests.get(<span class="string">&quot;https://m.shixiseng.com/intern/inn_sxjh0abyyqxf&quot;</span>, headers=head).text</span><br><span class="line"><span class="comment"># 获取font-face</span></span><br><span class="line">fontFace = re.search(<span class="string">r&#x27;font-family:myFont; src: url\(&quot;data:application/octet-stream;base64,(.+?)&quot;\)&#x27;</span>, text).group(<span class="number">1</span>)</span><br><span class="line">b = base64.b64decode(fontFace)</span><br><span class="line"><span class="comment"># 这里直接放入到管道内，不动用磁盘空间</span></span><br><span class="line">baseFont = TTFont(io.BytesIO(b))</span><br><span class="line">shapes = baseFont[<span class="string">&#x27;glyf&#x27;</span>]  <span class="comment"># 所有形状</span></span><br><span class="line">cmap = baseFont.getBestCmap()  <span class="comment"># code 与 name 的映射</span></span><br><span class="line"><span class="keyword">for</span> code, name <span class="keyword">in</span> cmap.items():  <span class="comment"># code == 0xe06e</span></span><br><span class="line">    <span class="comment"># 通过名字获取形状</span></span><br><span class="line">    shape = shapes[name]</span><br><span class="line">    <span class="comment"># 遍历之前获取的shape_name_map，如果形状相等，就将code替换成正确的字体 k</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> shape_name_map.items():</span><br><span class="line">        <span class="keyword">if</span> shape == v:</span><br><span class="line">            code = <span class="built_in">hex</span>(code)  <span class="comment"># 先把code替换成16进制  57454 ==》 0xe06e</span></span><br><span class="line">            <span class="comment"># 把code替换成网页的code形式  0xe06e ==》 &amp;#xe06e</span></span><br><span class="line">            webCode = <span class="built_in">str</span>(code).replace(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;&amp;#&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 把网页的code替换成正确的字体</span></span><br><span class="line">            text = re.sub(webCode, <span class="built_in">str</span>(k),text)</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>图片验证码识别</tag>
        <tag>字体识别</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架</title>
    <url>/2021/04/16/scrapy%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Scrapy框架："><a href="#Scrapy框架：" class="headerlink" title="Scrapy框架："></a>Scrapy框架：</h2><p>写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此Scrapy把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用Scrapy框架来解决。</p>
<a id="more"></a>

<h3 id="安装Scrapy框架："><a href="#安装Scrapy框架：" class="headerlink" title="安装Scrapy框架："></a>安装Scrapy框架：</h3><ol>
<li>pip install scrapy</li>
</ol>
<h3 id="Scrapy框架架构："><a href="#Scrapy框架架构：" class="headerlink" title="Scrapy框架架构："></a>Scrapy框架架构：</h3><ol>
<li><p>Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。</p>
</li>
<li><p>Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是需要的，都是由程序员自己决定。</p>
</li>
<li><p>Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。</p>
</li>
<li><p>Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。</p>
</li>
<li><p>Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。</p>
</li>
<li><p>Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。</p>
</li>
<li><p>Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。</p>
<p><a href="https://imgtu.com/i/cRzQ1S"><img src="https://z3.ax1x.com/2021/04/16/cRzQ1S.png" alt="cRzQ1S.png" style="zoom:50%;" /></a></p>
</li>
</ol>
<h3 id="创建Scrapy项目："><a href="#创建Scrapy项目：" class="headerlink" title="创建Scrapy项目："></a>创建Scrapy项目：</h3><ol>
<li>创建项目：<code>scrapy startproject [项目名称]</code>.</li>
<li>创建爬虫：<code>cd到项目中-&gt;scrapy genspider [爬虫名称] [域名]</code>.</li>
</ol>
<h3 id="项目文件作用："><a href="#项目文件作用：" class="headerlink" title="项目文件作用："></a>项目文件作用：</h3><ol>
<li><code>settings.py</code>：用来配置爬虫的。</li>
<li><code>middlewares.py</code>：用来定义中间件。</li>
<li><code>items.py</code>：用来提前定义好需要下载的数据字段。</li>
<li><code>pipelines.py</code>：用来保存数据。</li>
<li><code>scrapy.cfg</code>：用来配置项目的。</li>
</ol>
<h3 id="CrawlSpider爬虫："><a href="#CrawlSpider爬虫：" class="headerlink" title="CrawlSpider爬虫："></a>CrawlSpider爬虫：</h3><ol>
<li>作用：可以定义规则，让Scrapy自动的去爬取我们想要的链接。而不必跟Spider类一样，手动的yield Request。</li>
<li>创建：scrapy genspider -t crawl [爬虫名] [域名]</li>
<li>提取的两个类：<ul>
<li>LinkExtrator：用来定义需要爬取的url规则。</li>
<li>Rule：用来定义这个url爬取后的处理方式，比如是否需要跟进，是否需要执行回调函数等。</li>
</ul>
</li>
</ol>
<h3 id="Scrapy-Shell："><a href="#Scrapy-Shell：" class="headerlink" title="Scrapy Shell："></a>Scrapy Shell：</h3><p>在命令行中，进入到项目所在的路径。然后：<br><code>scrapy shell 链接</code><br>在这个里面，可以先去写提取的规则，没有问题后，就可以把代码拷贝到项目中。方便写代码。</p>
<h3 id="使用twisted异步保存mysql数据：（猎云网案例）"><a href="#使用twisted异步保存mysql数据：（猎云网案例）" class="headerlink" title="使用twisted异步保存mysql数据：（猎云网案例）"></a>使用twisted异步保存mysql数据：（猎云网案例）</h3><p>在Lspider中获取网页信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> LieyunItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunSpiderSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;lieyun_spider&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;lieyunwang.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://lieyunwang.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/latest/p\d+\.html&#x27;</span>), follow=<span class="literal">True</span>),</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;/archives/\d+&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">False</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        title_list = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/text()&quot;</span>).getall()</span><br><span class="line">        title = <span class="string">&quot;&quot;</span>.join(title_list).strip()</span><br><span class="line">        pub_time = response.xpath(<span class="string">&quot;//h1[@class=&#x27;lyw-article-title-inner&#x27;]/span/text()&quot;</span>).get()</span><br><span class="line">        author = response.xpath(<span class="string">&quot;//a[contains(@class,&#x27;author-name&#x27;)]/text()&quot;</span>).get()</span><br><span class="line">        context = response.xpath(<span class="string">&quot;//div[@id=&#x27;main-text-id&#x27;]&quot;</span>).getall()</span><br><span class="line">        item = LieyunItem(title=title, pub_time=pub_time, author=author, context=context, detail_url=response.url)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>在pipeline中，使用twisted.enterprise.adbapi来创建一个连接对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LieyunPipeline</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,mysql_config</span>):</span></span><br><span class="line">    self.dbpool = adbapi.ConnectionPool(</span><br><span class="line">        mysql_config[<span class="string">&#x27;DRIVER&#x27;</span>],</span><br><span class="line">        host=mysql_config[<span class="string">&#x27;HOST&#x27;</span>],</span><br><span class="line">        port=mysql_config[<span class="string">&#x27;PORT&#x27;</span>],</span><br><span class="line">        user=mysql_config[<span class="string">&#x27;USER&#x27;</span>],</span><br><span class="line">        password=mysql_config[<span class="string">&#x27;PASSWORD&#x27;</span>],</span><br><span class="line">        db=mysql_config[<span class="string">&#x27;DATABASE&#x27;</span>],</span><br><span class="line">        charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 重写该方法,获取配置文件中的MYSQL_CONFIG信息，再调用构造器</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">    mysql_config = crawler.settings[<span class="string">&#x27;MYSQL_CONFIG&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> cls(mysql_config)</span><br></pre></td></tr></table></figure>
<p>在插入数据的函数中，使用<code>runInteraction</code>来运行真正执行sql语句的函数。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">      <span class="comment"># 执行插入操作</span></span><br><span class="line">      result = self.dbpool.runInteraction(self.item_insert, item)</span><br><span class="line">      <span class="comment"># 失败调用</span></span><br><span class="line">      result.addErrback(self.insert_error)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 插入数据，通过游标cursor插入item中的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">item_insert</span>(<span class="params">self, cursor, item</span>):</span></span><br><span class="line">      sql = <span class="string">&quot;insert into lieyun values(null,%s,%s,%s,%s,%s)&quot;</span></span><br><span class="line">      args = (item[<span class="string">&#x27;title&#x27;</span>], item[<span class="string">&#x27;author&#x27;</span>], item[<span class="string">&#x27;detail_url&#x27;</span>], item[<span class="string">&#x27;pub_time&#x27;</span>], item[<span class="string">&#x27;context&#x27;</span>])</span><br><span class="line">      cursor.execute(sql, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出报错信息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_error</span>(<span class="params">self,fail</span>):</span></span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line">      print(fail)</span><br><span class="line">      print(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Scrapy下载图片："><a href="#Scrapy下载图片：" class="headerlink" title="Scrapy下载图片："></a>Scrapy下载图片：</h3><ol>
<li>根据网页解析图片的链接。</li>
<li>定义一个item，上面有一定要有两个字段，一个是image_urls，一个是images。其中image_urls是用来存储图片的链接，由开发者把数据爬取下来后添加的，images时存放相关信息的，我们不需要管他</li>
<li>使用scrapy.pipelines.images.ImagesPipeline来作为数据保存的pipeline。</li>
<li>在settings.py中设置IMAGES_SOTRE来定义图片下载的路径。</li>
</ol>
<h4 id="在settings-py这样定义"><a href="#在settings-py这样定义" class="headerlink" title="在settings.py这样定义"></a>在settings.py这样定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="comment"># &#x27;zcool.pipelines.ZcoolPipeline&#x27;: 300,</span></span><br><span class="line">    <span class="comment"># 不用自己的pipeline，用scrapy自带的图片pipeline</span></span><br><span class="line">    <span class="string">&#x27;scrapy.pipelines.images.ImagesPipeline&#x27;</span>: <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 图片保存路径</span></span><br><span class="line">IMAGES_STORE = os.path.join(os.path.dirname(os.path.dirname(__file__)), <span class="string">&#x27;images&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果上面这样写的换，图片路径全在images/full中</p>
<p>如果想要有更复杂的图片保存的路径需求，可以在pipeline中重写ImagePipeline的file_path方法，这个方法用来返回每个图片的保存路径。而<code>file_path</code>方法没有<code>item</code>对象，所以我们还需要重写<code>get_media_requests</code>方法，来把<code>item</code>绑定到<code>request</code>上。注:settings.py中要改回自定义的pipeline</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> zcool <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZcoolPipeline</span>(<span class="params">ImagesPipeline</span>):</span></span><br><span class="line">    <span class="comment"># 将item数据挂载到request中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span>(<span class="params">self, item, info</span>):</span></span><br><span class="line">        requests = <span class="built_in">super</span>(ZcoolPipeline, self).get_media_requests(item, info)</span><br><span class="line">        <span class="keyword">for</span> request <span class="keyword">in</span> requests:</span><br><span class="line">            request.item = item</span><br><span class="line">        <span class="keyword">return</span> requests</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 获取原来的图片路径</span></span><br><span class="line">        origin_path = <span class="built_in">super</span>(ZcoolPipeline, self).file_path(request, response, info)</span><br><span class="line">        <span class="comment"># 获取标题，并将不合法字符删除</span></span><br><span class="line">        title = request.item[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        title = re.sub(<span class="string">r&#x27;\\/:\*\?\|&lt;&gt;&quot;&#x27;</span>, title)</span><br><span class="line">        <span class="comment"># 根据图片的标题创建文件夹</span></span><br><span class="line">        dir_path = os.path.join(settings.IMAGES_STORE, title)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_path):</span><br><span class="line">            os.mkdir(dir_path)</span><br><span class="line"></span><br><span class="line">        curr_path = origin_path.replace(<span class="string">&quot;/full&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> os.path.join(dir_path,curr_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="下载器中间件："><a href="#下载器中间件：" class="headerlink" title="下载器中间件："></a>下载器中间件：</h2><p>下载器中间件是引擎和下载器之间通信的中间件。在这个中间件中我们可以设置代理、更换请求头等来达到反反爬虫的目的。要写下载器中间件，可以在下载器中实现两个方法。</p>
<ol>
<li>process_request(self,request,spider)：  请求发送之前会执行</li>
<li>process_response(self,request,response,spider)：数据下载到引擎之前执行</li>
</ol>
<p><a href="https://imgtu.com/i/cRzl6g"><img src="https://z3.ax1x.com/2021/04/16/cRzl6g.png" alt="cRzl6g.png" style="zoom:50%;" /></a></p>
<h3 id="Scrapy中更换请求头：使用fake-useragent-动态更换"><a href="#Scrapy中更换请求头：使用fake-useragent-动态更换" class="headerlink" title="Scrapy中更换请求头：使用fake_useragent 动态更换"></a>Scrapy中更换请求头：使用fake_useragent 动态更换</h3><p>pip install fake_useragent</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 自定义跟换请求头中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        <span class="comment"># 更换请求头</span></span><br><span class="line">        request.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = ua.random</span><br></pre></td></tr></table></figure>
<h3 id="Scrapy中设置代理："><a href="#Scrapy中设置代理：" class="headerlink" title="Scrapy中设置代理："></a>Scrapy中设置代理：</h3><ol>
<li><p>设置普通代理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义更换代理中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddlewares</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    proxies = &#123;<span class="string">&quot;code&quot;</span>: <span class="number">0</span>, <span class="string">&quot;data&quot;</span>: [&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;36.6.146.163&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4225</span>&#125;, &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;119.54.15.185&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">4258</span>&#125;],<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;success&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        <span class="comment"># 任意选中一个代理对象</span></span><br><span class="line">        proxy = random.choice(self.proxies[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">        <span class="comment"># 更换代理</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = <span class="string">&#x27;http://&#x27;</span> + proxy[<span class="string">&#x27;ip&#x27;</span>]+<span class="string">&quot;:&quot;</span>+<span class="built_in">str</span>(proxy[<span class="string">&#x27;port&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>设置独享代理：需要提供密钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPProxyDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request,spider</span>):</span></span><br><span class="line">        proxy = <span class="string">&#x27;121.199.6.124:16816&#x27;</span></span><br><span class="line">        user_password = <span class="string">&quot;970138074:rcdj35xx&quot;</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = proxy</span><br><span class="line">        <span class="comment"># bytes</span></span><br><span class="line">        b64_user_password = base64.b64encode(user_password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        request.headers[<span class="string">&#x27;Proxy-Authorization&#x27;</span>] = <span class="string">&#x27;Basic &#x27;</span> + b64_user_password.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>代理服务商：</p>
<ul>
<li>芝麻代理：<a href="http://http.zhimaruanjian.com/">http://http.zhimaruanjian.com/</a></li>
<li>太阳代理：<a href="http://http.taiyangruanjian.com/">http://http.taiyangruanjian.com/</a></li>
<li>快代理：<a href="http://www.kuaidaili.com/">http://www.kuaidaili.com/</a></li>
<li>讯代理：<a href="http://www.xdaili.cn/">http://www.xdaili.cn/</a></li>
<li>蚂蚁代理：<a href="http://www.mayidaili.com/">http://www.mayidaili.com/</a></li>
<li>极光代理：<a href="http://www.jiguangdaili.com/">http://www.jiguangdaili.com/</a></li>
</ul>
</li>
</ol>
<h3 id="猎聘网动态更换ip代理案例"><a href="#猎聘网动态更换ip代理案例" class="headerlink" title="猎聘网动态更换ip代理案例"></a>猎聘网动态更换ip代理案例</h3><h4 id="定义一个模型，根据代理ip的json数据，解析里面的代理ip"><a href="#定义一个模型，根据代理ip的json数据，解析里面的代理ip" class="headerlink" title="定义一个模型，根据代理ip的json数据，解析里面的代理ip"></a>定义一个模型，根据代理ip的json数据，解析里面的代理ip</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, proxy_dict</span>):</span></span><br><span class="line">        proxy_data = proxy_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        self.proxy_url = <span class="string">&quot;https://&quot;</span> + proxy_data[<span class="string">&#x27;ip&#x27;</span>] + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(proxy_data[<span class="string">&#x27;port&#x27;</span>])</span><br><span class="line">        self.expire_time = datetime.datetime.strptime(proxy_data[<span class="string">&#x27;expire_time&#x27;</span>], <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        self.is_backed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 时间是否过去</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_expire</span>(<span class="params">self</span>):</span></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        <span class="comment"># 如果超时或还剩5秒就返回True</span></span><br><span class="line">        <span class="keyword">if</span> (self.expire_time - now) &lt; datetime.timedelta(seconds=<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在中间件中定义代理ip的动态更换"><a href="#在中间件中定义代理ip的动态更换" class="headerlink" title="在中间件中定义代理ip的动态更换"></a>在中间件中定义代理ip的动态更换</h4><p>process_request : 更换 ip </p>
<p>process_response: 判断返回的网页是否有问题，如果有就标记  is_backed 为True，表示当前ip加入了黑名单</p>
<p>update_proxy：调用模型更新代理ip，将ip信息赋给 self.proxy_model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> proxy_model <span class="keyword">import</span> model</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiepinDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LiepinDownloaderMiddleware, self).__init__()</span><br><span class="line">        <span class="comment"># 存放代理ip的相关数据</span></span><br><span class="line">        self.proxy_model = <span class="literal">None</span></span><br><span class="line">        self.proxy_url = <span class="string">&#x27;通过代理服务商获取ip地址&#x27;</span></span><br><span class="line">        self.head = &#123; 。。。 &#125;</span><br><span class="line">        self.update_proxy()  <span class="comment"># 一开始就用代理ip</span></span><br><span class="line">        self.lock = threading.Lock() <span class="comment"># 锁</span></span><br><span class="line">        <span class="comment"># 另外开启一条线程管理ip代理</span></span><br><span class="line">        threading.Thread(target=self.update_proxy_in_thread).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = self.proxy_model.proxy_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response, spider</span>):</span></span><br><span class="line">        <span class="comment"># 如果状态码步数200，说明该代理ip加入黑名单了，需要标记一下,并直接返回request对象，下次继续加载该请求</span></span><br><span class="line">        <span class="keyword">if</span> response.status != <span class="number">200</span>:</span><br><span class="line">            self.lock.locked()  <span class="comment"># 加锁</span></span><br><span class="line">            self.proxy_model.is_backed = <span class="literal">True</span></span><br><span class="line">            self.lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line">            <span class="keyword">return</span> request</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新代理ip，将ip信息赋给self.proxy_model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy</span>(<span class="params">self</span>):</span></span><br><span class="line">        proxy_dict = requests.get(self.proxy_url, headers=self.head).json()</span><br><span class="line">        proxy_model = model(proxy_dict)</span><br><span class="line">        self.proxy_model = proxy_model</span><br><span class="line">        print(<span class="string">&quot;更换了代理&quot;</span>)</span><br><span class="line">        print(self.proxy_model.proxy_url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程的方式更新代理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_proxy_in_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="comment"># 每过5秒检查一次，如果代理 运行了60秒或 加入黑名单或 超时，就更换代理</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">60</span> <span class="keyword">or</span> self.proxy_model.is_backed <span class="keyword">or</span> self.proxy_model.is_expire:</span><br><span class="line">                self.update_proxy()</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count + <span class="number">5</span></span><br><span class="line">                print(<span class="string">&quot;代理运行了&quot;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;秒&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Scrapy中使用selenium动态爬虫"><a href="#Scrapy中使用selenium动态爬虫" class="headerlink" title="Scrapy中使用selenium动态爬虫"></a>Scrapy中使用selenium动态爬虫</h2><p>在中间件的request中使用selenium获取网页数据，直接返回给爬虫进行解析数据</p>
<h3 id="简书案例-获取加载更多中的全部数据"><a href="#简书案例-获取加载更多中的全部数据" class="headerlink" title="简书案例,获取加载更多中的全部数据"></a>简书案例,获取加载更多中的全部数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> is_item, ItemAdapter</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> scrapy.http.response.html <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianshuDownloaderMiddleware</span>:</span></span><br><span class="line">    <span class="comment"># 初始化dirver</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(JianshuDownloaderMiddleware, self).__init__()</span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;C:\project\pyCode\chromedriver.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拦截请求，自定义发送动态爬虫，直接返回response对象给爬虫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        self.driver.get(request.url)</span><br><span class="line">        <span class="comment"># 等待加载</span></span><br><span class="line">        WebDriverWait(self.driver, <span class="number">8</span>).until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, <span class="string">&quot;//section[position()=2]/h3&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 循环点击加载更多，直到加载完毕即可</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                add_more = self.driver.find_element_by_xpath(<span class="string">&quot;//section[position()=2]/div/div[@role=&#x27;button&#x27;]&quot;</span>)</span><br><span class="line">                print(add_more)</span><br><span class="line">                self.driver.execute_script(<span class="string">&quot;arguments[0].click();&quot;</span>, add_more)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        response = HtmlResponse(request.url, request=request, body=self.driver.page_source,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>此时爬虫spider中获取的response是从上面这个方法中传过来的，可以根据自己的需求获取相关数据</p>
<p>更多的介绍请参考API：<a href="https://scrapyd.readthedocs.io/en/stable/api.html">https://scrapyd.readthedocs.io/en/stable/api.html</a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas库</title>
    <url>/2021/04/18/pandas%E5%BA%93/</url>
    <content><![CDATA[<p>pandas的基本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pandas.Series(</span><br><span class="line"> data = <span class="literal">None</span>,</span><br><span class="line"> index = <span class="literal">None</span>,</span><br><span class="line"> dtype = <span class="literal">None</span>,</span><br><span class="line"> name = <span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Serires的dtype"><a href="#Serires的dtype" class="headerlink" title="Serires的dtype"></a>Serires的dtype</h3><p>• int8/int16/int32/int64(默认): 整型 </p>
<p>• float16/float32/float64(默认): 浮点型 </p>
<p>• str/string: 字符串 • bool: 布尔 </p>
<p>• category: 分类 • datetime64[ns]: 时间戳(纳秒) </p>
<p>• period[Y/M/D]: 时间周期(年/月/日) </p>
<p>• object: python对象混合类型</p>
<h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><h3 id="通过2维的list-like创建"><a href="#通过2维的list-like创建" class="headerlink" title="通过2维的list-like创建"></a>通过2维的list-like创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]], columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="通过字典创建"><a href="#通过字典创建" class="headerlink" title="通过字典创建"></a>通过字典创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">6</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">2</span>, <span class="number">8</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="通过读取Excel表-最常用"><a href="#通过读取Excel表-最常用" class="headerlink" title="通过读取Excel表(最常用)"></a>通过读取Excel表(最常用)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(<span class="string">&quot;xxx.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas读excel文件-pandas-read-excel-的参数"><a href="#pandas读excel文件-pandas-read-excel-的参数" class="headerlink" title="pandas读excel文件:pandas.read_excel()的参数"></a>pandas读excel文件:pandas.read_excel()的参数</h2><h3 id="io-路径-StringIO-URL"><a href="#io-路径-StringIO-URL" class="headerlink" title="io    路径, StringIO, URL"></a>io    路径, StringIO, URL</h3><p>可以使用os.chdir(“….”)来切换当前路径</p>
<h3 id="sheet-name-0-选择子表-sheet"><a href="#sheet-name-0-选择子表-sheet" class="headerlink" title="sheet_name=0    选择子表(sheet)"></a>sheet_name=0    选择子表(sheet)</h3><p>• int: 选第几个sheet, 下标从0开始    • str: sheet名字     • list: [0, “2月”], 返回字典    • None: 全部sheet, 返回字典</p>
<h3 id="nrows-None-要解析的行数"><a href="#nrows-None-要解析的行数" class="headerlink" title="nrows=None    要解析的行数"></a>nrows=None    要解析的行数</h3><p>norws=3   只解析当前表格的前3行，不包括表头</p>
<h3 id="sheet-header-0-指定作为’列索引’的行"><a href="#sheet-header-0-指定作为’列索引’的行" class="headerlink" title="sheet_header=0    指定作为’列索引’的行"></a>sheet_header=0    指定作为’列索引’的行</h3><p>header=[0, 1]   将第一行与第二行作为列索引，也可以   header=[‘姓名’,’年龄’]模式</p>
<h3 id="index-col-None-指定作为’行索引’的列"><a href="#index-col-None-指定作为’行索引’的列" class="headerlink" title="index_col=None     指定作为’行索引’的列"></a>index_col=None     指定作为’行索引’的列</h3><p>index_col=[0, 1]    将第一列与第二列作为行索引，注意不可以  index_col=[‘姓名’,’年龄’]   模式</p>
<h3 id="usecols-None-指定只使用哪些列"><a href="#usecols-None-指定只使用哪些列" class="headerlink" title="usecols=None    指定只使用哪些列"></a>usecols=None    指定只使用哪些列</h3><p>• int-list: [0, 2]    •str-list: [‘AAA’, ‘CCC’]   • str: ‘A,C’, ‘A,C:E’     • 函数: lambda x: x == ‘CCC’ </p>
<h3 id="skiprows-None-跳过⾏"><a href="#skiprows-None-跳过⾏" class="headerlink" title="skiprows=None  跳过⾏"></a>skiprows=None  跳过⾏</h3><p>skiprows=1  跳过第一行   ；   skiprows=[0, 2]  跳过0和2行</p>
<h3 id="dtype-None-设置列的类型"><a href="#dtype-None-设置列的类型" class="headerlink" title="dtype=None   设置列的类型"></a>dtype=None   设置列的类型</h3><p>dtype = {‘a’: ‘float64’, ‘b’: ‘int32’}</p>
<h3 id="names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。"><a href="#names-None-设置要使用的列表的列名-。-如果文件不包含标题行，则应显式传递-header-None。" class="headerlink" title="names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。"></a>names=None  设置要使用的列表的列名 。 如果文件不包含标题行，则应显式传递 header=None。</h3><p>header=None    </p>
<p>names=[‘⽉份’ , ‘销量’ , ‘销售额’]</p>
<h3 id="parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12"><a href="#parse-dates-False-指定解析成日期格式的列-只有默认格式会被解析-默认格式为为-2020-1-12" class="headerlink" title="parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12"></a>parse_dates=False    指定解析成日期格式的列,只有默认格式会被解析,默认格式为为 2020/1/12</h3><p>• True -&gt; 尝试解析index的格式</p>
<p>• [0, 1] 或 [‘a’, ‘b’] -&gt; 尝试解析指定列作为一个单独的日期列 </p>
<p>• [[0, 1, 2]] -&gt; 结合多列解析为单个日期列 ，如果年月日不在一起，可以这样使用将他们结合</p>
<p>• {‘日期’: [0, 1, 2]} -&gt; 同上, 结果的列名改为’日期’ •</p>
<h3 id="date-parser-None-function-解析日期格式的函数"><a href="#date-parser-None-function-解析日期格式的函数" class="headerlink" title="date_parser=None    function, 解析日期格式的函数"></a>date_parser=None    function, 解析日期格式的函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date_parser=<span class="keyword">lambda</span> x: pd.to_datetime(x, <span class="built_in">format</span>=<span class="string">&quot;%Y年%m月%d日&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="na-values-None-识别为-NaN-缺失值-的其他字符串"><a href="#na-values-None-识别为-NaN-缺失值-的其他字符串" class="headerlink" title="na_values=None    识别为 NaN(缺失值) 的其他字符串"></a>na_values=None    识别为 NaN(缺失值) 的其他字符串</h3><p>missing data (缺失值) (NaN)    Not a Number </p>
<p>默认情况下，以下值被解析为NaN</p>
<p> ‘-1.#IND’     ‘1.#IND’      ‘NA’     ‘#N/A’   ‘-1.#QNAN’     ‘1.#QNAN’     ‘NULL’     ‘#NA’     ‘-NaN’     ‘NaN’     ‘#N/A N/A’     ‘-nan’     ‘N/A’     ‘n/a’</p>
<p>na_values=[‘空值’, 0]   将’空值‘字符串和0变成NaN</p>
<p>na_values={1: [‘空值’, 0]}    将第二列中的’空值‘字符串和0变成NaN</p>
<h3 id="converters-None-值转换函数，注意传递的是dict"><a href="#converters-None-值转换函数，注意传递的是dict" class="headerlink" title="converters=None      值转换函数，注意传递的是dict"></a>converters=None      值转换函数，注意传递的是dict</h3><p>converters={ </p>
<p>“a”: lambda x: x +1, # 将 列’a‘中的值 + 1 </p>
<p>“b”: lambda x: x * 2, #  将列’b‘中的值 * 2</p>
<p>}</p>
<h3 id="true-values-None-变成-True-的值"><a href="#true-values-None-变成-True-的值" class="headerlink" title="true_values=None    变成 True 的值"></a>true_values=None    变成 True 的值</h3><p>true_values=[‘a’, ‘b’]     将’a‘与’b‘变成布尔类型TRUE</p>
<h3 id="false-values-None-变成-False-的值"><a href="#false-values-None-变成-False-的值" class="headerlink" title="false_values=None   变成 False 的值"></a>false_values=None   变成 False 的值</h3><p> false_values=[‘c’, ‘d’]     将’c‘与’d‘变成布尔类型FALSE</p>
<p>注意:上面的两个参数只对字符串起作⽤，并要一整列要么全部变要么全部不变</p>
<h3 id="mangle-dupe-cols-True-列名是否重复"><a href="#mangle-dupe-cols-True-列名是否重复" class="headerlink" title="mangle_dupe_cols=True   列名是否重复"></a>mangle_dupe_cols=True   列名是否重复</h3><p>如果重复命名,会自动修改 :   a    b     b   -&gt;  a   b    b.1</p>
<p>mangle_dupe_cols=False  如果出现重复命名将会报错:</p>
<p>ValueError: Setting mangle_dupe_cols=False is not supported yet</p>
<h2 id="pandas写excel文件"><a href="#pandas写excel文件" class="headerlink" title="pandas写excel文件:"></a>pandas写excel文件:</h2><h3 id="DataFrame写入excel"><a href="#DataFrame写入excel" class="headerlink" title="DataFrame写入excel"></a>DataFrame写入excel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(</span><br><span class="line"> self,</span><br><span class="line"> excel_writer, <span class="comment"># ⽂件路径/ExcelWriter</span></span><br><span class="line"> sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, <span class="comment"># sheet名字</span></span><br><span class="line"> index=<span class="literal">True</span>, <span class="comment"># 是否输出index</span></span><br><span class="line"> float_format=<span class="literal">None</span>, <span class="comment"># 浮点数输出格式, 如: &quot;%.2f&quot;</span></span><br><span class="line"> na_rep=<span class="string">&#x27;&#x27;</span> <span class="comment"># 缺失值输出的表示形式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="用pandas-ExcelWriter类写入"><a href="#用pandas-ExcelWriter类写入" class="headerlink" title="用pandas.ExcelWriter类写入"></a>用pandas.ExcelWriter类写入</h3><p>1: 设置datatime输出格式       2: 输出多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">&#x27;tb.xlsx&#x27;</span>,datetime_format=<span class="string">&quot;YYYY-MM-DD&quot;</span>) <span class="keyword">as</span> writer:</span><br><span class="line"> df1.to_excel(writer, sheet_name=<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line"> df2.to_excel(writer, sheet_name=<span class="string">&#x27;BBB&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas写-读csv"><a href="#pandas写-读csv" class="headerlink" title="pandas写/读csv"></a>pandas写/读csv</h2><h3 id="read-csv"><a href="#read-csv" class="headerlink" title="read_csv()"></a>read_csv()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(</span><br><span class="line"> filepath, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,    <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="to-csv"><a href="#to-csv" class="headerlink" title="to_csv()"></a>to_csv()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(</span><br><span class="line"> path_or_buf, <span class="comment"># 路径</span></span><br><span class="line"> sep=<span class="string">&#x27;,&#x27;</span>, <span class="comment"># 分隔符</span></span><br><span class="line"> index=<span class="literal">False</span>,   <span class="comment"># 是否输出行下标</span></span><br><span class="line"> encoding=<span class="string">&#x27;utf8&#x27;</span> <span class="comment"># gbk, gb2312, gb18030</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据表处理"><a href="#pandas数据表处理" class="headerlink" title="pandas数据表处理"></a>pandas数据表处理</h2><h3 id="一-数据常用筛选方法"><a href="#一-数据常用筛选方法" class="headerlink" title="一.数据常用筛选方法"></a>一.数据常用筛选方法</h3><p>1.基础索引方式,就是直接引用 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic[[<span class="string">&#x27;户主姓名&#x27;</span>,<span class="string">&#x27;农户生产经营类型&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>2.loc [行索引名称或者条件,列索引名称或者标签]   # 左闭右闭</p>
<p>可以接多个条件(&amp; , | )：（basic[‘age’]&gt;10）&amp; (basic[‘age’]&lt;2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.loc[<span class="number">0</span>:<span class="number">2</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>]] </span><br><span class="line">basic.loc[basic[<span class="string">&#x27;健康状况&#x27;</span>]== <span class="string">&#x27;良好&#x27;</span>,[<span class="string">&#x27;户主姓名&#x27;</span>, <span class="string">&#x27;户主身份证号&#x27;</span>,<span class="string">&#x27;健康状况&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>3.iloc [行索引位置,列索引位置]   # 左闭右开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.iloc[<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">order.iloc[:,[<span class="number">0</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="二-数据增加和删除"><a href="#二-数据增加和删除" class="headerlink" title="二.数据增加和删除"></a>二.数据增加和删除</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h4><p>df.insert(loc, column, value)   添加一列,loc添加位置,column字段名,value添加的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.insert(<span class="number">0</span>, <span class="string">&#x27;出生年月&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h4><p>del  df[column]   # 删除一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> basic[<span class="string">&#x27;数据&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>df.drop(labels,axis,inplace=True)    </p>
<p>labels表示删除的数据, axis表示作用轴，inplace=True表示是否对原数据生效</p>
<p>axis=0按行操作, axis=1按列操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.drop(labels = [<span class="string">&#x27;日期&#x27;</span>, <span class="string">&#x27;销量&#x27;</span>],axis = <span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">basic.drop(labels= <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">11</span>),axis=<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="三-数据修改和查找"><a href="#三-数据修改和查找" class="headerlink" title="三.数据修改和查找"></a>三.数据修改和查找</h3><p>db.rename()     修改列名称或者行索引名称   ，  inplace = True表示生效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic.rename(columns = &#123;<span class="string">&#x27;出生年月&#x27;</span>:<span class="string">&#x27;出生日期&#x27;</span>,<span class="string">&#x27;文化程度&#x27;</span>:<span class="string">&#x27;受教育水平&#x27;</span> &#125;,inplace = <span class="literal">True</span>) <span class="comment">#修改列</span></span><br><span class="line">basic.rename(index = &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;10&#x27;</span>:<span class="string">&#x27;ten&#x27;</span> &#125;,inplace = <span class="literal">True</span>)  <span class="comment">#修改行</span></span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>)   <span class="comment">#  重置索引，从0开始</span></span><br></pre></td></tr></table></figure>
<p>使用loc方法修改数据，查询到数据后直接赋值即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[ df[<span class="string">&#x27;性别&#x27;</span>]== <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;女‘  # 将性别为0的变成女</span></span><br></pre></td></tr></table></figure>
<p>条件与条件之间用 &amp; ， |  连接，分别代表‘且’和‘或’ ，也可以使用between和isin选择满足条件的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].between(<span class="number">18</span>,<span class="number">20</span>,inclusive=<span class="literal">True</span>)]   <span class="comment"># 获取age在18到20的行，inclusive=True表示是左右包含，False为不包含</span></span><br><span class="line">df[df[<span class="string">&#x27;age&#x27;</span>].isin([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])]  <span class="comment"># 获取age为10，20，30的行</span></span><br></pre></td></tr></table></figure>
<h3 id="四-数据整理"><a href="#四-数据整理" class="headerlink" title="四.数据整理"></a>四.数据整理</h3><p>pd.concat(objs,axis,join,ignore_index)  </p>
<p>连接多张表，objs: 表的集合, axis =1用于横向，0代表纵向,join=’inner’表示交集,等于’outer’表示并集，ignore_index=True表示重构索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([order1,order2,order3],axis=<span class="number">0</span>,ignore_index=<span class="literal">False</span>)  </span><br><span class="line"><span class="comment"># 纵向连接3张表，不重构索引，可以在后面使用df.reset_index(inplace=True),默认并集</span></span><br></pre></td></tr></table></figure>
<p>pd.merge(left,right,how,left_on,right_on)      # 很想MySQL数据库中的内连接</p>
<p>合并left与right两张表，how是链接方式，默认inner（内连接），left_on与right_on表示采用左右表的哪个字段链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp.merge(left=df1,right=df2,how=<span class="string">&#x27;inner&#x27;</span>,left_on=<span class="string">&#x27;user_id&#x27;</span>,right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="五-层次化索引"><a href="#五-层次化索引" class="headerlink" title="五.层次化索引"></a>五.层次化索引</h3><p>在一个轴上拥有两个或者两个以上的索引 </p>
<p> 使用loc语句进行访问 , loc里面接受tuple,   如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[(<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;江西&#x27;</span>),<span class="string">&#x27;name&#x27;</span>]  <span class="comment"># 获取&#x27;中国&#x27;索引中的&#x27;江西&#x27;索引的行里面的name列</span></span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">10</span>,(<span class="string">&#x27;第一季&#x27;</span>,[<span class="string">&#x27;销量&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>])]   <span class="comment"># 获取0到10行中&#x27;第一季&#x27;索引下的&#x27;销量&#x27;与&#x27;利润&#x27;列表</span></span><br></pre></td></tr></table></figure>
<h2 id="pandas数据转换"><a href="#pandas数据转换" class="headerlink" title="pandas数据转换"></a>pandas数据转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将列的数据类型变成最接近的类型</span></span><br><span class="line">df.convert_dtypes()</span><br><span class="line"><span class="comment"># 选中string类型的列</span></span><br><span class="line">df.select_dtypes(include=<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="comment"># 转换类型</span></span><br><span class="line">df[<span class="string">&#x27;销量&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一-日期格式数据处理"><a href="#一-日期格式数据处理" class="headerlink" title="一.日期格式数据处理"></a>一.日期格式数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成时间格式 datetime64</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>] = pd.to_datetime(d1[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 时间格式可以使用dt提取年月日时分秒</span></span><br><span class="line">d1[<span class="string">&#x27;日期&#x27;</span>].dt.year</span><br></pre></td></tr></table></figure>
<h3 id="二-高阶函数数据处理"><a href="#二-高阶函数数据处理" class="headerlink" title="二.高阶函数数据处理"></a>二.高阶函数数据处理</h3><p>apply函数，axis=0表示对行进行操作,axis=1表示对列进行操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;贷款余额&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x).strip() )</span><br></pre></td></tr></table></figure>
<p>map函数，将dict中出现的键全部替换成值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;gender&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="三-字符串数据处理"><a href="#三-字符串数据处理" class="headerlink" title="三.字符串数据处理"></a>三.字符串数据处理</h3><p>通过 df[col].str 属性访问下列方法，例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;姓名&#x27;</span>].<span class="built_in">str</span>.srip()  <span class="comment"># 去除空白字符</span></span><br></pre></td></tr></table></figure>
<p>contains()      返回表示各str是否含有指定模式的字符串 </p>
<p>replace() 替换字符串。 </p>
<p>lower() 返回字符串的副本，其中所有字母都转换为小写。 </p>
<p>upper() 返回字符串的副本，其中所有字母都转换为大写。 </p>
<p>split() 返回字符串中的单词列表。 </p>
<p>strip() 删除前导和后置空格。 </p>
<p>join() 返回一个字符串，该字符串是给定序列中所有字符串的连接</p>
<h2 id="pandas数据统计"><a href="#pandas数据统计" class="headerlink" title="pandas数据统计"></a>pandas数据统计</h2><h3 id="一-数据分组运算"><a href="#一-数据分组运算" class="headerlink" title="一.数据分组运算"></a>一.数据分组运算</h3><p>使用 df.groupby方法进行分组计算，得到分组对象GroupBy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g1 = df.groupby(by = <span class="string">&#x27;product’)</span></span><br><span class="line"><span class="string">g2 = df.groupby(by = [&#x27;</span>product<span class="string">&#x27;,&#x27;</span>jgmc’]) </span><br></pre></td></tr></table></figure>
<p>分组对象GroupBy可以运用描述性统计方法, 如count、mean 、 median 、 max和min等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Group.mean() </span><br><span class="line">Group.<span class="built_in">sum</span>()</span><br><span class="line">Group.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<h3 id="二-聚合函数使用"><a href="#二-聚合函数使用" class="headerlink" title="二.聚合函数使用"></a>二.聚合函数使用</h3><p>象使用agg聚合函数   (np=numpy)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped.agg([np.mean,np.<span class="built_in">max</span>]).head(<span class="number">20</span>)</span><br><span class="line">grouped.agg(&#123;<span class="string">&#x27;ye&#x27;</span>:np.mean,<span class="string">&#x27;dkje&#x27;</span>:np.<span class="built_in">max</span>&#125;)</span><br><span class="line">df[[<span class="string">&#x27;销售额&#x27;</span>,<span class="string">&#x27;利润&#x27;</span>]].agg([np.<span class="built_in">sum</span>,np.mean])</span><br></pre></td></tr></table></figure>
<h2 id="pandas数据预处理"><a href="#pandas数据预处理" class="headerlink" title="pandas数据预处理"></a>pandas数据预处理</h2><h3 id="一-重复值处理"><a href="#一-重复值处理" class="headerlink" title="一.重复值处理"></a>一.重复值处理</h3><p>df.duplicated()   判断是否有重复值,返回掩码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.dumplicated()]  <span class="comment"># 获取重复值</span></span><br><span class="line">np.<span class="built_in">sum</span>(df.duplicated())   <span class="comment"># 获取重复的行数</span></span><br></pre></td></tr></table></figure>
<p>df.drop_duplicates()  删除重复值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>)  </span><br><span class="line"><span class="comment"># 如果[&#x27;appname&#x27;,&#x27;size&#x27;]中的值重复就表示为重复着</span></span><br><span class="line">df.drop_duplicates(subset= [<span class="string">&#x27;appname&#x27;</span>,<span class="string">&#x27;size&#x27;</span>],inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二-缺失值处理"><a href="#二-缺失值处理" class="headerlink" title="二.缺失值处理"></a>二.缺失值处理</h3><p>直接删除法 </p>
<p>df.dropna()        how=’any’ 表示只要一个是缺失值就删除，how=’all’表示全部是缺失值才删除，subset指定要判断的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(how=<span class="string">&#x27;any&#x27;</span>,subset=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])  </span><br></pre></td></tr></table></figure>
<p>均值替换、常数替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>,inplace=<span class="literal">True</span>)   <span class="comment"># 将所有缺省值替换成0,并在原表格中改变</span></span><br><span class="line">df.age.fillna(df.age.mean())     <span class="comment"># 在age中将缺失值替换成该字段的中位数</span></span><br><span class="line">df.fillna(value=&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;未知&#x27;</span>&#125;)   <span class="comment"># 根据不同情况填充不同的值</span></span><br></pre></td></tr></table></figure>
<p>前向、后向替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;age&#x27;</span>].fillna(method=<span class="string">&#x27;ffill&#x27;</span>)  <span class="comment"># 使用前一个值替换缺失值</span></span><br><span class="line">df[<span class="string">&#x27;name&#x27;</span>].fillna(method=<span class="string">&#x27;bfill&#x27;</span>)	<span class="comment"># 使用后一个值替换缺失值</span></span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/05/07/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>git命令行操作</p>
<h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git<a id="more"></a></h4><p>git init</p>
<h4 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h4><h5 id="项目级别-仓库级别：仅在当前本地库范围内有效"><a href="#项目级别-仓库级别：仅在当前本地库范围内有效" class="headerlink" title="项目级别/仓库级别：仅在当前本地库范围内有效"></a>项目级别/仓库级别：仅在当前本地库范围内有效</h5><p>git config user.name hui</p>
<p>git config user.email <a href="mailto:&#x31;&#x37;&#x36;&#52;&#x35;&#48;&#x31;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x31;&#x37;&#x36;&#52;&#x35;&#48;&#x31;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a> </p>
<p>信息保存位置：./.git/config 文件</p>
<h5 id="系统用户级别：登录当前操作系统的用户范围"><a href="#系统用户级别：登录当前操作系统的用户范围" class="headerlink" title="系统用户级别：登录当前操作系统的用户范围"></a>系统用户级别：登录当前操作系统的用户范围</h5><p>git config –global user.name hui </p>
<p>git config –global <a href="mailto:&#x31;&#55;&#54;&#52;&#x35;&#48;&#49;&#x35;&#54;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#55;&#54;&#52;&#x35;&#48;&#49;&#x35;&#54;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a> </p>
<p>信息保存位置：~/.gitconfig 文件 </p>
<h5 id="注-就近原则-项目级别优先于系统用户级别"><a href="#注-就近原则-项目级别优先于系统用户级别" class="headerlink" title="注: 就近原则,项目级别优先于系统用户级别"></a>注: 就近原则,项目级别优先于系统用户级别</h5><h4 id="其他常规操作"><a href="#其他常规操作" class="headerlink" title="其他常规操作"></a>其他常规操作</h4><p><font size='4'>状态查看   git status </font></p>
<p><font size='4'>添加  git add[file name] </font></p>
<p><font size='4'>提交 git commit -m’提交日志’ [file name] </font></p>
<h4 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h4><p><font size='4'>git log</font></p>
<p><font size='4'>git reflog  ( 最常用 )</font></p>
<p><font size='4'>git log –pretty=oneline </font></p>
<p><font size='4'>git log –oneline </font></p>
<p>多屏显示控制方式： 空格向下翻页 , b 向上翻页 , q 退出</p>
<h4 id="前进后退版本"><a href="#前进后退版本" class="headerlink" title="前进后退版本"></a>前进后退版本</h4><p>git reset –hard [局部索引值]</p>
<p>git reset –hard HEAD^</p>
<p>注：一个^表示后退一步，n 个表示后退 n 步</p>
<p>git reset –hard HEAD~n</p>
<p>注：表示后退 n 步</p>
<h4 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h4><p>–soft</p>
<p>​        仅仅在本地库移动 HEAD 指针</p>
<p>–mixed</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区</p>
<p>–hard</p>
<p>​        在本地库移动 HEAD 指针 </p>
<p>​        重置暂存区 </p>
<p>​        重置工作区</p>
<h4 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h4><p>git diff [文件名] </p>
<p>将工作区中的文件和暂存区进行比较 </p>
<p>git diff [本地库中历史版本] [文件名] </p>
<p>将工作区中的文件和本地库历史记录比较 ，如果不带文件名则比较多个文件</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>查看分支  git branch -v</p>
<p>创建分支  git branch [分支名]</p>
<p>切换分支  git checkout [分支名]</p>
<p>合并分支  git merge [有新内容分支名]</p>
<p>解决合并分支的冲突</p>
<p>​    第一步：编辑文件，删除特殊字符 </p>
<p>​    第二步：把文件修改到满意的程度，保存退出 </p>
<p>​    第三步：git add [文件名] </p>
<p>​    第四步：git commit -m “日志信息” </p>
<p>​    注意：此时 commit 一定不能带具体文件名</p>
<h4 id="github基本命令"><a href="#github基本命令" class="headerlink" title="github基本命令"></a>github基本命令</h4><p>git clone [远程地址]     克隆项目</p>
<p>git remote -v     查看当前所有远程地址别名</p>
<p>git remote add [别名] [远程地址]     添加远程地址</p>
<p>git push [别名] [分支名]     推送</p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>pull=fetch+merge </p>
<p>git fetch [远程库地址别名] [远程分支名] </p>
<p>git merge [远程库地址别名] [远程分支名] </p>
<p>git pull [远程库地址别名] [远程分支名]</p>
<h5 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h5><p>如果不是基于GitHub远程库的最新版本所做的修改，不能推送，必须先拉取</p>
<p>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可</p>
<p>续。。。</p>
]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX笔记</title>
    <url>/2021/05/09/AJAX%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。<a id="more"></a></p>
<h3 id="前提-服务器用express测试"><a href="#前提-服务器用express测试" class="headerlink" title="前提 : 服务器用express测试"></a>前提 : 服务器用express测试</h3><p>安装 : npm i express</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> express();</span><br><span class="line"><span class="comment">// 开启一个接口，all可替换成get 、 post</span></span><br><span class="line">app.all(<span class="string">&#x27;/server&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 请求头设置跨域 </span></span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="string">&quot;res&quot;</span>:<span class="string">&quot;ajax&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">    response.send(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动8000端口监听</span></span><br><span class="line">app.listen(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器已启动，8000 端口监听中...&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>启动： 打开终端，输入  node  express.js</p>
<h3 id="原生AJAX"><a href="#原生AJAX" class="headerlink" title="原生AJAX"></a>原生AJAX</h3><h4 id="基本API使用"><a href="#基本API使用" class="headerlink" title="基本API使用"></a>基本API使用</h4><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr =<span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure>
<h5 id="初始化-open-requestType-url"><a href="#初始化-open-requestType-url" class="headerlink" title="初始化    open( requestType , url)"></a>初始化    open( requestType , url)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&quot;http://127.0.0.1:8000/server_post?page=1&amp;count=10&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-rulencoded&quot;</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;odd-dog&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="发送-参数是post请求体，如果是get请求则不用传参数"><a href="#发送-参数是post请求体，如果是get请求则不用传参数" class="headerlink" title="发送       参数是post请求体，如果是get请求则不用传参数"></a>发送       参数是post请求体，如果是get请求则不用传参数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="string">&#x27;username=admin&amp;pwd=123&#x27;</span>) </span><br><span class="line"><span class="comment">// xhr.send(&#x27;username:admin&amp;pwd:123&#x27;)</span></span><br></pre></td></tr></table></figure>
<h5 id="事件绑定，处理服务器返回结果"><a href="#事件绑定，处理服务器返回结果" class="headerlink" title="事件绑定，处理服务器返回结果"></a>事件绑定，处理服务器返回结果</h5><p>onreadystatechange : 当readystata属性被改变时调用</p>
<p>readystata 表示xhr中状态的属性 : 0 ，1 ，2 ，3：返回部分响应 ，4：返回全部响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> )&#123;</span><br><span class="line">        <span class="comment">// 如果状态码为 200 </span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status === <span class="number">200</span> )&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status)   <span class="comment">// 状态码</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText)  <span class="comment">//  状态码提示文字</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.getAllResponseHeaders())  <span class="comment">// 打印所有响应头</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response) <span class="comment">//  响应数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理返回的JSON数据"><a href="#处理返回的JSON数据" class="headerlink" title="处理返回的JSON数据"></a>处理返回的JSON数据</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接转换</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(xhr.response)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.responseType=<span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过该时间就取消请求</span></span><br><span class="line">xhr.timeout = <span class="number">2000</span> </span><br><span class="line"><span class="comment">// 时间超时回调函数</span></span><br><span class="line">xhr.ontimeout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">&quot;网络延迟，请稍后重试！！！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure>
<h6 id="可以解决重复发送请求问题"><a href="#可以解决重复发送请求问题" class="headerlink" title="可以解决重复发送请求问题"></a>可以解决重复发送请求问题</h6><p>先定义一个全局变量  let isSending = false </p>
<p>发送请求前先判断，如果当前正在发送，就取消该次的请求，再标识当前正在发送 ，重新发送</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSending)&#123;</span><br><span class="line">    xhr.abort()</span><br><span class="line">&#125;</span><br><span class="line">isSending = <span class="literal">true</span> </span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>发送完毕就标记 isSending = false</p>
<h3 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>$.get(url, [data], [callback], [type])</p>
<p>type:设置返回内容格式，xml, html, script, json, text, _default。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;http://127.0.0.1:8000/server_get&quot;</span>,&#123;<span class="string">&#x27;page&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;num&#x27;</span>:<span class="number">10</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>$.post(url, [data], [callback], [type]) </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">&quot;http://127.0.0.1:8000/server_post&quot;</span>,&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jerry&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">13</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="string">&#x27;json&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注：get中的data参数是设置params，而post是设置请求体</p>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://127.0.0.1:8000/server&quot;</span>,</span><br><span class="line">    data : &#123;<span class="string">&quot;username&quot;</span> : <span class="string">&quot;admin&quot;</span> , <span class="string">&quot;gender&quot;</span> : <span class="string">&quot;man&quot;</span> &#125;,</span><br><span class="line">    type : <span class="string">&quot;POST&quot;</span>,  	<span class="comment">// 请求类型</span></span><br><span class="line">    dataType : <span class="string">&quot;json&quot;</span>,  <span class="comment">// 数据类型</span></span><br><span class="line">    timeout : <span class="number">2000</span> , 	<span class="comment">// 超时时间</span></span><br><span class="line">    <span class="comment">// 成功调用</span></span><br><span class="line">    success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败调用</span></span><br><span class="line">    error : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求失败，请重试！！！&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    headers : &#123;</span><br><span class="line">        name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        age : <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>设置通用地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL= <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>axios.get(url  [, config])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;server&quot;</span>,&#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">1</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p>axios.post(url[, data [, config]])</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;server&quot;</span>,&#123;<span class="attr">username</span> : <span class="string">&#x27;tom&#x27;</span>,<span class="attr">pwd</span> : <span class="string">&#x27;123&#x27;</span>&#125;, &#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    params : &#123;</span><br><span class="line">        page:<span class="number">10</span>, <span class="attr">nums</span>: <span class="number">20</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    headers: &#123; </span><br><span class="line">        name:<span class="string">&#x27;jerry&#x27;</span>,<span class="attr">age</span>:<span class="number">3</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h4><p>axios( {config} )</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;server&#x27;</span>,</span><br><span class="line">    method : <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    params : &#123;<span class="attr">width</span>:<span class="number">100</span>,<span class="attr">height</span>:<span class="number">200</span>&#125;,</span><br><span class="line">    data : &#123;<span class="attr">name</span>:<span class="string">&#x27;kyrie&#x27;</span>,<span class="attr">job</span>:<span class="string">&#x27;ball&#x27;</span>&#125;,</span><br><span class="line">    headers:&#123;<span class="attr">sure</span>:<span class="string">&#x27;yes&#x27;</span>&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求拦截器---成功&quot;</span>)</span><br><span class="line">    config.params=&#123;<span class="attr">page</span>:<span class="number">100</span>&#125;</span><br><span class="line">    <span class="comment">// throw &quot;error..........&quot;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求拦截器---失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;响应拦截器---成功&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.data</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;响应拦截器---失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    url:<span class="string">&quot; http://localhost:3000/posts&quot;</span>,</span><br><span class="line">    <span class="comment">// 设置取消请求</span></span><br><span class="line">    cancelToken:<span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">        cancel=c</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用该方法即可取消上面axios的请求</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>
<p>详情请参考   <a href="https://github.com/axios/axios">https://github.com/axios/axios</a> </p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。</p>
<p>同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。</p>
<h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><ol>
<li><p>JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 </p>
</li>
<li><p>在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p>
</li>
<li><p>JSONP 的使用</p>
</li>
</ol>
<p>通过script.src来访问需跨域的服务器，但是script返回的不能是单纯数据，需要返回一个函数的调用，这里事先定义一个函数 fn，让script返回 fn 函数的调用，在函数调用里面传入数据</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>动态创建script标签，设置src值，url参数设为回调函数名，然后讲scripy添加到body中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数中的data就是跨域后获取的数据，需要依靠script返回的结果来调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	alert(data.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>获取回调函数名，用拼接的方式返回该函数的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;/testAJAX&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 获取回调函数名</span></span><br><span class="line">   	<span class="keyword">var</span> callback = request.query.callback </span><br><span class="line">   	<span class="comment">// 获取数据(随便定义一下，一般这里是从数据库中获取)</span></span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;怪狗狗&#x27;</span>&#125;</span><br><span class="line">  	<span class="comment">// 返回函数的调用</span></span><br><span class="line">    response.send(callback+<span class="string">&quot;(&quot;</span>+ <span class="built_in">JSON</span>.stringify(data) +<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ol>
<li><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p>
</li>
<li><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 </p>
</li>
<li><p>CORS 的使用</p>
</li>
</ol>
<p>主要是服务器端来设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)   <span class="comment">// 允许任意源访问</span></span><br><span class="line">response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)  <span class="comment">// 允许设置自定义请求头</span></span><br></pre></td></tr></table></figure>
<p>了解更多CORS，请参考   <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6+新特性</title>
    <url>/2021/05/11/ES6-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个<a id="more"></a></p>
<p>ECMA-262（ECMAScript）历史版本查看网址</p>
<p> <a href="http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm">http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm</a></p>
<p><a href="https://imgtu.com/i/gU0McT"><img src="https://z3.ax1x.com/2021/05/11/gU0McT.png" alt="gU0McT.png"></a></p>
<h3 id="ES6-兼容性"><a href="#ES6-兼容性" class="headerlink" title="ES6 兼容性"></a>ES6 兼容性</h3><p><a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a> 可查看兼容性</p>
<p><a href="https://imgtu.com/i/gUBuad"><img src="https://z3.ax1x.com/2021/05/11/gUBuad.png" alt="gUBuad.png"></a></p>
<h3 id="ECMASript-6-新特性"><a href="#ECMASript-6-新特性" class="headerlink" title="ECMASript 6 新特性"></a>ECMASript 6 新特性</h3><h4 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h4><ol>
<li><p>不允许重复声明 </p>
</li>
<li><p>块儿级作用域 </p>
</li>
<li><p>不存在变量提升 </p>
</li>
<li><p>不影响作用域链 </p>
</li>
</ol>
<p>应用场景：以后声明变量使用 let 就对了</p>
<h4 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h4><ol>
<li><p>声明必须赋初始值 </p>
</li>
<li><p>标识符一般为大写 </p>
</li>
<li><p>不允许重复声明 </p>
</li>
<li><p>值不允许修改 </p>
</li>
<li><p>块儿级作用域</p>
</li>
</ol>
<p>应用场景：声明对象类型使用 const，非对象类型声明选择 let</p>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称 为解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;张学友&#x27;</span>, <span class="string">&#x27;刘德华&#x27;</span>, <span class="string">&#x27;黎明&#x27;</span>, <span class="string">&#x27;郭富城&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [zhang, liu, li, guo] = arr;</span><br><span class="line"><span class="comment">//对象的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">     name: <span class="string">&#x27;林志颖&#x27;</span>,</span><br><span class="line">     tags: [<span class="string">&#x27;车手&#x27;</span>, <span class="string">&#x27;歌手&#x27;</span>, <span class="string">&#x27;小旋风&#x27;</span>, <span class="string">&#x27;演员&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, tags&#125; = lin;</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识</p>
<ol>
<li><p>字符串中可以出现换行符</p>
</li>
<li><p>可以使用 ${xxx} 形式输出变量</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量拼接</span></span><br><span class="line"><span class="keyword">let</span> star = <span class="string">&#x27;王宁&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">`<span class="subst">$&#123;star&#125;</span>在前几年离开了开心麻花`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性和方法简写</span></span><br><span class="line"><span class="keyword">let</span> atguigu = &#123;</span><br><span class="line">     name,</span><br><span class="line">     slogon,</span><br><span class="line">     improve,</span><br><span class="line">     <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;可以改变你&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="箭头函数-lambda"><a href="#箭头函数-lambda" class="headerlink" title="箭头函数 lambda"></a>箭头函数 lambda</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">item</span> =&gt;</span> item * item</span><br></pre></td></tr></table></figure>
<h5 id="注-箭头函数-this-指向声明时所在作用域下-this-的值-；不能使用-arguments"><a href="#注-箭头函数-this-指向声明时所在作用域下-this-的值-；不能使用-arguments" class="headerlink" title="注: 箭头函数 this 指向声明时所在作用域下 this 的值  ；不能使用 arguments"></a>注: 箭头函数 this 指向声明时所在作用域下 this 的值  ；不能使用 arguments</h5><h4 id="rest-参数-与-spread-扩展运算符"><a href="#rest-参数-与-spread-扩展运算符" class="headerlink" title="rest 参数 与 spread 扩展运算符"></a>rest 参数 与 spread 扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rest 参数可以传任一个，但必须放最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// spread 对数组进行解构</span></span><br><span class="line"><span class="keyword">let</span> tfboys = [<span class="string">&#x27;德玛西亚之力&#x27;</span>,<span class="string">&#x27;德玛西亚之翼&#x27;</span>,<span class="string">&#x27;德玛西亚皇子&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> number = [<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;bob&#x27;</span>,<span class="string">&#x27;jerry&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> sum = [...tfboys, ...number];</span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提 供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p>
<p>ES6 创造了一种新的遍历命令 for…of/in 循环，Iterator 接口主要供 for…of/in 消费</p>
<p>具备iterator接口的数据有  Array、Arguments 、Set 、 Map、 String、 TypedArray 、NodeList</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>创建一个指针对象index，指向当前数据结构的起始位置 </p>
<p>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p>
<p>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</p>
<p>每调用 next 方法返回一个包含 value 和 done 属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代器iterator ，迭代team中的member数组</span></span><br><span class="line"><span class="keyword">let</span> team =&#123;</span><br><span class="line">    name : <span class="string">&#x27;hui&#x27;</span>,</span><br><span class="line">    member : [<span class="string">&#x27;怪狗狗&#x27;</span>,<span class="string">&#x27;super Saiya&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;jerry&#x27;</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="comment">// 定义一个指针</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            next:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( index &lt; <span class="built_in">this</span>.member.length)&#123;</span><br><span class="line">                    <span class="keyword">const</span> res= &#123;<span class="attr">value</span> : <span class="built_in">this</span>.member[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">                    index ++ </span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span> : <span class="string">&quot;迭代完毕&quot;</span>,<span class="attr">done</span> :<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> team)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器  *"></a>生成器  *</h4><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>1.生成器返回的结果是一个迭代器对象，调用该迭代器中的next方法可执行yield之间的代码块</p>
<p>2.yield相当于函数中的暂停标志, next方法可以传递参数，作为yield语句的返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;用户数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderData</span>(<span class="params">user_data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取user_data:&#x27;</span>+user_data)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;订单数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goodsData</span>(<span class="params">order_data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取order_data:&#x27;</span>+order_data)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;商品数据&quot;</span></span><br><span class="line">        <span class="comment">// 将数据传递给下一块执行区中</span></span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user_data = <span class="keyword">yield</span> userData()</span><br><span class="line">    <span class="keyword">let</span> order_data = <span class="keyword">yield</span> orderData(user_data)</span><br><span class="line">    goods_data = <span class="keyword">yield</span> goodsData(order_data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取goods_data:&#x27;</span>+goods_data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。 </p>
<h5 id="基本API调用"><a href="#基本API调用" class="headerlink" title="基本API调用"></a>基本API调用</h5><h6 id="new-Premose-fn"><a href="#new-Premose-fn" class="headerlink" title="new Premose(fn)"></a>new Premose(fn)</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用 resolve(data)  改变pending状态(PromiseState): fulfilled</span></span><br><span class="line"> <span class="comment">// 使用 reject(data)	  改变pending状态(PromiseState): rejected</span></span><br><span class="line"><span class="comment">//  抛出异常 throw:&#x27;xxx&#x27;  如果当前是 pending 就会变为 rejected</span></span><br><span class="line"><span class="keyword">let</span> p =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;<span class="attr">code</span>:<span class="number">200</span> ,<span class="attr">data</span> :<span class="string">&quot;数据....&quot;</span>,<span class="attr">error_message</span>:<span class="literal">null</span>&#125;</span><br><span class="line">    <span class="comment">// let res = &#123;code:403 ,data:null,error_message :&#x27;权限不足！！！&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">if</span>(res.code===<span class="number">200</span>)&#123;</span><br><span class="line">        resolve(res.data)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(res.error_message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-prototype-then-fn1-fn2"><a href="#Promise-prototype-then-fn1-fn2" class="headerlink" title="Promise.prototype.then(fn1[,fn2])"></a>Promise.prototype.then(fn1[,fn2])</h6><p>如果状态成功，就调用fn1，失败就调用[fn2]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success:&quot;</span>+value)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;failed:&quot;</span>+reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-prototype-catch-fn"><a href="#Promise-prototype-catch-fn" class="headerlink" title="Promise.prototype.catch(fn)"></a>Promise.prototype.catch(fn)</h6><p>失败就调用 fn函数  （为了让 语法与 then 区分）</p>
<h6 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h6><p>​    value: 成功的数据或 promise 对象</p>
<p>​    说明: 返回一个成功/失败的 promise 对象</p>
<h6 id="Promise-reject-value"><a href="#Promise-reject-value" class="headerlink" title="Promise.reject(value)"></a>Promise.reject(value)</h6><p>​    reason: 失败的原因 </p>
<p>​    说明: 返回一个失败的 promise 对象</p>
<h6 id="Promise-all-promises"><a href="#Promise-all-promises" class="headerlink" title="Promise.all(promises)"></a>Promise.all(promises)</h6><p>​    promises: 包含 n 个 promise对象 的数组 </p>
<p>​    说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就 直接失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;resolve(<span class="string">&quot;oh year&quot;</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
<h6 id="Promise-race-promises"><a href="#Promise-race-promises" class="headerlink" title="Promise.race(promises)"></a>Promise.race(promises)</h6><p>​    promises: 包含 n 个 promise 的数组 </p>
<p>​    说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(()=&#123;</span><br><span class="line">         resolve(<span class="string">&quot;oh year&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Promise</span>.race([p1,p2,p3])   </span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
<h5 id="promise-then-返回的新-promise-的结果状态"><a href="#promise-then-返回的新-promise-的结果状态" class="headerlink" title="promise.then()  返回的新 promise 的结果状态"></a>promise.then()  返回的新 promise 的结果状态</h5><p>① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p>
<p>② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p>
<p>③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p>
<p>因此 then() 可以链式调用</p>
<h5 id="promise-异常穿透"><a href="#promise-异常穿透" class="headerlink" title="promise 异常穿透"></a>promise 异常穿透</h5><p>使用promise的then链式调用时，可以在最后指定失败的回调 ,</p>
<p>前面任何操作出现了异常，都会传到最后失败的回调中处理</p>
<h5 id="中断-promise-链"><a href="#中断-promise-链" class="headerlink" title="中断 promise 链"></a>中断 promise 链</h5><p>当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>可在回调函数中返回一个 pendding 状态的 promise 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><p>新的数据结构，类似与java中的Set集合，去重 </p>
<p>常用方法  size   、 add 、 delete 、has 、clear</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> arr_set = [...new <span class="built_in">Set</span>(arr)] </span><br><span class="line"><span class="keyword">let</span> arr2_set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> res = arr_set.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2_set.has(item))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;交集:&quot;</span>+res)</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> res2 = [...new <span class="built_in">Set</span>([...arr,...arr2])]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;并集:&quot;</span>+res2)</span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> res3 = arr_set.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr2_set.has(item))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集:&quot;</span>+res3)</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>新的数据结构，类似与对象，但是‘ 键 ’ 的范围不限于字符串</p>
<p>常用方法 : size  、 set 、 get  、 has  、 clear</p>
<h4 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h4><p>新的 class 写法只是让对象 原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, color, price</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对象方法</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我可以打电话!!!&#x27;</span>)</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类   extends 继承 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, color, price, screen, pixel</span>)</span> &#123;</span><br><span class="line">         <span class="comment">// 调用父类方法</span></span><br><span class="line">         <span class="built_in">super</span>(brand, color, price);</span><br><span class="line">         <span class="built_in">this</span>.screen = screen;</span><br><span class="line">         <span class="built_in">this</span>.pixel = pixel;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">     <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;我可以进行视频通话!!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类方法</span></span><br><span class="line">     <span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	 <span class="built_in">console</span>.log(<span class="string">&#x27;我可以拍照!!&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">     <span class="keyword">static</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(<span class="string">&#x27;我可以运行程序&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">const</span> Nokia = <span class="keyword">new</span> Phone(<span class="string">&#x27;诺基亚&#x27;</span>, <span class="string">&#x27;灰色&#x27;</span>, <span class="number">230</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone6s = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>, <span class="number">6088</span>,<span class="string">&#x27;4.7inch&#x27;</span>,<span class="string">&#x27;500w&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="get-与-set"><a href="#get-与-set" class="headerlink" title="get 与 set"></a>get 与 set</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get_price。。。 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">money</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set_price...  &#x27;</span>+ money)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p =<span class="keyword">new</span> phone()</span><br><span class="line">p.price <span class="comment">// 调用get</span></span><br><span class="line">p.price = <span class="number">100</span>  <span class="comment">// 调用set</span></span><br></pre></td></tr></table></figure>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;odd-dog&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wolf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集体导出</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;smith&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wolf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hhhhh&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;name , wolf&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    wolf :<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;xxxxxxxx&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 常规引入</span></span><br><span class="line">    <span class="keyword">import</span> * as m1 from <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> * as m2 from <span class="string">&quot;./m2.js&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> * as m3 from <span class="string">&quot;./m3.js&quot;</span></span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 结构赋值形式 （不能重名）</span></span><br><span class="line">    <span class="keyword">import</span> &#123;name,wolf&#125; <span class="keyword">from</span> <span class="string">&quot;./m1.js&quot;</span></span><br><span class="line">    <span class="keyword">import</span> &#123;name <span class="keyword">as</span> n2,wolf <span class="keyword">as</span> w2&#125; <span class="keyword">from</span> <span class="string">&quot;./m2.js&quot;</span></span><br><span class="line">    <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m3 &#125; <span class="keyword">from</span> <span class="string">&quot;./m3.js&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 简便形式(针对默认导出)</span></span><br><span class="line">    <span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&#x27;./m3.js&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(m3)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="引入入口文件"><a href="#引入入口文件" class="headerlink" title="引入入口文件"></a>引入入口文件</h5><p>将所有的导入放入一个文件中  , 例如 app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来引入所需的所有js文件</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">&#x27;./m2.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">&#x27;./m3.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"><span class="built_in">console</span>.log(m2)</span><br><span class="line"><span class="built_in">console</span>.log(m3)</span><br></pre></td></tr></table></figure>
<p>index.html中这样引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./app.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-7-新特性"><a href="#ECMASript-7-新特性" class="headerlink" title="ECMASript 7 新特性"></a>ECMASript 7 新特性</h3><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h4><p>方法用来检测数组中是否包含某个元素，返回布尔类型值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mingzhu = [<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;水浒传&quot;</span>,<span class="string">&quot;红楼梦&quot;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&quot;西游记&quot;</span>))   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&quot;金瓶梅&quot;</span>))   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂运算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>)    <span class="comment">// 型特性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>))  <span class="comment">// 老方法</span></span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-8-新特性"><a href="#ECMASript-8-新特性" class="headerlink" title="ECMASript 8 新特性"></a>ECMASript 8 新特性</h3><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>​    1.async 函数的返回值为 promise 对象</p>
<p>​    2. 返回的promise 对象的由 async 函数执行的返回值决定</p>
<h4 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h4><ol>
<li><p>await 必须写在 async 函数中</p>
</li>
<li><p>await 右侧的表达式一般为 promise 对象 </p>
</li>
<li><p>await 返回的是 promise 成功的值 </p>
</li>
<li><p>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</p>
</li>
</ol>
<p>用async 与 await 发送AJAX</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将发送AJAX封装到一个promise方法中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAJAX</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&quot;get&quot;</span>,url)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">299</span>)&#123;</span><br><span class="line">                    resolve(xhr.response)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(<span class="string">&quot;出错了！！！&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来方法使用 then 调用,如果要使用then中的value，还需嵌套调用</span></span><br><span class="line"><span class="comment">// sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value =&gt; console.log(value))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用async 与 await 发送AJAX（让异步函数可以同步执行）</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;http://127.0.0.1:8000/server&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res3 = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;http://127.0.0.1:80000/server&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(res3)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h4 id="Object-keys-、values-和-entries"><a href="#Object-keys-、values-和-entries" class="headerlink" title="Object.keys  、values 和 entries"></a>Object.keys  、values 和 entries</h4><p>Object.keys()   获取对象 所有 键</p>
<p>Object.values() 获取对象 所有 值</p>
<p>Object.entries() 获取对象 [key,value] 的数组</p>
<h3 id="ECMASript-9-新特性"><a href="#ECMASript-9-新特性" class="headerlink" title="ECMASript 9 新特性"></a>ECMASript 9 新特性</h3><h4 id="为对象提供-Rest-Spread-属性"><a href="#为对象提供-Rest-Spread-属性" class="headerlink" title="为对象提供 Rest/Spread 属性"></a>为对象提供 Rest/Spread 属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================  扩展运算符 与rest 参数 ==================== </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span> (<span class="params">&#123;username,password, ...other_config&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="built_in">console</span>.log(password)</span><br><span class="line">    <span class="built_in">console</span>.log(other_config) <span class="comment">// 该属性包含了一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    username : <span class="string">&#x27;hui&#x27;</span>,</span><br><span class="line">    password : <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    port : <span class="number">3306</span>,</span><br><span class="line">    host : <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">connect(data)</span><br><span class="line"><span class="comment">// 对对象进行解构</span></span><br><span class="line"><span class="keyword">const</span> skillOne = &#123;<span class="attr">q</span> : <span class="string">&#x27;天音波&#x27;</span>&#125;;<span class="keyword">const</span> skillTwo = &#123;<span class="attr">w</span> : <span class="string">&#x27;金钟罩&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> skillThree = &#123;<span class="attr">e</span> : <span class="string">&#x27;拍地板&#x27;</span>&#125;;<span class="keyword">const</span> skillFour = &#123;<span class="attr">r</span> : <span class="string">&#x27;一库&#x27;</span>&#125; </span><br><span class="line"><span class="keyword">const</span> mangSeng = &#123;...skillOne , ...skillTwo , ...skillThree , ...skillFour&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mangSeng)</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h4><p>允许命名捕获组中使用符  ?&lt; name &gt; ,这样获取捕获结果可读性更强</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;a href=&quot;www.baidu.com&quot;&gt;去百度&lt;/a&gt;&#x27;</span></span><br><span class="line"><span class="comment">// 以前版本</span></span><br><span class="line"><span class="keyword">let</span> reg  = <span class="regexp">/&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/</span></span><br><span class="line"><span class="keyword">const</span> result = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span></span><br><span class="line"><span class="keyword">let</span> result2 =reg2.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(result2.groups.url)</span><br><span class="line"><span class="built_in">console</span>.log(result2.groups.text)</span><br></pre></td></tr></table></figure>
<h3 id="ECMASript-10-新特性"><a href="#ECMASript-10-新特性" class="headerlink" title="ECMASript 10 新特性"></a>ECMASript 10 新特性</h3><p>trimStart 和 trimEnd   去除前后空字符</p>
<p>Array.prototype.flat 与 flatMap   降维</p>
<p>Symbol.prototype.description  获取Symbol的字符串描述</p>
<h3 id="ECMASript-11-新特性"><a href="#ECMASript-11-新特性" class="headerlink" title="ECMASript 11 新特性"></a>ECMASript 11 新特性</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p>定义属性时前面加 # 号，外部将不能直接访问私有属性</p>
<h4 id="Promise-allSettled-与-all"><a href="#Promise-allSettled-与-all" class="headerlink" title="Promise.allSettled 与 all"></a>Promise.allSettled 与 all</h4><p>批量处理异步函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;用户数据--1&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;用户数据--2&quot;</span>)</span><br><span class="line">        <span class="comment">// reject(&quot;出错了！！！&quot;)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// allSettled 永远返回成功</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Promise</span>.allSettled([p1,p2])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">// all 异步任务全部成功才返回成功的值，只要失败一个，就返回该失败的值</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line"><span class="built_in">console</span>.log(res2)</span><br></pre></td></tr></table></figure>
<h4 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符   ?."></a>可选链操作符   ?.</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果直接这样写，用户没传数据则会报错</span></span><br><span class="line">    <span class="comment">// this.port = config.data.port</span></span><br><span class="line">    <span class="comment">// 原来的解决方法</span></span><br><span class="line">    <span class="comment">// this.port = config &amp;&amp; config.data &amp;&amp; config.data.port </span></span><br><span class="line">    <span class="comment">// 现在使用 可选链操作符</span></span><br><span class="line">    <span class="built_in">this</span>.port = config?.data?.port</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态-import-导入"><a href="#动态-import-导入" class="headerlink" title="动态 import 导入"></a>动态 import 导入</h4><p>懒加载，使用时动态导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// ===================  单击事件中动态导入module  =====================</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//import 返回一个Promise对象，该对象中有暴露的方法与属性</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./m.js&#x27;</span>).then(<span class="function"><span class="params">module</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.hello()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h4><p>无论在哪个环境中，globalThis都代表全局对象 window </p>
<h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>  </span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 存放回调函数</span></span><br><span class="line">        <span class="built_in">this</span>.callback = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现resolve</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 如果状态已经改变了，就不能继续改变状态与值了</span></span><br><span class="line">            <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span> </span><br><span class="line">            <span class="comment">// 改变promise状态与值</span></span><br><span class="line">            self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">            self.PromiseResult = data</span><br><span class="line">            <span class="comment">// 如果有回调函数就调用，遍历该回调函数数组</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.callback.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                    item.onResolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现reject</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span> </span><br><span class="line">            <span class="comment">// 改变promise状态与值</span></span><br><span class="line">            self.PromiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">            self.PromiseResult = data</span><br><span class="line">            <span class="comment">// 如果有回调函数就调用，遍历该回调函数数组</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.callback.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                    item.onReject(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用传递过来的方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onResolve,onReject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onResolve !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            onResolve = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onReject !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            onReject = <span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> reason</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 封装返回Promise的回调函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> result = type(self.PromiseResult)</span><br><span class="line">                    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                        result.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                            resolve(value)</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            reject(reason)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功回调</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 执行函数返回的结果影响着then的Promise返回结果</span></span><br><span class="line">                <span class="comment">// 变成异步</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    callback(onResolve)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败回调</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&quot;rejected&quot;</span>)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    callback(onReject)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态没改变，保留回调方法,等待状态改变时调用</span></span><br><span class="line">            <span class="comment">// 回调方法放入放入一个对象中，再压入数组中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState ===<span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.callback.push(&#123;</span><br><span class="line">                    onResolve:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        callback(onResolve)</span><br><span class="line">                    &#125; , </span><br><span class="line">                    onReject:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        callback(onReject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch</span></span><br><span class="line">    <span class="keyword">catch</span>(onReject)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onReject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  resolve</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                value.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(v)</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  reject</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  all</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历Promise数组，一旦有失败的Promise就立刻返回，并结束遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> res = []</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.length;i++)&#123;</span><br><span class="line">                promises[i].then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    res[i]=v</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static  race</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function"><span class="params">p</span>=&gt;</span>&#123;</span><br><span class="line">                p.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(v)</span><br><span class="line">                &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象笔记</title>
    <url>/2021/05/26/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>基本概念 : 构造方法名与类名完全相同并且没有返回值类型，连void都不许有。</p>
<p>默认构造方法 : 当一个类中没有定义任何构造方法时，编译器会自动添加一个无参空构 造构造方法，叫做默认/缺省构造方法， 若类中出现了构造方法，则编译器不再提供任何形式的构造方法 <a id="more"></a></p>
<p>作用 : 使用new关键字创建对象时会自动调用构造方法实现成员变量初始化工作</p>
<h2 id="方法重载（OverLoad）"><a href="#方法重载（OverLoad）" class="headerlink" title="方法重载（OverLoad）"></a>方法重载（OverLoad）</h2><p>基本概念 : 方法名称相同，参数列表不同，这样的方法之间构成重载关系</p>
<p>体现形式 : 方法重载的主要形式体现在：参数的个数不同、参数的类型不同、参数 的顺序不同，与返回值类型和形参变量名无关，但建议返回值类型最好 相同</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>基本概念 :</p>
<p>​    1.若在构造方法中出现了this关键字，则代表当前正在构造的对象</p>
<p>​    2.若在成员方法中出现了this关键字，则代表当前正在调用的对象</p>
<p>​    3.this关键字本质上就是当前类类型的引用变量</p>
<p>使用方式:</p>
<p>​    1. 当局部变量名与成员变量名相同时，在方法体中会优先使用局部变量(就 近原则)，若希望使用成员变量，则需要在成员变量的前面加上this.的前 缀，明确要求该变量是成员变量</p>
<p>​    2. this关键字除了可以通过this.的方式调用成员变量和成员方法外，还可以 作为方法的返回值</p>
<p>​    3. 再构造方法的第一行可以使用this()的方式来调用本类中的其他构造方法</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>基本概念 : 使用static关键字修饰成员变量表示静态的含义，此时成员变量由对象层 级提升为类层级，也就是整个类只有一份并被所有对象共享，该成员变 量随着类的加载准备就绪，与是否创建对象无关。  </p>
<p>注意事项 : </p>
<p>​        1.static关键字修饰的成员可以使用引用.的方式访问，但推荐类名.的方式</p>
<p>​        2. 在非静态成员方法中既能访问非静态的成员又能访问静态的成员</p>
<p>​        3. 在静态成员方法中只能访问静态成员不能访问非静态成员</p>
<h2 id="构造快和静态代码块"><a href="#构造快和静态代码块" class="headerlink" title="构造快和静态代码块"></a>构造快和静态代码块</h2><p>构造块：在类体中直接使用{}括起来的代码块。 每创建一个对象都会执行一次构造块。 </p>
<p>静态代码块：使用static关键字修饰的构造块 static{} 。  静态代码块随着类加载时执行一次。</p>
<p>执行顺序 ：静态代码块  =》 构造快 =》 构造方法</p>
<h2 id="单例设计模式的概念"><a href="#单例设计模式的概念" class="headerlink" title="单例设计模式的概念"></a>单例设计模式的概念</h2><p>在某些特殊场合中，一个类对外提供且只提供一个对象时，这样的类叫 做单例类，而设计单例的流程和思想叫做单例设计模式。单例设计模式的实现方式有两种：饿汉式 和 懒汉式。在以后的开发中推荐 饿汉式。</p>
<p>单例设计模式的实现流程 ：</p>
<pre><code>1. 私有化构造方法，使用private关键字修饰。 
2. 声明本类类型的引用指向本类类型的对象，并使用private static关键字共 同修饰。 
3.  提供公有的get方法负责将对象返回出去，并使用public static关键字共同 修饰。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">// 创建示例对象，保存到静态成员中，并且私有化，不允许被修改</span></span><br><span class="line">	<span class="comment">//private static Singleton sin = new Singleton();  // 饿汉式	</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton sin = <span class="keyword">null</span>;	   <span class="comment">// 懒汉式</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 私有化构造方法 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取实例，将实例对象暴露出去</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 懒汉式需加此判断</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span>==sin)&#123;</span><br><span class="line">			sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sin;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承(extends)"></a>继承(extends)</h2><p>概念  :  当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成 一个公共类，让多个类吸收公共类中已有特征和行为,而在多个类型只需 要编写自己独有特征和行为的机制，叫做继承。</p>
<p>特点:</p>
<p>1.子类不能继承父类的构造方法和私有方法，但私有成员变量可以被继承 只是不能直接访问。</p>
<p>2.无论使用何种方式构造子类的对象时都会自动调用父类的无参构造方法， 来初始化从父类中继承的成员变量，相当于在构造方法的第一行增加代 码   super()   的效果,也可以手动调用 super(arguments) 来调用父类的其他构造方法</p>
<p>重写(Override):</p>
<ol>
<li>要求方法名相同、参数列表相同以及返回值类型相同，从Java5开始允许 返回子类类型。 </li>
<li> 要求方法的访问权限不能变小，可以相同或者变大。 </li>
<li> 要求方法不能抛出更大的异常(异常机制)。</li>
</ol>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>常用的访问控制符</p>
<p><a href="https://imgtu.com/i/2CAd58"><img src="https://z3.ax1x.com/2021/05/26/2CAd58.png" alt="2CAd58.png" style="zoom:50%;" /></a></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>基本概念 : final本意为”最终的、不可改变的”，可以修饰类、成员方法以及成员变量</p>
<p>使用方式:</p>
<p>​    1.final关键字修饰类体现在该类不能被继承</p>
<p>​    2.final关键字修饰成员方法体现在该方法不能被重写但可以被继承。</p>
<p>​    3.final关键字修饰成员变量体现在该变量必须初始化且不能改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>  String AB = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="comment">// 也可以在代码块中定义常量,当然在构造函数中也行</span></span><br><span class="line"><span class="keyword">final</span> String CD;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.CD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量（constant）：在以后的开发中很少单独使用final关键字来修饰成员变量，通常使用 public static final关键字共同修饰成员变量来表达常量的含义，命名字母一般大写且下划线分开</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的语法格式： 父类类型 引用变量名 = new 子类类型() ；</p>
<p>特点:</p>
<p>​    1.当父类类型的引用指向子类类型的对象时，父类类型的引用可以直接调 用父类独有的方法。</p>
<p>​    2.当父类类型的引用指向子类类型的对象时，父类类型的引用不可以直接 调用子类独有的方法。</p>
<p>​    3.对于父子类都有的非静态方法来说，编译阶段调用父类版本，运行阶段 调用子类重写的版本（动态绑定）</p>
<p>​    4.对于父子类都有的静态方法来说，编译和运行阶段都调用父类版本</p>
<p>对于第二点，如果要调用子类独有的方法，可强制类型转换(向下转型)，将父类型转换成子类型，若强转目标类型不是该引用类型的真正指向的类型，编译会通过，但是运行阶段会发生类型转换异常ClassCastException。为了避免这种情况发生，可以在转换之前判断： if(引用变量 instanceof 数据类型) </p>
<p>多态的实际意义 :  在于屏蔽不同子类的差异性实现通用的编程带来不同的 效果。</p>
<h1 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h1><h2 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h2><p>抽象方法: 主要指不能具体实现的方法并且使用abstract关键字修饰，也就 是没有方法体。</p>
<p>抽象类 : 类主要指不能具体实例化的类并且使用abstract关键字修饰，也就是 不能创建对象.</p>
<p>抽象类与抽象方法的关系:</p>
<p>​    1.抽象类中可以有成员变量、构造方法、成员方法； </p>
<p>​    2.抽象类中可以没有抽象方法，也可以有抽象方法； </p>
<p>​    3.拥有抽象方法的类必须是抽象类，因此真正意义上的抽象类应该是具有 抽象方法并且使用abstract关键字修饰的类。</p>
<p>实际意义 : </p>
<p>​    1.抽象类的实际意义不在于创建对象而在于被继承。 </p>
<p>​    2.当一个类继承抽象类后必须重写抽象方法，否则该类也变成抽象类，也 就是抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</p>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><p>接口是一种比抽象类还抽象的类，体现在所有方法都为抽象方法。</p>
<p>接口与抽象类之间的关系:</p>
<p><a href="https://imgtu.com/i/2CaZMd"><img src="https://z3.ax1x.com/2021/05/27/2CaZMd.png" alt="2CaZMd.png" style="zoom:50%;" /></a></p>
<p>接口与类的主要区别:</p>
<p>1.定义抽象类的关键字是abstract class，而定义接口的关键字是interface。 </p>
<p>2.继承抽象类的关键字是extends，而实现接口的关键字是implements。 </p>
<p>3.继承抽象类支持单继承，而实现接口支持多实现。 </p>
<p>4.抽象类中可以有构造方法，成员变量，成员方法，而接口中只能有抽象方法与常量。  </p>
<p>5.抽象类中增加方法时子类可以不用重写，而接口中增加方法时实现类需 要重写（Java8以前的版本）。 </p>
<p>6.从Java8开始增加新特性，接口中允许出现非抽象方法和静态方法，但非 抽象方法需要使用default关键字修饰。 </p>
<p>7.从Java9开始增加新特性，接口中允许出现私有方法。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类 （Inner），而这个内部类所在的类叫做外部类（Outer）</p>
<h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>-直接将一个类的定义放在另外一个类的类体中。</p>
<p>使用方式:</p>
<p>​    1.普通内部类和普通类一样可以定义成员变量、成员方法以及构造方法等</p>
<p>​    2.如果内部类访问外部类中与本类内部同名的成员变量或方法时，需要使 用this关键字。</p>
<p>​    3. 普通内部类需要使用外部类对象来创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先创建外部类</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">// 根据外部类创建内部类</span></span><br><span class="line">Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>- 使用static关键字修饰的内部类，隶属于类层级</p>
<p>使用方式:</p>
<p>​    1.静态内部类不能直接访问外部类的非静态成员。</p>
<p>​    2.如果静态内部类访问外部类中与本类内同名的成员变量或方法时，需要 使用类名.的方式访问 </p>
<p>​    3. 静态内部类可以直接创建对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Inner inner = <span class="keyword">new</span>  Outer.Inner();</span><br></pre></td></tr></table></figure>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul>
<li>直接将一个类的定义放在方法体的内部时</li>
</ul>
<p>使用方式:</p>
<p>​    1.局部内部类只能在该方法的内部可以使用。 </p>
<p>​    2.局部内部类可以在方法体内部直接创建对象。 </p>
<p>​    3.局部内部类不能使用访问控制符和static关键字修饰符,直接 class 类名{ … } 即可</p>
<p>​    4.局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内 部类和局部变量的声明周期不同所致</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> - 就是指没有名字的内部类</p>
<p>语法格式 : 接口/父类类型 引用变量名 = new 接口/父类类型() { 方法的重写 }；</p>
<h2 id="枚举类（enum）"><a href="#枚举类（enum）" class="headerlink" title="枚举类（enum）"></a>枚举类（enum）</h2><p>在日常生活中这些事物的取值只有明确的几个固定值，此时描述这些事 物的所有值都可以一一列举出来，而这个列举出来的类型就叫做枚举类 型。</p>
<p>用class模拟写一个枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个方向类枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="comment">// 对外暴露4个类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction UP = <span class="keyword">new</span> Direction(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction DOWN = <span class="keyword">new</span> Direction(<span class="string">&quot;向下&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction LEFT = <span class="keyword">new</span> Direction(<span class="string">&quot;向左&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction RIGHT = <span class="keyword">new</span> Direction(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line">	<span class="comment">// 构造方法(必须是私有的)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类的定义:</p>
<p>​    1.使用public static final表示的常量描述较为繁琐，使用enum关键字来定 义枚举类型取代常量，枚举类型是从Java5开始增加的一种引用数据类型。 </p>
<p>​    2.枚举值就是当前类的类型，也就是指向本类的对象，默认使用public static final关键字共同修饰，因此采用 枚举类型. 的方式调用。 </p>
<p>​    3.枚举类可以自定义构造方法，但是构造方法的修饰符必须是private，默 认也是私有的。</p>
<p>定义一个枚举类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DirectionEnum</span> <span class="keyword">implements</span> <span class="title">Dir</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义枚举类暴露的类型个数,必须放在第一行</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>) ;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DirectionEnum</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的枚举类都继承自java.lang.Enum类，常用方法如下:</p>
<p><a href="https://imgtu.com/i/2CBb38"><img src="https://z3.ax1x.com/2021/05/27/2CBb38.png" alt="2CBb38.png" style="zoom:50%;" /></a></p>
<p>枚举类实现接口后需要重写抽象方法，而重写方法的方式有两种：</p>
<p>​    1.重写 一个</p>
<p>​    2.每个枚举对象都重写。(匿名内部类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UP(<span class="string">&quot;向上&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向上移动！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, DOWN(<span class="string">&quot;向下&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向下移动！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解（annotation）"><a href="#注解（annotation）" class="headerlink" title="注解（annotation）"></a>注解（annotation）</h2><p>又叫标注,从Java5开始增加的一种引用数据类型。注解本质上就是代码中的特殊标记，通过这些标记可以在编译、类加载、 以及运行时执行指定的处理。自动继承java.lang.annotation.Annotation接口</p>
<p>注解的使用方式:</p>
<p>参数成员类型只能是八 种基本数据类型、String类型、Class类型、enum类型及Annotation类型.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default表示默认值</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hui&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>可以注解到注解上的注解，或者说元注解是一种基本注解</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>说明该注解的生命周期，取值如下:</p>
<p>RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时 它将被丢弃忽视。</p>
<p>RetentionPolicy.CLASS： 注解只被保留到编译进行的时候，它并不会被加 载到 JVM 中，默认方式。</p>
<p>RetentionPolicy.RUNTIME: 注解可以保留到程序运行的时候，它会被加载 进入到 JVM 中，所以在程序运行时可以获取到它们</p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>用于指定被该注解将被javadoc工具提取成文档。 </p>
<p>定义为@Documented的注解必须设置Retention值为RUNTIME</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>用于指定被修饰的注解能用于哪些元素的修饰</p>
<p><a href="https://imgtu.com/i/2CrTl8"><img src="https://z3.ax1x.com/2021/05/27/2CrTl8.png" alt="2CrTl8.png" style="zoom:67%;" /></a></p>
<p>从Java8开始参数类型ElementType枚举值增加了两个：</p>
<p>ElementType.TYPE_PARAMETER ：该注解能写在类型变量的声明 语句中，如：泛型。</p>
<p>ElementType.TYPE_USE : 该注解能写在使用类型的任何语句中。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>如果一个超类被该注解标记，子类没有被任何注解应用时，则子类就继承超类的注解。</p>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>表示自然可重复使用的含义，从Java8开始增加的新特性</p>
<p>java8之前如果要重复使用一个注解，需要这样定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要重复使用的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义另一个注解，成员参数为上面的注解的数组类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过数组的方式使用重复注解</span></span><br><span class="line"><span class="meta">@MyAnnotations(</span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        @MyAnnotation(value=&quot;怪狗狗&quot;),</span></span><br><span class="line"><span class="meta">        @MyAnnotation(value=&quot;oddDog&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>java8有了@Repeatable元注解使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要重复使用的注解添加该元注解,参数为数组注解的class文件</span></span><br><span class="line"><span class="meta">@Repeatable(value = MyAnnotations.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用重复注解，注解调用两次即可</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;怪狗狗&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;oddDog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见的预制注解"><a href="#常见的预制注解" class="headerlink" title="常见的预制注解"></a>常见的预制注解</h3><p>​    预制注解就是Java语言自身提供的注解，具体如下:</p>
<p><a href="https://imgtu.com/i/2C6Mod"><img src="https://z3.ax1x.com/2021/05/27/2C6Mod.png" alt="2C6Mod.png" style="zoom:50%;" /></a></p>
<p><a href="https://imgtu.com/i/2C6GSP"><img src="https://z3.ax1x.com/2021/05/27/2C6GSP.png" alt="2C6GSP.png" style="zoom:50%;" /></a></p>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心类库</title>
    <url>/2021/05/30/java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><p><strong>基本概念</strong> : java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间 接子类。 如果定义一个Java类时没有使用extends关键字声明其父类，则其父类为 java.lang.Object 类。 Object类定义了“对象”的基本行为, 被子类默认继承。</p>
<p><strong>常用方法</strong> <a id="more"></a></p>
<ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>方法声明</th>
<th align="left">功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object()</td>
<td align="left">使用无参方式构造对象</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td align="left">用于判断调用对象是否与参数对象相等。 该方法默认比较两个对象的地址是否相等，与 == 运算符的结果一致 若希望比较两个对象的内容，则需要重写该方法。 若该方法被重写后，则应该重写hashCode方法来保证结果的一致 性。</td>
</tr>
<tr>
<td>int hashCode()</td>
<td align="left">用于获取调用对象的哈希码值(内存地址的编号)。 若两个对象调用equals方法相等，则各自调用该方法的结果必须相 同 若两个调用对象equals方法不相等，则各自调用该方法的结果应该 不相同。 为了使得该方法与equals方法保持一致，需要重写该方法。</td>
</tr>
<tr>
<td>String toString()</td>
<td align="left">用于获取调用对象的字符串形式 该方法默认返回的字符串为：包名.类名@哈希码值的十六进制 为了返回更有意义的数据，需要重写该方法 使用print或println打印引用或字符串拼接引用都会自动调用该方法</td>
</tr>
<tr>
<td>Class getClass()</td>
<td align="left">用于返回调用对象执行时的Class实例，反射机制使用</td>
</tr>
</tbody></table>
</li>
</ul>
<p>重写 equals()与hashCode() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == obj) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">        <span class="comment">// 通过 id 判断两类型是否相等</span></span><br><span class="line">        <span class="comment">// return this.getId() == ((Student) obj).getId();</span></span><br><span class="line">        <span class="comment">// 通过 name 判断两类型是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(((Student) obj).getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写hashCode,返回当前对象的name的哈希值并加上一些别的计算</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return 12 * 30 * this.getId();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span> * <span class="number">30</span> * <span class="keyword">this</span>.getName().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p><strong>概念</strong>  : 通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变 量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装 类。</p>
<p><strong>分类</strong> :  Byte , Short , Integer , Long , Float , Double , Character , Boolean</p>
<p>包装类的常用常量 :</p>
<table>
<thead>
<tr>
<th>常量类型和名称</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>public static final T  SIZE</td>
<td>表示 T 类型采用二进制补码形式的位数</td>
</tr>
<tr>
<td>public static final T BYTES</td>
<td>表示 T 类型所占的字节个数</td>
</tr>
<tr>
<td>public static final Class TYPE</td>
<td>表示 T 类型的Class实例</td>
</tr>
</tbody></table>
<p>包装类的常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Integer valueOf (xx i)</td>
<td>根据参数指定基本数据类型得到包装类xx的对象</td>
</tr>
<tr>
<td>xx xxValue()</td>
<td>将包装类xx转变成相对应的基本数据类型</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较调用对象与参数指定的对象是否相等</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回描述调用对象数值的字符串形式</td>
</tr>
<tr>
<td>static xxx parsexxx(String s)</td>
<td>将字符串类型转换为xxx基本数据类型并返回</td>
</tr>
<tr>
<td>static String toString(xxx i)</td>
<td>获取包装类的字符串的形式</td>
</tr>
</tbody></table>
<p><strong>装箱和拆箱的概念</strong></p>
<p>在Java5发布之前使用包装类对象进行运算时，需要较为繁琐的“拆箱”和“装箱”操作；即运算前先将 包装类对象拆分为基本类型数据，运算后再将结果封装成包装类对象。 从Java5开始增加了自动拆箱和自动装箱的功能。</p>
<h2 id="Integer-类的基本使用"><a href="#Integer-类的基本使用" class="headerlink" title="Integer 类的基本使用"></a>Integer 类的基本使用</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static String toBinaryString(int i)</td>
<td>获取参数指定整数的二进制字符串形式</td>
</tr>
<tr>
<td>static String toHexString(int i)</td>
<td>获取参数指定整数的十六进制字符串形式</td>
</tr>
<tr>
<td>static String toOctalString(int i)</td>
<td>获取参数指定整数的八进制字符串形式</td>
</tr>
</tbody></table>
<p><strong>自动装箱池</strong> </p>
<p>在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用 该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率</p>
<h2 id="Character-类的基本使用"><a href="#Character-类的基本使用" class="headerlink" title="Character 类的基本使用"></a>Character 类的基本使用</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static boolean isUpperCase(char ch)</td>
<td>判断参数指定字符是否为大写字符</td>
</tr>
<tr>
<td>static boolean isLowerCase(char ch)</td>
<td>判断参数指定字符是否为小写字符</td>
</tr>
<tr>
<td>static boolean isDigit(char ch)</td>
<td>判断参数指定字符是否为数字字符</td>
</tr>
<tr>
<td>static char toUpperCase(char ch)</td>
<td>将参数指定的字符转换为大写字符</td>
</tr>
<tr>
<td>static char toLowerCase(char ch)</td>
<td>将参数指定的字符转换为小写字符</td>
</tr>
</tbody></table>
<p>（其他包装类的用法跟Integer的用法基本相同，这里就不过多描述了）</p>
<h1 id="数学处理类"><a href="#数学处理类" class="headerlink" title="数学处理类"></a>数学处理类</h1><h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p> java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static int max(int a, int b)</td>
<td>返回两个参数中的最大值</td>
</tr>
<tr>
<td>static int min(int a, int b)</td>
<td>返回两个参数中的最小值</td>
</tr>
<tr>
<td>static double pow(double a, double b)</td>
<td>返回第一个参数的幂</td>
</tr>
<tr>
<td>static int abs(int a)</td>
<td>返回参数指定数值的绝对值</td>
</tr>
<tr>
<td>static long round(double a)</td>
<td>返回参数四舍五入的结果</td>
</tr>
<tr>
<td>static double sqrt(double a)</td>
<td>返回参数的平方根</td>
</tr>
<tr>
<td>static double random()</td>
<td>返回0.0到1.0的随机数</td>
</tr>
</tbody></table>
<h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>由于float类型和double类型在运算时可能会有误差，若希望实现精确运算则借助 java.math.BigDecimal类型加以描述。</p>
<p>BigDecimal(String val) 根据参数指定的字符串来构造对象</p>
<p>add 、 subtract 、 multiply 、 divide 分别实现加减乘除</p>
<h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。</p>
<p>BigInteger(String val) 根据参数指定的字符串来构造对象</p>
<p>add 、subtract 、multiply 、 divide 、remainder 、divideAndRemainder分别实现加减乘除、取余、取商和余数</p>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><strong>概述</strong> ：</p>
<ul>
<li><p>java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描 述。</p>
</li>
<li><p>该类由final关键字修饰，表示该类不能被继承。 </p>
</li>
<li><p>从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一 些空间。 </p>
</li>
<li><p>该类描述的字符串内容是个<strong>常量</strong>不可更改，因此可以被共享使用。</p>
</li>
</ul>
<p><strong>常量池的概念(原理)</strong></p>
<p> 由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量 池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对 象，从而提高了性能。（方法区）</p>
<p><strong>构造方法使用</strong></p>
<p>可传递 byte[] 与 char[] 数组 ，也能指定数组的起始位置与结束位置</p>
<p>也能传递String  xx ，根据参数指定的字符串内容来构造对象，新创建对象为参 数对象的副本。</p>
<p>这时在方法区有一个字符串 xx ，而栈区中也有一个 String对象 并指向方法区的xx。</p>
<p><strong>常用方法</strong> </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回字符串本身</td>
</tr>
<tr>
<td>byte[] getBytes()</td>
<td>将当前字符串内容转换为byte数组并返回</td>
</tr>
<tr>
<td>char[] toCharArray()</td>
<td>用于将当前字符串内容转换为char数组并返回</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串字符序列的长度</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>int compareTo(String anotherString)</td>
<td>用于比较调用对象和参数对象的大小关系</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>用于判断当前字符串是否包含参数指定的内容</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>返回字符串的大写形式</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回去掉前导和后继空白的字符串</td>
</tr>
<tr>
<td>boolean startsWith(String prefix)</td>
<td>判断字符串是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffix)</td>
<td>判断字符串是否以参数字符串结尾</td>
</tr>
</tbody></table>
<p><strong>有关查找的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>char charAt(int index)</td>
<td>方法charAt用于返回字符串指定位置的字符</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>在字符串中检索str返回其第一次出现的位置，若找不到返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>表示从字符串的fromIndex位置开始检索str第一次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>返回str指定字符串最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>用于从fromIndex位置开始反向搜索的第一次出现的下标。</td>
</tr>
<tr>
<td>String substring(int a, int b)</td>
<td>截取 a 到 b 下标的字符串</td>
</tr>
<tr>
<td>String substring(int  index)</td>
<td>从index开始截取到最后</td>
</tr>
</tbody></table>
<p><strong>正则表达式相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean matches(String regex)</td>
<td>判断当前正在调用的字符串是否匹配参数指定的正则表达式规则</td>
</tr>
<tr>
<td>String[] split(String regex)</td>
<td>参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>使用参数newChar替换此字符串中出现的所有参数oldChar</td>
</tr>
<tr>
<td>String replaceFirst(String regex,String replacement)</td>
<td>替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex,String replacement)</td>
<td>将字符串中匹配正则表达式regex的字符串替换成replacement</td>
</tr>
</tbody></table>
<h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p><strong>基本概念</strong></p>
<ul>
<li><p>由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串 时，只能单独申请和存储，此时会造成内存空间的浪费。 </p>
</li>
<li><p>为了解决上述问题，可以使用java.lang.StringBuilder类和java.lang.StringBuffer类来描述字符序 列可以改变的字符串</p>
</li>
<li><p>StringBuffer类是从jdk1.0开始存在，属于线程安全的类，因此效率比较低。 StringBuilder类是从jdk1.5开始存在，属于非线程安全的类，效率比较高</p>
</li>
</ul>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>使用无参方式构造对象，容量为16</td>
</tr>
<tr>
<td>StringBuilder(int capacity)</td>
<td>根据参数指定的容量来构造对象，容量为参数指定大小</td>
</tr>
<tr>
<td>StringBuilder(String str)</td>
<td>根据参数指定的字符串来构造对象，容量为：16+字符串长度</td>
</tr>
</tbody></table>
<p><strong>成员方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int capacity()</td>
<td>用于返回调用对象的容量</td>
</tr>
<tr>
<td>int length()</td>
<td>用于返回字符串的长度，也就是字符的个数</td>
</tr>
<tr>
<td>StringBuilder insert(int offset, String str)</td>
<td>插入字符串并返回调用对象的引用，就是自己。</td>
</tr>
<tr>
<td>StringBuilder append(String str)</td>
<td>追加字符串</td>
</tr>
<tr>
<td>StringBuilder deleteCharAt(int index)</td>
<td>将当前字符串中下标为index位置的单个字符删除</td>
</tr>
<tr>
<td>StringBuilder delete(int start，int end)</td>
<td>删除字符串</td>
</tr>
<tr>
<td>StringBuilder replace(int start，int end，String str)</td>
<td>替换字符串</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>字符串反转</td>
</tr>
</tbody></table>
<p><strong>注意</strong> ：</p>
<ul>
<li><p>作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值</p>
</li>
<li><p>StringBuilder的很多方法的返回值均为StringBuilder类型。这些方法的返回语句均为：return this。 由此可见，这些方法在对StringBuilder所封装的字符序列进行改变后又返回了该对象的引用。基 于这样设计的目的在于可以连续调用。</p>
</li>
</ul>
<h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><p>System中的  currentTimeMillis()    返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</p>
<h2 id="java8-之前的日期类型"><a href="#java8-之前的日期类型" class="headerlink" title="java8 之前的日期类型"></a>java8 之前的日期类型</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.util.Date类主要用于描述特定的瞬间，也就是年月日时分秒，可以精确到毫秒</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Date()</td>
<td>使用无参的方式构造对象，也就是当前系统时间</td>
</tr>
<tr>
<td>Date(long date)</td>
<td>根据参数指定毫秒数构造对象， 参数为距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>long getTime()</td>
<td>获取调用对象距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>void setTime(long time)</td>
<td>设置调用对象为距离基准时间time毫秒的时间点</td>
</tr>
</tbody></table>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p>搭配Date类的使用，将日期格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建  SimpleDateFormat  对象并指定格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 格式化日期</span></span><br><span class="line">String time = sdf.format(date);</span><br><span class="line"><span class="comment">// 将String格式的日期变成Date类型</span></span><br><span class="line">Date date = sdf.parse(time);</span><br></pre></td></tr></table></figure>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li>java.util.Calender类主要用于描述特定的瞬间，取代Date类中的过时方法实现全球化。</li>
<li> 该类是个抽象类，因此不能实例化对象，其具体子类针对不同国家的日历系统，其中应用最广泛的 是GregorianCalendar（格利高里日历），对应世界上绝大多数国家/地区使用的标准日历系统</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Calendar getInstance()</td>
<td>用于获取Calendar类型的引用</td>
</tr>
<tr>
<td>void set(int year, int month, int date, int hourOfDay, intminute, int second)</td>
<td>用于设置年月日时分秒信息</td>
</tr>
<tr>
<td>Date getTime()</td>
<td>用于将Calendar类型转换为Date类型</td>
</tr>
<tr>
<td>void set(int field, int value)</td>
<td>设置指定字段 (例如Calendar.YEAR) 的数值</td>
</tr>
<tr>
<td>void add(int field, int amount)</td>
<td>向指定字段增加数值</td>
</tr>
</tbody></table>
<h2 id="java8-中的日期类型"><a href="#java8-中的日期类型" class="headerlink" title="java8 中的日期类型"></a>java8 中的日期类型</h2><h3 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h3><p>LocalDate() + “T” + LocalTime()</p>
<p><strong>常用方法</strong> </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDateTime now()</td>
<td>从默认时区的系统时间中获取当前日期时间</td>
</tr>
<tr>
<td>static LocalDateTime of(int year, int month, intdayOfMonth, int hour, int minute, int second)</td>
<td>根据参数指定的年月日时分秒信息来设置日期时间</td>
</tr>
<tr>
<td>int getYear()</td>
<td>获取年份字段的数值</td>
</tr>
<tr>
<td>LocalDateTime withYear(int year)</td>
<td>设置为参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime plusYears(long years)</td>
<td>加上参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime minusYears(long years)</td>
<td>减去参数指定的年</td>
</tr>
</tbody></table>
<p><strong>注</strong>：后面4个方法，对于月日时分秒方法也一样</p>
<h3 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h3><p>java.time.Instant类主要用于描述瞬间的时间点信息，不会自动添加时区</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Instant now()</td>
<td>从系统时钟上获取当前时间OffsetDateTime</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>将此瞬间与偏移量组合以创建偏移日期时间</td>
</tr>
<tr>
<td>static Instant ofEpochMilli(long epochMilli)</td>
<td>根据参数指定的毫秒数来构造对象，参数为距离1970年1月1</td>
</tr>
<tr>
<td>long toEpochMilli()</td>
<td>获取距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间，不添加时区</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line"><span class="comment">// 添加8小时时区</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"><span class="comment">// 变成毫秒数</span></span><br><span class="line"><span class="keyword">long</span> l = instant.toEpochMilli();</span><br><span class="line"><span class="comment">// 根据毫秒数获取 instant对象，参数为距离1970年1月1</span></span><br><span class="line">Instant instant2 = Instant.ofEpochMilli(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h3><p>java.time.format.DateTimeFormatter类主要用于格式化和解析日期</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static DateTimeFormatter ofPattern(String pattern)</td>
<td>根据参数指定的模式来获取对象</td>
</tr>
<tr>
<td>String format(TemporalAccessor temporal)</td>
<td>将参数指定日期时间转换为字符串</td>
</tr>
<tr>
<td>TemporalAccessor parse(CharSequence text)</td>
<td>将参数指定字符串转换为日期时间</td>
</tr>
</tbody></table>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>java.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，因此该接口里定义的方法 既可用于操作List集合，也可用于操作Queue集合和Set集合</p>
<p><a href="https://imgtu.com/i/2VhVyD"><img src="https://z3.ax1x.com/2021/05/30/2VhVyD.png" alt="2VhVyD.png" style="zoom: 67%;" /></a></p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向集合中添加对象</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>用于将参数指定集合c中的所有元素添加到当前集合中</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断是否包含指定对象</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>判断是否包含参数指定的所有对象</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>保留当前集合中存在且参数集合中存在的所有对象（交集）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中删除对象</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>从集合中删除参数指定的所有对象</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>用于获取子List</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合</td>
</tr>
<tr>
<td>int size()</td>
<td>返回包含对象的个数</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>判断是否相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取当前集合的哈希码值</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>将集合转换为数组</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>获取当前集合的迭代器</td>
</tr>
</tbody></table>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p><strong>概念</strong> </p>
<ul>
<li>java.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。</li>
<li> java.util.Collection接口继承Iterator接口，因此所有实现Collection接口的实现类都可以使用该迭 代器对象。</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断集合中是否有可以迭代/访问的元素</td>
</tr>
<tr>
<td>E next()</td>
<td>用于取出一个元素并指向下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>用于删除访问到的最后一个元素</td>
</tr>
</tbody></table>
<ul>
<li>用迭代器打印 <strong>toString()</strong>  小案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合的toString()写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">MyToString</span><span class="params">(Iterator iterator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    s.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">            <span class="keyword">return</span> s.append(next+<span class="string">&quot;]&quot;</span>).toString();</span><br><span class="line">        s.append(next+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach 为增强版的for循环，也是经典迭代的“简化版”。</li>
</ul>
<p><strong><em>注</em></strong> ：在迭代的过程中不能使用集合中的remove方法，否则会出现并发修改异常 :UnsupportedOperationException</p>
<p>要使用iterator中的remove方法</p>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li><p>java.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。 </p>
</li>
<li><p>该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。 </p>
</li>
<li><p><strong><em>ArrayList</em></strong>类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。 </p>
</li>
<li><p><strong><em>LinkedList</em></strong>类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。 </p>
</li>
<li><p>可以认为ArrayList和LinkedList的方法在逻辑上完全一样，只是在性能上有一定的差别，ArrayList 更适合于随 机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。 </p>
</li>
<li><p><strong><em>Stack</em></strong>类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的 数据结构，叫做栈(last in first out LIFO)。 </p>
</li>
<li><p><strong><em>Vector</em></strong>类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的 类，效率比较低，以后开发中基本不用。</p>
<p>Arrays.asList()     可快速获取一个List集合</p>
</li>
</ul>
<h3 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>java.util.Queue集合是Collection集合的子集合，与List集合属于平级关系。 </li>
<li>该集合的主要用于描述具有先进先出特征的数据结构，叫做队列(first in first out FIFO)。 </li>
<li>该集合的主要实现类是<strong>LinkedList</strong>类，因此该类在增删方面比较有优势。</li>
</ul>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean offer(E e)</td>
<td>将一个对象添加至队尾，若添加成功则返回true</td>
</tr>
<tr>
<td>E poll()</td>
<td>从队首删除并返回一个元素</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队首的元素（但并不删除）</td>
</tr>
</tbody></table>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>java.util.Set集合是Collection集合的子集合，与List集合平级。 </li>
<li>该集合中元素没有先后放入次序，且不允许重复。 </li>
<li>该集合的主要实现类是：HashSet类 和 TreeSet类以及LinkedHashSet类。 </li>
<li><strong>HashSet</strong>类的底层是采用哈希表进行数据管理的。 </li>
<li><strong>TreeSet</strong>类的底层是采用红黑树进行数据管理的。 </li>
<li><strong>LinkedHashSet</strong>类与HashSet类的不同之处在于内部维护了一个双向链表，链表中记录了元 素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li>
</ul>
<p><strong>元素放入HashSet集合的原理</strong></p>
<ul>
<li>使用元素调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算出该元素在数组中的索 引位置。 </li>
<li>若该位置没有元素，则将该元素直接放入即可。 </li>
<li>若该位置有元素，则使用新元素与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放 入末尾。 </li>
<li>若新元素与已有元素的哈希值相同，则使用新元素调用equals方法与已有元素依次比较。 </li>
<li>若相等则添加元素失败，否则将元素直接放入即可。</li>
</ul>
<p><strong><em>思考</em></strong>   :  为什么要求重写equals方法后要重写hashCode方法呢?</p>
<p>当两个元素调用equals方法相等时证明这两个元素相同，重写hashCode方法后保证这两个元 素得到的哈希码值相同，由同一个哈希算法生成的索引位置相同，此时只需要与该索引位置已有元 素比较即可，从而提高效率并避免重复元素的出现。</p>
<p><strong><em>TreeSet集合的概念</em></strong></p>
<p>由于TreeSet集合的底层采用红黑树进行数据的管理，当有新元素插入到TreeSet集合时，需要使 用新元素与集合中已有的元素依次比较来确定新元素的合理位置。 </p>
<p>比较元素大小的规则有两种方式： </p>
<ul>
<li>使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口； </li>
<li>使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparator接口； </li>
<li>自然排序的规则比较单一，而比较器的规则比较多元化，而且比较器优先于自然排序；</li>
</ul>
<p><strong><em>自然排序规则</em></strong> 让一个Student类实现Comparable接口案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 重写比较的方法，返回正数表示当前对象大，负数表示小，0表示一样大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 名称一样的情况比较id(升序)</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="keyword">this</span>.getId() - o.getId() : i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>比较器规则</em></strong>   使用匿名内部类，也可以用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 名称一样的情况比较id(升序)</span></span><br><span class="line">        <span class="keyword">int</span> i = o1.getName().compareTo(o2.getName());</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? o1.getId() - o2.getId() : i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="泛型机制"><a href="#泛型机制" class="headerlink" title="泛型机制"></a>泛型机制</h3><p><strong><em>基本概念</em></strong></p>
<ul>
<li>通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此 从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换， 而强制类型转换可能会引发类型转换异常。 </li>
<li>为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt; 的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。</li>
<li> 泛型只在编译时期有效，在运行时期不区分是什么类型。</li>
</ul>
<p><strong><em>自定义泛型类</em></strong></p>
<p><strong><em>注</em></strong> :如果一个方法中使用了泛型的类型，则该方法不能用static修饰，因为泛型是创建对象时才能确定的，所以不能使用静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// E 表示泛型，可以传基本数据类型除外传任何类型 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> E gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>继承该泛型类</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没指定泛型类型，不继承泛型，父类泛型为Object类型</span></span><br><span class="line"><span class="comment">//public class SubPerson extends Person &#123;</span></span><br><span class="line"><span class="comment">// 指定泛型类型，不继承泛型，父类泛型为指定的类型，这里是Boolean类型</span></span><br><span class="line"><span class="comment">//public class SubPerson extends  Person&lt;Boolean&gt;&#123;</span></span><br><span class="line"><span class="comment">// 继承了该泛型，当然也可以有自己的泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; <span class="keyword">extends</span>  <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 使用自己的泛型</span></span><br><span class="line">    <span class="keyword">private</span> E type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>创建泛型对象</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定泛型，表示Object类型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 左边传入需要的类型，右边可以省略不写</span></span><br><span class="line">Person&lt;Integer&gt; p2 = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">SubPerson&lt;String,Boolean&gt; s= <span class="keyword">new</span> SubPerson();</span><br></pre></td></tr></table></figure>
<p><strong><em>自定义泛型方法</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型方法,该泛型方法与类中的泛型没有关系，使用该方法时，实参是什么类型该泛型就是什么类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">fan</span><span class="params">(X param)</span></span>&#123;</span><br><span class="line">    System.out.println(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>通配符的使用</em></strong>      （了解即可）</p>
<p>有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了。 如：之前传入的类型要求为Integer类型，但是后来业务需要Integer的父类Number类也可以传 入。 </p>
<p>泛型中有三种通配符形式： </p>
<ul>
<li><?>无限制通配符：表示我们可以传入任意类型的参数。 
</li>
<li><? extends E>表示类型的上界是E，只能是E或者是E的子类。 
</li>
<li><? super E>表示类型的下界是E，只能是E或者是E的父类。

</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://imgtu.com/i/2Vh8l8"><img src="https://z3.ax1x.com/2021/05/30/2Vh8l8.png" alt="2Vh8l8.png"></a></p>
<p><strong><em>基本概念</em></strong></p>
<ul>
<li>该集合中key是不允许重复的，而且一个key只能对应一个value。 </li>
<li>该集合的主要实现类有：HashMap类、TreeMap类、LinkedHashMap类、Hashtable类、 Properties类。 </li>
<li><strong><em>HashMap</em></strong>类的底层是采用哈希表进行数据管理的。 </li>
<li><strong><em>TreeMap</em></strong>类的底层是采用红黑树进行数据管理的。</li>
<li><strong><em>LinkedHashMap</em></strong>类与HashMap类的不同之处在于内部维护了一个双向链表，链表中记录了 元素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。 </li>
<li><strong><em>Hashtable</em></strong>类是古老的HashMap实现类，与HashMap类相比属于线程安全的类，且不允许null作 为key或者value的数值。 </li>
<li><strong><em>Properties</em></strong>类是Hashtable类的子类，该对象用于处理属性文件，key和value都是String类 型的。 </li>
<li>Map集合是面向查询优化的数据结构, 在大数据量情况下有着优良的查询性能。 经常用于根据key检索value的业务场景。</li>
</ul>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key, V value)</td>
<td>将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对应的Value，返回值为该Key原来所对应的</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td>返回与参数Key所对应的Value对象，如果不存在则返回null</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据参数指定的key进行删除</td>
</tr>
<tr>
<td>boolean containsKey(Objectkey)</td>
<td>判断集合中是否包含指定的Key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合中是否包含指定的Value</td>
</tr>
</tbody></table>
<p><strong><em>3种遍历的方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Set keySet()</td>
<td>返回此映射中包含的键的Set视图</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回此映射中包含的值的Set视图</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>返回此映射中包含的映射的Set视图</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// 获取所有key值，并遍历</span></span><br><span class="line">Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer i :set) &#123;</span><br><span class="line">    System.out.println(i+<span class="string">&quot;=&quot;</span>+map.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有value值，并遍历</span></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line"><span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有的键值对，并遍历</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entry = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; e:entry) &#123;</span><br><span class="line">    System.out.println(e.getKey()+<span class="string">&quot;=&quot;</span>+e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>元素放入HashMap集合的原理</em></strong>     </p>
<ul>
<li>使用元素的key调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算在数组中的索引 位置。 </li>
<li>若该位置没有元素，则将该键值对直接放入即可。 </li>
<li>若该位置有元素，则使用key与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放入到最后。 </li>
<li>若key与已有元素的哈希值相同，则使用key调用equals方法与已有元素依次比较。 </li>
<li>若相等则将对应的value修改，否则将键值对直接放入即可。</li>
</ul>
<p><strong><em>Map中的相关常量</em></strong></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量是16。 </li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子是0.75。 </li>
<li>threshold：扩容的临界值，该数值为：容量*填充因子，也就是12。 </li>
<li>TREEIFY_THRESHOLD：若Bucket中链表长度大于该默认值则转化为红黑树存储，该数值是8。</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，该数值是64。</li>
</ul>
<h2 id="Colleciotns工具类"><a href="#Colleciotns工具类" class="headerlink" title="Colleciotns工具类"></a>Colleciotns工具类</h2><p><strong><em>概念</em></strong>  :   java.util.Collections类主要提供了对集合操作或者返回集合的静态方法。</p>
<p><strong><em>常用方法</em></strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static &lt;T extends Object &amp; Comparable&lt;?super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td>
<td>将一个列表中的所有元素复制到另一个列表中</td>
</tr>
<tr>
<td>static void reverse(List&lt;?&gt; list)</td>
<td>反转指定列表中元素的顺序</td>
</tr>
<tr>
<td>static void shuffle(List&lt;?&gt; list)</td>
<td>使用默认的随机源随机置换指定的列表</td>
</tr>
<tr>
<td>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list)</td>
<td>根据其元素的自然顺序将指定列表按升序排序</td>
</tr>
<tr>
<td>static void sort(List list, Comparator&lt;? super T&gt; c)</td>
<td>根据指定比较器指定的顺序对指定列表进行排序</td>
</tr>
<tr>
<td>static void swap(List&lt;?&gt; list, int i, int j)</td>
<td>交换指定列表中指定位置的元素</td>
</tr>
<tr>
<td>static void fill(List&lt;?&gt; list, T value)</td>
<td>向list中填充值value</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy  将list中的值复制到list2中，</span></span><br><span class="line"><span class="comment">// 注意如果 list.size()&gt;list2.size()   会报错:IndexOutOfBoundsException  下标越界异常</span></span><br><span class="line"><span class="comment">// 所以初始化list2时，要先给定初始值，确保其 size() </span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(<span class="keyword">new</span> Integer[list.size()]);</span><br><span class="line">Collections.copy(list2,list);</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心类库plus</title>
    <url>/2021/06/03/java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93plus/</url>
    <content><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><p><strong>基本概念</strong></p>
<p>java.lang.Throwable类是Java语言中错误(Error)和异常(Exception)的超类。 <a id="more"></a></p>
<p>Error类主要用于描述Java虚拟机无法解决的严重错误，通常无法编码解决，如：JVM挂掉了 等。Exception类主要用于描述因编程错误或偶然外在因素导致的轻微错误，通常可以编码解决， 如：0作为除数等。</p>
<p><strong>异常Exception的分类</strong></p>
<ul>
<li>RuntimeException ： 运行时异常，也叫作非检测性异常</li>
<li>IOException和其他异常 ：其他异常，也叫作检测性异常，指在编译阶段都能 被编译器检测出来的异常。</li>
</ul>
<p><a href="https://imgtu.com/i/21VZYq"><img src="https://z3.ax1x.com/2021/06/03/21VZYq.png" alt="21VZYq.png"></a></p>
<p><strong>异常的捕获</strong></p>
<p>使用try{} catch(){}finally{} 捕获异常，其中可以有多个catch捕获异常，切记小类型发在大类型前面。finally中的代码无论如何都会执行，如果catch中出现了return ，会先执行finally中的代码块再返回去执行catch中的return。</p>
<p><strong>异常的抛出</strong></p>
<p>如 ： public void show() throws IOException{} ，可以抛出多个异常</p>
<p>如果子类重写父类的方法，只能抛出相同、更小的异常，或则不抛异常，进行捕获处理。</p>
<p><strong>自定义异常</strong></p>
<p>流程:</p>
<ul>
<li><p>继承Exception类或其子类</p>
</li>
<li><p>提供两个版本的构造方法，一个是无参构造方法，另外一个是字符串作为参数的构造方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异常的产生</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;年龄不合法!!!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>根据参数指定的路径名来构造对象</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>根据参数指定的父路径和子路径信息构造对象</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>根据参数指定的父抽象路径和子路径信息构造对象</td>
</tr>
</tbody></table>
<p><strong>获取文件相关信息的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>测试此抽象路径名表示的文件或目录是否存在</td>
</tr>
<tr>
<td>String getName()</td>
<td>用于获取文件的名称</td>
</tr>
<tr>
<td>long length()</td>
<td>返回由此抽象路径名表示的文件的长度</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>用于获取文件的最后一次修改时间</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>用于获取绝对路径信息</td>
</tr>
</tbody></table>
<p><strong>有关文件或目录操作的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean delete()</td>
<td>用于删除文件，当删除目录时要求是空目录</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>用于创建新的空文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>用于创建目录</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>用于创建多级目录</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断是否为文件</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断是否为目录</td>
</tr>
<tr>
<td>File[] listFiles()</td>
<td>获取该目录下的所有内容</td>
</tr>
<tr>
<td>File[] listFiles(FileFilter filter)</td>
<td>获取目录下满足筛选器的所有内容</td>
</tr>
</tbody></table>
<p><strong>获取一个目录下的所有内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个目录下的所有内容</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">       File[] files = f.listFiles();</span><br><span class="line">       <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">           <span class="comment">// 如果是目录，就递归调用该方法获取子文件</span></span><br><span class="line">           String name = file.getName();</span><br><span class="line">           <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;目录:&quot;</span>+name);</span><br><span class="line">               getAllFile(<span class="keyword">new</span> File(f,name));</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;文件:&quot;</span>+name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取a目录下的所有文本文件，listFiles()的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File a = <span class="keyword">new</span> File(<span class="string">&quot;c://a&quot;</span>);</span><br><span class="line"><span class="comment">// 将所有文本文件保存到 File 数组中，遍历该数组即可</span></span><br><span class="line">File[] files = a.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda 表达式写法</span></span><br><span class="line">File[] file2 = a.listFiles((File f)-&gt;f.getName().endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><strong>分类</strong></p>
<ul>
<li><p>按照读写数据的基本单位不同，分为 字节流 和 字符流。 </p>
<p>其中字节流主要指以字节为单位进行数据读写的流，可以读写任意类型的文件。 </p>
<p>其中字符流主要指以字符(2个字节)为单位进行数据读写的流，只能读写文本文件。 </p>
</li>
<li><p>按照读写数据的方向不同，分为 输入流 和 输出流（站在程序的角度）。 </p>
<p>其中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件。 </p>
<p>其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件。 </p>
</li>
<li><p>按照流的角色不同分为节点流和处理流。 </p>
<p>其中节点流主要指直接和输入输出源对接的流。 </p>
<p>其中处理流主要指需要建立在节点流的基础之上的流。</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/21nJbD"><img src="https://z3.ax1x.com/2021/06/03/21nJbD.png" alt="21nJbD.png" style="zoom:67%;" /></a></p>
<p><a href="https://imgtu.com/i/21n25j"><img src="https://z3.ax1x.com/2021/06/03/21n25j.png" alt="21n25j.png" style="zoom:67%;" /></a></p>
<h2 id="FileWriter与-FileReader"><a href="#FileWriter与-FileReader" class="headerlink" title="FileWriter与  FileReader"></a>FileWriter与  FileReader</h2><p>FileWriter类主要用于将文本内容写入到文本文件，FileReader 类主要用于从文本文件读取文本数据内容</p>
<p><strong>FileWriter常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FileWriter(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>FileWriter(String fileName, boolean append)</td>
<td>以追加的方式根据参数指定的文件名来构造对象</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写入单个字符</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>将指定字符数组中从偏移量off开始的len个字符写入此文件输出流</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>将cbuf.length个字符从指定字符数组写入此文件输出流中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p><strong>FileReader常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FileReader(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字符的数据并返回，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf, intoffset, int length)</td>
<td>从输入流中将最多len个字符的数据读入一个字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>从此输入流中将最多 cbuf.length 个字符的数据读入字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p><strong>拷贝,将a.text文件复制一份到b.text</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取输入输出流</span></span><br><span class="line">        FileReader r = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r = <span class="keyword">new</span> FileReader(<span class="string">&quot;c://a.text&quot;</span>);</span><br><span class="line">            w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;c://b.text&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝数据,一个一个字符的传递</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始拷贝...&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = r.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                w.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FileOutputStream-与-FileInputStream"><a href="#FileOutputStream-与-FileInputStream" class="headerlink" title="FileOutputStream 与  FileInputStream"></a>FileOutputStream 与  FileInputStream</h2><p>主要用对图像、视频等二进制数据的输入输出，使用方法和 FileWriter与  FileReader  基本相同。</p>
<p>不过输入输出时传递的不是char数组，而是bute数组。</p>
<p><strong>实现对数据的拷贝方式</strong></p>
<p>方式一 : 一个字节一个字节拷贝，与上面案例一样</p>
<p>方式二 ：根据文件大小创建缓冲区，将文件所有内容读入到缓冲区，再将缓冲区的内容全部写入到相应文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取输入输出流</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan02.png&quot;</span>);</span><br><span class="line"><span class="comment">// 开始传递数据</span></span><br><span class="line"><span class="keyword">int</span> len = in.available();  		<span class="comment">// 获取文件大小</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   <span class="comment">// 根据文件大小创建缓冲区</span></span><br><span class="line"><span class="keyword">int</span> data = in.read(bytes);  	<span class="comment">// 全部读入</span></span><br><span class="line">System.out.println(<span class="string">&quot;读取数据大小:&quot;</span> + data);</span><br><span class="line">out.write(bytes);				<span class="comment">// 全部写入</span></span><br></pre></td></tr></table></figure>
<p>方式三 : 按照合理的缓冲区大小进行copy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取输入输出流</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan03.png&quot;</span>);</span><br><span class="line"><span class="comment">// 缓冲区一般设为 1024 的整数倍</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((res = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    out.write(bytes, <span class="number">0</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BufferedOutputStream-与-BufferedInputStream"><a href="#BufferedOutputStream-与-BufferedInputStream" class="headerlink" title="BufferedOutputStream  与 BufferedInputStream"></a>BufferedOutputStream  与 BufferedInputStream</h2><p>要用于描述缓冲输入输出流，此时不用为写入的每个字节调用底层系统.使用方法和 FileOutputStream 与  FileInputStream  基本相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法需要一个 InputStream 或 OutputStream的实现类，当然缓冲流中也可以指定一个缓存区</span></span><br><span class="line">BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://superMan.png&quot;</span>));</span><br><span class="line">BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://superMan04.png&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="BufferedWriter-与-BufferedReader"><a href="#BufferedWriter-与-BufferedReader" class="headerlink" title="BufferedWriter  与  BufferedReader"></a>BufferedWriter  与  BufferedReader</h2><p>使用方法同上，不过 BufferedWriter 可以写入行newLine( ) ，BufferedReader可以读取一行readLine( ) ，如果读取完毕返回null</p>
<h2 id="OutputStreamWriter-与-InputStreamReader"><a href="#OutputStreamWriter-与-InputStreamReader" class="headerlink" title="OutputStreamWriter  与   InputStreamReader"></a>OutputStreamWriter  与   InputStreamReader</h2><p>类主要用于实现从字符流到字节流的转换，一个是输出时的转换，一个是输入时的转换</p>
<h2 id="PrintStream-与-PrintWriter"><a href="#PrintStream-与-PrintWriter" class="headerlink" title="PrintStream   与 PrintWriter"></a>PrintStream   与 PrintWriter</h2><p>主要用于更加方便地打印各种数据内容 ，例如熟悉的 ：println()</p>
<h2 id="ObjectOutputStream-与-ObjectInputStream"><a href="#ObjectOutputStream-与-ObjectInputStream" class="headerlink" title="ObjectOutputStream   与  ObjectInputStream"></a>ObjectOutputStream   与  ObjectInputStream</h2><p>用于对对象的输入输出。只能将支持 java.io.Serializable 接口的对象写入流中。 类通过实现 java.io.Serializable 接口以启用其序列化功能。</p>
<p><strong>序列化</strong> : 主要指将一个对象需要存储的相关信息有效组织成字节序列的转化过程。</p>
<p><strong>反序列化</strong> : 主要指将有效组织的字节序列恢复为一个对象及相关信息的转化过程</p>
<p><strong>序列化版本号</strong> : </p>
<p>序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如 果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 (InvalidCastException)</p>
<p><strong>transient 关键字</strong> :用来表示一个域不是该对象串行化的一部分。当一个对象被串行 化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transient表示该属性不参加序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String phone;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong> : 当希望将多个对象写入文件时，通常建议将多个对象放入一个集合中，然后将集合这个整体看做一 个对象写入输出流中，此时只需要调用一次readObject方法就可以将整个集合的数据读取出来， 从而避免了通过返回值进行是否达到文件末尾的判断</p>
<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>主要支持对随机访问文件的读写操作。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>RandomAccessFile(String name, Stringmode)</td>
<td>根据参数指定的名称和模式构造对象   r: 以只读方式打开     rw：打开以便读取和写入                                          rwd:打开以便读取和写入，同步文件内容的更新     rws:打开以便读取和写入，同步文件内容和元数据的更新</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字节的数据</td>
</tr>
<tr>
<td>void seek(long pos)</td>
<td>移动文件指针偏移量</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>在指针位置覆盖当前已有内容</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭流并释放有关的资源</td>
</tr>
</tbody></table>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程就是进程内部的程序流，也就是说操作系统内部支持多 进程的，而每个进程的内部又是支持多线程的，线程是轻量的，新建线程会共享所在进程的系统资 源，因此目前主流的开发都是采用多线程。 </p>
<p>多线程是采用时间片轮转法来保证多个线程的并发执行，所谓并发就是指宏观并行微观串行的机 制。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p><strong>概念</strong></p>
<ul>
<li><p>java.lang.Thread类代表线程，任何线程对象都是Thread类（子类）的实例。 </p>
</li>
<li><p>Thread类是线程的模板，封装了复杂的线程开启等操作，封装了操作系统的差异性</p>
</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Thread()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>Thread(String name)</td>
<td>根据参数指定的名称来构造对象</td>
</tr>
<tr>
<td>Thread(Runnable target)</td>
<td>根据参数指定的引用来构造对象，其中Runnable是个接口类型</td>
</tr>
<tr>
<td>Thread(Runnable target,String name)</td>
<td>根据参数指定引用和名称来构造对象</td>
</tr>
<tr>
<td>void run()</td>
<td>若使用Runnable引用构造了线程对象，调用该方法时最终调用接口中的方法，若没有使用Runnable引用构造线程对象，调用该方法调用时则啥也不做</td>
</tr>
<tr>
<td>void start()</td>
<td>用于启动线程，Java虚拟机会自动调用该线程的run方法</td>
</tr>
</tbody></table>
<p><strong>创建线程方式</strong></p>
<ul>
<li><p>自定义类继承Thread类并重写run方法，然后创建该类的对象调用start()方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建该类的对象调用start()方法。</span></span><br><span class="line">SubThread subThread = <span class="keyword">new</span> SubThread();</span><br><span class="line">subThread.start();</span><br></pre></td></tr></table></figure></li>
<li><p>自定义类实现Runnable接口并重写run方法，创建该类的对象作为实参来构造Thread类型的对 象，然后使用Thread类型的对象调用start方法。当然也能使用匿名内部类的方式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式二&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Thread构造方法，传递一个Runnable接口的实现类</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 匿名内部类方式创建线程</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方式三 : 内部类&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<p><strong>线程生命周期</strong></p>
</li>
</ul>
<p><a href="https://imgtu.com/i/21BBkj"><img src="https://z3.ax1x.com/2021/06/03/21BBkj.png" alt="21BBkj.png" style="zoom: 67%;" /></a></p>
<p><strong>Tread中有关线程编号和名称的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>long getId()</td>
<td>获取调用对象所表示线程的编号</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取调用对象所表示线程的名称</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置/修改线程的名称为参数指定的数值</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>获取当前正在执行线程的引用</td>
</tr>
</tbody></table>
<p><strong>其他常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static void yield()</td>
<td>当前线程让出处理器（离开Running状态），使当前线程进入Runnable状态等待</td>
</tr>
<tr>
<td>static void sleep(times)</td>
<td>使当前线程从 Running 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable如果其他线程打断当前线程的Block(sleep), 就会发生InterruptedException。</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>获取线程的优先级</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>修改线程的优先级。优先级越高的线程不一定先执行，但该线程获取到时间片的机会会更多一些</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>void join(long millis)</td>
<td>等待参数指定的毫秒数</td>
</tr>
<tr>
<td>boolean isDaemon()</td>
<td>用于判断是否为守护线程</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>用于设置线程为守护线程</td>
</tr>
</tbody></table>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p><strong>概念</strong></p>
<p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对线 程之间进行通信和协调，该机制就叫做线程的同步机制。</p>
<p><strong>异步操作</strong> :  多线程并发的操作，各自独立运行。</p>
<p><strong>同步操作</strong>  :  多线程串行的操作，有先后执行的顺序。</p>
<h3 id="使用synchronized关键字来实现线程同步"><a href="#使用synchronized关键字来实现线程同步" class="headerlink" title="使用synchronized关键字来实现线程同步"></a>使用synchronized关键字来实现线程同步</h3><p>1.实现部分代码的锁定，格式如下：</p>
<ul>
<li>synchronized(类类型的引用) { 编写所有需要锁定的代码； }</li>
</ul>
<p>2.实现所有代码的锁定， 直接使用synchronized关键字来修饰整个方法：</p>
<ul>
<li>public synchronized void test() { 方法体 }</li>
</ul>
<p>该方式等价于: synchronized(this) { 整个方法体的代码 } </p>
<p><strong>注意</strong> </p>
<p>1.对一个静态方法加锁，那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式:类名.class。</p>
<p>2.多个需要同步的线程在访问同步块时，看到的应该是同一个锁对象引用。 </p>
<p>3.在使用同步块时应当尽量减少同步范围以提高并发的执行效率</p>
<h3 id="使用Lock（锁）实现线程同步"><a href="#使用Lock（锁）实现线程同步" class="headerlink" title="使用Lock（锁）实现线程同步"></a>使用Lock（锁）实现线程同步</h3><p><strong>概念</strong></p>
<ul>
<li><p>从Java5开始提供了更强大的线程同步机制—使用显式定义的同步锁对象来实现。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</p>
</li>
<li><p>该接口的主要实现类是ReentrantLock类，该类拥有与synchronized相同的并发性，在以后的线程 安全控制中，经常使用ReentrantLock类显式加锁和释放锁。</p>
</li>
</ul>
<p><strong>lock 与 synchronized 比较</strong></p>
<p>Lock是显式锁，需要手动实现开启和关闭操作，而synchronized是隐式锁，执行锁定代码后自动 释放。 </p>
<p>Lock只有同步代码块方式的锁，而synchronized有同步代码块方式和同步方法两种锁。 </p>
<p>使用Lock锁方式时，Java虚拟机将花费较少的时间来调度线程，因此性能更好。</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock()</td>
<td>使用无参方式构造对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<h3 id="Object类常用的方法"><a href="#Object类常用的方法" class="headerlink" title="Object类常用的方法"></a>Object类常用的方法</h3><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>用于使得线程进入等待状态，直到其它线程调用notify()或notifyAll()方法</td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>用于进入等待状态，直到其它线程调用方法或参数指定的毫秒数已经过去为止</td>
</tr>
<tr>
<td>void notify()</td>
<td>用于唤醒等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>用于唤醒等待的所有线程</td>
</tr>
</tbody></table>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>通过上面的实现线程同步的方法，模拟一个生产者消费者模型。</p>
<p><strong>仓库，负责存储产品，容量为10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreHouse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 生产产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">productGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产了&quot;</span> + (count + <span class="number">1</span>) + <span class="string">&quot;号产品&quot;</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumerGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> + count + <span class="string">&quot;号产品&quot;</span>);</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生产者，生产产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须访问的是同一仓库</span></span><br><span class="line">    <span class="keyword">private</span> StoreHouse house;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(StoreHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            house.productGoods();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者，消费产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须访问的是同一仓库</span></span><br><span class="line">    <span class="keyword">private</span> StoreHouse house;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(StoreHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            house.consumerGoods();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 创建仓库</span></span><br><span class="line">    StoreHouse house = <span class="keyword">new</span> StoreHouse();</span><br><span class="line">    <span class="comment">// 创建生产者与消费者，当然可以创建多个</span></span><br><span class="line">    Product p = <span class="keyword">new</span> Product(house);</span><br><span class="line">    Consumer c = <span class="keyword">new</span> Consumer(house);</span><br><span class="line">    <span class="comment">// 开始生产与消费</span></span><br><span class="line">    p.start();</span><br><span class="line">    c.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>从Java5开始新增加创建线程的第三种方式为实现java.util.concurrent.Callable接口。该线程有返回值，主要用于计算。</p>
<p><strong>实现方式</strong>   : 实现  Callable 接口  —》 重写 call() 方法 </p>
<p><strong>FutureTask类</strong></p>
<p>java.util.concurrent.FutureTask类用于描述可取消的异步计算，该类提供了Future接口的基本实 现，包括启动和取消计算、查询计算是否完成以及检索计算结果的方法，也可以用于获取方法调用 后的返回结果。</p>
<p><strong>FutureTask类常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>FutureTask(Callable callable)</td>
<td>根据参数指定的引用来创建一个未来任务</td>
</tr>
<tr>
<td>V get()</td>
<td>获取call方法计算的结果</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 1-1000 累加 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">        <span class="comment">// 接受结果</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callableTest);</span><br><span class="line">        <span class="comment">// 创建线程并开启</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取计算结果</span></span><br><span class="line">            Object o = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为；&quot;</span>+o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>从Java5开始提供了线程池的相关类和接口：java.util.concurrent.Executors类和 java.util.concurrent.ExecutorService接口。</p>
<p>其中Executors是个工具类和线程池的工厂类，可以创建并返回不同类型的线程池，常用方法如 下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static ExecutorService newCachedThreadPool()</td>
<td>创建一个可根据需要创建新线程的线程池</td>
</tr>
<tr>
<td>static ExecutorService newFixedThreadPool(int Threads)</td>
<td>创建一个可重用固定线程数的线程池</td>
</tr>
<tr>
<td>static ExecutorService newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池</td>
</tr>
</tbody></table>
<p>其中ExecutorService接口是真正的线程池接口，主要实现类是ThreadPoolExecutor，常用方法 如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务和命令，通常用于执行Runnable</td>
</tr>
<tr>
<td>Future submit(Callable task)</td>
<td>执行任务和命令，通常用于执行Callable</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>启动有序关闭</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启一个10条线程的线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 向线程池中添加任务</span></span><br><span class="line">    <span class="comment">// 添加实现 Runnable 接口的线程</span></span><br><span class="line">    executorService.execute(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">    <span class="comment">// 添加实现 Callable 接口的线程</span></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> CallableTest());</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程需要提供：IP地址 + 端口号，组合在一起叫做网络套接字：Socket。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议(Transmission Control Protocol)，是一种面向连接的协议，类似于打电话。 </p>
<ul>
<li>建立连接 =&gt; 进行通信 =&gt; 断开连接 在传输前采用”三次握手”方式。 </li>
<li>在通信的整个过程中全程保持连接，形成数据传输通道。 </li>
<li>保证了数据传输的可靠性和有序性。 </li>
<li>是一种全双工的字节流通信方式，可以进行大数据量的传输。 </li>
<li>传输完毕后需要释放已建立的连接，发送数据的效率比较低。</li>
</ul>
<p><strong>编程模型</strong></p>
<ul>
<li><p>服务器： </p>
<p>（1）创建ServerSocket类型的对象并提供端口号； </p>
<p>（2）等待客户端的连接请求，调用accept()方法； </p>
<p>（3）使用输入输出流进行通信； </p>
<p>（4）关闭Socket； </p>
</li>
<li><p>客户端： </p>
<p>（1）创建Socket类型的对象并提供服务器的IP地址和端口号； </p>
<p>（2）使用输入输出流进行通信； </p>
<p>（3）关闭Socket；</p>
</li>
</ul>
<p><strong>ServerSocket类</strong>  java.net.ServerSocket类主要用于描述服务器套接字信息</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>ServerSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>Socket accept()</td>
<td>侦听并接收到此套接字的连接请求</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>Socket类</strong>   java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Socket(String host, int port)</td>
<td>根据指定主机名和端口来构造对象</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>用于获取当前套接字的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>用于获取当前套接字的输出流</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>注</strong> ：客户端 Socket 与服务器端 Socket 对应, 都包含输入和输出流。</p>
<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">socket socket = server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="comment">// 获取输出流</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    <span class="keyword">if</span>(s.equalsIgnoreCase(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已下线!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:&quot;</span>+s);</span><br><span class="line">    <span class="comment">// 回复</span></span><br><span class="line">    ps.println(<span class="string">&quot;I received!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭所有连接。。。。。</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端连接服务区</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 获取输出流</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 传输数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要传输的内容:&quot;</span>);</span><br><span class="line">    String say = sc.next();</span><br><span class="line">    ps.println(say);</span><br><span class="line">    <span class="keyword">if</span>(say.equalsIgnoreCase(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器:&quot;</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭所有连接...</span></span><br></pre></td></tr></table></figure>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议(User Datagram Protocol)，是一种非面向连接的协议，类似于写信。 </p>
<ul>
<li>在通信的整个过程中不需要保持连接，其实是不需要建立连接。 </li>
<li>不保证数据传输的可靠性和有序性。 </li>
<li>是一种全双工的数据报通信方式，每个数据报的大小限制在64K内。 </li>
<li>发送数据完毕后无需释放资源，开销小，发送数据的效率比较高，速度快。</li>
</ul>
<p><strong>编程模型</strong></p>
<ul>
<li><p>接收方： </p>
<p>（1）创建DatagramSocket类型的对象并提供端口号； </p>
<p>（2）创建DatagramPacket类型的对象并提供缓冲区； </p>
<p>（3）通过Socket接收数据内容存放到Packet中，调用receive方法； </p>
<p>（4）关闭Socket； </p>
</li>
<li><p>发送方： </p>
<p>（1）创建DatagramSocket类型的对象； </p>
<p>（2）创建DatagramPacket类型的对象并提供接收方的通信地址； </p>
<p>（3）通过Socket将Packet中的数据内容发送出去，调用send方法； </p>
<p>（4）关闭Socket；</p>
</li>
</ul>
<p><strong>DatagramSocket类</strong>    java.net.DatagramSocket类主要用于描述发送和接收数据报的套接字(邮局)</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramSocket()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>DatagramSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>void receive(DatagramPacket p)</td>
<td>用于接收数据报存放到参数指定的位置</td>
</tr>
<tr>
<td>void send(DatagramPacket p)</td>
<td>用于将参数指定的数据报发送出去</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭Socket并释放相关资源</td>
</tr>
</tbody></table>
<p><strong>DatagramPacket类</strong>   java.net.DatagramPacket类主要用于描述数据报，数据报用来实现无连接包裹投递服务</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramPacket(byte[] buf, int length)</td>
<td>根据参数指定的数组来构造对象，用于接收长度为length的数据报</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf, int length,InetAddress address, int port)</td>
<td>根据参数指定数组来构造对象，将数据报发送到指定地址和端口</td>
</tr>
<tr>
<td>InetAddress getAddress()</td>
<td>用于获取发送方或接收方的通信地址</td>
</tr>
<tr>
<td>int getPort()</td>
<td>用于获取发送方或接收方的端口号</td>
</tr>
<tr>
<td>int getLength()</td>
<td>用于获取发送数据或接收数据的长度</td>
</tr>
</tbody></table>
<p><strong>接收方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;等待接收消息...&quot;</span>);</span><br><span class="line"><span class="comment">// 创建Socket</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 创建package</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line"><span class="comment">// 接受数据</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line">System.out.println(<span class="string">&quot;接收到的数据为:&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受到消息后回复</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="string">&quot;I received!&quot;</span>.getBytes();</span><br><span class="line">DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bytes2, bytes2.length, dp.getAddress(), dp.getPort());</span><br><span class="line">ds.send(dp2);</span><br><span class="line">System.out.println(<span class="string">&quot;回复消息成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<p><strong>发送方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Socket</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">// 创建package</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">&quot;hello&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//  InetAddress.getLocalHost() 用于获取当前主机的通信地址</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">System.out.println(<span class="string">&quot;发送数据完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收回复消息</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bytes2, bytes2.length);</span><br><span class="line">ds.receive(dp2);</span><br><span class="line">System.out.println(<span class="string">&quot;接收回复的消息是:&quot;</span> + <span class="keyword">new</span> String(bytes2, <span class="number">0</span>, bytes2.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<h2 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h2><p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>URL(String spec)</td>
<td>根据参数指定的字符串信息构造对象</td>
</tr>
<tr>
<td>URLConnection openConnection()</td>
<td>获取URLConnection类的实例</td>
</tr>
</tbody></table>
<p> <strong>URLConnection类</strong> </p>
<ul>
<li>java.net.URLConnection类是个抽象类，该类表示应用程序和URL之间的通信链接的所有类的超 类，主要实现类有支持HTTP特有功能的HttpURLConnection类</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream getInputStream()</td>
<td>获取输入流</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>断开连接</td>
</tr>
</tbody></table>
<p>模拟爬虫，获取一个网页的html代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.lagou.com/&quot;</span>);</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">HttpURLConnection HttpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">InputStream inputStream = HttpURLConnection.getInputStream();</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line"><span class="comment">// 根据输入流读取数据</span></span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 断开连接</span></span><br><span class="line">inputStream.close();</span><br><span class="line">HttpURLConnection.disconnect();</span><br></pre></td></tr></table></figure>
<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><p>反射机制就是用于动态创建对象并且动态调用方法的机制,也叫做动态编程技术</p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><strong>概念 :</strong> </p>
<p>java.lang.Class类的实例可以用于描述Java应用程序中的类和接口，也就是一种数据类型。 </p>
<p>该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造完成，本质上就是加载到内 存中的运行时类。</p>
<p><strong>获取Class对象的方式</strong></p>
<ul>
<li><p>数据类型.class（常用）</p>
</li>
<li><p>引用/对象.getClass()      基本数据类型不能使用该方法</p>
</li>
<li><p>包装类.TYPE       获取对应基本数据类型的Class对象。</p>
</li>
<li><p>Class.forName()    获取参数指定类型的Class对象（常用）。</p>
</li>
<li><p>使用类加载器ClassLoader的方式获取指定类型的Class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = String.class.getClassLoader(); <span class="comment">// 获取类加载器，随便哪个类的加载器都行</span></span><br><span class="line">classLoader.loadClass(<span class="string">&quot;java.util.Date&quot;</span>);  <span class="comment">// 根据类加载器获取时间对象</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>常用的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt; forName(String className)</td>
<td>获取参数指定类型对应的Class对象并返回</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>创建该Class对象所表示类的实例（已过时）</td>
</tr>
</tbody></table>
<h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>获取此Class对象所表示类型中参数指定的公共构造方法</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>获取此Class对象所表示类型中所有的公共构造方法</td>
</tr>
</tbody></table>
<p> <strong>Constructor类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object… initargs)</td>
<td>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
</tbody></table>
<h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Field getDeclaredField(String name)</td>
<td>用于获取此Class对象所表示类中参数指定的单个成员变量信息</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>用于获取此Class对象所表示类中所有成员变量信息</td>
</tr>
</tbody></table>
<p> <strong>Field类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Object get(Object obj)</td>
<td>获取参数对象obj中此Field对象所表示成员变量的数值</td>
</tr>
<tr>
<td>void set(Object obj, Object value)</td>
<td>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值</td>
</tr>
<tr>
<td>void setAccessible(boolean flag)</td>
<td>当实参传递true时，则反射对象在使用时应该取消 Java 语言访问检查</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取成员变量的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType()</td>
<td>获取成员变量的数据类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取成员变量的名称</td>
</tr>
</tbody></table>
<h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>
<p><strong>Class类搭配的方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Method getMethod(String name,Class&lt;?&gt;… parameterTypes)</td>
<td>用于获取该Class对象表示类中名字为name参数为parameterTypes的指定公共成员方法</td>
</tr>
<tr>
<td>Method[] getMethods()</td>
<td>用于获取该Class对象表示类中所有公共成员方法</td>
</tr>
</tbody></table>
<p> <strong>Method类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Object invoke(Object obj,Object… args)</td>
<td>使用对象obj来调用此Method对象所表示的成员方法，实参传递args</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getReturnType()</td>
<td>获取方法的返回值类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getExceptionTypes()</td>
<td>获取方法的异常信息</td>
</tr>
</tbody></table>
<h2 id="获取其它结构信息"><a href="#获取其它结构信息" class="headerlink" title="获取其它结构信息"></a>获取其它结构信息</h2><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>Package getPackage()</td>
<td>获取所在的包信息</td>
</tr>
<tr>
<td>Class&lt;? super T&gt; getSuperclass()</td>
<td>获取继承的父类信息</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getInterfaces()</td>
<td>获取实现的所有接口</td>
</tr>
<tr>
<td>Annotation[] getAnnotations()</td>
<td>获取注解信息</td>
</tr>
<tr>
<td>Type[] getGenericInterfaces()</td>
<td>获取泛型信息</td>
</tr>
</tbody></table>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p><strong>代理模式作用</strong></p>
<ol>
<li>功能增强:在你原有的功能上,增加了额外的功能. </li>
<li>控制访问:代理类不让你访问目标,例如商家不让用户访问厂家</li>
</ol>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>模拟一个用户购买u盘的行为。</strong><br>用户是客户端类<br>商家：代理，代理某个品牌的u盘。<br>厂家：目标类。</p>
<p><strong>实现步骤</strong><br>1.创建一个接口,定义卖u盘的方法,表示厂家和商家做的事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="comment">// amount:表示一次购买的数量,返回值表示购买的u盘的价格</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建厂家类,实现1步骤的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标类:金士顿厂家,不接受用户的单独购买</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbKingFactory</span> <span class="keyword">implements</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设一个U盘  100 元</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100.0f</span>*amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建商家,就是代理,也需要实现1步骤中的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//淘宝是一个商家,代理金士顿U盘的销售</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBao</span> <span class="keyword">implements</span> <span class="title">usbSell</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明 商家代理的厂家具体是谁</span></span><br><span class="line">    <span class="keyword">private</span> UsbKingFactory factory =<span class="keyword">new</span> UsbKingFactory();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//实现销售U盘功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">// 1.目标类中方法的调用，厂家需要多少钱</span></span><br><span class="line">        <span class="keyword">float</span> price = factory.sell(amount);</span><br><span class="line">        <span class="comment">// 2.功能增强，每个U盘价格+40</span></span><br><span class="line">        price = price + amount*<span class="number">40</span>;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.创建客户端类,调用商家的方法买一个u盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//  创建代理商家----淘宝对象</span></span><br><span class="line">    TaoBao taoBao = <span class="keyword">new</span> TaoBao();</span><br><span class="line">    <span class="comment">//  向淘宝代理购买买两件产品,得到报价</span></span><br><span class="line">    <span class="keyword">float</span> price = taoBao.sell(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;购买两件产品.淘宝的报价为: &quot;</span>+price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>    1. 实现简单     2. 容易理解。</p>
<p><strong>缺点</strong> </p>
<ol>
<li><p>当目标类增加了,代理类可能也需要成倍的增加</p>
</li>
<li><p>当你的接口中功能在增加了,或者修改了,会影响众多的实现类,厂家类,代理都需要修改,影响比较多</p>
</li>
</ol>
<h2 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h2><ol>
<li>动态代理是指代理类对象在程序运行时由JVM根据反射机制动态生成的。动态代理不需要定义代理类的，java源文件。</li>
<li>动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM。</li>
</ol>
<p><strong>两种方式</strong></p>
<ul>
<li>jdk动态代理(理解):使用java反射包中的类和接口实现动态代理的功能。反射包java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy</li>
<li>cglib动态代理(了解): cglib是第三方的工具库,创建代理对象<ul>
<li>cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中<br>重写父类中同名的方法，实现功能的修改。</li>
<li>因为cglib是继承，重写方法，所以要求目标类不能是fina1的，方法也不能是final的。cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用，比如mybatis，spring框架中都有使用。</li>
</ul>
</li>
</ul>
<h3 id="InvocationHandler类"><a href="#InvocationHandler类" class="headerlink" title="InvocationHandler类"></a>InvocationHandler类</h3><p>代理类需要实现InvocationHandler类，重写invoke方法，代理类要完成的功能就写在invoke（）方法中。</p>
<p><strong>代理类完成的功能</strong>    </p>
<ol>
<li><p>调用目标方法,执行目标方法的功能    </p>
</li>
<li><p>功能增强,在目标方法调用时,增加功能</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Object  proxy</strong>        jdk创建的代理对象，无需赋值</p>
<p><strong>Method  method</strong>   目标类中的方法，jdk提供。</p>
<p><strong>Object[]  args</strong>          目标类中方法的参数，jkd提供。</p>
<h3 id="proxy类"><a href="#proxy类" class="headerlink" title="proxy类"></a>proxy类</h3><p>创建代理对象，使用其中的静态方法 <code>newProxyInstance()</code>  , 等同于静态代理中直接  new  商家(代理)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">( ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>ClassLoader loader</strong>   类加载器,负责向内存中加载对象的,使用反射机制获取对象的classLoader,</p>
<p><strong>Class&lt;?&gt;[] interfaces</strong>   接口,目标对象实现的接口,也是反射获取的</p>
<p><strong>InvocationHandler  h</strong>  : 我们自己写的,代理类要完成的功能</p>
<h3 id="实现动态代理的步骤"><a href="#实现动态代理的步骤" class="headerlink" title="实现动态代理的步骤"></a>实现动态代理的步骤</h3><ol>
<li>创建接口,定义目标类要完成的功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义卖u盘的方法,表示厂家和商家做的事情</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建目标类,并实现上面接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  厂家</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KingstonUSB</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 100 元一个usb</span></span><br><span class="line">        <span class="keyword">return</span> count * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建InvocationHandler接口的实现类,在invoke方法中完成代理类的功能<ol>
<li>调用目标方法</li>
<li>增强功能</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态代理，增强 KingstonUSB中的 sell 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KingstonUSBHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> USB kingstonUSB;</span><br><span class="line">	<span class="comment">// 构造方法，初始化 目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KingstonUSBHandler</span><span class="params">(USB kingstonUSB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kingstonUSB = kingstonUSB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原来的方法</span></span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) method.invoke(kingstonUSB, args);</span><br><span class="line">        <span class="comment">// 功能增强 , 每个 usb 价格 + 40 并 返回一张优惠券</span></span><br><span class="line">        res = res + ( (<span class="keyword">int</span>)args[<span class="number">0</span>] * <span class="number">40</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;淘宝优惠券一张！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用Proxy类的静态方法,创建代理对象,并把返回值转换成接口类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建目标对象</span></span><br><span class="line">    KingstonUSB usb = <span class="keyword">new</span> KingstonUSB();</span><br><span class="line">    <span class="comment">// 创建InvocationHandler对象</span></span><br><span class="line">    KingstonUSBHandler handler = <span class="keyword">new</span> KingstonUSBHandler(usb);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    USB proxyUSB =(USB) Proxy.newProxyInstance(usb.getClass().getClassLoader(), usb.getClass().getInterfaces(), handler);</span><br><span class="line">    <span class="comment">// 通过代理执行方法</span></span><br><span class="line">    <span class="keyword">int</span> money = proxyUSB.sell(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;价格为:&quot;</span>+money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java新特性</title>
    <url>/2021/06/05/java%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h1><p><strong>概述</strong>   Java8是 Java 语言的一个重要版本，该版本于2014年3月发布，是自Java5以来最具革命性的版 本，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。<a id="more"></a></p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul>
<li><p>函数式接口主要指只包含一个抽象方法的接口，如：java.lang.Runnable、java.util.Comparator 接口等。 </p>
</li>
<li><p>Java8提供@FunctionalInterface注解来定义函数式接口，若定义的接口不符合函数式的规范便会 报错</p>
</li>
<li><p>Java8中增加了java.util.function包，该包包含了常用的函数式接口，具体如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></td>
<td>void accept(T t)</td>
<td>根据指定的参数执行操作</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>得到一个返回值</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>根据指定的参数执行操作并返回</td>
</tr>
<tr>
<td>Predicate<T></td>
<td>boolean test(T t)</td>
<td>判断指定的参数是否满足条件</td>
</tr>
</tbody></table>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>Lambda 表达式是实例化函数式接口的重要方式，使用 Lambda 表达式可以使代码变的更加简洁 紧凑。</p>
<p>语法格式：(参数列表) -&gt; { 方法体; }     其中 ()、参数类型、{} 以及return关键字 可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = ()-&gt; System.out.println(<span class="string">&quot;随便写写！&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用主要指通过方法的名字来指向一个方法而不需要为方法引用提供方法体，该方法的调用交 给函数式接口执行。所在特定场合下lambda表达式的一种简写形式。方法中传递与返回的数据类型要与函数是接口保持一致。</p>
<p>方法引用使用一对冒号 :: 将类或对象与方法名进行连接，通常使用方式如下：</p>
<ul>
<li><p>对象的非静态方法引用 ObjectName :: MethodName </p>
</li>
<li><p>类的静态方法引用 ClassName :: StaticMethodName </p>
</li>
<li><p>类的非静态方法引用 ClassName :: MethodName </p>
</li>
<li><p>构造器的引用 ClassName :: new </p>
</li>
<li><p>数组的引用 TypeName[] :: new</p>
</li>
</ul>
<h2 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h2><p><strong>概念</strong>    java.util.stream.Stream接口是对集合功能的增强，可以对集合元素进行复杂的查找、过滤、筛选 等操作。</p>
<p><strong>创建方式</strong></p>
<ul>
<li>通过调用集合的默认方法来获取流，如：default Stream stream() </li>
<li>通过数组工具类中的静态方法来获取流，如：static IntStream stream(int[] array) </li>
<li>通过Stream接口的静态方法来获取流，如：static Stream of(T… values) </li>
<li>通过Stream接口的静态方法来获取流，static Stream generate(Supplier s)</li>
</ul>
<p><strong>中间操作</strong></p>
<ul>
<li>筛选与切片</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream filter(Predicate&lt;? super T&gt; predicate)</td>
<td>返回一个包含匹配元素的流</td>
</tr>
<tr>
<td>Stream distinct()</td>
<td>返回不包含重复元素的流</td>
</tr>
<tr>
<td>Stream limit(long maxSize)</td>
<td>返回不超过给定元素数量的流</td>
</tr>
<tr>
<td>Stream skip(long n)</td>
<td>返回丢弃前n个元素后的流</td>
</tr>
</tbody></table>
<ul>
<li>映射</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream map(Function&lt;? super T,? extends R&gt; mapper)</td>
<td>返回每个处理过元素组成的流</td>
</tr>
<tr>
<td>Stream flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</td>
<td>返回每个被替换过元素组成的流，并将所有流合成一个流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取list集合中所有对象的name值，并答应出来</span></span><br><span class="line"><span class="comment">//list.stream().map(p-&gt; p.getName()).forEach(name -&gt; System.out.println(name));</span></span><br><span class="line">list.stream().map(Person::getName).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>排序</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream sorted()</td>
<td>返回经过自然排序后元素组成的流</td>
</tr>
<tr>
<td>Stream sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>返回经过比较器排序后元素组成的流</td>
</tr>
</tbody></table>
<p><strong>终止操作</strong></p>
<ul>
<li>匹配与查找</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional findFirst()</td>
<td>返回该流的第一个元素</td>
</tr>
<tr>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回所有元素是否匹配</td>
</tr>
<tr>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回没有元素是否匹配</td>
</tr>
<tr>
<td>Optional max(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回最大元素</td>
</tr>
<tr>
<td>Optional min(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回最小元素</td>
</tr>
<tr>
<td>long count()</td>
<td>返回元素的个数</td>
</tr>
<tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>对流中每个元素执行操作</td>
</tr>
</tbody></table>
<ul>
<li>规约</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional reduce(BinaryOperator accumulator)</td>
<td>返回结合后的元素值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算list集合中的所有对象的年龄和</span></span><br><span class="line"><span class="comment">//Optional&lt;Integer&gt; reduce = list.stream().map(Person::getAge).reduce((o1, o2) -&gt; o1 + o2);</span></span><br><span class="line">Optional&lt;Integer&gt; reduce = list.stream().map(Person::getAge).reduce(Integer::sum);</span><br><span class="line">System.out.println(<span class="string">&quot;年龄和为:&quot;</span>+reduce);</span><br></pre></td></tr></table></figure>
<ul>
<li>收集</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</td>
<td>使用收集器对元素进行处理</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取list中所有对象的name值，并保存到另一个集合中</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; collect = list.stream().map(p -&gt; p.getName()).collect(Collectors.toList());</span></span><br><span class="line">List&lt;String&gt; collect = list.stream().map(Person::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p><strong>概述</strong> java.util.Optional类可以理解为一个简单的容器，其值可能是null或者不是null，代表一个值存在 或不存在。 该类的引入很好的解决空指针异常，不用显式进行空值检测。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Optional ofNullable(T value)</td>
<td>根据参数指定数值来得到Optional类型的对象</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Optional  判断字符串是否为空，若不为空则打印字符串的长度，否则打印0</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;==============常规写法============================&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==str)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;str为null，长度为:0&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;长度为:&quot;</span>+str.length());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;==============Optional写法============================&quot;</span>);</span><br><span class="line"><span class="comment">// 将 str 放入Optional容器中</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line"><span class="comment">// 根据映射,获取一个新的optional对象</span></span><br><span class="line">Optional&lt;String&gt; optional2 = optional.map(optional+<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line"><span class="comment">// 输出内容</span></span><br><span class="line">System.out.println(optional.orElse(<span class="string">&quot;odddog&quot;</span>));</span><br><span class="line">System.out.println(optional2.orElse(<span class="string">&quot;不存在&quot;</span>));</span><br></pre></td></tr></table></figure>
<h1 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h1><p><strong>概述</strong> :Java9发布于2017年9月发布，带来了很多新特性，其中最主要的变化是模块化系统。 模块就是代码和数据的封装体，模块的代码被组织成多个包，每个包中包含Java类和接口，模块的 数据则包括资源文件和其他静态信息。</p>
<p><strong>模块化的使用</strong></p>
<p>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块 , 具体如下： </p>
<p> module 模块名称 {</p>
<p>​     exports …         // 导出</p>
<p>​    requires …         // 导入</p>
<p>  }</p>
<p><strong>钻石操作符的使用升级</strong></p>
<p>在Java9中允许在匿名内部类的使用中使用钻石操作符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; c = <span class="keyword">new</span> Consumer&lt;&gt;() &#123;<span class="comment">//代码块&#125;</span></span><br></pre></td></tr></table></figure>
<p> <strong>集合工厂方法</strong></p>
<ul>
<li>Java9的List、Set和Map集合中增加了静态工厂方法of实现不可变实例的创建。 </li>
<li>不可变体现在无法添加、修改和删除它们的元素。 </li>
<li>不允许添加null元素对象</li>
</ul>
<p><strong>InputStream的增强</strong></p>
<p>InputStream类中提供了transferTo方法实现将数据直接传输到OutputStream中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件的复制，直接套用transferTo即可，内部封装了缓冲流</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://a&quot;</span>);</span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c://b&quot;</span>);</span><br><span class="line">in.transferTo(out);</span><br></pre></td></tr></table></figure>
<h1 id="Java10新特性"><a href="#Java10新特性" class="headerlink" title="Java10新特性"></a>Java10新特性</h1><p>Java10于2018年3月发布，改进的关键点包括一个本地类型推断、一个垃圾回收的增强。</p>
<p>Java10计划只是一个短期版本，因此公开更新将在六个月内结束，9月份发布的Java11将是Java的 长期支持（LTS）版本，LTS版本的发布每三年发布一次。</p>
<p><strong>局部变量类型推断</strong></p>
<ul>
<li>Java10可以使用var作为局部变量类型推断标识符，此符号仅适用于局部变量，增强for循环的索 引，以及传统for循环的本地变量。 </li>
<li>它不能使用于方法形式参数，构造函数形式参数，方法返回类型，字段，catch形式参数或任何其 他类型的变量声明。</li>
</ul>
<h1 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h1><p><strong>概述</strong> java11于2018年9月正式发布，这是 Java 大版本周期变化 后的第一个长期支持版本，非常值得关 注。</p>
<p><strong>简化的编译运行操作</strong> </p>
<ul>
<li>在Java11中可以使用java命令一次性进行编译和运行操作。 </li>
<li>执行源文件中的第一个类必须包含主方法。 </li>
<li>不可以使用其它源文件中自定义的类。</li>
</ul>
<p><strong>String类新增方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isBlank()</td>
<td>判断字符串是否为空或只包含空白代码点</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>新特性</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO笔记</title>
    <url>/2021/06/07/NIO%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>概念</strong>   </p>
<ul>
<li>Java New IO , non-blocking io (非阻塞 IO)</li>
<li>是1个全新的、 <code>JDK 1.4</code>后提供的 <code>IO API</code></li>
<li>Java API中提供了两套NIO，一套是针对<code>标准文件输入输出NIO</code>，另一套就是<code>网络编程NIO</code><a id="more"></a></li>
<li>IO是以<strong>流</strong>的方式处理数据，而NIO是以<strong>块</strong>的方式处理数据</li>
</ul>
<p><strong>面向流</strong>的IO一次一个字节的处理数据，一个输入流产生一个字节，一个输出流就消费一个字节。</p>
<p><strong>面向块</strong>的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多</p>
<p><a href="https://imgtu.com/i/2dhTaT"><img src="https://z3.ax1x.com/2021/06/07/2dhTaT.png" alt="2dhTaT.png"></a></p>
<h1 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h1><p><strong>概念</strong>  用来存放具体要被传输的数据。这里将数据装入 Buffer 再通过通道进行传输。Buffer 就是一个数组，用来保存不同数据类型的数据</p>
<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer，对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继承关系如下图所示</p>
<p><a href="https://imgtu.com/i/2d4dFU"><img src="https://z3.ax1x.com/2021/06/07/2d4dFU.png" alt="2d4dFU.png"></a></p>
<h2 id="ByteBuffer的基本使用"><a href="#ByteBuffer的基本使用" class="headerlink" title="ByteBuffer的基本使用"></a>ByteBuffer的基本使用</h2><p><strong>ByteBuffer的创建方式</strong>(其他用法一样)</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static ByteBuffer allocate(int capacity)</td>
<td>在堆中创建缓冲区(常用)</td>
</tr>
<tr>
<td>static ByteBuffer allocateDirect(int capacity)</td>
<td>在系统内存创建缓冲区</td>
</tr>
<tr>
<td>static ByteBuffer wrap(byte[] arr)</td>
<td>通过普通数组创建缓冲区</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuffer put(byte b)</td>
<td>添加元素,返回自己(this)</td>
</tr>
<tr>
<td>ByteBuffer get(byte[] bytes)</td>
<td>获取元素,将buffer中的元素填充到bytes数组中，返回自己</td>
</tr>
<tr>
<td>byte[] array()</td>
<td>获取元素，将buffer中的数据变成byte数组</td>
</tr>
<tr>
<td>ByteBuffer flip()</td>
<td>更新limit与position的值，读与写的转换</td>
</tr>
<tr>
<td>ByteBuffer mark()</td>
<td>读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</td>
</tr>
<tr>
<td>ByteBuffer reset()</td>
<td>返回上一次操作，position的位置变成Mark所指的位置</td>
</tr>
<tr>
<td>ByteBuffer clear()</td>
<td>“清空”缓冲区，还原limit以及position的值，但是butter里的值还是存在的</td>
</tr>
<tr>
<td>ByteBuffer compact()</td>
<td>把未读完的部分向前压缩，然后切换至写模式</td>
</tr>
<tr>
<td>ByteBuffer hasRemaining()</td>
<td>buffer里是否还有剩余内容可读</td>
</tr>
</tbody></table>
<p><strong>4个核心变量属性</strong></p>
<ul>
<li><p>容量  Capacity</p>
<ul>
<li><strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li>
</ul>
</li>
<li><p>界限 Limit</p>
<ul>
<li><strong>缓冲区中可以操作数据的大小</strong>，代表了当前缓冲区中一共有多少数据（从limit开始后面的位置不能操作）</li>
</ul>
</li>
<li><p>位置 Position</p>
<ul>
<li><strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的 <code>get( )</code>和 <code>put( )</code>函数更新</li>
</ul>
</li>
<li><p>Mark</p>
<ul>
<li><strong>用于记录上一次读写的位置</strong>。一个备忘位置</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/2dHtm9"><img src="https://z3.ax1x.com/2021/06/07/2dHtm9.png" alt="2dHtm9.png" style="zoom:67%;" /></a></p>
<ul>
<li>compact切换读写模式</li>
</ul>
<p><a href="https://imgtu.com/i/qHOSlq"><img src="https://s1.ax1x.com/2022/04/04/qHOSlq.png" alt="qHOSlq.png"></a></p>
<h2 id="调试工具类"><a href="#调试工具类" class="headerlink" title="调试工具类"></a>调试工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> String[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> String[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="keyword">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugAll</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugRead</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startIndex = offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> remainder = length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="keyword">int</span> row, <span class="keyword">int</span> rowStartIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转ByteBuffer</span></span><br><span class="line">ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">ByteBuffer buffer2 = Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"><span class="comment">// ByteBuffer转字符串</span></span><br><span class="line">CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString())</span><br></pre></td></tr></table></figure>
<h2 id="解决粘包半包"><a href="#解决粘包半包" class="headerlink" title="解决粘包半包"></a>解决粘包半包</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔</span></span><br><span class="line"><span class="comment">         但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</span></span><br><span class="line"><span class="comment">             Hello,world\n</span></span><br><span class="line"><span class="comment">             I&#x27;m zhangsan\n</span></span><br><span class="line"><span class="comment">             How are you?\n</span></span><br><span class="line"><span class="comment">         变成了下面的两个 byteBuffer (黏包，半包)</span></span><br><span class="line"><span class="comment">             Hello,world\nI&#x27;m zhangsan\nHo</span></span><br><span class="line"><span class="comment">             w are you?\n</span></span><br><span class="line"><span class="comment">         现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        source.put(<span class="string">&quot;hello,word\nI&#x27;m bob\nHo&quot;</span>.getBytes());</span><br><span class="line">        split(source);  </span><br><span class="line">        source.put(<span class="string">&quot;w are your\nhaha!\n&quot;</span>.getBytes());</span><br><span class="line">        split(source);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决粘包半包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">        source.flip();<span class="comment">// 切换读模式</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取到分隔符</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = i + <span class="number">1</span> - source.position(); <span class="comment">// 获取当前要读取长度</span></span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(len);</span><br><span class="line">                <span class="comment">// 将要读取的内容写入到target</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact(); <span class="comment">// 压缩为读取的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><p><strong>概述</strong> ：Channel 类似于传统的“<strong>流</strong>”。</p>
<p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<p> Java 为 Channel 接口提供的最主要实现类如下：</p>
<p><a href="https://imgtu.com/i/2wCAUS"><img src="https://z3.ax1x.com/2021/06/07/2wCAUS.png" alt="2wCAUS.png" style="zoom:67%;" /></a></p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。 </li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。 </li>
<li>SocketChannel：通过 TCP 读写网络中的数据。 </li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来 的连接都会创建一个 SocketChannel。</li>
</ul>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p><strong>读取文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;from.text&quot;</span>).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="comment">// 读取文件,向buffer写入内容</span></span><br><span class="line">        <span class="keyword">while</span> ((i = channel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip(); <span class="comment">// 切换读模式</span></span><br><span class="line">            <span class="comment">// 输出内容</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear(); <span class="comment">// 切换写模式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取</strong></p>
<p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<p><strong>两个 Channel 传输数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小文件传输</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileChannel input = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel output = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;from.text&quot;</span>).getChannel();</span><br><span class="line">        output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;to.text&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 传输,transferTo方法最多传输2G</span></span><br><span class="line">        input.transferTo(<span class="number">0</span>, input.size(), output);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传输超过2G的文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileChannel input = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel output = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;from.text&quot;</span>).getChannel();</span><br><span class="line">        output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;to.text&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 传输,transferTo方法最多传输2G</span></span><br><span class="line">        <span class="keyword">long</span> size = input.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> remain = size; remain &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">            <span class="keyword">long</span> l = input.transferTo(size - remain, remain, output);</span><br><span class="line">            remain -= l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h2><p>jdk7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line">Path projects = Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d:\data\projects\a\..\b  &#x3D;&#x3D;  d:\data\projects\b</span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>Files是对文件进行操作的工具类</p>
<p><strong>检查文件是否存在</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>
<p><strong>创建一级目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p><strong>创建多级目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>
<p><strong>拷贝文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p><strong>移动文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p><strong>删除文件及目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果文件不存在，会抛异常 NoSuchFileException</p>
</li>
<li><p>如果目录还有内容，会抛异常 DirectoryNotEmptyException</p>
</li>
</ul>
<p><strong>遍历目录文件</strong></p>
<p>使用 FIles.walkFileTree() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">    AtomicInteger dirCount = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 统计目录个数</span></span><br><span class="line">    AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 统计文件个数</span></span><br><span class="line">    </span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="comment">// 对目录操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 对文件操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(dirCount); </span><br><span class="line">    System.out.println(fileCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>统计 jar文件 的个数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历文件夹,统计jar包个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    AtomicInteger jarCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_131&quot;</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                jarCount.incrementAndGet();</span><br><span class="line">                System.out.println(file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;jar count:&quot;</span> + jarCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拷贝多级目录</strong></p>
<p>使用 FIles.walk() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDir</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String source = <span class="string">&quot;C:\\test&quot;</span>;</span><br><span class="line">    String target = <span class="string">&quot;C:\\test2&quot;</span>;</span><br><span class="line">    Files.walk(Paths.get(<span class="string">&quot;C:\\test&quot;</span>)).forEach(path -&gt; &#123;</span><br><span class="line">        <span class="comment">// 目标路径</span></span><br><span class="line">        String targetPath = path.toString().replace(source, target);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 文件夹,创建</span></span><br><span class="line">            <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Files.exists(Paths.get(targetPath))) &#123;</span><br><span class="line">                    Files.createDirectory(Paths.get(targetPath));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 普通文件,拷贝</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">                Files.copy(path, Paths.get(targetPath));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用<strong>线程池技术</strong>来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">    server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">	<span class="comment">// 连接集合</span></span><br><span class="line">    List&lt;SocketChannel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待连接..&quot;</span>);</span><br><span class="line">        SocketChannel socketChannel = server.accept();  <span class="comment">// 阻塞方法,等待连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">        list.add(socketChannel);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (SocketChannel channel : list) &#123;</span><br><span class="line">            channel.read(buffer); <span class="comment">// 阻塞方法,等待客户端发送消息</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    SocketChannel channel = SocketChannel.open();</span><br><span class="line">    channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    channel.write(StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h2><ul>
<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">      <span class="comment">// 创建服务端</span></span><br><span class="line">      ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">      server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">      server.configureBlocking(<span class="keyword">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">    	<span class="comment">// 连接集合</span></span><br><span class="line">      List&lt;SocketChannel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          SocketChannel channel = server.accept(); <span class="comment">// 非阻塞,直接向下运行</span></span><br><span class="line">          <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">              channel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">              list.add(channel);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (SocketChannel c : list) &#123;</span><br><span class="line">              <span class="keyword">int</span> i = c.read(buffer);  <span class="comment">// 非阻塞,直接向下运行</span></span><br><span class="line">              <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  buffer.flip();</span><br><span class="line">                  debugRead(buffer);</span><br><span class="line">                  buffer.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端代码不变</strong></p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO </li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入</li>
</ul>
</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br></pre></td></tr></table></figure>
<h3 id="绑定Channel事件"><a href="#绑定Channel事件" class="headerlink" title="绑定Channel事件"></a>绑定Channel事件</h3><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>
<ul>
<li>channel 必须工作在非阻塞模式</li>
<li>绑定的事件类型可以有<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<h3 id="监听Channel事件"><a href="#监听Channel事件" class="headerlink" title="监听Channel事件"></a>监听Channel事件</h3><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞直到绑定事件发生</span></span><br><span class="line"><span class="keyword">int</span> counrt = selector.select();</span><br><span class="line"><span class="comment">// 阻塞直到绑定事件发生，或是超时（时间单位为 ms）</span></span><br><span class="line"><span class="keyword">int</span> counrt = selector.select(<span class="keyword">long</span> timeout);</span><br><span class="line"><span class="comment">// 不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</span></span><br><span class="line"><span class="keyword">int</span> counrt = selector.selectNow();</span><br></pre></td></tr></table></figure>
<h3 id="select-何时不阻塞"><a href="#select-何时不阻塞" class="headerlink" title="select 何时不阻塞"></a>select 何时不阻塞</h3><ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发 accept 事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>
<li>channel 可写，会触发 write 事件</li>
<li>在 linux 下 nio bug 发生时</li>
</ul>
</li>
<li>调用 selector.wakeup()</li>
<li>调用 selector.close()</li>
<li>selector 所在线程 interrupt</li>
</ul>
<h2 id="处理accept事件"><a href="#处理accept事件" class="headerlink" title="处理accept事件"></a>处理accept事件</h2><p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 创建selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册accept事件</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">// 阻塞,等待事件</span></span><br><span class="line">            <span class="comment">// 获取触发事件的迭代器,并遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keys.next();</span><br><span class="line">                keys.remove(); <span class="comment">// 将事件移除</span></span><br><span class="line">                <span class="comment">// accept事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 连接客户端</span></span><br><span class="line">                    SocketChannel sc = c.accept();</span><br><span class="line">                    <span class="comment">// 客户端注册read事件</span></span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接成功&quot;</span> + sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        channel.write(Charset.defaultCharset().encode(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理read事件"><a href="#处理read事件" class="headerlink" title="处理read事件"></a>处理read事件</h2><p><strong>修改客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 阻塞,等待事件</span></span><br><span class="line">    <span class="comment">// 获取触发事件的迭代器</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keys.next();</span><br><span class="line">        keys.remove();</span><br><span class="line">        <span class="comment">// accept事件</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">// 连接客户端</span></span><br><span class="line">            SocketChannel sc = c.accept();</span><br><span class="line">            <span class="comment">// 客户端注册read事件</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功&quot;</span> + sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端连接</span></span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">                <span class="comment">// 读取</span></span><br><span class="line">                <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugAll(buffer); <span class="comment">// 输出</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 客户端注册断开连接,需要取消事件,关闭连接</span></span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 客户端强行断开,需取消read事件</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为何要-keys-remove"><a href="#为何要-keys-remove" class="headerlink" title="为何要 keys.remove()"></a>为何要 keys.remove()</h3><p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li><p>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </p>
</li>
<li><p>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</p>
</li>
</ul>
<h3 id="key-cancel-的作用"><a href="#key-cancel-的作用" class="headerlink" title="key.cancel() 的作用"></a>key.cancel() 的作用</h3><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
<h3 id="处理消息边界问题"><a href="#处理消息边界问题" class="headerlink" title="处理消息边界问题"></a>处理消息边界问题</h3><p>这里采用按分隔符 ‘\n’ 进行拆分消息</p>
<p><strong>attachment(附件)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册事件时,可传递第三个参数 , 附件是每个channel独享的对象</span></span><br><span class="line">channel.register(selector, 绑定事件,附件);</span><br><span class="line"><span class="comment">// 获取附件    </span></span><br><span class="line">key.attachment();</span><br><span class="line"><span class="comment">// 替换附件</span></span><br><span class="line">key.attach(object);</span><br></pre></td></tr></table></figure>
<p><strong>添加处理粘包半包方法(上面写过)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决粘包半包</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = source.get(i);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = i + <span class="number">1</span> - source.position();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                buffer.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(buffer); <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改服务端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 阻塞,等待事件</span></span><br><span class="line">    <span class="comment">// 获取触发事件的迭代器</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keys.next();</span><br><span class="line">        keys.remove();</span><br><span class="line">        <span class="comment">// accept事件</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">// 连接客户端</span></span><br><span class="line">            SocketChannel sc = c.accept();</span><br><span class="line">            <span class="comment">// 客户端注册read事件</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);  <span class="comment">// buffer作为附件,传递给SelectionKey,作为socketChannel独享的对象</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功&quot;</span> + sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端连接</span></span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment(); <span class="comment">// 获取附件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取,如果一次没读完,会在下一次循环读取</span></span><br><span class="line">                <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    split(buffer);</span><br><span class="line">                    <span class="comment">// compact压缩无效,就扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                        ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);  <span class="comment">// 容量*2</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        newBuffer.put(buffer);</span><br><span class="line">                        <span class="comment">// 替换原来的附件</span></span><br><span class="line">                        key.attach(newBuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 客户端注册断开连接,需要取消事件,关闭连接</span></span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 客户端强行断开,需取消read事件</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;hello\nworld\n&quot;</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理write事件"><a href="#处理write事件" class="headerlink" title="处理write事件"></a>处理write事件</h2><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>没写完,就不取消，每次都会触发 write 事件</li>
</ul>
</li>
</ul>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册accept事件</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">// 阻塞</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keys.next();</span><br><span class="line">                keys.remove(); <span class="comment">// 手动移除已处理完的事件</span></span><br><span class="line">                <span class="comment">// accept事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 获取客户端</span></span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    <span class="comment">// 客户端添加可读事件</span></span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey scKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 向客户端发送大量数据</span></span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">int</span> len = sc.write(buffer); <span class="comment">// 写</span></span><br><span class="line">                    System.out.println(len); <span class="comment">// 输出长度</span></span><br><span class="line">                    <span class="comment">// 如果没写完,添加写事件,让服务器下一次执行</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        scKey.interestOps(scKey.interestOps() + SelectionKey.OP_WRITE);  <span class="comment">// 原来的事件+写事件</span></span><br><span class="line">                        scKey.attach(buffer); <span class="comment">// buffer作为附件添加</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// write事件</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">// 继续写,没写完下一次循环会继续写</span></span><br><span class="line">                    <span class="keyword">int</span> len = sc.write(buffer);</span><br><span class="line">                    System.out.println(len); <span class="comment">// 输出长度</span></span><br><span class="line">                    <span class="comment">// 如果写完,就移除附件和写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                        key.attach(<span class="keyword">null</span>);</span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="comment">// 原来的事件-写事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">		<span class="comment">// 统计</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h2><p>前面的代码只有一个选择器，没有充分利用多核 cpu,需要改进,  分两组选择器</p>
<ul>
<li>单线程配一个selector，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个selector，轮流处理 read 事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();   <span class="comment">// 获取cpu核心数</span></span><br><span class="line"><span class="comment">// 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</span></span><br><span class="line"><span class="comment">// 这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</span></span><br></pre></td></tr></table></figure>
<p><strong>服务端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 创建boss选择器,并注册accept事件</span></span><br><span class="line">        Selector boss = Selector.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 创建workers注册器数组,负责读事件</span></span><br><span class="line">        Worker[] worker = <span class="keyword">new</span> Worker[Runtime.getRuntime().availableProcessors()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; worker.length; i++) &#123;</span><br><span class="line">            worker[i] = <span class="keyword">new</span> Worker(<span class="string">&quot;worker-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            boss.select(); <span class="comment">// 阻塞,等待连接</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keys.next();</span><br><span class="line">                keys.remove(); <span class="comment">// 移除当前事件</span></span><br><span class="line">                <span class="comment">// accept事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 注册, 采用轮询算法</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;before register,&#123;&#125;&quot;</span> + sc.getRemoteAddress());</span><br><span class="line">                    worker[count.getAndIncrement() % worker.length].register(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;  <span class="comment">// 名称</span></span><br><span class="line">        <span class="keyword">private</span> Selector selector; <span class="comment">// 选择器</span></span><br><span class="line">        <span class="keyword">private</span> Thread thread; <span class="comment">// 线程</span></span><br><span class="line">        <span class="comment">// 是否已经初始化</span></span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean start = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 任务队列,存放注册事件</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (start.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加任务: 注册read事件</span></span><br><span class="line">            queue.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒selector</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    selector.select(); <span class="comment">// 阻塞</span></span><br><span class="line">                    <span class="comment">// 获取任务,完成客户端注册</span></span><br><span class="line">                    Runnable task = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = keys.next();</span><br><span class="line">                        keys.remove(); <span class="comment">// 移除当前事件</span></span><br><span class="line">                        <span class="comment">// read事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">                            sc.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            <span class="comment">// 输出内容</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;thread:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;abcdefg&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>
<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>
</ul>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;</span><br><span class="line">            channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            channel.receive(buffer);  <span class="comment">// 阻塞</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            debug(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            channel.send(buffer, address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over….</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>常用的设计原则</strong> </p>
<ul>
<li>开闭原则（Open Close Principle） 对扩展开放对修改关闭，为了使程序的扩展性好，易于维护和升级。</li>
<li>里氏代换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现，多使用<a id="more"></a>多态的方式。 </li>
<li>依赖倒转原则（Dependence Inversion Principle） 尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性 </li>
<li>接口隔离原则（Interface Segregation Principle） 尽量多使用小接口而不是大接口，避免接口的污染，降低类之间耦合度。</li>
<li>迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少与其他实体之间发生相互作用，使系统功能模块相对独立。 高内聚，低耦合。 </li>
<li>合成复用原则（Composite Reuse Principle） 尽量多使用合成/聚合的方式，而不是继承的方式</li>
</ul>
<h1 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h1><p><strong>基本分类</strong></p>
<ul>
<li>创建型模式 - 单例设计模式、工厂方法模式、抽象工厂模式、… </li>
<li>结构型模式 - 装饰器模式、代理模式、… </li>
<li>行为型模式 - 模板设计模式、…</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式主要分为：饿汉式 和 懒汉式，懒汉式需要对多线程进行同步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == sin) &#123;</span><br><span class="line">            <span class="comment">// 锁定创建的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == sin) &#123;</span><br><span class="line">                    sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h3><p><strong>概念</strong>  普通工厂方法模式就是建立一个工厂类，对实现了同一接口的不同实现类进行实例的创建。</p>
<p><strong>缺点</strong>  在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，并且可能出现空指针异 常。</p>
<p><strong>注</strong>  这里创建了一个Toy接口，只有一个void paly() 方法，实现类有 DogToy  CatToy  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通工厂模式,根据传递的字符串创建相应的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">(String toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toy.equals(<span class="string">&quot;CatToy&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toy.equals(<span class="string">&quot;DogToy&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ToyFactory factory = <span class="keyword">new</span> ToyFactory();</span><br><span class="line">     Toy cat = factory.produce(<span class="string">&quot;CatToy&quot;</span>);</span><br><span class="line">     cat.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个工厂模式"><a href="#多个工厂模式" class="headerlink" title="多个工厂模式"></a>多个工厂模式</h3><p><strong>缺点</strong>  在多个工厂方法模式中，为了能够正确创建对象，先需要创建工厂类的对象才能调用工厂类中的生 产方法。代码有点啰嗦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多个工厂方法模式，根据不同的方法创建不同的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produceDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produceCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ToyFactory factory = <span class="keyword">new</span> ToyFactory();</span><br><span class="line">     Toy cat = factory.produceCat();</span><br><span class="line">     cat.play();</span><br><span class="line">     Toy dog = factory.produceDog();</span><br><span class="line">     dog.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><p><strong>缺点</strong>  工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序生产新的产 品，就必须对工厂类的代码进行修改，这就违背了开闭原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态工厂模式,不用创建工厂类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toy <span class="title">produceDogStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toy <span class="title">produceCatStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Toy dog = ToyFactory.produceDogStatic();</span><br><span class="line">     dog.play();</span><br><span class="line">     Toy cat4 = ToyFactory.produceCatStatic();</span><br><span class="line">     cat.play();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong>概念</strong>   定义一个工厂接口。如果新增了别的产品，继承该接口即可，不需要在原有的代码上更改，符合开闭原则</p>
<p>定义一个玩具工厂接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Toy <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个生产玩具狗工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个生产玩具猫工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这时又新增了一个玩具熊BearToy类，需要新创建一个生产玩具熊的工厂类，直接实现接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BearFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Toy <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BearToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Factory factory = <span class="keyword">new</span> DogFactory();</span><br><span class="line">    Toy dog = factory.produce();</span><br><span class="line">    dog.play();</span><br><span class="line">    Factory factory2 =  <span class="keyword">new</span> CatFactory();</span><br><span class="line">    Toy cat = factory2.produce();</span><br><span class="line">    cat.play();</span><br><span class="line">    Factory factory3 = <span class="keyword">new</span> BearFactory();</span><br><span class="line">    Toy bear = factory3.produce();</span><br><span class="line">    bear.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><strong>概念</strong> 装饰器模式就是给一个对象动态的增加一些新功能，要求装饰对象和被装饰对象实现同一个接口， 装饰对象持有被装饰对象的实例。</p>
<p>定义一个Source接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个SourcePlay类，实现Source接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourcePlay</span> <span class="keyword">implements</span> <span class="title">Source</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩LoL。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个装饰器，对 SourcePlay类 中扩展功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//装饰对象和被装饰对象实现同一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装饰对象持有被装饰对象的实例</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原有的方法</span></span><br><span class="line">        source.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;打完游戏后吃饭。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SourcePlay sourcePlay = <span class="keyword">new</span> SourcePlay();</span><br><span class="line">    sourcePlay.doSomething();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用装饰器模式在原有的代码上扩展功能：&quot;</span>);</span><br><span class="line">    Decorator decorator = <span class="keyword">new</span> Decorator(<span class="keyword">new</span> SourcePlay());</span><br><span class="line">    decorator.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际意义</strong>  </p>
<ul>
<li>可以实现一个类功能的扩展。 </li>
<li>可以动态的增加功能，而且还能动态撤销（继承不行）。 </li>
</ul>
<p><strong>缺点</strong>   产生过多相似的对象，不易排错。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>概念</strong> 如果需要对类中原有的方法进行改进，可以采用一个代理类调用原有方法，并且对产生的 结果进行控制，这种方式就是代理模式。 </p>
<p>用代理模式定义一个类，对 SourcePlay类 中扩展功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  代理模式 , 实现同一个接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SourcePlay sourcePlay;</span><br><span class="line">    <span class="comment">// 不用手动传递被代理的对象，直接创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sourcePlay = <span class="keyword">new</span> SourcePlay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用原有的功能</span></span><br><span class="line">        sourcePlay.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;不吃饭。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际意义</strong>     使用代理模式，可以将功能划分的更加清晰，有助于后期维护。</p>
<p><strong>代理模式和装饰器模式的比较</strong> </p>
<ul>
<li>装饰器模式通常的做法是将原始对象作为一个参数传给装饰者的构造器，而代理模式通常在一个代 理类中创建一个被代理类的对象。 </li>
<li>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong>概念</strong>  模板方法模式主要指一个抽象类中封装了一个固定流程，流程中的具体步骤可以由不同子类进行不 同的实现，通过抽象类让固定的流程产生不同的结果。</p>
<p><strong>实际意义</strong> </p>
<ul>
<li>将多个子类共有且逻辑基本相同的内容提取出来实现代码复用。 </li>
<li>不同的子类实现不同的效果形成多态，有助于后期维护。</li>
</ul>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>工厂模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql笔记</title>
    <url>/2021/06/10/MySql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>SQL语句的分类</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据定义语言</td>
<td>简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。</td>
</tr>
<tr>
<td>数据操作语言</td>
<td>简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。</td>
</tr>
<tr>
<td>数据查询语言</td>
<td>简称DQL(Data Query Language)，用来查询数据库中表的记录。</td>
</tr>
<tr>
<td>数据控制语言</td>
<td>简称DCL(Date Control Language)，用来定义数据库的访问权限和安全级别，及创建用户。(了解)</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h1><h2 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a>对数据库的操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>create database 数据库名</td>
<td>创建指定名称的数据库。</td>
</tr>
<tr>
<td>create database 数据库名 character set字符集</td>
<td>创建指定名称的数据库，并且指定字符集（一般都指定utf-8）</td>
</tr>
<tr>
<td>alter database 数据库名 character set 字符集</td>
<td>数据库的字符集修改操作</td>
</tr>
<tr>
<td>drop database 数据库名</td>
<td>从MySql中永久的删除某个数据库</td>
</tr>
</tbody></table>
<p><strong>查看/选择数据库</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>use 数据库</td>
<td>切换数据库</td>
</tr>
<tr>
<td>select database()</td>
<td>查看当前正在使用的数据库</td>
</tr>
<tr>
<td>show databases</td>
<td>查看Mysql中 都有哪些数据库</td>
</tr>
<tr>
<td>show create database 数据库名；</td>
<td>查看一个数据库的定义信息</td>
</tr>
</tbody></table>
<h2 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h2><p><strong>创建表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段名称1 字段类型（长度），</span><br><span class="line">    字段名称2 字段类型 -- 注意 最后一列不要加逗号</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>查看表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show tables</td>
<td>查看当前数据库中的所有表名</td>
</tr>
<tr>
<td>desc 表名</td>
<td>查看数据表的结构</td>
</tr>
</tbody></table>
<p><strong>删除表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>drop table 表名</td>
<td>删除表（从数据库中永久删除某一张表）</td>
</tr>
<tr>
<td>drop table if exists 表名</td>
<td>判断表是否存在， 存在的话就删除,不存在就不执行删除</td>
</tr>
</tbody></table>
<p><strong>修改表</strong></p>
<ul>
<li><p>修改表名</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE category TO category1;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表的字符集</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table category character set gbk;</span><br></pre></td></tr></table></figure></li>
<li><p>向表中添加列， 关键字 ADD</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE category ADD cdesc VARCHAR(20);</span><br></pre></td></tr></table></figure></li>
<li><p>修改表中列的 数据类型或长度 ， 关键字 MODIFY</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE category MODIFY cdesc VARCHAR(50)</span><br></pre></td></tr></table></figure></li>
<li><p>修改列名称 , 关键字 CHANGE</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE category CHANGE cdesc description VARCHAR(30);</span><br></pre></td></tr></table></figure></li>
<li><p>删除列 ，关键字 DROP</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE category DROP description;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>数据类型</strong></p>
<p>常用的有 varchar  、int 、double 、 date</p>
<p><a href="https://imgtu.com/i/2g7dFU"><img src="https://z3.ax1x.com/2021/06/10/2g7dFU.png" alt="2g7dFU.png"></a></p>
<h1 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h1><p><strong>insert</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名 （字段名1，字段名2...） values(字段值1，字段值2...);</span><br><span class="line">INSERT INTO 表名 VALUES(字段值1，字段值2...);</span><br></pre></td></tr></table></figure>
<p><strong>update</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 &#x3D; 值 [where 字段名 &#x3D; 值 ];</span><br></pre></td></tr></table></figure>
<p><strong>delete</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 逐条删除</span><br><span class="line">delete from 表名 [where 字段名 &#x3D; 值];</span><br><span class="line">-- 先删除整张表, 然后再重新创建一张一模一样的表</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<h1 id="DQL操作"><a href="#DQL操作" class="headerlink" title="DQL操作"></a>DQL操作</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select [distinct] 列名 from 表名 [where 字段名 &#x3D; 值]</span><br></pre></td></tr></table></figure>
<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</td>
<td>大于、小于、大于(小于)等于、不等于</td>
</tr>
<tr>
<td>BETWEEN …AND…</td>
<td>显示在某一区间的值例如: 2000-10000之间： Between 2000 and 10000</td>
</tr>
<tr>
<td>IN(集合)</td>
<td>集合表示多个值,使用逗号分隔,例如: name in (悟空，八戒)，in中的每个数据都会作为一次条件,只要满足条件就会显示</td>
</tr>
</tbody></table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>And &amp;&amp;</td>
<td>多个条件同时成立</td>
</tr>
<tr>
<td>Or  ||</td>
<td>多个条件任一成立</td>
</tr>
<tr>
<td>Not</td>
<td>不成立，取反。</td>
</tr>
</tbody></table>
<p><strong>模糊查询</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LIKE</td>
<td>模糊查询，通常搭配通配符，如查询 A 开头的数据:  ‘A%’</td>
</tr>
<tr>
<td>IS NULL</td>
<td>查询某一列为NULL的值, 注: 不能写 = NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>查询不为空的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>表示匹配任意多个字符串</td>
</tr>
<tr>
<td>_</td>
<td>表示匹配 一个字符</td>
</tr>
</tbody></table>
<p><strong>排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表名 [WHERE 字段 &#x3D; 值] ORDER BY 字段名 [ASC &#x2F; DESC]</span><br></pre></td></tr></table></figure>
<p>ASC  : 升序 （默认）</p>
<p>DESC : 降序</p>
<p>如果单个排序不能满足要求，可以组合排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表明 [WHERE 字段 &#x3D; 值 ] ORDER BY 字段名一 [ASC&#x2F;DESC],字段名二 [ASC&#x2F;DESC]; </span><br></pre></td></tr></table></figure>
<p><strong>聚合函数</strong></p>
<p>之前我们做的查询都是横向查询，而聚合函数查询是纵向 查询，它是对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空值)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 聚合函数(字段名) FROM 表名;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>count(字段)</td>
<td>统计指定列不为NULL的记录行数</td>
</tr>
<tr>
<td>sum(字段)</td>
<td>计算指定列的数值和</td>
</tr>
<tr>
<td>max(字段)</td>
<td>计算指定列的最大值</td>
</tr>
<tr>
<td>min(字段)</td>
<td>计算指定列的最小值</td>
</tr>
<tr>
<td>avg(字段)</td>
<td>计算指定列的平均值</td>
</tr>
</tbody></table>
<p><strong>分组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 分组字段&#x2F;聚合函数 FROM 表名 GROUP BY 分组字段 [HAVING 条件];</span><br></pre></td></tr></table></figure>
<p>使用 GROUP BY 语句,对查询的信息进行分组,相同数据作为一组。分组如果不适用聚合函数，其结果只会显示每一组的第一行数据，没有任何意义。如果在分组后,对数据进行过滤,使用 关键字 having</p>
<ul>
<li>where 与 having的区别</li>
</ul>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>where</td>
<td>where 进行分组前的过滤<br/>where 后面不能写 聚合函数</td>
</tr>
<tr>
<td>having</td>
<td>having 是分组后的过滤<br/>having 后面可以写 聚合函数</td>
</tr>
</tbody></table>
<ul>
<li>案例 ： 查询平均薪资大于6000的部门</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT dept_name ,AVG(salary) FROM emp </span><br><span class="line">WHERE dept_name IS NOT NULL GROUP BY dept_name</span><br><span class="line">HAVING AVG(salary) &gt;6000 ;</span><br></pre></td></tr></table></figure>
<p><strong>limit关键字</strong></p>
<ul>
<li>限制返回的查询结果的行数 (可以通过limit指定查询多少行数据) ,  limit 语法是 MySql的方言,用来完成分页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 LIMIT offset [, length];</span><br></pre></td></tr></table></figure>
<ul>
<li>offset     起始行数, 从0开始记数, 如果省略 则默认为 0.</li>
<li>length 返回的行数</li>
<li>分页公式 :   起始索引 = (当前页 - 1) * 每页条数</li>
</ul>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>通过指定的条件去匹配两张表中的数据, 匹配上就显示,匹配不上就不显示</p>
<p><strong>隐式内连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 左表, 右表 WHERE 连接条件;</span><br></pre></td></tr></table></figure>
<p><strong>显式内连接   [inner] join</strong>     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件;</span><br></pre></td></tr></table></figure>
<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p><strong>左外连接   left [outer] join</strong>    </p>
<p>以左表为基准, 匹配右边表中的数据,如果匹配的上,就展示匹配到的数据 如果匹配不到, 左表中的数据正常展示, 右边的展示为null.</p>
<p><strong>右外连接   right [outer] join</strong></p>
<p>以右表为基准，匹配左边表中的数据，如果能匹配到，展示匹配到的数据 如果匹配不到，右表中的数据正常展示, 左边展示为null</p>
<p><a href="https://imgtu.com/i/2WkO4U"><img src="https://z3.ax1x.com/2021/06/11/2WkO4U.png" alt="2WkO4U.png" style="zoom: 67%;" /></a></p>
<h2 id="子查询-SubQuery"><a href="#子查询-SubQuery" class="headerlink" title="子查询 (SubQuery)"></a>子查询 (SubQuery)</h2><p>一条select 查询语句的结果, 作为另一条 select 语句的一部分</p>
<p><strong>分类</strong></p>
<ul>
<li><strong>where型</strong>  将子查询的结果, 作为父查询的比较条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM 表 WHERE 字段&#x3D;（子查询）;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>from型</strong>  将子查询的结果, 作为 一张表,提供给父层查询使用 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM （子查询）表别名 WHERE 条件;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>exists型</strong>  子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查 询的结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询字段 FROM 表 WHERE 字段 IN （子查询）;</span><br></pre></td></tr></table></figure>
<h1 id="DCL操作"><a href="#DCL操作" class="headerlink" title="DCL操作"></a>DCL操作</h1><p>MySql默认使用的都是 root 用户，超级管理员，拥有全部的权限。除了root用户以外，我们还可以通 过DCL语言来定义一些权限较小的用户, 分配不同的权限来管理和维护数据库。</p>
<p><strong>创建用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</span><br></pre></td></tr></table></figure>
<p>本地用户可用 ‘localhost’表示主机名，  如果想让该用户可以 从任意远程主机登陆，可以使用通配符 %</p>
<p> <strong>用户授权</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT 权限 1, 权限 2... ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p>权限为 ： CREATE、ALTER、SELECT、INSERT、UPDATE等，如果要赋值所有权限就使用 ‘ALL’</p>
<p>数据库名.表名  ：写成  *.*   代表可赋予所有数据库与表的操作</p>
<p> <strong>查看权限</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>删除用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure>
<p> <strong>查询用户</strong></p>
<p>用户的信息在 mysql的 数据库中的 user表,直接用 DQL语句即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM USER;</span><br></pre></td></tr></table></figure>
<h1 id="数据库备份-amp-还原"><a href="#数据库备份-amp-还原" class="headerlink" title="数据库备份&amp;还原"></a>数据库备份&amp;还原</h1><h2 id="SQLYog的备份与还原"><a href="#SQLYog的备份与还原" class="headerlink" title="SQLYog的备份与还原"></a>SQLYog的备份与还原</h2><p>直接使用图形化界面操作就行了，不过SQLYog的备份与还原是整个数据库的操作</p>
<h2 id="命令行的备份与还原"><a href="#命令行的备份与还原" class="headerlink" title="命令行的备份与还原"></a>命令行的备份与还原</h2><p>命令行的备份与还原是将整个数据库的表全部提取出来，不会重新创建数据库</p>
<p><strong>备份</strong></p>
<ul>
<li><p>进入到Mysql安装目录的 bin目录下, 打开DOS命令行，输入以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 数据库 &gt; 要保存到的文件路径</span><br></pre></td></tr></table></figure></li>
<li><p>*还原**</p>
</li>
<li><p>先创建一个 相同名称的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 当前数据库;    --选中当前数据库   </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source sql 文件地址</span><br></pre></td></tr></table></figure>
<h1 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h1><p>约束的作用: 对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性. 违反约束的 不正确数据,将无法插入到表中</p>
</li>
</ul>
<p><strong>常见的约束</strong></p>
<table>
<thead>
<tr>
<th>约束名</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>primary key</td>
</tr>
<tr>
<td>唯一</td>
<td>unique</td>
</tr>
<tr>
<td>非空</td>
<td>not null</td>
</tr>
<tr>
<td>外键</td>
<td>foreign key</td>
</tr>
<tr>
<td>默认值</td>
<td>default</td>
</tr>
</tbody></table>
<h1 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h1><p>事务是一个整体,由一条或者多条SQL 语句组成,这些SQL语句要么都执行成功,要么都执行失败, 只要有一 条SQL出现异常,整个操作就会回滚,整个业务执行失败</p>
<p><strong>手动提交事务</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>语句</th>
</tr>
</thead>
<tbody><tr>
<td>开启事务</td>
<td>start transaction; 或者 BEGIN;</td>
</tr>
<tr>
<td>提交事务</td>
<td>commit;</td>
</tr>
<tr>
<td>回滚事务</td>
<td>rollback;</td>
</tr>
</tbody></table>
<p><a href="https://imgtu.com/i/2WFIw6"><img src="https://z3.ax1x.com/2021/06/11/2WFIw6.png" alt="2WFIw6.png" style="zoom:50%;" /></a></p>
<p><strong>自动提交事务</strong> </p>
<p>MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执 行完毕 自动提交事务，MySQL 默认开始自动提交事务。</p>
<p><strong>取消自动提交</strong> </p>
<p>MySQL默认是自动提交事务,设置为手动提交.</p>
<ul>
<li>登录mysql，查看autocommit状态。on ：自动提交 off : 手动提交</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li> 把 autocommit 改成 off;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@autocommit&#x3D;off;</span><br></pre></td></tr></table></figure>
<p><strong>事务的四大特性 ACID</strong></p>
<ul>
<li><strong>原 子 性</strong> 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都 失败。 </li>
<li><strong>一 致 性</strong> 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前2个人的 总金额 是 2000，转账后 2 个人总金额也是 2000. </li>
<li><strong>隔 离 性</strong> 事务与事务之间不应该相互影响，执行时保持隔离的状态. </li>
<li><strong>持 久 性</strong> 一旦事务执行成功，对数据库的修改是持久的。就算关机，数据也是要保存下来的.</li>
</ul>
<p><strong>并发访问会产生的问题</strong></p>
<table>
<thead>
<tr>
<th>并发访问的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读取到了另一个事务中尚未提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务中两次读取的数据内容不一致, 要求的是在一个事务中多次读取时数据是一致的. 这是进行 update 操作时引发的问题</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务中,某一次的 select 操作得到的结果所</td>
</tr>
</tbody></table>
<p><strong>四种隔离级别</strong>       (✔ 会出现问题 ✘ 不会出现问题)</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>名字</th>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>数据库的默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>读未提交</td>
<td>read uncommitted</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>读已提交</td>
<td>read committed</td>
<td>✘</td>
<td>✔</td>
<td>✔</td>
<td>Oracle和SQLServer</td>
</tr>
<tr>
<td>3</td>
<td>可重复读</td>
<td>repeatable read</td>
<td>✘</td>
<td>✘</td>
<td>✔</td>
<td>MySql</td>
</tr>
<tr>
<td>4</td>
<td>串行化</td>
<td>serializable</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td></td>
</tr>
</tbody></table>
<p><strong>隔离级别相关命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set global transaction isolation level 级别名称;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令MySQL的查询和 运行更加高效。</p>
<table>
<thead>
<tr>
<th>索引名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引 (primarykey)</td>
<td>主键是一种唯一性索引,每个表只能有一个主键, 用于标识数据表中的每一条记录</td>
</tr>
<tr>
<td>唯一索引 (unique)</td>
<td>唯一索引指的是 索引列的所有值都只能出现一次, 必须唯一.</td>
</tr>
<tr>
<td>普通索引 (index)</td>
<td>最常见的索引,作用就是 加快对数据的访问速度</td>
</tr>
</tbody></table>
<p><strong>索引的优点</strong> </p>
<ul>
<li>大大的提高查询速度 </li>
<li>可以显著的减少查询中分组和排序的时间。 </li>
</ul>
<p>索引的缺点</p>
<ul>
<li>创建索引和维护索引需要时间，而且数据量越大时间越长 </li>
<li>当对表中的数据进行增加，修改，删除的时候，索引也要同时进行维护，降低了数据的维护 速度</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h2><p>视图是一种虚拟表 , 建立在已有表的基础上, 视图赖以建立的这些表称为基表。</p>
<p><strong>创建视图</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名 [column_list] as select语句;</span><br></pre></td></tr></table></figure>
<p>对视图的其他操作与对表的操作一模一样</p>
<p><strong>视图与表的区别</strong></p>
<ul>
<li>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 </li>
<li>通过视图不能改变表中数据（一般情况下视图中的数据都是表中的列 经过计算得到的结果,不允许 更新） </li>
<li>删除视图，表不受影响，而删除表，视图不再起作用</li>
</ul>
<h2 id="存储过程（procedure）"><a href="#存储过程（procedure）" class="headerlink" title="存储过程（procedure）"></a>存储过程（procedure）</h2><p> 一堆 SQL 语句的合并。中间加入了一些逻辑控制。</p>
<p><strong>创建存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$ -- 声明语句结束符，可以自定义 一般使用$$</span><br><span class="line">-- 声明存储过程，形参可以有多个，返回参数只能有一个</span><br><span class="line">CREATE PROCEDURE 过程名称([IN 形参名 形参类型],[out 输出参数名 输出参数类型]) </span><br><span class="line">BEGIN -- 开始编写存储过程</span><br><span class="line">-- 要执行的操作</span><br><span class="line">END $$ -- 存储过程结束</span><br></pre></td></tr></table></figure>
<p><strong>调用存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名</span><br><span class="line">call 存储过程名(实参)</span><br><span class="line">call 存储过程名(实参,@输出数据)</span><br></pre></td></tr></table></figure>
<p><strong>变量赋值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @变量名&#x3D;值</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 向订单表 插入一条数据, 返回1,表示插入成功</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE orders_proc(IN o_id INT , IN g_id INT ,IN price INT, OUT out_num INT)</span><br><span class="line">BEGIN</span><br><span class="line">    -- 执行插入操作</span><br><span class="line">    INSERT INTO orders VALUES(o_id,o_id,price);</span><br><span class="line">    -- 设置 num的值为 1</span><br><span class="line">    SET @out_num &#x3D; 1;</span><br><span class="line">    -- 返回 out_num的值</span><br><span class="line">    SELECT @out_num;</span><br><span class="line">END $$</span><br><span class="line"># 调用存储过程插入数据,获取返回值</span><br><span class="line">CALL orders_proc(1,2,30,@out_num);</span><br></pre></td></tr></table></figure>
<h2 id="触发器（trigger）"><a href="#触发器（trigger）" class="headerlink" title="触发器（trigger）"></a>触发器（trigger）</h2><p> 当我们执行一条sql语句的时候，这条sql语句的执行会自动去触发执行其他的sql语句。</p>
<p><strong>四要素</strong></p>
<ul>
<li>监视地点（table） </li>
<li>监视事件（insert/update/delete） 3</li>
<li>触发时间（before/after） </li>
<li>触发事件（insert/update/delete）</li>
</ul>
<p><strong>创建触发器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $ -- 将Mysql的结束符号从 ; 改为 $,避免执行出现错误</span><br><span class="line">CREATE TRIGGER Trigger_Name -- 触发器名，在一个数据库中触发器名是唯一的</span><br><span class="line">before&#x2F;after（insert&#x2F;update&#x2F;delete） -- 触发的时机 和 监视的事件</span><br><span class="line">on table_Name -- 触发器所在的表</span><br><span class="line">for each row -- 固定写法 叫做行触发器, 每一行受影响，触发事件都执行</span><br><span class="line">begin</span><br><span class="line">-- begin和end之间写触发事件</span><br><span class="line">end $ -- 结束标记</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -- 在下订单的时候，对应的商品的库存量要相应的减少，卖出商品之后减少库存量</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE TRIGGER t1</span><br><span class="line">AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	UPDATE goods SET num &#x3D; num -1 WHERE gid &#x3D; 1;</span><br><span class="line">END$</span><br></pre></td></tr></table></figure>


<p>over 。。。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>XML笔记</title>
    <url>/2021/06/13/XML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>XML即可扩展标记语言（Extensible Markup Language） 。W3C在1998年2月发布1.0版本，2004年2月又发布1.1版本，但因为1.1版本不能向下兼容1.0版 本，所以1.1没有人用。同时，在2004年2月W3C又发布了1.0版本的第三版。我们要学习的还是 1.0版本 ! <a id="more"></a></p>
<p><strong>XML作用</strong></p>
<ul>
<li><ol>
<li>储数据     2) 配置文件   3)在网络中 传输 </li>
</ol>
</li>
</ul>
<p><strong>XML语法</strong></p>
<ul>
<li>文档声明必写在第一行</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--versioin：指定XML文档版本。encoding：指定当前文档的编码。可选属性，默认值是utf-8；--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML 必须有且只有一个根元素，它是所有其他元素的父元素</p>
</li>
<li><p>普通元素的结构开始标签、元素体、结束标签组成。类似于HTML标签</p>
</li>
</ul>
<h1 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h1><p>在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。 </p>
<p><strong>常见的xml约束</strong>    DTD 、 Schema</p>
<h2 id="DTD约束"><a href="#DTD约束" class="headerlink" title="DTD约束"></a>DTD约束</h2><p>DTD（Document Type Definition），文档类型定义，用来约束XML文档。规定XML文档中元素的名 称，子元素的名称及顺序，元素的属性等。</p>
<p><strong>创建一个约束文件student.dtd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT students (student+) &gt;</span><br><span class="line">&lt;!ELEMENT student (name,age,sex)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">&lt;!ATTLIST student number ID #REQUIRED&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">ELEMENT: 用来定义元素</span><br><span class="line">students (student+) : 代表根元素 必须是 &lt;students&gt;</span><br><span class="line">student+ : 根标签中至少有一个 student子元素, + 代表至少一个</span><br><span class="line">student (name,age,sex): student 标签中包含的子元素,按顺序出现</span><br><span class="line">#PCDATA: 是普通文本内容</span><br><span class="line">ATTLIST: 用来定义属性</span><br><span class="line">student number ID #REQUIRED</span><br><span class="line">student子元素中 有一个ID属性叫做 number,是必须填写的</span><br><span class="line">ID: 唯一 值只能是字母或者下划线开头</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p><strong>创建student.xml文件并引入DTD约束</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">students</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;student.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Schema约束"><a href="#Schema约束" class="headerlink" title="Schema约束"></a>Schema约束</h2><p><strong>概念</strong></p>
<ul>
<li>Schema是新的XML文档约束, 比DTD强大很多，是DTD 替代者； </li>
<li>Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。 </li>
<li>Schema 功能更强大，内置多种简单和复杂的数据类型 </li>
<li>Schema 支持命名空间 (一个XML中可以引入多个约束文档)</li>
</ul>
<p><strong>创建一个Schema约束文件student.xsd</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.hui.com/xml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.hui.com/xml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentsType&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentsType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ageType&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;sexType&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">type</span>=<span class="string">&quot;numberType&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;sexType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;ageType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:integer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;numberType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:pattern</span> <span class="attr">value</span>=<span class="string">&quot;hui_\d&#123;4&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建student.xml文件并引入Schema约束</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">&lt;students</span><br><span class="line">        xmlns=&quot;http://www.hui.com/xml&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.hui.com/xml student.xsd&quot;</span><br><span class="line">&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;hui_1234&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;hui_5678&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>3<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>xmlns</strong> 表示根元素来自哪个命名空间</p>
<p><strong>xmlns:xsi</strong>  引入 w3c的标准命名空间</p>
<p><strong>xsi:schemaLocation</strong>  表示引入的命名空间跟哪个xsd文件对应，第一个值为为命名空间 第二个值为xsd文件的路径</p>
<h1 id="XML-解析"><a href="#XML-解析" class="headerlink" title="XML 解析"></a>XML 解析</h1><p><strong>XML解析方式</strong></p>
<ul>
<li>DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象。 <ul>
<li>优点：元素与元素之间保留结构关系，故可以进行增删改查操作。 </li>
<li>缺点：XML文档过大，可能出现内存溢出显现。 </li>
</ul>
</li>
<li>SAX：是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。并以事件驱动的方 式进行具体解析，每执行一行，都将触发对应的事件。<ul>
<li>优点：占用内存少 处理速度快，可以处理大文件 </li>
<li>缺点：只能读，逐行后将释放资源。</li>
</ul>
</li>
</ul>
<p><strong>XML常见的解析器</strong></p>
<ul>
<li>JAXP：sun公司提供的解析器，支持DOM和SAX两种思想 </li>
<li>DOM4J：一款非常优秀的解析器 , Dom4j是一个易用的、开源的库，用于XML，XPath和XSLT。 它应用于Java平台，采用了Java集合框架并完全支持DOM，SAX和JAXP。</li>
<li> Jsoup：jsoup 是一款Java 的HTML解析器 ,也可以解析XML </li>
<li>PULL：Android内置的XML解析方式，类似SAX。</li>
</ul>
<h2 id="dom4j-的使用"><a href="#dom4j-的使用" class="headerlink" title="dom4j 的使用"></a>dom4j 的使用</h2><p>所需jar包   <strong>dom4j-1.6.1.jar</strong></p>
<p>通过核心类SaxReader加载xml文档获得Document，通过Document 对象获得文档的根元素，然后就 可以操作了</p>
<p><strong>SaxReader对象</strong>  read(…) 加载执行xml文档 </p>
<p><strong>Document对象</strong>  getRootElement() 获得根元素 </p>
<p><strong>Element对象</strong> </p>
<ul>
<li>elements(…) 获得指定名称的所有子元素。可以不指定名称 </li>
<li>element(…) 获得指定名称的第一个子元素。可以不指定名称 </li>
<li>getName() 获得当前元素的元素名 </li>
<li>attributeValue(…) 获得指定属性名的属性值 </li>
<li>elementText(…) 获得指定名称子元素的文本值 </li>
<li>getText() 获得当前元素的文本内容</li>
</ul>
<p><strong>使用案例</strong></p>
<ul>
<li>创建一个user.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;01&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王二麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;02&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>34<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;03&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>怪狗狗<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 dom4j 解析user.xml文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">    	<span class="comment">// 构造获取SAXReader对象</span></span><br><span class="line">       SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    	<span class="comment">// 指定XML文件地址获取Document对象</span></span><br><span class="line">       Document document = saxReader.read(<span class="string">&quot;C:\\project\\javaCode\\java_base\\jdbc_xml\\xml\\src\\com\\hui\\dom4j\\user.xml&quot;</span>);</span><br><span class="line">    	<span class="comment">// 获取根元素</span></span><br><span class="line">       Element root = document.getRootElement();</span><br><span class="line">    	<span class="comment">// 获取根元素的所有子元素</span></span><br><span class="line">       List&lt;Element&gt; elements = root.elements();</span><br><span class="line">       <span class="comment">// 解析第一个子元素 user</span></span><br><span class="line">       Element user = elements.get(<span class="number">0</span>);</span><br><span class="line">       String name = user.getName();      					<span class="comment">// 获取标签名</span></span><br><span class="line">       String id = user.attributeValue(<span class="string">&quot;id&quot;</span>);				<span class="comment">// 获取user的id属性</span></span><br><span class="line">       String nameText = user.elementText(<span class="string">&quot;name&quot;</span>);			<span class="comment">// 获取name子元素的文本内容</span></span><br><span class="line">       String ageText = user.elementText(<span class="string">&quot;age&quot;</span>);		    <span class="comment">// 获取age子元素的文本内容</span></span><br><span class="line">       String hobbyText = user.element(<span class="string">&quot;hobby&quot;</span>).getText(); <span class="comment">// 获取hobby子元素的文本内容</span></span><br><span class="line">       System.out.println(name + <span class="string">&quot; : &quot;</span> + id + <span class="string">&quot; &quot;</span> + nameText + <span class="string">&quot; &quot;</span> + ageText + <span class="string">&quot; &quot;</span> + hobbyText);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="xpath方式读取xml"><a href="#xpath方式读取xml" class="headerlink" title="xpath方式读取xml"></a>xpath方式读取xml</h2><p>XPath 是一门在 XML 文档中查找信息的语言。 可以是使用xpath查找xml中的内容</p>
<p>所需jar包       <strong>jaxen-1.1-beta-6.jar</strong></p>
<p><strong>常用方法</strong></p>
<p><strong>Document对象</strong>   <strong>Element对象</strong>    <strong>Node对象</strong>都可应调用下面两个xpath查询的方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Node selectSingleNode(String query)</td>
<td>查找和 XPath 查询匹配的一个节点。 参数是Xpath 查询串。</td>
</tr>
<tr>
<td>Node selectNodes(String query)</td>
<td>得到的是xml根节点下的所有满足 xpath 的节点,参数是Xpath 查询串</td>
</tr>
</tbody></table>
<p>返回值是Node对象，该对象的方法与Element对象的方法差不多</p>
<table>
<thead>
<tr>
<th>xpath基本语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/AAA/DDD/BBB</td>
<td>表示一层一层的，AAA下面 DDD下面的BBB</td>
</tr>
<tr>
<td>//BBB</td>
<td>表示和这个名称相同，表示只要名称是BBB，都得到</td>
</tr>
<tr>
<td>//*</td>
<td>所有元素</td>
</tr>
<tr>
<td>BBB[1] , BBB[last()]</td>
<td>第一种表示第一个BBB元素, 第二种表示最后一个BBB元素</td>
</tr>
<tr>
<td>//BBB[@id]</td>
<td>表示只要BBB元素上面有id属性，都得到</td>
</tr>
<tr>
<td>//BBB[@id=’b1’]</td>
<td>表示元素名称是BBB,在BBB上面有id属性，并且id的属性值是b1</td>
</tr>
</tbody></table>
<h2 id="JDBC自定义XML"><a href="#JDBC自定义XML" class="headerlink" title="JDBC自定义XML"></a>JDBC自定义XML</h2><p><strong>创建自定义xml 文件jdbc-config.xml, 保存 数据库连接信息</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>nofuck<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>编写JDBC工具类 , 使用xpath 读取数据库信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.dom4j.jdbc;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: 李昭辉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/13/12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JDBC工具类，相关配置从 jdbc-config.xml 文件中获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String DRIVER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PASSWORD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取配置文件信息</span></span><br><span class="line">            SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = saxReader.read(<span class="string">&quot;C:\\project\\javaCode\\java_base\\jdbc_xml\\xml\\src\\com\\hui\\dom4j\\jdbc\\jdbc-config.xml&quot;</span>);</span><br><span class="line">            DRIVER = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;driverClass&#x27;]&quot;</span>).getText();</span><br><span class="line">            URL = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;jdbcUrl&#x27;]&quot;</span>).getText();</span><br><span class="line">            USER = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;user&#x27;]&quot;</span>).getText();</span><br><span class="line">            PASSWORD = document.selectSingleNode(<span class="string">&quot;/jdbc/property[@name=&#x27;password&#x27;]&quot;</span>).getText();</span><br><span class="line">            <span class="comment">// 加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>xpath</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC笔记</title>
    <url>/2021/06/12/JDBC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul>
<li><p>JDBC(Java Data Base Connectivity) 是 Java 访问数据库的标准规范.是一种用于执行SQL语句的Java API，可以为 多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范.<a id="more"></a></p>
</li>
<li><p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需 要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>所需jar包   mysql-connector-java-5.1.37-bin.jar</strong></p>
<ul>
<li>JDBC规范定义驱动接口： java.sql.Driver MySql</li>
<li>驱动包提供了实现类： com.mysql.jdbc.Driver</li>
</ul>
<p><strong>删除案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//1.注册驱动 , forName 方法执行将类进行初始化</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获得连接   url,用户名, 密码</span></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hui?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">    Connection con = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//3.获取语句执行平台</span></span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">	<span class="comment">//5.增删改操作 使用executeUpdate,增加一张表</span></span><br><span class="line">    <span class="keyword">int</span> i = statement.executeUpdate(<span class="string">&quot;delete form hui where id = 1&quot;</span>);</span><br><span class="line">    <span class="comment">//6.返回值是受影响的函数</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">//7.关闭流</span></span><br><span class="line">    statement.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Connection 的 createStatement() 方法 获取sql语句执行对象Statement </p>
<p><strong>Statement</strong> ： 代表一条语句对象，用于发送 SQL 语句给服务器，用于执行静态 SQL 语句并返回它所生成结 果的对象。</p>
<table>
<thead>
<tr>
<th>Statement类 常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int executeUpdate(String sql);</td>
<td>执行insert update delete语句.返回int类型,代表受影响的行数</td>
</tr>
<tr>
<td>ResultSet executeQuery(String sql);</td>
<td>执行select语句, 返回ResultSet结果集对象</td>
</tr>
</tbody></table>
<p><strong>结果集 ResultSet 的处理</strong></p>
<table>
<thead>
<tr>
<th>ResultSet接口方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean next()</td>
<td>游标向下一行 ，返回 boolean 类型，如果还有下一条记录，返回 true，否则返回 false</td>
</tr>
<tr>
<td>xxx getXxx( String or int)</td>
<td>传递字段名  或  字段的列号，从1开始</td>
</tr>
</tbody></table>
<p><strong>查询案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement statement = con.createStatement();</span><br><span class="line"><span class="comment">// 执行查询语句获取结果集</span></span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line"><span class="comment">// 遍历结果集，获取所有数据</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String username = resultSet.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    Date createTime = resultSet.getDate(<span class="string">&quot;createTime&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username+<span class="string">&quot;,createTime:&quot;</span>+createTime)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure>
<p><strong>步骤总结</strong></p>
<ol>
<li>获取驱动(可以省略) </li>
<li> 获取连接</li>
<li> 获取Statement对象 </li>
<li>处理结果集(只在查询时处理) </li>
<li>释放资源</li>
</ol>
<p><strong>自定义一个 JDBCUtil 工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: 李昭辉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/12/9:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JDBC 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(URL, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;nofuck&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SQL预处理对象"><a href="#SQL预处理对象" class="headerlink" title="SQL预处理对象"></a>SQL预处理对象</h2><p><strong>Sql注入问题</strong></p>
<ul>
<li>我们让用户输入的密码和 SQL 语句进行字符串拼接。用户输入的内容作为了 SQL 语句语法的一部分，改变了 原有 SQL 真正的意义，以上问题称为 SQL 注入 .</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--  这样一条SQL语句就表示查询所有</span><br><span class="line">SELECT * FROM jdbc_user WHERE username &#x3D; &#39;tom&#39; AND password&#x3D; &#39;123&#39;  OR  &#39;1&#39; &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure>
<p>因为SQL语句是用字符串拼接的，当用户输入密码时输入: XXX ‘  OR  ‘1’ = ‘1，就可以随便登入了，这时我们可以用JDBC中的预处理对象</p>
<p><strong>PreparedStatement 接口</strong></p>
<ul>
<li>PreparedStatement 是 Statement 接口的子接口，继承于父接口中所有的方法。</li>
<li>它是一个预编译的 SQL 语 句对象. 预编译: 是指SQL 语句被预编译,并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行 该语句。</li>
</ul>
<p><strong>优点</strong> ：1）因为有预先编译的功能，提高 SQL 的执行效率； 2）可以有效的防止 SQL 注入的问题，安全性更高</p>
<p><strong>获取预处理对象</strong> 通过连接 Connection.prepareStatement(sql语句) 直接获取</p>
<table>
<thead>
<tr>
<th>PreparedStatement接口常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int executeUpdate();</td>
<td>执行insert update delete语句.</td>
</tr>
<tr>
<td>ResultSet executeQuery();</td>
<td>执行select语句. 返回结果集对象 Resulet</td>
</tr>
<tr>
<td>void setXXX(int parameterIndex, XXX value)</td>
<td>设置占位符?parameterIndex出的值为XXX类型的value</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理防止注入问题</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       Connection con = JDBCUtil.getConnection(); <span class="comment">//获取链接</span></span><br><span class="line">       <span class="comment">// 获取预处理对象，先将sql放入，数据库可以预先编译，?表示占位符</span></span><br><span class="line">       String sql = <span class="string">&quot;select * from user where username=? and password= ? &quot;</span>;</span><br><span class="line">       PreparedStatement statement = con.prepareStatement(sql);</span><br><span class="line">       <span class="comment">// 控制台模拟用户输入用户名与密码</span></span><br><span class="line">       Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">       String name = sc.nextLine();</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);<span class="comment">// 输入 xxx&#x27; or &#x27;1&#x27;=&#x27;1 将无法注入</span></span><br><span class="line">       String pwd = sc.nextLine();</span><br><span class="line">       <span class="comment">// 将预处理中sql中的占位符填充数据</span></span><br><span class="line">       statement.setString(<span class="number">1</span>, name);</span><br><span class="line">       statement.setString(<span class="number">2</span>, pwd);</span><br><span class="line">       <span class="comment">// 执行SQL</span></span><br><span class="line">       ResultSet resultSet = statement.executeQuery();</span><br><span class="line">       System.out.println(resultSet.next() ? <span class="string">&quot;登入成功!&quot;</span> : <span class="string">&quot;登入失败!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>预处理插入多条数据案例</strong>   SQL语句发送给数据库，数据库只需要编译一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取预处理对象</span></span><br><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">&quot;insert into jdbc_user values(null,?,?)&quot;</span>);</span><br><span class="line"><span class="comment">//第一条数 设置占位符对应的参数</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"><span class="comment">//执行插入</span></span><br><span class="line">ps.executeUpdate();</span><br><span class="line"><span class="comment">//第二条数据</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//执行插入</span></span><br><span class="line">ps.executeUpdate();</span><br></pre></td></tr></table></figure>
<p> <strong>Statement 与 PreparedStatement的区别</strong></p>
<ul>
<li><p>Statement用于执行静态SQL语句，在执行时，必须指定一个事先准备好的SQL语句。</p>
</li>
<li><p>PrepareStatement是预编译的SQL语句对象，语句中可以包含动态参数“?”，在执行时可以为“?”动态设置参数 值</p>
</li>
<li><p>PrepareStatement可以减少编译次数提高数据库性能</p>
</li>
</ul>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p><strong>Connection中事务相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void setAutoCommit(boolean autoCommit)</td>
<td>参数是 true 或 false 如果设置为 false，表示关闭自动提交，相当于开启事务</td>
</tr>
<tr>
<td>void commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback()</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟银行转账操作 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = JDBCUtil.getConnection(); <span class="comment">// 获取连接</span></span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">            <span class="comment">// 预处理模拟转账操作</span></span><br><span class="line">            ps = con.prepareStatement(<span class="string">&quot;update account set money=money- ? where username = ?&quot;</span>);</span><br><span class="line">            ps.setInt(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);  <span class="comment">// 模拟出现异常</span></span><br><span class="line">            ps = con.prepareStatement(<span class="string">&quot;update account set money=money+ ? where username = ?&quot;</span>);</span><br><span class="line">            ps.setInt(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            con.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            JDBCUtil.close(con, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据库批处理batch"><a href="#数据库批处理batch" class="headerlink" title="数据库批处理batch"></a>数据库批处理batch</h2><p>批处理指的是一次操作中执行多条SQL语句，批处理相比于一次一次执行效率会提高很多。 当向数据库中添加大量的数据时，需要用到批处理。</p>
<p>Statement和PreparedStatement都支持批处理操作，这里介绍一下PreparedStatement的批处理方式</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addBatch()</td>
<td>将给定的 SQL 命令添加到此 Statement 对象的当前命令列表中。通过调用方法 executeBatch 可以批量执行此列表中的命令。</td>
</tr>
<tr>
<td>int[] executeBatch()</td>
<td>每次提交一批命令到数据库中执行，如果所有的命令都成功执行了，那么返回一个数组，这个数组是说明每条命令所影响的行数</td>
</tr>
</tbody></table>
<p><strong>注</strong> mysql 批处理是默认关闭的，所以需要加一个参数才能打开mysql 数据库批处理，在url中添加 rewriteBatchedStatements=true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/db5?characterEncoding=UTF-8&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure>
<p><strong>插入10000条数据案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批处理操作</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAdd</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       Connection con = JDBCUtil.getConnection();</span><br><span class="line">       PreparedStatement ps = con.prepareStatement(<span class="string">&quot;insert into user values(null,?,&#x27;123&#x27;, &#x27;2021-6-15&#x27;)&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           ps.setString(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span> + i);</span><br><span class="line">           ps.addBatch();</span><br><span class="line">       &#125;</span><br><span class="line">       ps.executeBatch();</span><br><span class="line">       JDBCUtil.close(con, ps);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MySql元数据MetaData"><a href="#MySql元数据MetaData" class="headerlink" title="MySql元数据MetaData"></a>MySql元数据MetaData</h2><p>除了表之外的数据都是元数据,可以分为三类 </p>
<ul>
<li>查询结果信息： UPDATE 或 DELETE语句 受影响的记录数。 </li>
<li>数据库和数据表的信息： 包含了数据库及数据表的结构信息。 </li>
<li>MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等</li>
</ul>
<p><strong>DatabaseMetaData类</strong>    </p>
<p>描述数据库的元数据对象，通过Connection 连接对象的 getMetaData () 方法获取</p>
<table>
<thead>
<tr>
<th>DatabaseMetaData方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>getURL() : 获取数据库的URL</td>
</tr>
<tr>
<td>getUserName(): 获取当前数据库的用户名</td>
</tr>
<tr>
<td>getDatabaseProductName(): 获取数据库的产品名称</td>
</tr>
<tr>
<td>getDatabaseProductVersion(): 获取数据的版本号</td>
</tr>
<tr>
<td>getDriverName(): 返回驱动程序的名称</td>
</tr>
<tr>
<td>isReadOnly(): 判断数据库是否只允许只读 true 代表只读</td>
</tr>
</tbody></table>
<p><strong>ResultSetMetaData类</strong>    </p>
<p>描述结果集的元数据对象，通过PrepareStatement 预处理对象的 getMetaData ()获取</p>
<table>
<thead>
<tr>
<th>ResultSetMetaData方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>getColumnCount() :v 当前结果集共有多少列</td>
</tr>
<tr>
<td>getColumnName(int i) : 获取指定列号的列名, 参数是整数 从1开始</td>
</tr>
<tr>
<td>getColumnTypeName(int i): 获取指定列号列的类型, 参数是整数 从1开始</td>
</tr>
</tbody></table>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>管理Connection连接的创建与销毁 ， 可以重复使用Connection。 当使用完Connection后，调用Connection的 close()方法也不会真的关闭Connection，而是把Connection“归还”给池。</p>
<p>Java为数据库连接池提供了公共的接口：javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。 这样应用程序可以方便的切换不同厂商的连接池。</p>
<h2 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h2><p> DBCP也是一个开源的连接池，是Apache成员之一，在企业开发中也比较常见，tomcat内置的连接池</p>
<p>所需jar包  : <strong>commons-dbcp-1.4.jar</strong>        <strong>commons-pool-1.5.6.jar</strong></p>
<p><strong>常见配置项</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>driverClassName</td>
<td>数据库驱动名称</td>
</tr>
<tr>
<td>url</td>
<td>数据库地址</td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
</tr>
<tr>
<td>maxActive</td>
<td>最大连接数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>最大空闲连接</td>
</tr>
<tr>
<td>minIdle</td>
<td>最小空闲连接</td>
</tr>
<tr>
<td>initialSize</td>
<td>初始化连接</td>
</tr>
</tbody></table>
<p><strong>DBCP 工具类</strong>                    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBCPUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_NAME = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="comment">// dbcp 连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化连接池</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pool = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">            pool.setDriverClassName(DRIVER_NAME);</span><br><span class="line">            pool.setUrl(URL);</span><br><span class="line">            pool.setUsername(USERNAME);</span><br><span class="line">            pool.setPassword(PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = pool.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p> C3P0是一个开源的JDBC连接池,支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、 Spring等</p>
<p>所需jar包    <strong>c3p0-0.9.5.2.jar</strong>      <strong>mchange-commons-java-0.2.12.jar</strong></p>
<p><strong>导入配置文件 c3p0-config.xml</strong>  </p>
<ul>
<li>c3p0-config.xml 文件名不可更改 。直接放到src下,也可以放到到资源文件夹中，连接池会直接读取</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--默认配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- initialPoolSize：初始化时获取三个连接，</span></span><br><span class="line"><span class="comment">			  取值应在minPoolSize与maxPoolSize之间。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- maxIdleTime：最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>60<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- maxPoolSize：连接池中保留的最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- minPoolSize: 连接池中保留的最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!--配置连接池mysql1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/homework?characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置连接池2,可以配置多个--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>C3P0 工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource pool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//        pool=new ComboPooledDataSource();</span></span><br><span class="line">        <span class="comment">// 指定使用配置文件中的哪个配置</span></span><br><span class="line">        pool = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = pool.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p> Druid（德鲁伊）是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行 情况。</p>
<p>所需jar包   <strong>druid-1.0.9.jar</strong></p>
<p><strong>导入配置文件</strong> </p>
<ul>
<li>properties形式，可以叫任意名称，但需要手动读取。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/db5?characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<p><strong>Druid工具类</strong></p>
<p> 通过 DruidDataSourceFactory工厂类的createDataSource( Properties properties)  获取连接池对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.connectionPool;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource; <span class="comment">// 连接池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取配置文件的输入流</span></span><br><span class="line">            InputStream stream = DruidUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建属性集对象，从字节流中读取配置文件</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(stream);</span><br><span class="line">            <span class="comment">// 通过工厂方法获取连接池</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接 ，这里的关闭不是真正意义上的关闭，而是将连接归还跟连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resultSet) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != statement) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != con) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement statement)</span> </span>&#123;</span><br><span class="line">        close(con, statement, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DBUtils工具类"><a href="#DBUtils工具类" class="headerlink" title="DBUtils工具类"></a>DBUtils工具类</h1><p> Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程 序的开发，同时也不会影响程序的性能。</p>
<p>所需jar包      <strong>commons-dbutils-1.6.jar</strong></p>
<h2 id="QueryRunner核心类"><a href="#QueryRunner核心类" class="headerlink" title="QueryRunner核心类"></a>QueryRunner核心类</h2><p>提供对sql语句操作的API</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>QueryRunner()</td>
<td>手动模式，获取QueryRunner对象</td>
</tr>
<tr>
<td>QueryRunner(DataSource ds)</td>
<td>自动模式，提供数据源（连接池），DBUtils底层自动维护连接connection,后续操作不再需要提供Connection对象</td>
</tr>
<tr>
<td>update([Connection conn,] String sql, Object… params)</td>
<td>用来完成表数据的增加、删除、更新操作</td>
</tr>
<tr>
<td>query([Connection conn,] String sql, ResultSetHandler<T> rsh, Object… params)</td>
<td>用来完成表数据的查询操作</td>
</tr>
</tbody></table>
<h2 id="ResultSetHandler接口"><a href="#ResultSetHandler接口" class="headerlink" title="ResultSetHandler接口"></a>ResultSetHandler接口</h2><p>ResultSetHandler可以对查询出来的ResultSet结果集进行处理，达到一些业务上的需求。</p>
<table>
<thead>
<tr>
<th>ResultSetHandler实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayHandler</td>
<td>将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值</td>
</tr>
<tr>
<td>ArrayListHandler</td>
<td>将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。</td>
</tr>
<tr>
<td>BeanHandler</td>
<td>将结果集中第一条记录封装到一个指定的javaBean中.</td>
</tr>
<tr>
<td>BeanListHandler</td>
<td>将结果集中每一条记录封装到指定的javaBean中，再将这些javaBean在封装到List集合中</td>
</tr>
<tr>
<td>ColumnListHandler</td>
<td>将结果集中指定的列的字段值，封装到一个List集合中</td>
</tr>
<tr>
<td>KeyedHandler</td>
<td>将结果集中每一条记录封装到Map&lt;String,Object&gt;,在将这个map集合做为另一个Map的value,另一个Map集合的key是指定的字段的值。</td>
</tr>
<tr>
<td>MapHandler</td>
<td>将结果集中第一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值</td>
</tr>
<tr>
<td>MapListHandler</td>
<td>将结果集中每一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值，在将这些Map封装到List集合中。</td>
</tr>
<tr>
<td>ScalarHandler</td>
<td>它是用于封装单个数据。例如 select count(*) from 表操作</td>
</tr>
</tbody></table>
<p><strong>使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动模式,删除数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;delete from user where username=?&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = qr.update(sql, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;受影响行数:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 查询相关的操作,用javaBean封装数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;select * from user where id in (?,?)&quot;</span>;</span><br><span class="line">        List&lt;User&gt; query = qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(User.class), <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : query) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 查询相关的操作,获取用户个数，单个数据 scalar</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(DruidUtil.getDataSource());</span><br><span class="line">        String sql = <span class="string">&quot;select count(*) from user&quot;</span>;</span><br><span class="line">        Object query = qr.query(sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;());</span><br><span class="line">        System.out.println(<span class="string">&quot;用户个数为:&quot;</span> + query);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>JDBC</tag>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>javaWeb笔记</title>
    <url>/2021/06/18/javaWeb%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>JavaWeb</strong>主要指使用Java语言进行动态Web资源开发技术的统称，是解决相关Web互联网领域的技 术总和。JavaWeb有三大组件，分别为：<strong>Servlet</strong>、<strong>Filter</strong>、 <strong>Listener</strong>。<a id="more"></a></p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat 服务器是一个开源的轻量级Web应用服务器，在中小型系统和并发量小的场合下被普遍使 用，是开发和调试Servlet、JSP 程序的首选。</p>
<p><strong>目录结构说明</strong></p>
<ul>
<li>bin 主要存放二进制可执行文件和脚本。 </li>
<li>conf 主要存放各种配置文件。 </li>
<li>lib 主要用来存放Tomcat运行需要加载的jar包。 </li>
<li>logs 主要存放Tomcat在运行过程中产生的日志文件。 </li>
<li>temp 主要存放Tomcat在运行过程中产生的临时文件。 </li>
<li>webapps 主要存放应用程序，当Tomcat启动时会去加载该目录下的应用程序。 </li>
<li>work 主要存放tomcat在运行时的编译后文件，例如JSP编译后的文件。</li>
</ul>
<p><strong>启动和关闭</strong> </p>
<ul>
<li>启动方式 使用bin目录下的批处理文件startup.bat来启动Tomcat服务器，若出现一个毫秒数说明启动成 功。 </li>
<li>关闭方式 使用bin目录下的批处理文件shutdown.bat来关闭Tomcat服务器。 </li>
</ul>
<p><strong>注意事项</strong> 启动之前首先安装JDK并配置环境变量JAVA_HOME，若希望Tomcat服务器可以在任意路径启动， 则需要配置环境变量CATALINA_HOME。 </p>
<p><strong>启动信息乱码的处理方式</strong>    logging.properties文件修改编码java.util.logging.ConsoleHandler.encoding = GBK</p>
<p><strong>配置文件</strong></p>
<ul>
<li>server.xml文件是服务器的主配置文件，可以设置端口号、设置域名或IP、默认加载的项目、请求 编码等。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tomcat-users.xml文件用来配置管理Tomcat服务器的用户与权限 。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p><strong>基本概念</strong></p>
<ul>
<li>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，是Java语言编写 的服务器端程序，换句话说，Servlet就是运行在服务器上的Java类。 </li>
<li>Servlet用来完成B/S架构下客户端请求的响应处理，也就是交互式地浏览和生成数据，生成动态 Web内容。</li>
</ul>
<h2 id="Servlet的编程步骤"><a href="#Servlet的编程步骤" class="headerlink" title="Servlet的编程步骤"></a>Servlet的编程步骤</h2><ul>
<li><p>建立一个Java Web Application项目并配置Tomcat服务器。 </p>
</li>
<li><p>自定义类实现Servlet接口或继承其子类， 并重写service方法。 </p>
</li>
<li><p>将自定义类的信息配置到 web.xml文件并启动项目</p>
</li>
<li><p>在浏览器上访问的方式为：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/工程路径/servlet访问名</span><br></pre></td></tr></table></figure>
<h3 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h3><p><strong>xml方式配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> myServlet <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet类名的真实路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span> com.hui.MyServlet <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- myServlet是Servlet类的别名，与上述名称必须相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> myServlet <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /hello是供浏览器使用的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span> /hello <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注解方式配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  name是别名，urlPatterns是供浏览器使用的地址</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;myServlet4&quot;, urlPatterns = &quot;/my4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....................................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><p>javax.servlet.Servlet接口用于定义所有servlet必须实现的方法。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void init(ServletConfig config)</td>
<td>由servlet容器调用，以向servlet指示servlet正在被放入服务中</td>
</tr>
<tr>
<td>void service(ServletRequest req,ServletResponse res)</td>
<td>由servlet容器调用，以允许servlet响应请求</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>返回ServletConfig对象，该对象包含此servlet的初始化和启动参数</td>
</tr>
<tr>
<td>String getServletInfo()</td>
<td>返回有关servlet的信息，如作者、版本和版权</td>
</tr>
<tr>
<td>void destroy()</td>
<td>由servlet容器调用，以向servlet指示该servlet正在退出服务</td>
</tr>
</tbody></table>
<h3 id="GenericServlet类"><a href="#GenericServlet类" class="headerlink" title="GenericServlet类"></a>GenericServlet类</h3><p>javax.servlet.GenericServlet类主要用于定义一个通用的、与协议无关的servlet，该类实现了 Servlet接口。 若编写通用servlet，只需重写service抽象方法即可。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>abstract void service(ServletRequest req,ServletResponse res)</td>
<td>由servlet容器调用允许servlet响应请求</td>
</tr>
</tbody></table>
<h3 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类"></a>HttpServlet类</h3><p>javax.servlet.http.HttpServlet类是个抽象类并继承了GenericServlet类。 用于创建适用于网站的HTTP Servlet，该类的子类必须至少重写一个方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void doGet(HttpServletRequest req,HttpServletResponse resp)</td>
<td>处理客户端的GET请求</td>
</tr>
<tr>
<td>void doPost(HttpServletRequest req,HttpServletResponse resp)</td>
<td>处理客户端的POST请求</td>
</tr>
<tr>
<td>void init()</td>
<td>进行初始化操作</td>
</tr>
<tr>
<td>void service(HttpServletRequest req,HttpServletResponse resp)</td>
<td>根据请求决定调用doGet还是doPost方法</td>
</tr>
<tr>
<td>void destroy()</td>
<td>删除实例时释放资源</td>
</tr>
</tbody></table>
<ul>
<li><p>继承HttpServlet接口一般不实现service() 方法，而是实现 doGet()   和   doPost() 方法，因为service()方法里就是根据请求决定调用doGet还是doPost。</p>
</li>
<li><p>代码一般写在doPost() 方法里，而doGet() 方法中则直接调用doPost()方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br></pre></td></tr></table></figure>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3></li>
<li><p>构造方法只被调用一次，当第一次请求Servlet时调用构造方法来创建Servlet的实例。</p>
<ul>
<li>如果在配置文件中配置<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>标签 ，就会在程序启动时实例化该servlet</li>
</ul>
</li>
<li><p>init方法只被调用一次，当创建好Servlet实例后立即调用该方法实现Servlet的初始化。</p>
</li>
<li><p>service方法被多次调用，每当有请求时都会调用service方法来用于请求的响应。 </p>
</li>
<li><p>destroy方法只被调用一次，当该Servlet实例所在的Web应用被卸载前调用该方法来释放当前占用 的资源。</p>
</li>
</ul>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发出GET请求的主要方式：</span><br><span class="line">    （1）在浏览器输入URL按回车</span><br><span class="line">    （2）点击&lt;a&gt;超链接</span><br><span class="line">    （3）点击submit按钮，提交 &lt;form method&#x3D;“get”&gt;表单</span><br><span class="line">GET请求特点：</span><br><span class="line">	 会将请求数据添加到请求URL地址的后面，只能提交少量的数据、不安全</span><br></pre></td></tr></table></figure>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发出POST请求的方法如下：</span><br><span class="line">	点击submit按钮，提交 &lt;form method&#x3D;“post”&gt;表单</span><br><span class="line">POST请求的特点：</span><br><span class="line">	请求数据添加到HTTP协议体中，可提交大量数据、安全性好</span><br></pre></td></tr></table></figure>
<h3 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a>ServletRequest接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletRequest接口主要用于向servlet提供客户端请求信息，可以从中获取到任何 请求信息。 </li>
<li>Servlet容器创建一个ServletRequest对象，并将其作为参数传递给Servlet的service方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter(String name)</td>
<td>以字符串形式返回请求参数的值，如果该参数不存在，则返回空值</td>
</tr>
<tr>
<td>String[] getParameterValues(String name)</td>
<td>返回一个字符串对象数组，其中包含给定请求参数所具有的所有值，如果该参数不存在，则返回空值</td>
</tr>
<tr>
<td>Enumeration getParameterNames()</td>
<td>返回包含此请求中包含的参数名称的字符串对象的枚举。如果请求没有参数，则方法返回空枚举</td>
</tr>
<tr>
<td>Map&lt;String, String[]&gt; getParameterMap()</td>
<td>返回请求参数的键值对，一个键可以对应多个值</td>
</tr>
<tr>
<td>String getRemoteAddr()</td>
<td>返回发送请求的客户端或最后一个代理的IP地址</td>
</tr>
<tr>
<td>int  getRemotePort()</td>
<td>返回发送请求的客户端或最后一个代理的端口号</td>
</tr>
</tbody></table>
<h3 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.http.HttpServletRequest接口是ServletRequest接口的子接口，主要用于提供HTTP 请求信息的功能。 </li>
<li>不同于表单数据，在发送HTTP请求时，HTTP请求头直接由浏览器设置。 </li>
<li>可直接通过HttpServletRequest对象提供的一系列get方法获取请求头数据。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getRequestURI()</td>
<td>返回此请求的资源路径信息</td>
</tr>
<tr>
<td>StringBuffer getRequestURL()</td>
<td>返回此请求的完整路径信息</td>
</tr>
<tr>
<td>String getMethod()</td>
<td>返回发出此请求的HTTP方法的名称，例如GET、POST</td>
</tr>
<tr>
<td>String getQueryString()</td>
<td>返回路径后面请求中附带的参数</td>
</tr>
<tr>
<td>String getServletPath()</td>
<td>返回此请求中调用servlet的路径部分</td>
</tr>
</tbody></table>
<h3 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletResponse接口用于定义一个对象来帮助Servlet向客户端发送响应。 </li>
<li>Servlet容器创建ServletResponse对象，并将其作为参数传递给servlet的service方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter getWriter()</td>
<td>返回可向客户端发送字符文本的PrintWriter对象</td>
</tr>
<tr>
<td>String getCharacterEncoding()</td>
<td>获取响应内容的编码方式</td>
</tr>
<tr>
<td>void setContentType(String type)</td>
<td>如果尚未提交响应，则设置发送到客户端响应的内容类型。内容类型可以包括字符编码规范，例如text/html;charset=UTF-8</td>
</tr>
</tbody></table>
<h3 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h3><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.http.HttpServletResponse接口继承ServletResponse接口，以便在发送响应时提供 特定于HTTP的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sendRedirect(String location)</td>
<td>使用指定的重定向位置URL向客户端发送临时重定向响应</td>
</tr>
</tbody></table>
<h2 id="Servlet接收中文乱码"><a href="#Servlet接收中文乱码" class="headerlink" title="Servlet接收中文乱码"></a>Servlet接收中文乱码</h2><h3 id="接收乱码"><a href="#接收乱码" class="headerlink" title="接收乱码"></a>接收乱码</h3><p>浏览器在提交表单时，会对中文参数值进行自动编码。当Tomcat服务器接收到浏览器请求后自动 解码，当编码与解码方式不一致时,就会导致乱码。</p>
<p><strong>解决POST请求乱码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>解决GET请求乱码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将接收到的中文乱码重新编码  （万能方式）</span></span><br><span class="line">String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 将中文字符重新编码，默认编码为ISO-8859-1</span></span><br><span class="line">String userName = <span class="keyword">new</span> String(name.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="响应乱码"><a href="#响应乱码" class="headerlink" title="响应乱码"></a>响应乱码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h2><p><strong>基本概念</strong></p>
<p>javax.servlet.ServletConfig接口用于描述Servlet本身的相关配置信息，在初始化期间用于将信息 传递给Servlet配置对象。</p>
<p>Servlet接口中有 getServletConfig() 方法，子类中直接调用即可获取 ServletConfig对象。</p>
<p>init() 方法中，ServletConfig是init()的参数，可直接调用 ServletConfig对象。</p>
<p><strong>xml配置方法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中配置ServletConfig初始化参数,可配置多个init-param --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>actionservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lagou.demo01.ActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Serlvet 的初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 参数名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 参数值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>struts.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getServletName()</td>
<td>返回Servlet的别名</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>返回包含初始化参数值的字符串，如果该参数不存在，则返回null</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>返回对调用方正在其中执行的ServletContext的引用</td>
</tr>
</tbody></table>
<h2 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h2><p><strong>基本概念</strong></p>
<ul>
<li>javax.servlet.ServletContext接口主要用于定义一组方法，Servlet使用这些方法与其它的Servlet容 器通信。 </li>
<li>服务器容器在启动时会为每个项目创建唯一的一个ServletContext对象，用于实现多个Servlet之间 的信息共享和通信。 </li>
<li>在Servlet中通过this.getServletContext()方法可以获得ServletContext对象，也可以通过ServletConfig对象获取。</li>
</ul>
<p><strong>xml配置方法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中配置ServletContext初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hui<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123465<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getInitParameter(String name)</td>
<td>返回包含初始化参数值的字符串，如果该参数不存在，则返回null</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举</td>
</tr>
<tr>
<td>String getRealPath(String path)</td>
<td>返回包含给定虚拟路径的实际路径的字符串</td>
</tr>
<tr>
<td>String getContextPath()</td>
<td>返回与此上下文关联的主路径</td>
</tr>
<tr>
<td>InputStream getResourceAsStream(String path)</td>
<td>将位于指定路径的资源作为InputStream对象返回</td>
</tr>
<tr>
<td>void setAttribute(String name, Object object)</td>
<td>将指定的属性名和属性值绑定到当前对象</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>根据执行的属性名获取属性值</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>删除指定的属性名信息</td>
</tr>
</tbody></table>
<h2 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>首先客户浏览器发送http请求，当web服务器接受后发送302状态码响应及对应新的location给客 户浏览器，客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location 地址，服务器根据此请求寻找资源并发送给客户。</p>
<p><strong>实现</strong></p>
<p>实现重定向需要借助javax.servlet.http.HttpServletResponse接口中的以下方法：</p>
<table>
<thead>
<tr>
<th>response中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sendRedirect(String location)</td>
<td>使用指定的重定向位置URL向客户端发送临时重定向响应</td>
</tr>
</tbody></table>
<p><strong>特点</strong> </p>
<ul>
<li>重定向之后，浏览器地址栏的URL会发生改变。 </li>
<li>重定向过程中会将前面Request对象销毁，然后创建一个新的Request对象。 重定向的URL可以是其它项目工程。</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>一个Web组件（Servlet/JSP）将未完成的处理通过容器转交给另外一个Web组件继续处理，转发 的各个组件会共享Request和Response对象。</p>
<p><strong>实现</strong></p>
<ul>
<li>获取转发器对象</li>
</ul>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>RequestDispatcher getRequestDispatcher(String path)</td>
<td>返回一个RequestDispatcher对象，该对象充当位于给定路径上的资源的包装器，形参为要转发的地址</td>
</tr>
</tbody></table>
<ul>
<li>转发操作</li>
</ul>
<table>
<thead>
<tr>
<th>RequestDispatcher中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void forward(ServletRequest request, ServletResponse response)</td>
<td>将请求从一个servlet转发到服务器上的另一个资源（Servlet、JSP文件或HTML文件）</td>
</tr>
</tbody></table>
<p><strong>特点</strong> </p>
<ul>
<li>转发之后浏览器地址栏的URL不会发生改变。 </li>
<li>转发过程中共享Request对象，可以在request中使用setAttribute() 设置需要额外传递的数据。</li>
<li>转发的URL不可以是其它项目工程。</li>
</ul>
<h2 id="Servlet线程安全"><a href="#Servlet线程安全" class="headerlink" title="Servlet线程安全"></a>Servlet线程安全</h2><p>服务器在收到请求之后，会启动一个线程来进行相应的请求处理。 </p>
<p>默认情况下，服务器为每个Servlet只创建一个对象实例。当多个请求访问同一个Servlet时，会有 多个线程访问同一个Servlet对象，此时就可能发生线程安全问题。 </p>
<p>多线程并发逻辑，需要使用synchronized对代码加锁处理，但尽量避免使用。</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul>
<li>Web程序基于HTTP协议通信，而HTTP协议是”<strong>无状态</strong>”的协议，一旦服务器响应完客户的请求之 后，就断开连接，而同一个客户的下一次请求又会重新建立网络连接。 </li>
<li>服务器程有时是需要判断是否为同一个客户发出的请求，因此，有必 要跟踪同一个客户发出的一系列请求。 </li>
<li>把浏览器与服务器之间多次交互作为一个整体，将多次交互所涉及的数据保存下来，即状态管理。 多次交互的数据状态可以在客户端保存，也可以在服务器端保存。</li>
<li>状态管理主要分为以下两类： <ul>
<li>客户端管理：将状态保存在客户端。基于Cookie技术实现。 </li>
<li>服务器管理：将状态保存在服务器端。基于Session技术实现。</li>
</ul>
</li>
</ul>
<h3 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h3><p><strong>基本概念</strong></p>
<ul>
<li>Cookie本意为”饼干“的含义，在这里表示客户端以“键值对”形式进行保存的一种技术。 </li>
<li>浏览器向服务器发送请求时，服务器将数据以Set-Cookie消息头的方式响应给浏览器，然后浏览器 会将这些数据以文本文件的方式保存起来。 </li>
<li>当浏览器再次访问服务器时，会将这些数据以Cookie消息头的方式发送给服务器。</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><table>
<thead>
<tr>
<th>Cookie类中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie(String name, String value)</td>
<td>根据参数指定数值构造对象</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回此Cookie对象中的名字</td>
</tr>
<tr>
<td>String getValue()</td>
<td>返回此Cookie对象的数值</td>
</tr>
<tr>
<td>void setValue(String newValue)</td>
<td>设置Cookie的数值</td>
</tr>
</tbody></table>
<p><strong>request请求获取cookie对象</strong></p>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie[] getCookies()</td>
<td>返回此请求中包含的所有Cookie对象</td>
</tr>
</tbody></table>
<p><strong>response响应添加cookie对象</strong></p>
<table>
<thead>
<tr>
<th>respose中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void addCookie(Cookie cookie)</td>
<td>添加参数指定的对象到响应</td>
</tr>
</tbody></table>
<h4 id="Cookie的生命周期"><a href="#Cookie的生命周期" class="headerlink" title="Cookie的生命周期"></a>Cookie的生命周期</h4><p>默认情况下，浏览器会将Cookie信息保存在内存中，只要浏览器关闭，Cookie信息就会消失。 </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int getMaxAge()</td>
<td>返回cookie的最长使用期限（以秒为单位）</td>
</tr>
<tr>
<td>void setMaxAge(int expiry)</td>
<td>设置cookie的最长保留时间（秒）</td>
</tr>
</tbody></table>
<p><strong>setMaxAge中的形参设置</strong> : 0 表示立即删除  ，正数表示多少秒后删除，负数表示关闭浏览器就删除。</p>
<h4 id="Cookie的路径问题"><a href="#Cookie的路径问题" class="headerlink" title="Cookie的路径问题"></a>Cookie的路径问题</h4><ul>
<li>浏览器在访问服务器时，会比较Cookie的路径与请求路径是否匹配，只有匹配的Cookie才会发送 给服务器。 </li>
<li>Cookie的默认路径等于添加这个Cookie信息时的组件路径，例如：/项目名/目录/add 请求添加 了一个Cookie信息，则该Cookie的路径是 /项目名/目录。</li>
<li>访问的请求地址必须符合Cookie的路径或者其子路径时，浏览器才会发送Cookie信息。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void setPath(String uri)</td>
<td>设置cookie的路径信息</td>
</tr>
</tbody></table>
<h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><ul>
<li>将状态数据保存在浏览器端，不安全。 </li>
<li>保存数据量有限制，大约4KB左右。 </li>
<li>只能保存字符串信息。 </li>
<li>可以通过浏览器设置为禁止使用。</li>
</ul>
<h3 id="session技术"><a href="#session技术" class="headerlink" title="session技术"></a>session技术</h3><p><strong>基本概念</strong></p>
<ul>
<li>Session本意为”会话”的含义，是用来维护一个客户端和服务器关联的一种技术。 </li>
<li>浏览器访问服务器时，服务器会为每一个浏览器都在服务器端的内存中分配一个空间，用于创建一 个Session对象，该对象有一个id属性且该值唯一，我们称为SessionId，并且服务器会将这个 SessionId以Cookie方式发送给浏览器存储。 </li>
<li>浏览器再次访问服务器时会将SessionId发送给服务器，服务器可以依据SessionId查找相对应的 Session对象</li>
</ul>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p><strong>request请求中获取session</strong></p>
<table>
<thead>
<tr>
<th>request中的方法</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>HttpSession getSession()</td>
<td>返回此请求关联的当前Session，若此请求没有则创建一个</td>
</tr>
</tbody></table>
<p><strong>HttpSession接口中常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNew()</td>
<td>判断是否为新创建的Session</td>
</tr>
<tr>
<td>String getId()</td>
<td>获取Session的编号</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>返回在此会话中用指定名称绑定的对象，如果没有对象在该名称下绑定，则返回空值</td>
</tr>
<tr>
<td>void setAttribute(String name, Object value)</td>
<td>使用指定的名称将对象绑定到此会话</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>从此会话中删除与指定名称绑定的对象</td>
</tr>
</tbody></table>
<h4 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h4><p>为了节省服务器内存空间资源，服务器会将空闲时间过长的Session对象自动清除掉，服务器默认 的超时限制一般是30分钟。 </p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int getMaxInactiveInterval()</td>
<td>获取失效时间</td>
</tr>
<tr>
<td>void setMaxInactiveInterval(int interval)</td>
<td>设置失效时间</td>
</tr>
</tbody></table>
<p>也可以通过xml配置设置session过期时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="session的特点"><a href="#session的特点" class="headerlink" title="session的特点"></a>session的特点</h4><ul>
<li>数据比较安全。 </li>
<li>能够保存的数据类型丰富，而Cookie只能保存字符串。 </li>
<li>能够保存更多的数据，而Cookie大约保存4KB。</li>
<li>数据保存在服务器端会占用服务器的内存空间，如果存储信息过多、用户量过大，会严重影响服务器的性能。</li>
</ul>
<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><p><strong>基本概念</strong></p>
<ul>
<li>JSP是Java Server Pages的简称，跟Servlet一样可以动态生成HTML响应， JSP文件命名为 xxx.jsp。 </li>
<li>与Servlet不同，JSP文件以HTML标记为主，然后内嵌Java代码段，用于处理动态内容。</li>
</ul>
<p><strong>JSP与Servlet的关系</strong></p>
<p><a href="https://imgtu.com/i/RCBNLt"><img src="https://z3.ax1x.com/2021/06/19/RCBNLt.png" alt="RCBNLt.png" style="zoom:80%;" /></a></p>
<p><strong>JSP语法结构</strong> </p>
<ul>
<li><p>声明区 </p>
</li>
<li><p>程序代码区 </p>
</li>
<li><p>表达式 </p>
</li>
<li><p>注释 </p>
</li>
<li><p>指令和动作 </p>
</li>
<li><p>内置对象</p>
</li>
</ul>
<h2 id="声明区"><a href="#声明区" class="headerlink" title="声明区"></a>声明区</h2><p>可以定义全局变量、方法、类。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span></span>&#123;… …&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h2><p>可以定义局部变量以及放入任何的Java程序代码</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</span><br><span class="line">    	… …</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>可以输出一个变量或一个具体内容，但 = 后面必须是字符串变量或者可以被转换成字符串的 表达式。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=“hello world”%&gt;</span><br><span class="line">&lt;%=i+<span class="number">1</span>%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--… …--&gt; HTML文件的注释，浏览器可以查看到</span><br><span class="line">&lt;%--… …--%&gt; JSP文件的注释，浏览器看不到</span><br><span class="line">&lt;%<span class="comment">//… …%&gt; Java语言中的单行注释，浏览器看不到</span></span><br><span class="line">&lt;%<span class="comment">/*… …*/</span>%&gt; Java语言中的多行注释，浏览器看不到</span><br></pre></td></tr></table></figure>
<h2 id="指令和动作"><a href="#指令和动作" class="headerlink" title="指令和动作"></a>指令和动作</h2><p><strong>指令格式</strong>   &lt;%@指令 属性=“属性值”%&gt;  指令的属性可以设定多个。 </p>
<p><strong>常用指令</strong>   page、taglib、include</p>
<h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><p>page指令用于导包和设置一些页面属性，常用属性如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import 导入相应的包，惟一允许在同一文档中多次出现的属性</span><br><span class="line">contentType 设置Content-Type响应报头，标明即将发送到浏览器的文档类型</span><br><span class="line">pageEncoding 设置页面的编码</span><br><span class="line">language 指定页面使用的语言,默认java</span><br><span class="line">session 控制页面是否参与HTTP会话</span><br><span class="line">errorPage 处理当前页面中抛出但未被捕获的任何异常</span><br><span class="line">isErrorPage 当前页是否可以作为其他页面的错误处理页面</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tablib指令"><a href="#tablib指令" class="headerlink" title="tablib指令"></a>tablib指令</h3><p>taglib指令用来扩展JSP程序的标签元素，引入其他功能的标签库文件。<strong>详情下面会写道</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- prefix属性用于指定库前缀 --&gt;</span><br><span class="line">&lt;!-- uri属性用于指定库的标识 --&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;tagLibary&quot;</span> prefix=<span class="string">&quot;prefix&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3><p>include指令用于引入另一个JSP程序或HTML文件等，格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;被包含的文件地址&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
<p>JSP引擎会在JSP文件的转换时期先把file属性设定的文件包含进来，然后开始执行转换及编译的工 作。</p>
<h3 id="jsp-include动作"><a href="#jsp-include动作" class="headerlink" title="jsp:include动作"></a>jsp:include动作</h3><ul>
<li>jsp:include动作用于引入另一个JSP程序或HTML文件等。 </li>
<li>执行到include时，被include的文件才会被编译。 </li>
<li>如果include的是jsp文件，那它不会被转换成Servlet文件。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=“URLSpec” flush=“<span class="keyword">true</span>”/&gt;</span><br><span class="line">&lt;jsp:include page=“URLSpec” flush=“<span class="keyword">true</span>”&gt;</span><br><span class="line">&lt;jsp:param name=“key” value=“value”/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>
<p><strong>include指令和include动作的区别</strong> </p>
<ul>
<li>include指令是在JSP程序的转换时期就将file属性所指定的程序内容嵌入再编译执行（静态包 含）。 </li>
<li>include动作在转换时期是不会被编译的，只有在客户端请求时期被执行到才会被动态的编译载入 （动态包含，推荐）。</li>
</ul>
<h3 id="jsp-forward动作"><a href="#jsp-forward动作" class="headerlink" title="jsp:forward动作"></a>jsp:forward动作</h3><p>forward动作用于在JSP中实现转发，将请求转发到另一个指定的JSP程序或者Servlet中处理</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=“urlSpec” flush=“<span class="keyword">true</span>”/&gt;</span><br><span class="line">&lt;jsp:forward page=“urlSpec”&gt;</span><br><span class="line">    &lt;!-- 用于指定参数和其对应的值 --&gt;</span><br><span class="line">    &lt;jsp:param name=“key” value=“value”/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><p><strong>基本概念</strong> </p>
<ul>
<li>在JSP程序中有9个内置对象由容器为用户进行实例化，程序员可以不用定义就直接使用这些变量。 </li>
<li>在JSP转换成Servlet后，会自动追加这些变量的定义，使用内置对象可以简化JSP的开发。</li>
<li>内置对象的方法就是Servlet中对应类的使用</li>
</ul>
<table>
<thead>
<tr>
<th>对象变量</th>
<th>对象类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>out</td>
<td>JSPWriter</td>
<td>输出流</td>
</tr>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>请求信息</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
<td>响应信息</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>会话</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>全局的上下文对象</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
<td>JSP页面上下文</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>JSP页面本身</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>Servlet配置对象</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>捕获网页异常</td>
</tr>
</tbody></table>
<h3 id="out内置对象"><a href="#out内置对象" class="headerlink" title="out内置对象"></a>out内置对象</h3><p>out内置对象是一个缓冲的输出流，用来给客户端输出信息</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void println(String x)</td>
<td>向客户端输出各种类型数据</td>
</tr>
<tr>
<td>void newLine()</td>
<td>输出一个换行符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>int getBufferSize()</td>
<td>返回缓冲区的大小</td>
</tr>
<tr>
<td>int getRemaining()</td>
<td>返回缓冲区中未使用的字节数</td>
</tr>
<tr>
<td>void flush()</td>
<td>输出缓冲区里的数据</td>
</tr>
<tr>
<td>void clearBuffer()</td>
<td>清除缓冲区里的数据，同时把数据输出到客户端</td>
</tr>
<tr>
<td>void clear()</td>
<td>清除缓冲区里的数据，但不把数据输出到客户端</td>
</tr>
</tbody></table>
<h3 id="pageContext内置对象"><a href="#pageContext内置对象" class="headerlink" title="pageContext内置对象"></a>pageContext内置对象</h3><p>pageContext对象是PageContext类型的对象，可以使用这个对象来管理其他的隐含对象。 只在一个页面中保存数据。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String name, Object value,int scope)</td>
<td>使用适当的作用域设置指定的名称和值</td>
</tr>
<tr>
<td>Object getAttribute(String name, int scope)</td>
<td>返回指定作用域中名称关联的对象，若找不到则返回null</td>
</tr>
<tr>
<td>ServletRequest getRequest()</td>
<td>获取请求对象</td>
</tr>
<tr>
<td>ServletResponse getResponse()</td>
<td>获取响应对象</td>
</tr>
<tr>
<td>HttpSession getSession()</td>
<td>获取会话对象</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>获取配置对象</td>
</tr>
<tr>
<td>JspWriter getOut()</td>
<td>获取输出对象</td>
</tr>
<tr>
<td>Object getPage()</td>
<td>获取页面对象</td>
</tr>
<tr>
<td>Exception getException()</td>
<td>获取异常对象</td>
</tr>
</tbody></table>
<h3 id="exception内置对象"><a href="#exception内置对象" class="headerlink" title="exception内置对象"></a>exception内置对象</h3><p>exception 对象是Throwable的实例，表示的是JSP的异常信息。</p>
<p>如果要使用它，必须将对应异常页面page指令的isErrorPage属性设置成true。</p>
<ul>
<li>单页处理方法</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> errorPage=<span class="string">&quot;error.jsp&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以在web.xml中配置统一的异常处理页面</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Throwable<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="javaBean组件"><a href="#javaBean组件" class="headerlink" title="javaBean组件"></a>javaBean组件</h2><p>JavaBean 是使用 Java 语言开发的一个可重用的组件，在 JSP 开发中可以使用 JavaBean 减少重复 代码，使整个 JSP 代码的开发更加简洁。</p>
<p><strong>使用方式</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--创建一个JavaBean对象，scope表示范围--%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;user&quot; scope=&quot;session&quot; class=&quot;com.hui.User&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%--set，如果是从前端获取的数据则可以使用param属性而不是value属性 --%&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;user&quot; property=&quot;name&quot; value=&quot;怪狗狗&quot;&gt;&lt;/jsp:setProperty&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;user&quot; property=&quot;age&quot; value=&quot;13&quot;&gt;&lt;/jsp:setProperty&gt;</span><br><span class="line">&lt;%--get--%&gt;</span><br><span class="line">姓名 : &lt;jsp:getProperty name=<span class="string">&quot;user&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">年龄 : &lt;jsp:getProperty name=<span class="string">&quot;user&quot;</span> property=<span class="string">&quot;age&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>JavaBean的保存范围scope有page、request、session以及application，默认是page范围。</p>
<p><strong>删除方式</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	内置对象.removeAttribute(“JavaBean的名字”);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p><strong>基本概念</strong></p>
<ul>
<li>MVC是模型(Model)和视图(View)以及控制器(Controller)的简写，是一种将数据、界面显示和业务 逻辑进行分离的组织方式，这样在改进界面及用户交互时，不需要重新编写业务逻辑，从而提高了 代码的可维护性。 <ul>
<li>M：主要用于封装业务数据的JavaBean(Bean) 和 业务逻辑的JavaBean(Service)及访问数据库的 DAO对象。 </li>
<li>V：主要负责数据收集 和 数据展现，通常由JSP文件完成。 </li>
<li>C：主要负责流程控制 和 页面跳转，通常由Servlet完成。</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/RChX7Q"><img src="https://z3.ax1x.com/2021/06/19/RChX7Q.png" alt="RChX7Q.png"></a></p>
<h1 id="EL和JSTL核心技术"><a href="#EL和JSTL核心技术" class="headerlink" title="EL和JSTL核心技术"></a>EL和JSTL核心技术</h1><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language）表达式提供了在JSP中简化表达式的方法，可以方便地访问各种数据 并输出。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li>依次访问pageContext、request、session和application作用域对象存储的数据。如需获取指定作用域数据则使用  xxxScope.xxx </li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">原来的访问request中的属性:&lt;%=request.getAttribute(<span class="string">&quot;varName&quot;</span>)%&gt;</span><br><span class="line">用EL实现: $&#123; varName &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取请求参数值。</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">在EL之前使用下列方式访问请求参数的数据</span><br><span class="line">request.getParameter(name);</span><br><span class="line">request.getParameterValues(hobby);</span><br><span class="line">在EL中使用下列方式访问请求参数的数据</span><br><span class="line">&lt;!-- 获取指定参数的数值 --&gt;</span><br><span class="line">$&#123;param.name&#125;</span><br><span class="line">&lt;!-- 获取指定参数中指定下标的数值 --&gt;</span><br><span class="line">$&#123;paramValues.hobby[<span class="number">0</span>]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问Bean对象的属性。 </li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">方式一: $&#123;user.name&#125;  </span><br><span class="line">方式二: $&#123;user[<span class="string">&quot;name&quot;</span>]&#125;</span><br><span class="line">当要存取的属性名中包含一些特殊字符，如： . 或 ,等并非字母或数字的符号，就一定要使用第二种方式</span><br><span class="line">使用第二种的方式可以动态取值，如获取request等作用域对象存储的数据，不用加双引号</span><br></pre></td></tr></table></figure>
<ul>
<li>访问集合中的数据。</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- student为ArrayList类型的对象 --&gt;</span><br><span class="line">$&#123;student[<span class="number">0</span>].name&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出简单的运算结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;1+2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的内置对象"><a href="#常用的内置对象" class="headerlink" title="常用的内置对象"></a>常用的内置对象</h3><table>
<thead>
<tr>
<th>类别</th>
<th>标识符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JSP</td>
<td>pageContext</td>
<td>PageContext 处理当前页面</td>
</tr>
<tr>
<td>作用域</td>
<td>pageScope</td>
<td>同页面作用域属性名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>requestScope</td>
<td>同请求作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>sessionScope</td>
<td>同会话作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td></td>
<td>applicationScope</td>
<td>同应用程序作用域属性的名称和值有关的Map类</td>
</tr>
<tr>
<td>请求参数</td>
<td>param</td>
<td>根据名称存储请求参数的值的Map类</td>
</tr>
<tr>
<td></td>
<td>paramValues</td>
<td>把请求参数的所有值作为一个String数组来存储的Map类</td>
</tr>
<tr>
<td>请求头</td>
<td>header</td>
<td>根据名称存储请求头主要值的Map类</td>
</tr>
<tr>
<td></td>
<td>headerValues</td>
<td>把请求头的所有值作为一个String数组来存储的Map类</td>
</tr>
<tr>
<td></td>
<td>Cookie cookie</td>
<td>根据名称存储请求附带的cookie的Map类</td>
</tr>
<tr>
<td>初始化参数</td>
<td>initParam</td>
<td>根据名称存储Web应用程序上下文初始化参数的Map类</td>
</tr>
</tbody></table>
<h3 id="常用的运算符"><a href="#常用的运算符" class="headerlink" title="常用的运算符"></a>常用的运算符</h3><p><strong>算数运算符</strong></p>
<p>+    -       *      / (或div)      %(或mod)  。   这里的除会保留小数</p>
<p><strong>关系运算符</strong></p>
<p>==       &gt;     &gt;=        &lt;        &lt;=     !=</p>
<p><strong>逻辑运算符</strong></p>
<p>&amp;&amp; 或 and      || 或or       ! 或not </p>
<p><strong>条件运算符</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;条件表达式? 语句<span class="number">1</span> : 语句<span class="number">2</span>&#125;  就是三目运算符</span><br></pre></td></tr></table></figure>
<p><strong>验证运算符</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;empty 表达式&#125;</span><br><span class="line">返回布尔值,判断表达式是否为<span class="string">&quot;空&quot;</span>值，<span class="keyword">null</span>值、无元素的集合或数组、长度为零的String的值。</span><br></pre></td></tr></table></figure>
<h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><p><strong>基本概念</strong></p>
<ul>
<li>JSTL( JSP Standard Tag Library ) 被称为JSP标准标签库。 </li>
<li>开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护 难度。</li>
</ul>
<p>下载JSTL的jar包并添加到项目中，下载地址为：<a href="https://tomcat.apache.org/download-taglibs.cgi">https://tomcat.apache.org/download-taglibs.cgi</a></p>
<h3 id="核心标签"><a href="#核心标签" class="headerlink" title="核心标签"></a>核心标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%-- 使用taglib指令引入标签库 --%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出标签  out</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:out value=<span class="string">&quot;hello world&quot;</span>/&gt;  </span><br></pre></td></tr></table></figure>
<ul>
<li>设置标签 set</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- 相当于  &lt;% pageContext.setAttrivute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tom&quot;</span>); %&gt;--%&gt;</span><br><span class="line">&lt;c:set var=&quot;name&quot;  value=&quot;tom&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;name&#125;&quot;&gt;&lt;/c:out&gt; &lt;br&gt;</span><br><span class="line">&lt;%-- 创建一个实体类user，使用set对实体类进行赋值,在使用out输出user的属性 --%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;user&quot; class=&quot;com.hui.User&quot; scope=&quot;page&quot; &gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;c:set target=&quot;$&#123;user&#125;&quot; property=&quot;name&quot; value=&quot;jeerry&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:set target=&quot;$&#123;user&#125;&quot; property=&quot;age&quot; value=&quot;11&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;user[&#x27;name&#x27;]&#125;&quot;&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;user[&#x27;age&#x27;]&#125;&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除标签  remove</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:remove var=&quot;user&quot; scope=&quot;page&quot; &gt;&lt;/c:remove&gt;  删除pageContext作用域的user对象</span><br></pre></td></tr></table></figure>
<ul>
<li>单条件判断标签  if</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;age&quot; value=&quot;20&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;age&gt;18&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;已成年&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>多条件判断标签  chose &gt;  when —otherwise</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;age&quot; value=&quot;20&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;age&lt;18&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;未成年!&lt;/h1&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h1&gt;已成年&lt;/h1&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>循环标签</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	String[] arr = &#123;<span class="string">&quot;11&quot;</span>,<span class="string">&quot;22&quot;</span>,<span class="string">&quot;33&quot;</span>,<span class="string">&quot;44&quot;</span>,<span class="string">&quot;55&quot;</span>&#125;;</span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;arr&quot;</span>,arr);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;s&quot;</span> items=<span class="string">&quot;$&#123;arr&#125;&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;3&quot;</span> &gt;   &lt;%--包含下标<span class="number">1</span>到<span class="number">3</span> --%&gt;</span><br><span class="line">    &lt;span&gt;$&#123;s&#125;&lt;/span&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<h3 id="函数标签"><a href="#函数标签" class="headerlink" title="函数标签"></a>函数标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fn&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/functions&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>小案例</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;% pageContext.setAttribute(<span class="string">&quot;text&quot;</span>,<span class="string">&quot;Hello World&quot;</span>); %&gt;</span><br><span class="line">&lt;p&gt; $&#123;text&#125; &lt;/p&gt;</span><br><span class="line">&lt;p&gt;是否包含 world : $&#123;fn:contains(text,&quot;World&quot; )&#125;  &lt;/p&gt;</span><br><span class="line">&lt;p&gt;转大写 : $&#123;fn:toUpperCase(text)&#125; &lt;/p&gt;</span><br><span class="line">&lt;p&gt;转小写 : $&#123;fn:toLowerCase(text)&#125; &lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>小案例，格式化日期</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取系统时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;date&quot;</span>,date);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%--显示时间并格式化--%&gt;</span><br><span class="line">&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><ul>
<li>编写标签类继承SimpleTagSupport类重写doTag方法或继承TagSupport类并重写doStartTag方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义一个name属性，提供get set方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取输出流，向页面中输出数据</span></span><br><span class="line">        JspWriter out = <span class="keyword">this</span>.getJspContext().getOut();</span><br><span class="line">        out.println(<span class="string">&quot;自定义标签的参数为：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义标签库文件（tld标签库文件）并配置标签说明文件到到WEB-INF下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;taglib xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-jsptaglibrary_2_1.xsd&quot;</span><br><span class="line">        version&#x3D;&quot;2.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 这里定义版本，库前缀，库的标识 --&gt;</span><br><span class="line">    &lt;tlib-version&gt;1.0&lt;&#x2F;tlib-version&gt;</span><br><span class="line">    &lt;short-name&gt;me&lt;&#x2F;short-name&gt;</span><br><span class="line">    &lt;uri&gt;http:&#x2F;&#x2F;hui.com&lt;&#x2F;uri&gt;</span><br><span class="line">    </span><br><span class="line">	&lt;!-- 这里可以编写tag标签，每一个标签都要对应一个java类 --&gt;</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">    	&lt;name&gt;myTag&lt;&#x2F;name&gt;</span><br><span class="line">    	&lt;tag-class&gt;com.hui.MyTag&lt;&#x2F;tag-class&gt;</span><br><span class="line">    	&lt;body-content&gt;empty&lt;&#x2F;body-content&gt;</span><br><span class="line">    	&lt;attribute&gt;</span><br><span class="line">            &lt;name&gt;name&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;required&gt;true&lt;&#x2F;required&gt;</span><br><span class="line">    	&lt;&#x2F;attribute&gt;</span><br><span class="line">    &lt;&#x2F;tag&gt;</span><br><span class="line">&lt;&#x2F;taglib&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在JSP中添加taglib指令引入标签库就可以使用了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;me&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;hui.com&quot; %&gt;</span><br><span class="line">&lt;!-- 使用方式与其他标签一样 --&gt;</span><br><span class="line">&lt;me:myTag name&#x3D;&quot;怪狗狗&quot;&gt;&lt;&#x2F;me:myTag&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><p><strong>基本概念</strong></p>
<ul>
<li>Filter本意为”过滤“的含义，是JavaWeb的三大组件之一   </li>
<li>过滤器是向 Web 应用程序的请求和响应处理添加功能的 Web 服务组件。 </li>
<li>过滤器相当于浏览器与Web资源之间的一道过滤网，在访问资源之前通过一系列的过滤器对请求 进行修改、判断以及拦截等，也可以对响应进行修改、判断以及拦截等。</li>
</ul>
<p><strong>工作方式</strong></p>
<p><a href="https://imgtu.com/i/RVeA0J"><img src="https://z3.ax1x.com/2021/06/21/RVeA0J.png" alt="RVeA0J.png"></a></p>
<h2 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h2><ul>
<li>自定义类实现Filter接口并重写doFilter方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 放行，写在上面的代码是对响应前的操作</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 写在下面的代码是对响应后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml文件中配置过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hui.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    还能配置多个参数    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>k1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/main.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Filter接口"><a href="#Filter接口" class="headerlink" title="Filter接口"></a>Filter接口</h2><p>javax.servlet.Filter接口主要用于描述过滤器对象，可以对资源的请求和资源的响应操作进行筛选 操作。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void init(FilterConfig filterConfig)</td>
<td>实现过滤器的初始化操作</td>
</tr>
<tr>
<td>void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)</td>
<td>执行过滤操作的功能</td>
</tr>
<tr>
<td>void destroy()</td>
<td>实现过滤器的销毁操作</td>
</tr>
</tbody></table>
<p><strong>注</strong>   所有的过滤器都是在服务器启动时创建，所以init方法也是在服务器启动时调用，服务器关闭则会调用 destroy方法，每次访问过滤器都会调用doFilter方法进行过滤。</p>
<h2 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h2><p>javax.servlet.FilterConfig 接口主要用于描述过滤器的配置信息</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String getFilterName()</td>
<td>获取过滤器的名字</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>获取指定的初始化参数信息</td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td>获取所有的初始化操作名称</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>获取ServletContext对象</td>
</tr>
</tbody></table>
<p><strong>多个过滤器的使用</strong> </p>
<p>如果有多个过滤器都满足过滤的条件，则容器依据映射 (filter-mapping) 的先后顺序来调用各个过滤器。</p>
<p><a href="https://imgtu.com/i/RVeyAs"><img src="https://z3.ax1x.com/2021/06/21/RVeyAs.png" alt="RVeyAs.png"></a></p>
<p><strong>过滤器优点</strong></p>
<p>实现代码的“可插拔性”，即增加或减少某个功能模块，不会影响程序的正常执行。 可以将多个相同处理逻辑的模块集中写在过滤器里面，可实现重复利用、也方便代码的维护。</p>
<h1 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h1><p><strong>基本概念</strong></p>
<ul>
<li>Servlet规范中定义的一种特殊的组件，用来监听Servlet容器产生的事件并进行相应的处理。 </li>
<li>容器产生的事件分类如下： <ul>
<li>生命周期相关的事件。 </li>
<li>属性状态相关的事件。 </li>
<li>存值状态相关的事件。 </li>
</ul>
</li>
<li>底层原理是采用接口回调的方式实现。</li>
</ul>
<p><strong>基本分类</strong></p>
<table>
<thead>
<tr>
<th>监听器类型</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>javax.servlet.ServletRequestListener</td>
<td>监听request作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.ServletRequestAttributeListener</td>
<td>监听request作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionListener</td>
<td>监听session作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionAttributeListener</td>
<td>监听session作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.ServletContextListener</td>
<td>监听application作用域的创建和销毁</td>
</tr>
<tr>
<td>javax.servlet.ServletContextAttributeListener</td>
<td>监听application作用域的属性状态变化</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionBindingListener</td>
<td>监听对象与session的绑定和解除</td>
</tr>
<tr>
<td>javax.servlet.http.HttpSessionActivationListener</td>
<td>监听session数值的钝化和活化</td>
</tr>
</tbody></table>
<h2 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>实现监听器接口,并重写相关方法，这里以ServletRequestListener监听器为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求销毁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置web.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.hui.RequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注</strong>   HttpSessionBindingListener与HttpSessionActivationListener两个监听器是单独写在一个实体类上的，所以不需要配置</p>
<h2 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h2><p>在ServletRequest创建和关闭时都会通知ServletRequestListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void requestInitialized(ServletRequestEvent sre)</td>
<td>实现ServletRequest对象的初始化</td>
</tr>
<tr>
<td>void requestDestroyed(ServletRequestEvent sre)</td>
<td>实现ServletRequest对象的销毁</td>
</tr>
</tbody></table>
<h2 id="ServletRequestAttributeListener"><a href="#ServletRequestAttributeListener" class="headerlink" title="ServletRequestAttributeListener"></a>ServletRequestAttributeListener</h2><p>向ServletRequest添加、删除或者替换一个属性的时候，将会通知 ServletRequestAttributeListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>增加属性时触发</td>
</tr>
<tr>
<td>void attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>修改属性时触发</td>
</tr>
<tr>
<td>void attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>删除属性时触发</td>
</tr>
</tbody></table>
<h2 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h2><p>当一个HttpSession刚被创建或者失效（invalidate）的时候，将会通知HttpSessionListener监听 器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionCreated(HttpSessionEvent se)</td>
<td>当一个HttpSession对象被创建时会调用这个方法</td>
</tr>
<tr>
<td>void sessionDestroyed(HttpSessionEvent se)</td>
<td>当一个HttpSession超时或者调用HttpSession的invalidate()方法让它销毁时，将会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h2><p>HttpSession中添加、删除或者替换一个属性的时候，将会通知HttpSessionAttributeListener监 听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(HttpSessionBindingEvent se)</td>
<td>当往会话中加入一个属性的时候会调用这个方法</td>
</tr>
<tr>
<td>void attributeRemoved(HttpSessionBindingEvent se)</td>
<td>当从会话中删除一个属性的时候会调用这个方法</td>
</tr>
<tr>
<td>void attributeReplaced(HttpSessionBindingEvent se)</td>
<td>当改变会话中的属性的时候会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h2><p>在ServletContext创建和关闭时都会通知ServletContextListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void contextInitialized(ServletContextEvent sce)</td>
<td>当ServletContext创建的时候，将会调用这个方法</td>
</tr>
<tr>
<td>void contextDestroyed(ServletContextEvent sce)</td>
<td>当ServletContext销毁的时候（例如关闭应用服务器或者重新加载应用），将会调用这个方法</td>
</tr>
</tbody></table>
<h2 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h2><p>向ServletContext添加、删除或者替换一个属性的时候，将会通知 ServletContextAttributesListener监听器</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletContextAttributeEvent scae)</td>
<td>往ServletContext中加入一个属性的时候触发</td>
</tr>
<tr>
<td>void attributeRemoved(ServletContextAttributeEvent scae)</td>
<td>从ServletContext中删除一个属性的时候触发</td>
</tr>
<tr>
<td>void attributeReplaced(ServletContextAttributeEvent scae)</td>
<td>改变ServletContext中属性的时候触发</td>
</tr>
</tbody></table>
<h2 id="HttpSessionBindingListener"><a href="#HttpSessionBindingListener" class="headerlink" title="HttpSessionBindingListener"></a>HttpSessionBindingListener</h2><p>HttpSession中绑定和解除绑定时，将会通知HttpSessionListener监听器。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void valueBound(HttpSessionBindingEvent event)</td>
<td>有对象绑定时调用该方法</td>
</tr>
<tr>
<td>void valueUnbound(HttpSessionBindingEvent event)</td>
<td>有对象解除绑定时调用该方法</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="comment">// User类实现了HttpSessionBindingListener接口</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">// 解绑</span></span><br><span class="line">    session.removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h2><p>当有session数值的钝化和活化操作时，将会通知HttpSessionActivationListener监听器</p>
<p><strong>钝化</strong>   关闭服务器时，将session中的实现了序列化接口的实体类保存到磁盘</p>
<p><strong>活化</strong>   开启服务器后，访问磁盘中的session数据，反序列化</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionWillPassivate(HttpSessionEvent se)</td>
<td>有钝化操作时调用该方法</td>
</tr>
<tr>
<td>void sessionDidActivate(HttpSessionEvent se)</td>
<td>有活化操作时调用该方法</td>
</tr>
</tbody></table>
<ul>
<li>配置tomcat中的config文件夹下的context.xml文件，可以改变session保存本地磁盘的地址</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.PersistentManager&quot;</span> <span class="attr">saveOnRestart</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置文件存放的路径信息，可以自由指定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.FileStore&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;C:\session&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p><strong>统计在线人数</strong></p>
<p><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计人数  ,  session统计在线人数，servletContext作为全局变量保存总人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span>, <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    ServletContext servletContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 servletContext</span></span><br><span class="line">        servletContext = servletContextEvent.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        servletContext = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有一个用户上线了&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取总人数，+1</span></span><br><span class="line">        Integer count = (Integer) servletContext.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, ++count);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前在线人数:&quot;</span> + servletContext.getAttribute(<span class="string">&quot;count&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个用户下线&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取总人数，-1</span></span><br><span class="line">        Integer count = (Integer) servletContext.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;count&quot;</span>, --count);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前在线人数:&quot;</span> + servletContext.getAttribute(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>web.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.hui.CountListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>jsp页面</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;统计人数&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">            当前访问人数 $&#123;applicationScope.count&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="通用Servlet"><a href="#通用Servlet" class="headerlink" title="通用Servlet"></a>通用Servlet</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>之前一个Servlet只对应一个功能，这样编码太麻烦，没必要这样细分。我们可以让一个Servlet对应一个模块的功能。</p>
<p>让前端传递 一个参数  <strong>methodName = xxx</strong>  ，这样可以判断当前要调用哪个方法。再调用相应的方法时，将request与response传递过去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过前端传递的参数，调用相应的方法</span></span><br><span class="line">  		<span class="keyword">if</span> (<span class="string">&quot;delete&quot;</span>.equals(method)) &#123;</span><br><span class="line">            delete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;update&quot;</span>.equals(method)) &#123;</span><br><span class="line">            update(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(method)) &#123;</span><br><span class="line">            add(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有该方法!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// methodName 相对应的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;删除。。。&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;修改。。。&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123; System.out.println(<span class="string">&quot;添加。。。&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面的全是通过  if..else..  判断，比较的low。我们可以使用反射去对代码进行优化, 提升代码的可维护性/可扩展性.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;    </span><br><span class="line">    String methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过前端传递的参数，调用相应的方法    </span></span><br><span class="line">    <span class="keyword">if</span>(methodName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 通过反射优化代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过方法名与参数获取相关方法对象</span></span><br><span class="line">            Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BaseServlet类"><a href="#BaseServlet类" class="headerlink" title="BaseServlet类"></a>BaseServlet类</h2><p>当前代码依然存在问题，每个Servlet都需要写一份相同的反射代码</p>
<p><strong>解决方案</strong>: 将反射相关的代码抽取到一个 <strong>BaseServlet类</strong>  中, 让BaseServlet去继承HTTPServlet，其他的Servlet继承BaseServelt。</p>
<p>这样其他的Servlet可以不用重写 doPost() 与 doGet() 方法，直接写自己的功能即可。</p>
<p><strong>注意</strong>  其他Servelt中的方法要加形参  request 与 response</p>
<p><strong>BaseServlet类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(methodName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 通过反射优化代码</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过方法名与获取相关方法</span></span><br><span class="line">                Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">                <span class="comment">// 调用方法</span></span><br><span class="line">                method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理JSON请求数据"><a href="#处理JSON请求数据" class="headerlink" title="处理JSON请求数据"></a>处理JSON请求数据</h2><p>POST 请求方法常用的三种数据提交格式</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type : application/x-www-formurlencoded</td>
<td>请求体中的数据会以普通表单形式（键值对）发送到后端。</td>
</tr>
<tr>
<td>Content-Type : application/json ; charset=utf-8</td>
<td>请求体中的数据会以json字符串的形式发送到后端。</td>
</tr>
<tr>
<td>Content-Type : multipart/form-data</td>
<td>多部件上传既可以上传键值对 也可以上传文件。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>   第二种JSON格式与第三种多部件上传,使用 getParameter() 方法都无法获取数据</p>
<p>第三种多部件上传下面文件上传会介绍，这里解决第二种JSON格式, 我们需要修改  BaseServlet类</p>
<p><strong>在BaseServlet类 中创建一个方法,用来获取JSON格式的数据</strong></p>
<p>如果请求参数是JSON格式的数, 我们可以通过 request.getReader() 这个方法,获取一个流对象来进行 读取.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求格式为 application/json;charset=utf-8</span></span><br><span class="line"><span class="comment">     * 在这个方法中我们使用流的方式,获取到POST请求的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPostJSON</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 BufferedReader 流</span></span><br><span class="line">        reader = req.getReader();</span><br><span class="line">        <span class="comment">// 保存JSON数据</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 读取流中的数据，保存到 sb 中</span></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;<span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改BaseServlet中的doGet方法</strong></p>
<p>1.获取POST请求的 Content-Type类型 </p>
<p>2.判断传递的数据是不是JSON格式 </p>
<p>3.如果是 JSON格式</p>
<p>​    就调用上面编写的 getPostJSON方法,获取数据 ,将获取到的JSON格式的字符串转换为 Map </p>
<p>​    从Map中获取要调用的方法名 </p>
<p>​    将Map保存到request域对象中 (流只能使用一次)</p>
<p>4.如果不是JSON格式，就按照原来的方法     req.getParameter(“methodName”);</p>
<p>5.继续执行之前的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      String methodName = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 获取数据提交格式</span></span><br><span class="line">      String ContentType = req.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">      <span class="comment">// 如果数据是 JSON 的格式，需要解析</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;application/json;charset=utf-8&quot;</span>.equalsIgnoreCase(ContentType)) &#123; </span><br><span class="line">          String JsonDate = getPostJSON(req);</span><br><span class="line">          <span class="comment">// 将 JSON 字符串转换成 map 类型</span></span><br><span class="line">          Map&lt;String, Object&gt; map = JSON.parseObject(JsonDate, Map.class);</span><br><span class="line">          <span class="comment">// 获取请求的 功能</span></span><br><span class="line">          methodName = (String) map.get(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">          <span class="comment">// 将其他的数据保存到 request域 中</span></span><br><span class="line">          req.setAttribute(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通模式,可以直接获取</span></span><br><span class="line">          methodName = req.getParameter(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (methodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 通过反射优化代码</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 通过方法名与获取相关方法</span></span><br><span class="line">              Method method = <span class="keyword">this</span>.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">              <span class="comment">// 调用方法</span></span><br><span class="line">              method.invoke(<span class="keyword">this</span>, req, resp);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              System.out.println(<span class="string">&quot;没有该方法！！！&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><a href="https://imgtu.com/i/WZh2QI"><img src="https://z3.ax1x.com/2021/07/14/WZh2QI.jpg" alt="WZh2QI.jpg"></a></p>
<p><strong>JSON的特点</strong></p>
<ul>
<li>JSON 是一种轻量级的数据交换格式。</li>
<li>JSON采用完全独立于语言的文本格式，就是说不同的编程语言JSON数据是一致的。</li>
<li>JSON易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</li>
</ul>
<p>目前, 前后端的ajax通讯几乎用的都是json格式的了,所以在开发的过程中,我们经常会涉及到JSON数据的转换</p>
<p><a href="https://imgtu.com/i/W9QnaD"><img src="https://z3.ax1x.com/2021/07/11/W9QnaD.jpg" alt="W9QnaD.jpg"></a></p>
<h2 id="XML与JSON的区别"><a href="#XML与JSON的区别" class="headerlink" title="XML与JSON的区别"></a>XML与JSON的区别</h2><ul>
<li><p>XML : 可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言。 </p>
</li>
<li><p>JSON:  (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</p>
</li>
<li><p>相同点:  </p>
<ul>
<li>它们都可以作为一种数据交换格式。</li>
</ul>
</li>
<li><p>二者区别:</p>
<ul>
<li><p>XML是重量级的，JSON是轻量级的,XML在传输过程中比较占带宽，JSON占带宽少，易于压缩。</p>
</li>
<li><p>XML和json都用在项目交互下，XML多用于做配置文件，JSON用于数据交互</p>
</li>
<li><p>JSON独立于编程语言存在,任何编程语言都可以去解析json</p>
</li>
</ul>
</li>
</ul>
<h2 id="JSON语法格式"><a href="#JSON语法格式" class="headerlink" title="JSON语法格式"></a>JSON语法格式</h2><p>用{} 包裹，用 逗号分隔数据，每个数据采用键值对的方式，键一定要用双引号引起，值如果是数字，可以不用双引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象格式</span><br><span class="line">&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 集合格式</span><br><span class="line">&#123;&quot;person&quot;:[&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;jack&quot;,&quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:22&#125;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组格式</span><br><span class="line">[&#123;&quot;name&quot;:&quot;老五&quot;,&quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;会长&quot;,&quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:12&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><ul>
<li>Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</li>
<li>FastJson特点如下：<ul>
<li> 能够支持将java bean序列化成JSON字符串，也能够将JSON字符串反序列化成Java bean。</li>
<li> 顾名思义，FastJson操作JSON的速度是非常快的。</li>
<li> 无其他包的依赖, 使用比较方便。</li>
</ul>
</li>
</ul>
<p><strong>基本使用</strong></p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.colobu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson-jaxrs-json-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常用方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>JSON.toJSONString(Object obj)</td>
<td>将Java对象转换为JSON字符串格式</td>
</tr>
<tr>
<td>JSON.parseObject(String jsonString [, Class&lt;T&gt; class] )</td>
<td>将JSON字符串转换为Java对象，注意反序列化时为对象时，必须要有默认无参的构造函数，否则会报异常。 可在后面加class的泛型，指定要转换的类型。</td>
</tr>
<tr>
<td>JSON.parseArray(String jsonString)</td>
<td>将JSON字符串转换为集合对象</td>
</tr>
</tbody></table>
<p>使用 JSON.toJSONString(Object obj) ，可以传递一个SimplePropertyPreFilter对象，指定需要格式化的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将course对象JSON格式化,如果只要 id 与 name 字段</span></span><br><span class="line">SimplePropertyPreFilter filter = <span class="keyword">new</span> SimplePropertyPreFilter(Course.class, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">String res = JSON.toJSONString(course, filter);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Fastjson中的 <strong>@JSONField</strong> 注解</p>
<p>通过 <strong>@JSONField</strong> 我们可以自定义字段的名称进行输出，并控制字段的排序，还可以进行序列化标记。 </p>
<ul>
<li>name属性, 指定JSON格式化后的字段的名称 </li>
<li>ordinal属性, 指定字段的顺序</li>
<li>serialize属性, 指定字段不序列化</li>
</ul>
</li>
</ul>
<p>也可以通过  <strong>new JSONObject()</strong>  直接创建 JSON 对象，使用 <strong>jsonObject.put()</strong> 经行赋值</p>
<h1 id="BeanUtil工具类"><a href="#BeanUtil工具类" class="headerlink" title="BeanUtil工具类"></a>BeanUtil工具类</h1><p>BeanUtils 是 Apache commons组件的成员之一，主要用于简化JavaBean封装数据的操作。<strong>可以将一个表单提交的所有数据封装到JavaBean中</strong>。</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>BeanUtils 对象常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanUtils.populate(Object bean, Map properties)</td>
<td>将Map数据封装到指定Javabean中，<br />一般用于将表单的所有数据封装到javabean</td>
</tr>
<tr>
<td>BeanUtils.copyProperties(Object obj1, Object obj2);</td>
<td>将参数一中的数据拷贝到参数二中</td>
</tr>
<tr>
<td>setProperty(Object obj,String name,Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td>getProperty(Object obj,String name)</td>
<td>获得属性值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建course对象</span></span><br><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line"><span class="comment">//2.创建Map</span></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//3.向map集合中添加数据, key要与course的属性名保持一致,value的数据类型与course的属性的类型保持一致</span></span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;course_name&quot;</span>,<span class="string">&quot;大数据&quot;</span>);</span><br><span class="line"><span class="comment">//将map中的数据封装到 course中</span></span><br><span class="line">BeanUtils.populate(course,map);</span><br></pre></td></tr></table></figure>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传的实质：文件的拷贝</p>
<ul>
<li>文件上传：从本地将文件拷贝到服务器磁盘上 <ul>
<li>客户端:  需要编写文件上传表单</li>
<li>服务端:  需要编写代码接受上传的 文件</li>
</ul>
</li>
</ul>
<h2 id="客户端编码"><a href="#客户端编码" class="headerlink" title="客户端编码"></a>客户端编码</h2><p><strong>三要素</strong> </p>
<ul>
<li>使用表单的POST提交 (get方式提交有大小限制,post没有) </li>
<li>表单的enctype属性必须设置为   <strong>multipart/form-data.</strong>  <ul>
<li>encodetype就是编码类型的意思.</li>
<li>multipart/form-data是多部件文件上传 , 指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思。</li>
</ul>
</li>
<li>表单必须有文件上传项: <strong>file</strong>,必须要有name属性和值 </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;文件上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 默认情况下，表单的enctype的值是application/x-www-form-urlencoded，不能用于文件上传，只有使用了multipart/form-data，才能完整的传递文件数据</p>
<h2 id="服务端编码"><a href="#服务端编码" class="headerlink" title="服务端编码"></a>服务端编码</h2><p>服务端要接收文件上传的表单数据</p>
<h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><h4 id="上传文件-抓包分析"><a href="#上传文件-抓包分析" class="headerlink" title="上传文件, 抓包分析"></a>上传文件, 抓包分析</h4><p>使用360浏览器进行抓包,谷歌浏览器不方便查看</p>
<p><a href="https://imgtu.com/i/WVD0v4"><img src="https://z3.ax1x.com/2021/07/14/WVD0v4.jpg" alt="WVD0v4.jpg"></a></p>
<p>每个input都是一个表单项，被分隔符分开,如果是文件上传项，会有filenamme属性</p>
<h4 id="服务端获上传的文件"><a href="#服务端获上传的文件" class="headerlink" title="服务端获上传的文件"></a>服务端获上传的文件</h4><ol>
<li><p>通过request获取请求体的内容</p>
</li>
<li><p>解析请求体 </p>
<p>根据分隔符将请求中所有的内容,切割成数组,数组中的每一个元素 都是一个表单项</p>
</li>
<li><p>遍历数组,分清楚那个是普通的表单项, 哪个是 文件上传项</p>
<p>如何区分? 判断是否有 filename</p>
</li>
<li><p>获取到普通表单项中的内容,通过属性name获取</p>
</li>
<li><p>获取文件上传项内容</p>
<p>文件名: filname = aaa.txt</p>
<p>文件内容: </p>
</li>
<li><p>使用IO将文件内容,保存到服务器中</p>
</li>
</ol>
<h3 id="FileUpload工具类"><a href="#FileUpload工具类" class="headerlink" title="FileUpload工具类"></a>FileUpload工具类</h3><p>FileUpload包可以很容易地将文件上传到你的Web应用程序.</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>FileUpload 核心类介绍</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DiskFileItemFactory</td>
<td>磁盘文件项工厂, 读取文件时相关的配置,比如:  缓存的大小 , 临时目录的位置</td>
</tr>
<tr>
<td>ServletFileUplaod</td>
<td>文件上传的一个核心类</td>
</tr>
<tr>
<td>FileItem</td>
<td>代表每一个表单项</td>
</tr>
</tbody></table>
<p><strong>ServletFileUpload类 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean  isMultipartContent(request);</td>
<td>判断是否是一个文件上传的表单</td>
</tr>
<tr>
<td>List  parseRequest(request);</td>
<td>解析request获得表单项的集合</td>
</tr>
<tr>
<td>void  setHeaderEncoding(“UTF-8”);</td>
<td>设置上传的文件名的编码方式</td>
</tr>
</tbody></table>
<p><strong>FIleItem类 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean  isFormField()</td>
<td>判断是否是普通表单项</td>
</tr>
<tr>
<td>String  getFieldName()</td>
<td>获得表单的name属性值</td>
</tr>
<tr>
<td>String  getString()</td>
<td>获得表单的value值</td>
</tr>
<tr>
<td>String  getName()</td>
<td>获得上传文件的名称</td>
</tr>
<tr>
<td>InputStream  getInputStream()</td>
<td>获得上传文件的输入流</td>
</tr>
</tbody></table>
<p><strong>文件上传后台代码编写</strong></p>
<p>​    1、创建磁盘文件项工厂</p>
<p>​    2、创建文件上传的核心类</p>
<p>​    3、解析request—获得文件项集合</p>
<p>​    4、遍历文件项集合</p>
<p>​    5、判断普通表单项/文件上传项</p>
<p>​            普通表单项: 使用 getFieldName() 与  getString()  方法获取 普通表单的name属性值与value值</p>
<p>​            文件上传项: 使用getName()获取文件名称， getInputStream()获取输入流，通过IO流将文件保存到服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建磁盘文件项工厂</span></span><br><span class="line">            DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">            <span class="comment">// 创建文件上传的核心类</span></span><br><span class="line">            ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">            upload.setHeaderEncoding(<span class="string">&quot;UTF-8&quot;</span>);  <span class="comment">// 设置编码</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = upload.isMultipartContent(req);  <span class="comment">// 是否是一个文件上传的表单</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//解析request-- - 获得文件项集合</span></span><br><span class="line">                List&lt;FileItem&gt; itemList = upload.parseRequest(req);</span><br><span class="line">                <span class="comment">// 不为空，则遍历文件项集合</span></span><br><span class="line">                <span class="keyword">if</span> (itemList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (FileItem item : itemList) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> b = item.isFormField();</span><br><span class="line">                        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                            <span class="comment">//  普通表单项</span></span><br><span class="line">                            String fieldName = item.getFieldName();   <span class="comment">// 获取表单的键</span></span><br><span class="line">                            String value = item.getString(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">// 换取表单的值</span></span><br><span class="line">                            System.out.println(fieldName + <span class="string">&quot;=&quot;</span> + value); <span class="comment">// 输出打印</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 文件上传项</span></span><br><span class="line">                            String fileName = item.getName(); <span class="comment">// 换取文件的名</span></span><br><span class="line">                            <span class="comment">// 通过UUID 换取一个新的文件名</span></span><br><span class="line">                            String newFileName = UUIDUtils.getUUID() + fileName;</span><br><span class="line">                            <span class="comment">// 获取文件的输入流</span></span><br><span class="line">                            InputStream in = item.getInputStream();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将文件保存到tomcat中webapp下的upload文件夹中</span></span><br><span class="line">                            <span class="comment">// 获取项目的实际路径  C:\apache-tomcat-8.5.55\webapps\lagou_edu_home</span></span><br><span class="line">                            String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                            <span class="comment">// 将 lagou_edu_home截取掉，获取 C:\apache-tomcat-8.5.55\webapps\</span></span><br><span class="line">                            String path = realPath.substring(<span class="number">0</span>, realPath.indexOf(<span class="string">&quot;lagou_edu_home&quot;</span>));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 创建一个输出流，文件保存在tomcat中webapps下的upload文件中</span></span><br><span class="line">                            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(path + <span class="string">&quot;/upload/&quot;</span> + newFileName);</span><br><span class="line">                            <span class="comment">// 文件传输</span></span><br><span class="line">                            in.transferTo(out);</span><br><span class="line">                            <span class="comment">// 关闭流</span></span><br><span class="line">                            out.close();</span><br><span class="line">                            in.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将图片上传到tomcat服务器"><a href="#将图片上传到tomcat服务器" class="headerlink" title="将图片上传到tomcat服务器"></a>将图片上传到tomcat服务器</h2><p><strong>idea中部署项目两种方式</strong></p>
<ul>
<li>war模式：将项目以war包的形式上传真实到服务器的webapps目录中；</li>
<li>war exploded模式：仅仅是目录的映射，就相当于tomcat在项目源文件夹中启动一样；</li>
</ul>
<p><a href="https://imgtu.com/i/WVcn1K"><img src="https://z3.ax1x.com/2021/07/14/WVcn1K.jpg" alt="WVcn1K.jpg"></a></p>
<p>这里使用war模式，这样才能通过获取项目的路径，进入获取tomcat的路径，将文件保存到里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将文件保存到tomcat中webapp下的upload文件夹中</span></span><br><span class="line"><span class="comment">// 获取项目的实际路径  C:\apache-tomcat-8.5.55\webapps\lagou_edu_home</span></span><br><span class="line">String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">// 将 lagou_edu_home截取掉，获取 C:\apache-tomcat-8.5.55\webapps\</span></span><br><span class="line">String path = realPath.substring(<span class="number">0</span>, realPath.indexOf(<span class="string">&quot;lagou_edu_home&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>页面加载图片</strong></p>
<p>将tomcat作为图片服务器使用时，存储上传的图片后,如果想要图片可以访问,需要在idea中进行配置:</p>
<p>1）打开tomcat配置 —&gt;  在Deployment中添加 —&gt; 选择external source —&gt; 找到webapps目录下的的upload文件夹</p>
<p><a href="https://imgtu.com/i/WVg3KU"><img src="https://z3.ax1x.com/2021/07/14/WVg3KU.jpg" alt="WVg3KU.jpg"></a></p>
<p><a href="https://imgtu.com/i/WVgaP1"><img src="https://z3.ax1x.com/2021/07/14/WVgaP1.jpg" alt="WVgaP1.jpg"></a></p>
<p>2）在项目内部页面加载图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/upload/xxxxxx.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li> 也可以通过HTTP方式访问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;upload&#x2F;xxxxxx.jpg</span><br></pre></td></tr></table></figure>
<h1 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h1><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协 议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。</p>
<p>前后端分离项目，前端向后端发送请求，会出现跨域问题</p>
<ul>
<li>已被CORS策略阻止：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</li>
</ul>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置 Access-Control-AllowOrigin 及相关一系列参数，提供跨域访问的允许策略。</p>
<ol>
<li>在POM文件中引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决跨域问题所需依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thetransactioncompany<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cors-filter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在web.xml中 配置跨域 filter</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置跨域过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.thetransactioncompany.cors.CORSFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>自定义创建Filter，设置响应头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">    <span class="comment">//配置来源 &#x27;*&#x27;</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, request.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">    <span class="comment">//允许获取证书</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="comment">//配置请求方法</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">    <span class="comment">//配置请求头，如果有自定义的请求头，必须配置</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;Content-type, X-Requested-With, Authorization, myKey, my-Date, Content-xxx, Accept&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本用法</title>
    <url>/2021/06/26/Linux%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>目录结构</p>
<p><a href="https://imgtu.com/i/R8yC0e"><img src="https://z3.ax1x.com/2021/06/26/R8yC0e.png" alt="R8yC0e.png"></a></p>
<a id="more"></a>

<p><strong>目录详情</strong></p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>binarie:存放二进制可执行文件 (例如tomcat的bin目录)</td>
</tr>
<tr>
<td>/sbin</td>
<td>super binaries:存放二进制文件,只有root用户才能访问</td>
</tr>
<tr>
<td>/boot</td>
<td>系统启动核心目录,存放系统启动程序文件，例:查看启动文件的大小</td>
</tr>
<tr>
<td>/dev</td>
<td>devices:用于存放硬件设备文件</td>
</tr>
<tr>
<td>/etc</td>
<td>etcetera:存放系统配置文件(字体文件等)</td>
</tr>
<tr>
<td>/home</td>
<td>家目录,每一个用户都有一个”家”，用户的起始目录,创建用户跟随创建相应的家目录</td>
</tr>
<tr>
<td>/lib</td>
<td>library:系统资源文件类库</td>
</tr>
<tr>
<td>/proc</td>
<td>内存映射目录,可以查看系统相关硬件的信息</td>
</tr>
<tr>
<td>/var</td>
<td>variable:可变的,变量. 部署项目用的</td>
</tr>
<tr>
<td>/tmp</td>
<td>temporary:用来存放临时文件</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户root的家目录</td>
</tr>
<tr>
<td>/usr</td>
<td>unix shared resouce: 存放unix共享系统资源，类似于” C:/ Program Files”,用于安装各种软件</td>
</tr>
</tbody></table>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><strong>命令的格式</strong> </p>
<p>命令 [-选项] [参数] </p>
<p>命令区分大小写，其中选项和参数是可选的，中间采用空格隔开。</p>
<p><strong>查看当前目录下的信息</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>pwd</td>
<td>插卡当前位置</td>
</tr>
<tr>
<td>ls</td>
<td>list显示文件</td>
</tr>
<tr>
<td>ls -l</td>
<td>或 ll list -list  显示详细信息</td>
</tr>
<tr>
<td>ls -a</td>
<td>list -all  显示全部(包含隐藏文件)文件</td>
</tr>
<tr>
<td>ls -al</td>
<td>list -all list  上两个合体，看直接使用 ll 代替</td>
</tr>
<tr>
<td>ls 目录名</td>
<td>查看目录下有什么东西</td>
</tr>
</tbody></table>
<p><strong>用户相关操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>whoami</td>
<td>查看当前用户的名称</td>
</tr>
<tr>
<td>su</td>
<td>普通用户切换到root用户</td>
</tr>
<tr>
<td>su 用户名</td>
<td>切换到普通用户</td>
</tr>
<tr>
<td>exit</td>
<td>退回到原来用户,最好使用su和exit搭配使用，否则多次使用su指令会导致用户的”叠加”</td>
</tr>
<tr>
<td>useradd xxx</td>
<td>创建用户</td>
</tr>
<tr>
<td>passwd xxx</td>
<td>为创建的用户设置密码</td>
</tr>
<tr>
<td>userdel xxx</td>
<td>删除用户</td>
</tr>
</tbody></table>
<p><strong>文件操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>touch fileName</td>
<td>创建名字为fileName的文件</td>
</tr>
<tr>
<td>touch dir/fileName</td>
<td>在dir目录下创建名字为fileName的文件</td>
</tr>
<tr>
<td>echo 内容 &gt; fileName</td>
<td>把内容覆盖写到文件中，若文件不存在则创建</td>
</tr>
<tr>
<td>echo 内容 &gt;&gt; fileName</td>
<td>把内容追加到文件中</td>
</tr>
<tr>
<td>cat fileName</td>
<td>打印文件内容到终端</td>
</tr>
<tr>
<td>more fileName</td>
<td>分屏查看文件各行内容，不支持回看</td>
</tr>
<tr>
<td>less fileName</td>
<td>查看文件各部分内容，支持回看</td>
</tr>
<tr>
<td>head -n fileName</td>
<td>查看文件的前n行内容</td>
</tr>
<tr>
<td>tail -n fileName</td>
<td>查看文件末尾n行内容</td>
</tr>
<tr>
<td>wc fileName</td>
<td>查看文件的行数</td>
</tr>
</tbody></table>
<p><strong>目录操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir 目录名</td>
<td>创建普通文件夹</td>
</tr>
<tr>
<td>mkdir -p 目录/目录/目录</td>
<td>递归方式创建多级父子文件夹</td>
</tr>
<tr>
<td>mv dir1 dir2</td>
<td>将dir1移动到dir2中</td>
</tr>
<tr>
<td>mv dir1 name</td>
<td>将dir1改名为name</td>
</tr>
<tr>
<td>cp dir1 name</td>
<td>将dir1拷贝为name</td>
</tr>
<tr>
<td>cp -r dir1 dir2</td>
<td>需要设置参数 -r (recursive递归) 无视目录层次</td>
</tr>
<tr>
<td>rm 文件</td>
<td>删除文件</td>
</tr>
<tr>
<td>rm -r 目录</td>
<td>递归删除目录(无视目录层次)</td>
</tr>
<tr>
<td>rm -rf 文件/目录</td>
<td>force(强制) 删除文件/目录</td>
</tr>
</tbody></table>
<p><strong>查找操作</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>find / -name passwd[完整名称]</td>
<td>查找passwd文件</td>
</tr>
<tr>
<td>find ./ -name “p*”</td>
<td>查找带”p”的文件</td>
</tr>
<tr>
<td>find ./ -type f</td>
<td>查找所有文件</td>
</tr>
<tr>
<td>find ./ -type d</td>
<td>查找所有目录</td>
</tr>
<tr>
<td>grep 内容 fileName</td>
<td>从指定文件中查找指定的内容</td>
</tr>
</tbody></table>
<hr>
<p><strong>权限管理</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>chmod 权限 文件/目录名</td>
<td>管理指定文件的权限信息，r读:4 w写:2 x执行:1</td>
</tr>
</tbody></table>
<p>权限分3类，分别是   <strong>u自己、g同组、o其他组</strong>    的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> a.txt添加所有权限</span></span><br><span class="line">chmod 777 a.txt  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 给自己添加对a.txt文件可执行权限</span></span><br><span class="line">chmod u+x a.txt</span><br></pre></td></tr></table></figure>
<p><strong>进程管理</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>查看当前终端窗口里的进程</td>
</tr>
<tr>
<td>ps -aux</td>
<td>查看系统中的所有进程</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看进程列表</td>
</tr>
<tr>
<td>kill 进程号</td>
<td>杀死指定的进程</td>
</tr>
<tr>
<td>kill -9 进程号</td>
<td>强制杀死指定的进程</td>
</tr>
</tbody></table>
<p><strong>防火墙</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对外开放3306端口，供外部的计算机访问</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent</span><br><span class="line"># 重启防火墙才生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 或</span><br><span class="line">service firewalld restart</span><br></pre></td></tr></table></figure>
<ul>
<li>firewall-cmd：Linux中提供的操作firewall的工具。</li>
<li>–zone：指定作用域。</li>
<li>–add-port=3306/tcp：添加的端口，格式为：端口/通讯协议。</li>
<li>–permanent：表示永久生效，没有此参数重启后会失效。</li>
</ul>
<p>也可直接修改 <strong>/etc/firewalld/zones/public.xml</strong>  文件内容来配置防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 zone 标签下添加</span><br><span class="line">&lt;port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;3306&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>firewall其他一些操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line">service firewalld status</span><br><span class="line">或</span><br><span class="line">systemctl status firewalld</span><br><span class="line">或</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">service firewalld start</span><br><span class="line">或</span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line">service firewalld stop</span><br><span class="line">或</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p><strong>其他命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>tar -zcvf 文件名.tar.gz 路径1 路径2 …</td>
<td>压缩，实现一组文件或文件夹的打包</td>
</tr>
<tr>
<td>tar -zxvf 文件名.tar.gz</td>
<td>解压， 实现解压缩解包</td>
</tr>
<tr>
<td>unzip  xxx.zip</td>
<td>解压zip压缩文件</td>
</tr>
<tr>
<td>ifconfig</td>
<td>查看当前系统的IP地址等信息</td>
</tr>
<tr>
<td>man [章节号] 命令/函数名</td>
<td>查询指定的命令或函数</td>
</tr>
</tbody></table>
<h1 id="vi工具的使用"><a href="#vi工具的使用" class="headerlink" title="vi工具的使用"></a>vi工具的使用</h1><p>vi和vim是Linux系统命令行下的文本编辑器，通常格式为：vi 文件名 或 vim 文件名。</p>
<p><strong>三种模式之间的切换</strong></p>
<p><a href="https://imgtu.com/i/R84MHP"><img src="https://z3.ax1x.com/2021/06/26/R84MHP.png" alt="R84MHP.png" style="zoom:67%;" /></a></p>
<p><strong>命令模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切换编辑模式</span><br><span class="line">i   在当前位置之前插入</span><br><span class="line">a   在当前位置之后插入</span><br><span class="line">o   在当前行下插入</span><br><span class="line">其他操作</span><br><span class="line">dd 剪切行</span><br><span class="line">p 当前行下粘贴</span><br><span class="line">u 撤销</span><br><span class="line">ctrl+r 取消撤销</span><br></pre></td></tr></table></figure>
<p><strong>底行模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w  			存盘</span><br><span class="line">:w newfile 		存成新文件</span><br><span class="line">:wq 			存盘退出Vi(或ZZ，或:x)</span><br><span class="line">:q! 			强行退出不存盘</span><br><span class="line">:set nu			显示行号</span><br><span class="line">:set nonu   	不显示行号</span><br><span class="line">:&#x2F;xx			搜索 xx</span><br><span class="line">:set hlsearch  	高亮显示搜索内容</span><br><span class="line">:set nohlsearch 取消高亮显示</span><br><span class="line">:1,2co3 		拷贝行1，行2在行3之后</span><br><span class="line">:4,5mo6 		移动行4，行5在行6之后</span><br><span class="line">:%s &#x2F;源字符串&#x2F;目标字符串   替换改行第一个</span><br><span class="line">:%s &#x2F;源字符串&#x2F;目标字符串&#x2F;g 替换每一行中的所有</span><br></pre></td></tr></table></figure>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="jdk下载与安装"><a href="#jdk下载与安装" class="headerlink" title="jdk下载与安装"></a>jdk下载与安装</h2><p><strong>下载和安装</strong></p>
<p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a> </p>
<p>安装方式：将下载好的jdk安装包通过Xftp工具传输到CentOS7系统中，使用tar命令解压即可。</p>
<p><strong>配置环境变量</strong></p>
<ul>
<li>使用root用户打开配置文件/etc/profile，向文件末尾追加内容如下：(这里将jdk改名了，并且放在了 /usr目录下)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;jkd11</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<ul>
<li>保存退出后让文件生效并验证是否配置成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="Tomcat的下载与安装"><a href="#Tomcat的下载与安装" class="headerlink" title="Tomcat的下载与安装"></a>Tomcat的下载与安装</h2><p><strong>下载和安装</strong></p>
<p>下载地址：<a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a> </p>
<p>安装方式：将下载好的Tomcat安装包通过Xftp工具传输到CentOS系统中，使用tar命令解压即 可</p>
<p><strong>启动和关闭</strong></p>
<p>进入 Tomcat 的bin目录 使用 startup.sh 命令 与  shutdown.sh命令</p>
<p><strong>开启8080端口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 8080 -j ACCEPT 开启8080端口（暂时开通）</span><br></pre></td></tr></table></figure>
<p>如果是购买的阿里云上的服务器，需要手动配置安全组</p>
<p><strong>配置环境变量</strong></p>
<p>使用root用户打开配置文件/etc/profile，向文件末尾追加内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;tomcat</span><br><span class="line">export PATH&#x3D;$CATALINA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>保存退出后让文件生效并验证是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">.&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>   一般Tomcat服务器不配置环境变量</p>
<p><strong>发布Web项目</strong></p>
<p>将Web项目打成war包，通过Xftp工具将war包放在tomcat/webapp目录并启动</p>
<h2 id="Mysql的下载与安装"><a href="#Mysql的下载与安装" class="headerlink" title="Mysql的下载与安装"></a>Mysql的下载与安装</h2><p><strong>下载Mysql的repo源</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">#如果没安装wget需要先安装</span><br><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
<p><strong>安装rpm包</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>安装Mysql</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p><strong>启动服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p><strong>查看服务状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>
<p><strong>查看临时密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<p><strong>登入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p 密码</span><br></pre></td></tr></table></figure>
<p><strong>修改临时密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;OddDog@666&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>这时不支持远程连接登入,需修改mysql库中的user表的中的host字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 进入mysql库</span><br><span class="line">use mysql;</span><br><span class="line">## 查看root用户允许哪个ip能够连接,默认localhost</span><br><span class="line">select host from user where user&#x3D;&#39;root&#39;;</span><br><span class="line">## 允许所有ip地址连接root用户</span><br><span class="line">update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;; </span><br><span class="line">## 刷新</span><br><span class="line">flush privileges;  </span><br></pre></td></tr></table></figure>
<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><p><strong>基本概念</strong> </p>
<ul>
<li>Shell是一个命令行解释器，可以接收应用程序或用户命令，然后访问操作系统内核。 </li>
<li>Shell是一个功能相当强大的编程语言，易编写、易调试、灵活性强；</li>
</ul>
<p> <strong>简单编写</strong></p>
<p>创建以 .sh 为后缀的文件。 以#!/bin/bash开头并编写代码后续代码</p>
<p><strong>执行Shell程序</strong></p>
<ul>
<li>方式一：./文件名，此方式需要执行权限。 </li>
<li>方式二：/bin/bash 文件名，此方式不需要执行权限。或 bash 文件名    或    sh 文件名</li>
</ul>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p><strong>语法格式</strong> </p>
<ul>
<li><p>定义变量：变量=值 </p>
</li>
<li><p>撤销变量：unset 变量 </p>
</li>
</ul>
<p><strong>定义规则</strong></p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。 </li>
<li>不能使用bash里的关键字。 </li>
<li>中间不能有空格，可以有下划线。 </li>
<li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。 </li>
<li>变量的值如果有空格，需要使用双引号或单引号括起来。</li>
</ul>
<h2 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h2><p><strong>算术运算符</strong> : 与java中的一模一样，+  -  *   /   %   =   ==   !=</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算数运算符的用法</span></span><br><span class="line">a=5</span><br><span class="line">b=10</span><br><span class="line"><span class="comment"># 方式一,注意：在expr中使用乘法*，需要转义</span></span><br><span class="line"><span class="built_in">echo</span> `expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</span><br><span class="line"><span class="comment"># 方式二，通过中括号</span></span><br><span class="line"><span class="built_in">echo</span> $[<span class="variable">$a</span>-<span class="variable">$b</span>]</span><br><span class="line"><span class="comment"># 方式三，通过小括号</span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>*<span class="variable">$b</span>))</span><br></pre></td></tr></table></figure>
<p><strong>关系运算符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-eq		是否等于</span><br><span class="line">-ne		是否不等于</span><br><span class="line">-gt		是否大于</span><br><span class="line">-lt		是否小于</span><br><span class="line">-ge		是否大于等于</span><br><span class="line">-le		是否小于等于</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">score=66</span><br><span class="line"></span><br><span class="line">if [ $score -gt 60 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;恭喜你，及格了&quot;</span><br><span class="line">elif [ $score -eq 60 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;60分万岁，多一分浪费！&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;等着补考把&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="case判断"><a href="#case判断" class="headerlink" title="case判断"></a>case判断</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">  &quot;值1&quot;）</span><br><span class="line">	 如果变量的值等于值1，则执行程序1</span><br><span class="line">  ;;</span><br><span class="line">  &quot;值2&quot;）</span><br><span class="line">	 如果变量的值等于值2，则执行程序2</span><br><span class="line">  ;;</span><br><span class="line">  *）</span><br><span class="line">  	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;请输入命令&quot;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">case $num in</span><br><span class="line">  1)</span><br><span class="line">    echo &quot;1号命令&quot;</span><br><span class="line">  ;;      </span><br><span class="line">  2)     </span><br><span class="line">    echo &quot;2号命令&quot;</span><br><span class="line">  ;;     </span><br><span class="line">  3)    </span><br><span class="line">    echo &quot;3号命令&quot; </span><br><span class="line">  ;;         </span><br><span class="line">  *)  </span><br><span class="line">    echo &quot;无该命令&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 累加1-100</span></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for (( i=0;i&lt;=100;i++ ))</span><br><span class="line">do</span><br><span class="line">  sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 累加1-100</span></span><br><span class="line">sum=0</span><br><span class="line">i=0</span><br><span class="line"></span><br><span class="line">while (( i&lt;=100 ))</span><br><span class="line">do</span><br><span class="line">   sum=$[$sum+$i]</span><br><span class="line">   i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">	Action;</span><br><span class="line">	[return int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>
<p><strong>使用案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个函数，对两个形参相乘</span></span><br><span class="line">function mul()</span><br><span class="line">&#123;</span><br><span class="line">    s=$[$1*$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示用户输入两个实参</span></span><br><span class="line">read -p &quot;请输入第一个参数&quot; num1</span><br><span class="line">read -p &quot;请输入第二个参数&quot; num2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用函数</span></span><br><span class="line">mul num1 num2</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>maven笔记</title>
    <url>/2021/07/14/maven%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Maven是一个跨平台的项目管理工具。作为Apache组织的一个颇为成功的开源项目，其主要服务于基于Java平台的项目创建，依赖管理和项目信息管理。<a id="more"></a>maven是Apache的顶级项目，解释为“专家，内行”，它是一个项目管理的工具，maven自身是纯java开发的，可以使用maven对java项目进行构建、依赖管理。</p>
<p><strong>Maven的作用</strong></p>
<ul>
<li>依赖管理<ul>
<li>依赖指的就是是 我们项目中需要使用的第三方Jar包, 一个大一点的工程往往需要几十上百个Jar包,按照我们之前的方式,每使用一种Jar,就需要导入到工程中,还要解决各种Jar冲突的问题.</li>
<li>Maven可以对Jar包进行统一的管理,包括快速引入Jar包,以及对使用的 Jar包进行统一的版本控制</li>
</ul>
</li>
<li>一键构建项目<ul>
<li>之前我们创建项目,需要确定项目的目录结构,比如<code>src</code> 存放Java源码, <code>resources</code>存放配置文件,还要配置环境比如JDK的版本等等,如果有多个项目 那么就需要每次自己搞一套配置,十分麻烦</li>
<li>Maven为我们提供了一个标准化的Java项目结构,我们可以通过Maven快速创建一个标准的Java项目.</li>
</ul>
</li>
</ul>
<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><p> <strong>到官网去下载它的安装软件</strong></p>
<p><a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a>    ,例如找到 apache-maven-3.6.3-bin.zip,直接下载即可。</p>
<p><strong>将下载好的Maven压缩包 直接解压，放到一个没有中文没有空格的路径下</strong></p>
<p>如 C:\study\softwareInstall\maven</p>
<p><strong>maven下的文件说明</strong></p>
<ul>
<li>bin:存放了 maven 的命令</li>
<li>boot:存放了一些 maven 本身的引导程序，如类加载器等</li>
<li>conf:存放了 maven 的一些配置文件，如 setting.xml 文件 </li>
<li>lib:存放了 maven 本身运行所需的一些 jar 包 </li>
</ul>
<p><strong>Maven环境变量配置</strong></p>
<ul>
<li>配置系统变量 MAVEN_HOME ，变量值就是你的 maven 安装的路径（bin 目录之前一级目录）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量名 : MAVEN_HOME</span><br><span class="line">变量值 : C:\study\softwareInstall\maven\apache-maven-3.6.3</span><br></pre></td></tr></table></figure>
<ul>
<li>将MAVEN_HOME 添加到Path系统变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%MAVEN_HOME%\bin</span><br></pre></td></tr></table></figure>
<p><strong>软件版本测试</strong></p>
<p>再cmd窗口输入  mvn-v 命令检查 maven 是是否安装成功，如果看到maven版本与java版本则安装成功。</p>
<h1 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h1><p>Maven中的仓库是用来存放maven构建的项目和各种依赖的(Jar包)</p>
<p><strong>Maven的仓库分类</strong></p>
<ul>
<li><strong>本地仓库</strong>:    位于自己计算机中的仓库, 用来存储从远程仓库或中央仓库下载的插件和 jar 包，</li>
<li><strong>远程仓库</strong>:    需要联网才可以使用的仓库。如阿里提供了一个免费的maven 远程仓库  <a href="https://maven.aliyun.com/mvn/search%E3%80%82">https://maven.aliyun.com/mvn/search。</a></li>
<li><strong>中央仓库</strong>:    在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件</li>
</ul>
<p><a href="https://imgtu.com/i/WVid4H"><img src="https://z3.ax1x.com/2021/07/14/WVid4H.jpg" alt="WVid4H.jpg"></a></p>
<p><strong>Maven 本地仓库的配置</strong></p>
<p>1.maven仓库默认是在 C盘  .m2 目录下</p>
<p>2.一般会把maven仓库放到别的地方，如C:\study\softwareInstall\repository。</p>
<p>3.需在 maven/conf/settings.xml 配置文件中设置仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置本地仓库位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\study\softwareInstall\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便使用仓库，可以先引入别人的仓库，这样就不用自己浪费时间去下载了</p>
<p>链接：<a href="https://pan.baidu.com/s/18OGIHpkpOlpWvYRKyfoKdA">https://pan.baidu.com/s/18OGIHpkpOlpWvYRKyfoKdA</a><br>提取码：gvbp </p>
<p><strong>配置阿里云远程仓库</strong></p>
<p>Maven默认的远程仓库是在国外, 所以下载jar包时速度会非常慢, 这里推荐使用阿里云仓库</p>
<p>打开 settings.xml 文件 ， 在 mirrors 标签下添加 ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置本地仓库位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven项目"><a href="#maven项目" class="headerlink" title="maven项目"></a>maven项目</h1><p>在idea中创建一个maven的项目，不使用模板，创建好的默认工程长这样：</p>
<p><a href="https://imgtu.com/i/WVAF9H"><img src="https://z3.ax1x.com/2021/07/14/WVAF9H.jpg" alt="WVAF9H.jpg"></a></p>
<p>如果编译后还会出现一个  <strong>target</strong> 目录 ： 项目输出位置，编译后的class 文件会输出到此目录 </p>
<h2 id="将maven工程改造成-web项目"><a href="#将maven工程改造成-web项目" class="headerlink" title="将maven工程改造成 web项目"></a>将maven工程改造成 web项目</h2><ul>
<li>在main目录下创建一个webapp文件夹</li>
<li>选中  project Structure —&gt; facets—&gt; 点击+号 添加web —&gt; 选择当前工程hello_maven</li>
</ul>
<p><a href="https://imgtu.com/i/WVEFaT"><img src="https://z3.ax1x.com/2021/07/14/WVEFaT.jpg" alt="WVEFaT.jpg" style="zoom: 50%;" /></a></p>
<ul>
<li>修改路径信息 </li>
</ul>
<p><a href="https://imgtu.com/i/WVEkIU"><img src="https://z3.ax1x.com/2021/07/14/WVEkIU.jpg" alt="WVEkIU.jpg"></a></p>
<p><a href="https://imgtu.com/i/WVE1IO"><img src="https://z3.ax1x.com/2021/07/14/WVE1IO.jpg" alt="WVE1IO.jpg"></a></p>
<h2 id="pom核心配置文件"><a href="#pom核心配置文件" class="headerlink" title="pom核心配置文件"></a>pom核心配置文件</h2><p>一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的信息、项目依赖、引入插件等</p>
<p>1） 一个Maven工程就是由<code>groupId</code>，<code>artifactId </code>和 <code>version</code> 作为唯一标识, 我们在引用其他第三方库的时候，也是通过这3个变量确定</p>
<p>Maven坐标主要组成(GAV) - 确定一个jar在互联网位置 </p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupId</strong></td>
<td>定义当前Maven组织名称,通常是公司名</td>
</tr>
<tr>
<td><strong>artifactId</strong></td>
<td>定义实际项目名称</td>
</tr>
<tr>
<td><strong>version</strong></td>
<td>定义当前项目的当前版本</td>
</tr>
<tr>
<td><strong>packaging</strong></td>
<td>打包类型<br />jar：执行 package 会打成 jar 包       war：执行 package 会打成 war 包</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello_maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>引入其他jar包</li>
</ol>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>dependencies</strong></td>
<td>表示依赖关系</td>
</tr>
<tr>
<td><strong>dependency</strong></td>
<td>使用 <code>&lt;dependency&gt; </code>声明一个依赖后，Maven就会自动下载这个依赖包</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>添加插件</li>
</ol>
<p>添加编译插件,  设置 jdk 编译版本 </p>
<p>本教程使用 jdk11，需要设置编译版本为 11，这里需要使用 maven 的插件来设置</p>
<p>在pom中加入如下配置: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- properties 是全局设置,可以设置整个maven项目的编译器 JDK版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 重点  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在build中 我们需要指定一下项目的JDK编译版本,maven默认使用1.5版本进行编译</span></span><br><span class="line"><span class="comment">    注意 build 与 dependencies是平级关系,标签不要写错位置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">release</span>&gt;</span>11<span class="tag">&lt;/<span class="name">release</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven的常用命令"><a href="#maven的常用命令" class="headerlink" title="maven的常用命令"></a>maven的常用命令</h2><p><strong>maven项目生命周期</strong></p>
<p><a href="https://imgtu.com/i/WVmDns"><img src="https://z3.ax1x.com/2021/07/14/WVmDns.jpg" alt="WVmDns.jpg"></a></p>
<p>maven 通过执行一些简单命令即可实现上边生命周期的各个过程</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>mvn clean</strong></td>
<td>执行完毕后，会将target目录删除.</td>
</tr>
<tr>
<td><strong>mvn compile</strong></td>
<td>完成编译操作 , 执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</td>
</tr>
<tr>
<td><strong>mvn test</strong></td>
<td>执行完毕后，会在target目录中生成三个文件夹：<br />surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）</td>
</tr>
<tr>
<td><strong>mvn package</strong></td>
<td>完成打包操作, 执行完毕后，会在target目录中生成一个文件，该文件可能是 jar、war</td>
</tr>
<tr>
<td><strong>mvn install</strong></td>
<td>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作 ,<br /> 执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用</td>
</tr>
</tbody></table>
<p> <strong>idea中maven视图介绍</strong></p>
<p><a href="https://imgtu.com/i/WVmfc4"><img src="https://z3.ax1x.com/2021/07/14/WVmfc4.jpg" alt="WVmfc4.jpg"></a></p>
<p><strong>工具栏介绍</strong></p>
<p><a href="https://imgtu.com/i/WVn9Et"><img src="https://z3.ax1x.com/2021/07/14/WVn9Et.jpg" alt="WVn9Et.jpg"></a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.根据pom.xml文件重新导入所有Maven项目和依赖,刷新</span><br><span class="line">2.创建源码（重新编译）并更新目录</span><br><span class="line">3.下载源码或文档</span><br><span class="line">4.添加Maven项目</span><br><span class="line">5.执行生命周期中的阶段，选中lifecycle选项中生命周期中的一个阶段（phase），才能点击执行。</span><br><span class="line">6.运行Maven生命周期或插件</span><br><span class="line">7.切换离线模式，就是关闭和远程仓库的链接，从本地仓库中获取，也不能将jar包提交到远程仓库</span><br><span class="line">8.是否跳过测试，点击选中就可以跳过测试，在点击选择取消跳过测试</span><br><span class="line">9.展示当前选中的maven项目jar包的依赖，并且可以直接在图形化依赖图上进行排除依赖操作</span><br><span class="line">10.收起下面展开的视图</span><br><span class="line">11.跳转到maven的Setting页面</span><br></pre></td></tr></table></figure>
<h2 id="依赖范围介绍"><a href="#依赖范围介绍" class="headerlink" title="依赖范围介绍"></a>依赖范围介绍</h2><p>A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包 括： </p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译范围，指 A在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。</td>
</tr>
<tr>
<td>provided</td>
<td>provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依 赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。</td>
</tr>
<tr>
<td>test</td>
<td>test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如：junit。由于运行时不需要所以test范围依赖不会被打包。</td>
</tr>
<tr>
<td>system</td>
<td>system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 模块名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖范围, 指定依赖范围是编译与测试时有效,运行时无效,运行时使用tomcat中的依赖,避免冲突 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven的依赖传递"><a href="#maven的依赖传递" class="headerlink" title="maven的依赖传递"></a>maven的依赖传递</h1><p>在maven中，依赖是可以传递的，假设存在三个项目，分别是项目A，项目B以及项目C。假设C依赖 B，B依赖A，那么我们可以根据maven项目依赖的特征不难推出项目C也依赖A。</p>
<p><a href="https://imgtu.com/i/fnMlBd"><img src="https://z3.ax1x.com/2021/08/06/fnMlBd.png" alt="fnMlBd.png"></a></p>
<p><strong>依赖冲突</strong></p>
<p>由于依赖传递现象的存在，例如: spring-webmvc 依赖 spirng-beans-5.1.5，spring-aop 依赖 springbeans-5.1.6，但是发现 spirng-beans-5.1.5 加入到了工程中，而我们希望 spring-beans-5.1.6 加入工 程。这就造成了依赖冲突。</p>
<h2 id="如何解决依赖冲突"><a href="#如何解决依赖冲突" class="headerlink" title="如何解决依赖冲突"></a>如何解决依赖冲突</h2><h3 id="使用maven提供的依赖调解原则"><a href="#使用maven提供的依赖调解原则" class="headerlink" title="使用maven提供的依赖调解原则"></a>使用maven提供的依赖调解原则</h3><p><strong>第一声明者优先原则</strong> </p>
<p>在 pom 文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传 递过来的依赖。</p>
<p><strong>路径近者优先原则</strong> </p>
<p>直接引入需要的依赖的坐标——–直接依赖大于依赖传递</p>
<h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>使用<strong>exclusions</strong>标签将传递过来的依赖排除出去。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--依赖排除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="锁定版本"><a href="#锁定版本" class="headerlink" title="锁定版本"></a>锁定版本</h3><p>采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以 锁定的版本为准添加到工程中，此方法在企业开发中经常使用。</p>
<p>在<strong>dependencyManagement</strong>标签中锁定依赖的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>   这里只是锁定了版本，并没有导入依赖，还需再<strong>dependencies</strong>标签中导入依赖，可以不用再指定<strong>version</strong></p>
<p><strong>properties标签的使用</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将版本提取出来，properties里的标签是自定义的，随便怎么写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springmvc.version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">springmvc.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--锁定jar版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springMVC --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springmvc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="maven的聚合工程"><a href="#maven的聚合工程" class="headerlink" title="maven的聚合工程"></a>maven的聚合工程</h1><p>在企业项目开发中，由于项目规模大，业务复杂，参与的人员比较多，一般会通过合理的模块拆分将一 个大型的项目拆分为N多个小模块，分别进行开发。而且拆分出的模块可以非常容易的被其他模块复用 常见的拆分方式有两种： </p>
<p><strong>第一种</strong>  按照业务模块进行拆分，每个模块拆分成一个maven工程，例如将一个项目分为用户模块，订 单模块，购物车模块等，每个模块对应就是一个maven工程 </p>
<p><strong>第二种</strong>   按照层进行拆分，例如持久层、业务层、表现层等，每个层对应就是一个maven工程 不管上面那种拆分方式，通常都会提供一个父工程，将一些公共的代码和配置提取到父工程中进行统一 管理和配置。</p>
<p><a href="https://imgtu.com/i/fn8Jl6"><img src="https://z3.ax1x.com/2021/08/06/fn8Jl6.png" alt="fn8Jl6.png"></a></p>
<h2 id="maven工程的继承"><a href="#maven工程的继承" class="headerlink" title="maven工程的继承"></a>maven工程的继承</h2><p>在Java语言中，类之间是可以继承的，通过继承，子类就可以引用父类中非private的属性和方法。同 样，在maven工程之间也可以继承，子工程继承父工程后，就可以使用在父工程中引入的依赖。继承的 目的是为了消除重复代码。</p>
<p><strong>父工程pom部分定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意打包方式一定是pom--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子工程pom部分定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意打包方式一定是pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-children<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven工程的聚合"><a href="#maven工程的聚合" class="headerlink" title="maven工程的聚合"></a>maven工程的聚合</h2><p>在maven工程的pom.xml文件中可以使用标签将其他maven工程聚合到一起，聚合的目的是为了进行 统一操作.</p>
<p>例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来 非常繁琐。这时就可以使用标签将这些工程统一聚合到maven父工程中，需要打包的时候，只需要在此 工程中执行一次打包命令，其下被聚合的工程就都会被打包了。</p>
<p><strong>父工程中pom定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-children-4<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>over 。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>vue笔记</title>
    <url>/2021/07/19/vue%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是， Vue 被设计 为可以自底向上逐层应用. </p>
<p>Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。<a id="more"></a>另一 方面，当与 现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 </p>
<p>自底向上逐层应用：作为渐进式框架要实现的目标就是方便项目增量开发(即插即用)</p>
<p><strong>官网</strong>  <a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p>
<h1 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h1><h2 id="vue入门"><a href="#vue入门" class="headerlink" title="vue入门"></a>vue入门</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul>
<li><p>定义html，引入vue.js </p>
</li>
<li><p>定义app div，此区域作为vue的接管区域 </p>
</li>
<li><p>定义Vue实例，接管app区域。 </p>
</li>
<li><p>定义model（数据对象） </p>
</li>
<li><p>在app中展示数据</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一种 引入 vue.js的CDN地址 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;/script&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二种 本地导入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 定义app div，此区域作为vue的接管区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//3. 创建vue实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//定义 Vue实例挂载的元素节点,表示vue接管该div</span></span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">//4.定义model模型数据对象</span></span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                name:<span class="string">&quot;怪狗狗&quot;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Vue基本属性"><a href="#Vue基本属性" class="headerlink" title="Vue基本属性"></a>Vue基本属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>el</td>
<td>Vue实例挂载的元素节点,表示vue接管该区域，建议用div标签，不能使用HTML和Body标签</td>
</tr>
<tr>
<td>data</td>
<td>Vue中用到的数据定义在data中 。data中可以写复杂类型 ，相当于js中的对象</td>
</tr>
<tr>
<td>methods</td>
<td>定义方法</td>
</tr>
<tr>
<td>computed</td>
<td>计算属性。效果与方法一样，但是数据是基于它们的响应式依赖进行缓存的 。一般重复的计算或格式化等方法 会定义到计算属性中</td>
</tr>
</tbody></table>
<h3 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h3><p><strong>插值表达式（两个大括号）</strong></p>
<p> 通常用来获取Vue实例中定义的数据(data) ，属性节点中 不能够使用插值表达式</p>
<p> <strong>v-text 指令</strong> </p>
<p>获取data数据, 设置标签的内容. </p>
<p>注意: 默认写法会替换全部内容,使用<strong>插值表达式</strong>(两个大括号)可以替换指定内容.</p>
<p> <strong>v-html 指令</strong> </p>
<p>设置元素的 innerHTML (可以向元素中写入新的标签)</p>
<p> <strong>v-on 指令</strong></p>
<p>为元素绑定事件, 比如: v-on:click,可以简写为 @click=”方法” </p>
<p>绑定的方法定义在 VUE实例的, method属性中,可通过  .  添加修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-on 绑定click 点击事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 @符号也可以绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 绑定键盘按下事件，添加了enter修饰符，表示按下enter键才会触发事件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单击事件，添加stop修饰符，阻止事件冒泡 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击按钮&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>v-show 指令</strong> </p>
<p>v-show指令, 根据真假值,切换元素的显示状态</p>
<p>原理是修改元素的display,实现显示或者隐藏 。表达式为 true 显示, 为false 则隐藏 数据改变之后,显示的状态会同步更新</p>
<p> <strong>v-if 指令</strong> </p>
<p> 根据表达式的真假切换元素的显示状态 </p>
<p>本质是通过操作dom元素,来切换显示状态  表达式为true 元素存在与dom树,为false从dom树中移除</p>
<p>频繁切换使用 v-show 指令 ,反之使用v-if 指令</p>
<p><strong>v-bind 指令</strong></p>
<p>为元素绑定属性 完整写法 v-bind:属性名，可以简写为 :属性名</p>
<p> <strong>v-for 指令</strong></p>
<p>根据数据生成列表结构 ，数组经常和 v-for结合使用</p>
<p>数组有两个常用方法: push() 向数组末尾添加一个或多个元素 ，shift() 把数组中的第一个元素删除</p>
<p> 语法是: (item,index) in 数据 item和index </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以结合其他指令一起使用 数组的长度变化,会同步更新到页面上,是响应式的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- p 为persons中的每一个元素，index为下标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) in persons&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;p.name&quot;</span>&gt;</span></span><br><span class="line">	&#123;&#123;p.index&#125;&#125; : &#123;&#123;p.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>v-mode 指令</strong></p>
<p>获取和设置表单元素的值(实现双向数据绑定)</p>
<ul>
<li>单向绑定: 就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动 更新。 </li>
<li>双向绑定: 用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。</li>
</ul>
<p><strong>v-cloak指令</strong></p>
<p>解决插值表达式闪烁问题，当网络比较慢时，Vue来不及渲染页面中的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在id为app的div（挂载点）中添加 v-cloak  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 添加样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 通过属性选择器,设置 添加了v-cloak */</span></span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h3><p> MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式. MVVM模式将页面,分层了 M 、V、和VM。 </p>
<p><strong>Model</strong>    负责数据存储</p>
<p><strong>View</strong>      负责页面展示 </p>
<p><strong>View Model</strong>    负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- View 视图部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建的vue实例,就是 VM ViewModel</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//data就是MVVM模式中的 model</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">&quot;hello&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/WGq3Bn"><img src="https://z3.ax1x.com/2021/07/19/WGq3Bn.jpg" alt="WGq3Bn.jpg"></a></p>
<p>我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关 键。 </p>
<ul>
<li>从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如 果有变化，则更改Model中的数据</li>
<li>从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的 DOM元素。</li>
</ul>
<h2 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter 过滤器"></a>filter 过滤器</h2><p>过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原 来的数据，只是在原数据的基础上产生新的数据。</p>
<h3 id="过滤器使用位置"><a href="#过滤器使用位置" class="headerlink" title="过滤器使用位置"></a>过滤器使用位置</h3><p><strong>双括号插值内</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg是需要处理的数据, filter是过滤器, | 这个竖线是管道,通过这个管道将数据传输给过滤器进行过滤 加工操作</span><br><span class="line">&#123;&#123; msg | filter &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>v-bind绑定的值的地方</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-bind:id&#x3D;&quot; msg | filter&quot;&gt; &#123;&#123; msg &#125;&#125; &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><p><strong>需求</strong>   给价格前面 添加一个符号¥</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;price | my&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">            data:&#123; <span class="attr">price</span>:<span class="number">199</span> &#125;,</span><br><span class="line">            <span class="comment">// 局部过滤器</span></span><br><span class="line">            filters:&#123;</span><br><span class="line">                my:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span> + value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body</span><br></pre></td></tr></table></figure>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p><strong>需求</strong>   将第一个单词转大写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name | my&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name | changeName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局过滤器  一定要在在创建Vue实例之前定义</span></span></span><br><span class="line"><span class="javascript">        Vue.filter(<span class="string">&quot;changeName&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            data:&#123;<span class="attr">name</span>:<span class="string">&quot;hui&quot;</span>&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h2><p>当一些数据需要随着其它数据变动而变动时，可以使用侦听属性</p>
<p><strong>需求</strong>: 监听姓与名变化,实时显示姓名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        姓 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        名 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;last_name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123;full_name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                first_name:<span class="string">&quot;&quot;</span>, </span></span><br><span class="line"><span class="javascript">                last_name:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                full_name:<span class="string">&quot;&quot;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 监听的值只能是data中的数据</span></span></span><br><span class="line">            watch:&#123;</span><br><span class="line"><span class="javascript">                first_name:<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.full_name = newVal +<span class="string">&quot; &quot;</span>+ <span class="built_in">this</span>.last_name</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                last_name:<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.full_name =  <span class="built_in">this</span>.first_name +<span class="string">&quot; &quot;</span>+ newVal</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="component-组件"><a href="#component-组件" class="headerlink" title="component 组件"></a>component 组件</h2><p>组件（Component）是自定义封装的功能。在前端开发过程中，经常出现多个网页的功能是重复 的，而且很多不同的页面之间，也存在同样的功能。 </p>
<p>我们将相同的功能进行抽取,封装为组件,这样，前端人员就可以在组件化开发时，只需要书写一次代 码，随处引入即可使用。 </p>
<p><strong>注意</strong></p>
<ul>
<li>组件名以小写开头，采用短横线分割命名: 例如 hello-Word </li>
<li>组件中的data 必须是一个函数,注意与Vue实例中的data区分 </li>
<li>在template模板中, 只能有一个根元素</li>
</ul>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用全局组件，可以使用多次 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;my-component&quot;</span>,&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            template:&quot;<span class="tag">&lt;<span class="name">h4</span> @<span class="attr">click</span>=<span class="string">&#x27;kk&#x27;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//组件中的data是一个函数</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    message:<span class="string">&quot;这是一个全局组件哦&quot;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 组件的相关的js方法，与vue写法相同</span></span></span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                kk:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.alert(<span class="string">&quot;hello kk&quot;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">		<span class="comment">// 创建vue实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 定义局部组件</span></span></span><br><span class="line">            components:&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&quot;my-component&quot;</span>:&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">                    template:&quot;<span class="tag">&lt;<span class="name">h5</span> &gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="xml">&lt;/h5&#125;&quot;,</span></span></span><br><span class="line"><span class="javascript">                    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;<span class="attr">message</span>:<span class="string">&quot;这是一个局部组件哦&quot;</span>&#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件与模板分离"><a href="#组件与模板分离" class="headerlink" title="组件与模板分离"></a>组件与模板分离</h3><p>把html语言写在组件里面很不方便，也不太好看所以将它们分开写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件模板，不会被页面加载显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hui&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            components:&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&quot;my-component&quot;</span>:&#123;</span></span><br><span class="line"><span class="javascript">                    template:<span class="string">&quot;#hui&quot;</span>,<span class="comment">// 通过id选择器找到对应html代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            message:<span class="string">&quot;吼吼吼吼&quot;</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h2><p>每个Vue实例在被创建之前都要经过一系列的初始化过程,这个过程就是vue的生命周期</p>
<p><a href="https://imgtu.com/i/WJSzN9"><img src="https://z3.ax1x.com/2021/07/19/WJSzN9.png" alt="WJSzN9.png" style="zoom: 50%;" /></a></p>
<p><strong>钩子函数</strong>  在一个事件触发的时候，在系统级捕获到了他，然后做一些操作</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate()</td>
<td>在创建Vue实例之前,可以执行这个方法. 例如 加载动画操作</td>
</tr>
<tr>
<td>created()</td>
<td>实例创建完成,属性绑定好了,但是DOM还没有生成.</td>
</tr>
<tr>
<td>beforeMount()</td>
<td>模板已经在内存中编辑完成了，尚未被渲染到页面中.</td>
</tr>
<tr>
<td>mounted()</td>
<td>内存中的模板已经渲染到页面，用户已经可以看见内容.</td>
</tr>
<tr>
<td>beforeUpdate()</td>
<td>数据更新的前一刻 , 组件在发生更新之前,调用的函数</td>
</tr>
<tr>
<td>updated()</td>
<td>updated执行时，内存中的数据已更新，并且页面已经被渲染</td>
</tr>
<tr>
<td>beforeDestroy ()</td>
<td>钩子函数在实例销毁之前调用</td>
</tr>
<tr>
<td>destroyed ()</td>
<td>钩子函数在Vue 实例销毁后调用</td>
</tr>
</tbody></table>
<h2 id="Vue-Router-路由"><a href="#Vue-Router-路由" class="headerlink" title="Vue Router 路由"></a>Vue Router 路由</h2><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>单页面Web应用（single page web application），就是只有一张Web页面的应用， 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序</p>
<p><strong>特点</strong></p>
<ul>
<li>用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。</li>
<li>适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲 染。</li>
</ul>
<h3 id="路由相关概念"><a href="#路由相关概念" class="headerlink" title="路由相关概念"></a>路由相关概念</h3><p><strong>router</strong> </p>
<p>​        是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用（SPA）变得易 如反掌 ,router 就相当于一个管理者，它来管理路由。 </p>
<p><strong>route</strong> </p>
<p>​        route相当于路由器, route就相当于一条路由.比如: Home按钮 =&gt; home内容， 这是一条route; news按钮 =&gt; news内容， 这是另一条路由。 </p>
<p><strong>routes</strong></p>
<p>​        一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}] </p>
<p><strong>router-link组件</strong> </p>
<p>​        router-link 是一个组件，是对 a 标签的一个封装. 该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容 </p>
<p><strong>router-view 组件</strong></p>
<p>​        路由导航到指定组件后,进行渲染显示页面。路由显示的出口。</p>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>1.Vue.js 路由需要载入 vue-router 库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1: 本地导入</span></span><br><span class="line">&lt;script src=<span class="string">&quot;vue-router.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">//方式2: CDN</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.定义路由所需的组件</p>
<p>3.创建router路由器实例 ,配置路由<strong>routes</strong>。每个路由都由两部分 <strong>path</strong> (路径) 和<strong>component</strong> (组件) </p>
<p>4.创建Vue实例, 注入路由对象, 使用$mount() 指定挂载点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择需要跳转的路由 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>to home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news&quot;</span>&gt;</span>to news<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 载入vue-router库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定义多个组件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> home = &#123;<span class="attr">template</span>:<span class="string">&quot;&lt;h2&gt;这是首页&lt;/h2&gt;&quot;</span>&#125;;  <span class="comment">// 首页</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> news = &#123;<span class="attr">template</span>:<span class="string">&quot;&lt;h2&gt;这是新闻页&lt;/h2&gt;&quot;</span>&#125;;  <span class="comment">// 新闻页</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建路由实例，并配置路由</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="javascript">                &#123;<span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>:home&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="attr">path</span>:<span class="string">&quot;/news&quot;</span>, <span class="attr">component</span>:news&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 创建vue实例，挂载路由</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> VM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">            router:router</span><br><span class="line"><span class="javascript">        &#125;).$mount(<span class="string">&quot;#app&quot;</span>) <span class="comment">// $mount是手动挂载，代替 el，两者没区别</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue cli是基于Vue的应用开发提供的一个标准的脚手架工具.为应用搭建基础的框架结构,提供插 件、开发服务、Preset、构建打包功能 </p>
<p>Vue cli 背后集成了现代化开发的诸多功能,通过简单的命令就可以完成 “零配置”的项目环境搭建</p>
<p><strong>安装 Vue-cli</strong></p>
<p>先确保安装了 node 与 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>安装完成后，输入 Vue -v  查看版本</p>
<h2 id="构建Vue项目"><a href="#构建Vue项目" class="headerlink" title="构建Vue项目"></a>构建Vue项目</h2><p>1.打开cmd命令行，切换到对应的文件夹，输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create 项目名</span><br></pre></td></tr></table></figure>
<p>2.会出现相应的选项，配置完后，开始下载Vue项目</p>
<p>3.进入项目目录，输入  <strong>npm run serve</strong> 启动项目</p>
<p>4.访问项目    <a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p><strong>项目结构介绍</strong></p>
<p><a href="https://imgtu.com/i/WJZBWD"><img src="https://z3.ax1x.com/2021/07/19/WJZBWD.jpg" alt="WJZBWD.jpg" style="zoom:50%;" /></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-project 项目名称</span><br><span class="line">    node_modules 存放依赖包的目录</span><br><span class="line">    public 静态资源管理目录</span><br><span class="line">    src 组件源码目录(我们写的代码)</span><br><span class="line">        assets 存放静态图片资源(CSS也可以放在这里)</span><br><span class="line">        components 存放各种组件(一个页面可以看做一个组件)，各个组件联系在一起组成一个</span><br><span class="line">        完整的项目</span><br><span class="line">        router 存放了项目路由文件</span><br><span class="line">        views 放置的为公共组件(主要还是各个主要页面)</span><br><span class="line">        App.vue 网站首页，是一个vue项目的主组件，页面入口文件</span><br><span class="line">    	main.js 打包运行的入口文件，引入了vue模块和app.vue组件以及路由route</span><br><span class="line">    abel.config.js babel配置文件, 对源代码进行转码(把es6&#x3D;&gt;es5)</span><br><span class="line">    package.json 项目及工具的依赖配置文件</span><br><span class="line">    paxkage-lock.json 依赖配置文件</span><br><span class="line">    README.md 项目说明</span><br></pre></td></tr></table></figure>
<p><strong>package.js 配置文件</strong></p>
<p> package.json 文件定义了这个项目所需要的各种模 块，以及项目的配置信息（比如名称、版本、许可证等元数据）。 npm install 命令根据这个配置文 件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.项目基本信息</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;project3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//2.指定运行脚本命令</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//4.生产环境所依赖模块的版本</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^3.6.5&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.11&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//5.本地环境开发所依赖的版本</span></span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-babel&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-router&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@vue/cli-service&quot;</span>: <span class="string">&quot;~4.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.6.11&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在最末端添加如下配置: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;vue&quot;:&#123;</span><br><span class="line">    &quot;devServer&quot;:&#123;</span><br><span class="line">        &quot;port&quot;:&quot;8888&quot;, // 访问端口</span><br><span class="line">        &quot;open&quot;:true   //  打包完成自动打开浏览器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>单独的配置文件配置项目</strong></p>
<p>在项目的根目录创建 vue.config.js 文件 ，在该文件进行相关配置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        open:true</span><br><span class="line">        port:8889</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-组件化开发"><a href="#Vue-组件化开发" class="headerlink" title="Vue 组件化开发"></a>Vue 组件化开发</h2><p>组件化是Vue的精髓，Vue项目就是由一个一个的组件构成的。 </p>
<p>我们主要的工作就是开发的组件,每一个*.vue 文件都是一个组件 。</p>
<p><strong>组件分类</strong></p>
<ul>
<li>页面级别的组件 <ul>
<li>页面级别的组件，通常是 views 目录下的.vue组件，是组成整个项目的各个主要</li>
</ul>
</li>
<li>业务上可复用的基础组件<ul>
<li>这一类组件通常是在业务中被各个页面复用的组件，这一类组件通常都写到 components 目 录下，然后通过import在各个页面中使用</li>
</ul>
</li>
</ul>
<p><strong>组件的组成部分</strong></p>
<ul>
<li>template : 组件的HTML部分 </li>
<li>script: 组件的JS脚本 (使用ES6语法编写) </li>
<li>style: 组件的CSS样式</li>
</ul>
<p><strong>组件的使用</strong></p>
<p>创建 Hui.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div &gt;&#123;&#123;msg&#125;&#125;&#x3D;&#x3D;&#123;&#123;flag&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;JS 部分</span><br><span class="line">    export default &#123;</span><br><span class="line">        name:&quot;Hui&quot;, &#x2F;&#x2F;组件的名称</span><br><span class="line">        props:[&#39;flag&#39;], &#x2F;&#x2F; 组件中的属性, 表示组件可以接受参数</span><br><span class="line">        data() &#123; &#x2F;&#x2F;data函数</span><br><span class="line">            return &#123;</span><br><span class="line">                msg:&quot;这是一个hui组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>在别的页面中引入 hui 组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Hui flag&#x3D;&quot;吼吼吼吼&quot;&gt;&lt;&#x2F;Hui&gt; &lt;!--使用Hui组件，给fag属性传递参数--&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 引入 Hui.vue 文件</span><br><span class="line">    import Hui from &#39;@&#x2F;components&#x2F;Hui.vue&#39;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;Home&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            Hui  &#x2F;&#x2F; 注册组件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="项目运行流程"><a href="#项目运行流程" class="headerlink" title="项目运行流程"></a>项目运行流程</h2><p><strong>首先载入口文件 main.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//关闭启动提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">//创建Vue实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router, <span class="comment">//为整个项目添加路由</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//这是一个函数ES6语法,作用是生成模板: App = App.vue</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">//挂载的是App.vue组件中的id为app的区域</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>App.vue</strong></p>
<p>页面入口文件 ，所有页面都是在App.vue下进行切换的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App.vue 中的模板(HTML代码)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt; 挂载的是这个div</span><br><span class="line">    &lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">        这里是两个路由导航链接</span><br><span class="line">        1. to&#x3D;&quot;&#x2F;&quot; 项目根路径 跳转的是首页</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt; |</span><br><span class="line">        2. to&#x3D;&quot;&#x2F;about&quot; 点击About按钮,跳转到about组件</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    router-view 的作用是 根据访问的路径,渲染路径匹配到的视图组件</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>router 路由</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入所需文件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">//vue库</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span> <span class="comment">//vue-router库</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span> <span class="comment">//首页</span></span><br><span class="line"><span class="comment">//使用路由功能</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">//创建路由规则</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>, <span class="comment">//路径</span></span><br><span class="line">        name: <span class="string">&#x27;Home&#x27;</span>, <span class="comment">//名称</span></span><br><span class="line">        component: Home <span class="comment">//组件 Home.vue</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">        component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span></span><br><span class="line">            <span class="string">&#x27;../views/About.vue&#x27;</span>) <span class="comment">// 动态导入About.vue组件</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//创建路由管理器,管理routes</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//export 用来导出模块 router就代表了整个路由文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p> <strong>npm安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
<p><strong>打开 main.js , 导入Element-UI 相关资源</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入组件库</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">//导入组件相关样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"><span class="comment">//配置Vue插件 将El安装到Vue上</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p><strong>npm安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure>
<p><strong>在main.js文件中导入axios 相关资源</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">//Vue对象使用axios</span></span><br><span class="line">Vue.prototype.axios = axios;</span><br></pre></td></tr></table></figure>


<h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><p><strong>修改配置文件</strong></p>
<ul>
<li><p>.env.development     开发环境的配置文件</p>
</li>
<li><p>.env.production    生产环境的配置文件</p>
</li>
</ul>
<p>修改生产环境的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 后端项目的路径</span><br><span class="line">VUE_APP_API_BASE &#x3D; http:&#x2F;&#x2F;192.168.52.100:8080&#x2F;lagou_edu_home</span><br></pre></td></tr></table></figure>
<p><strong>修改 vue.config.js 配置文件</strong></p>
<p>直接复制即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// relative path for dev</span></span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;/edu-boss/&quot;</span> : <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="comment">// for gh-pages</span></span><br><span class="line">    indexPath: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    lintOnSave: process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    css: &#123;</span><br><span class="line">        <span class="comment">// sourceMap: process.env.NODE_ENV !== &#x27;production&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8081</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>前端项目打包</strong></p>
<p>执行  <strong>npm run build</strong>   命令经行打包</p>
<p>生产 dist 目录，dist文件就是vue项目的线上发布文件</p>
<p><strong>运行tomcat</strong></p>
<p>将 dist 文件放入tomcat中的webapps目录下。</p>
<p>开启tomcat服务器，可通过 <a href="http://localhost:8080/dist/">http://localhost:8080/dist/</a>  访问到Vue项目</p>
<p>不过一般建议把dist名称改一下，并且tomcat的端口号改一改，避免与后端项目起冲突。</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2021/07/24/mybatis/</url>
    <content><![CDATA[<p>​        MyBatis是一个优秀的基于ORM的半自动轻量级持久层框架，它对jdbc的操作数据库的过程进行封装， 使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建 statement、手动设置参数、结果集检索等jdbc繁杂的过程代码<a id="more"></a></p>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移 到了google code，随着开发团队转投到Google Code旗下，iBatis正式改名为MyBatis ，代码于2013 年11月迁移到Github </p>
<p><strong>Github地址</strong>：<a href="https://github.com/mybatis/mybatis-3/">https://github.com/mybatis/mybatis-3/</a></p>
<p> <strong>ORM（Object Relational Mapping）对象关系映射</strong></p>
<ul>
<li>O（对象模型）： 实体对象，即我们在程序中根据数据库表结构建立的一个个实体javaBean </li>
<li>R（关系型数据库的数据结构）： 关系数据库领域的Relational（建立的数据库表） </li>
<li>M（映射）： 从R（数据库）到O（对象模型）的映射，可通过XML文件映射</li>
</ul>
<p>ORM作为是一种思想 帮助我们跟踪实体的变化,并将实体的变化翻译成sql脚本,执行到数据库中去,也就是将实体的变化映射到 了表的变化。 mybatis采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问 细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作 。</p>
<h1 id="Mybatis基本使用"><a href="#Mybatis基本使用" class="headerlink" title="Mybatis基本使用"></a>Mybatis基本使用</h1><p>MyBatis官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p>
<p><strong>需求</strong>   通过mybatis查询数据库user表的所有记录，封装到User对象中，打印到控制台上</p>
<ol>
<li><p>创建数据库及user表</p>
</li>
<li><p>创建maven工程，导入依赖（MySQL驱动、mybatis、junit）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建User实体类</p>
</li>
<li><p>编写UserMapper.xml映射配置文件（ORM思想）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace与id 是唯一表示，可通过这两个元素获取sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有，resultType为返回的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hui.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写SqlMapConfig.xml核心配置文件 </p>
<p>​    数据库环境配置 </p>
<p>​    映射关系配置的引入(引入映射配置文件的路径)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用MySQL环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用JDBC类型事务管理器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis_db&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载映射配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.加载核心配置文件</span></span><br><span class="line">    <span class="comment">// Resources.class.getClassLoader().getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span></span><br><span class="line">    InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.获取sqlSessionFactory工厂对象</span></span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(stream);</span><br><span class="line">    <span class="comment">// 3.获取sqlSession会话对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 4.执行sql，传递的参数是xml映射中namespace与id组成的唯一标识</span></span><br><span class="line">    List&lt;User&gt; userList = session.selectList(<span class="string">&quot;userMapper.selectUser&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增删改操作分别使用 <strong>insert</strong> 、<strong>delete</strong>、<strong>update</strong> 标签与方法</p>
</li>
</ol>
<p>如果要传递参数，xml映射需使用 <strong>parameterType</strong>属性指定要插入的数据类型</p>
<p>Sql语句中使用 <strong>#{xxx}</strong> 方式引用实体中的属性值</p>
<p>另外，增删改操作要使用sqlSession对象提交事务，即 sqlSession.commit()</p>
<p><strong>log4j的使用</strong></p>
<ul>
<li>1)导入配置依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   log4j日志     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2)导入配置文件  log4j.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### direct messages to file mylog.log ###</span></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">c:/mylog.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### set log levels - for more verbose logging change &#x27;info&#x27; to &#x27;debug&#x27; ###</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout</span></span><br></pre></td></tr></table></figure>
<h1 id="Mybatis核心配置文件"><a href="#Mybatis核心配置文件" class="headerlink" title="Mybatis核心配置文件"></a>Mybatis核心配置文件</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p>
<p> 配置文档的顶层结构如下：</p>
<ul>
<li>configuration（配置）<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<h2 id="MyBatis常用配置解析"><a href="#MyBatis常用配置解析" class="headerlink" title="MyBatis常用配置解析"></a>MyBatis常用配置解析</h2><h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><p><a href="https://imgtu.com/i/WcRs54"><img src="https://z3.ax1x.com/2021/07/24/WcRs54.png" alt="WcRs54.png"></a></p>
<p><strong>transactionManager</strong>(事务管理器) , 类型有两种</p>
<p>​        JDBC： 这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 </p>
<p>​        MANAGED： 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。 例如：mybatis与spring整合后，事务交给spring容器管理。</p>
<p><strong>dataSource</strong> (数据源) ，类型有三种</p>
<p>​        POOLED： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>​        UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 </p>
<p>​        JNDI : 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据 源，然后放置一个 JNDI 上下文的数据源引用</p>
<h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的 properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///mybatis_db</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在mybatis核心配置文件中可以这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><p>为 Java 类型设置一个短的名字。为了简化映射文件 Java 类型设置，mybatis框架为我们设置好的一些常用的类型的别名：string 、long 、int 、double、boolean …</p>
<p>以查询为例，原来的类型名称配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询所有，resultType为返回的类型，需要填写全限定名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hui.domain.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用typeAliases标签起别名:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  起别名typeAlias单个起别名，package给包起别名,该包下的所有实体类不区分大小写  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.hui.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 使用相对于类路径的资源引用，例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">2. 使用完全限定资源定位符（URL），例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">《下面两种mapper代理开发中使用》</span><br><span class="line">3. 使用映射器接口实现类的完全限定类名，例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.userMapper&quot;</span>/&gt;</span></span><br><span class="line">4. 将包内的映射器接口实现全部注册为映射器，例如：(常用)</span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><p>配置各种设置，如  支持驼峰命名、延迟加载设置、缓存设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  数据库字段转驼峰命名法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>settings</strong> 与 <strong>plugins</strong> 在后面还会了解到</p>
<h1 id="Mybatis的基本API"><a href="#Mybatis的基本API" class="headerlink" title="Mybatis的基本API"></a>Mybatis的基本API</h1><p><strong>SqlSessionFactoryBuilder</strong></p>
<p>SqlSession工厂构建器，通过加载mybatis的配置文件的输入流，构建一个SqlSessionFactory对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resources工具类只是加载资源文件,在org.apache.ibatis.io 包中</span></span><br><span class="line">InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xmo&quot;</span>);</span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(stream);</span><br></pre></td></tr></table></figure>
<p><strong>SqlSessionFactory</strong></p>
<p> SqlSession工厂对象，用来构建SqlSession实例。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SqlSession openSession()</td>
<td>会默认开启一个事务，但事务不会自动提交。</td>
</tr>
<tr>
<td>SqlSession openSession(boolean autoCommit)</td>
<td>参数为true表示事务自动提交</td>
</tr>
</tbody></table>
<p> <strong>SqlSession会话对象</strong></p>
<p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务 和获取映射器实例的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 执行sql语句主要方法</span><br><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> T selectOne(String statement, Object parameter)</span><br><span class="line"><span class="tag">&lt;<span class="name">E</span>&gt;</span> List<span class="tag">&lt;<span class="name">E</span>&gt;</span> selectList(String statement, Object parameter)</span><br><span class="line">int insert(String statement, Object parameter)</span><br><span class="line">int update(String statement, Object parameter)</span><br><span class="line">int delete(String statement, Object parameter)</span><br><span class="line">// 事务相关方法</span><br><span class="line">void commit()</span><br><span class="line">void rollback()</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong></p>
<p><a href="https://imgtu.com/i/Wc4ZeP"><img src="https://z3.ax1x.com/2021/07/24/Wc4ZeP.png" alt="Wc4ZeP.png"></a></p>
<h1 id="代理开发模式"><a href="#代理开发模式" class="headerlink" title="代理开发模式"></a>代理开发模式</h1><p><strong>传统开发方式</strong></p>
<p>编写UserMapper接口=》编写UserMapper实现类=》编写UserMapper.xml映射文件</p>
<p><strong>缺点</strong></p>
<p>​        实现类中，存在mybatis模板代码重复；</p>
<p>​        实现类调用方法时，xml中的sql statement (namespace+id) 硬编码到java代码中</p>
<p><strong>代理开发模式介绍</strong></p>
<p>采用 Mybatis 的基于接口代理方式实现 持久层 的开发，这种方式是我们后面进入企业的主流。 基于接口代理方式的开发只需要程序员编写 Mapper 接口Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p><strong>这种模式需要遵循一定规范</strong></p>
<ul>
<li>Mapper.xml映射文件中的namespace与mapper接口的全限定名相同 </li>
<li>Mapper接口方法名和Mapper.xml映射文件中定义的每个statement的id相同 </li>
<li>Mapper接口方法的输入参数类型和mapper.xml映射文件中定义的每个sql的parameterType的类 型相同 </li>
<li>Mapper接口方法的输出参数类型和mapper.xml映射文件中定义的每个sql的resultType的类型相 同</li>
</ul>
<p><a href="https://imgtu.com/i/Wc5YjA"><img src="https://z3.ax1x.com/2021/07/24/Wc5YjA.png" alt="Wc5YjA.png"></a></p>
<ol>
<li><p>编写UserMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载核心配置文件</span></span><br><span class="line">    InputStream is = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得SqlSessionFactory工厂对象</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span></span><br><span class="line">        SqlSessionFactoryBuilder().build(is);</span><br><span class="line">    <span class="comment">// 获得SqlSession会话对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 获得Mapper代理对象</span></span><br><span class="line">    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    List&lt;User&gt; list = userMapper.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h1></li>
</ol>
<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p><strong>需求</strong>   根据id和username查询user表</p>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>使用 #{arg0}-#{argn} 或者 #{param1}-#{paramn} 获取参数</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(Integer id, String username)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;arg0&#125; and username = #&#123;arg1&#125;</span><br><span class="line">    <span class="comment">&lt;!-- select * from user where id=#&#123;param1&#125; and username = #&#123;param2&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：多个参数就不需要填写 parameterType </p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用注解，引入 @Param() 注解获取参数，#{} 中填写的值要与@Param中的值一样</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id, <span class="meta">@Param(&quot;username&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    select  * from user where id=#&#123;id&#125; and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用pojo对象传递参数</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByIdAndName</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdAndName3&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select  * from user where id=#&#123;id&#125; and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="与-区别"><a href="#与-区别" class="headerlink" title="${} 与 #{} 区别"></a>${} 与 #{} 区别</h3><p><strong>#{} :表示一个占位符号，连接sql时不需要手动加引号</strong></p>
<ul>
<li>通过 #{} 可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，# {}可以有效防止sql注入。</li>
<li>如果parameterType传输单个简单类型值， #{} 括号中名称随便写。</li>
</ul>
<p><strong>${} :表示拼接sql串，连接sql时需要手动加引号</strong></p>
<ul>
<li>通过 ${} 可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，会出现sql注入 问题。</li>
<li>如果parameterType传输单个简单类型值， ${} 括号中只能是value。</li>
</ul>
<h2 id="返回主键"><a href="#返回主键" class="headerlink" title="返回主键"></a>返回主键</h2><p>向数据库插入一条记录后，希望能立即拿到这条记录在数据库中的主键值。</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="方法一-useGeneratedKeys"><a href="#方法一-useGeneratedKeys" class="headerlink" title="方法一:useGeneratedKeys"></a>方法一:useGeneratedKeys</h3><p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>useGeneratedKeys=”true”    声明返回主键 </p>
<p>keyProperty=”id”   把返回主键的值，封装到实体的id属性中</p>
<p><strong>注意</strong>  只适用于主键自增的数据库，mysql和sqlserver支持，oracle不行。</p>
<h3 id="方法二-selectKey"><a href="#方法二-selectKey" class="headerlink" title="方法二:selectKey"></a>方法二:selectKey</h3><p>selectKey 适用范围广，支持所有类型数据库</p>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>keyColumn=”id” 指定主键列名 </p>
<p>keyProperty=”id” 指定主键封装到实体的id属性中 </p>
<p>resultType=”int” 指定主键类型 </p>
<p>order=”AFTER” 设置在sql语句执行前（后），执行此语句,也可以写 “BEFORE” 值</p>
<p> SELECT LAST_INSERT_ID()  该sql语句表示查询最后插入的主键id</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 代理对象</span></span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">&quot;oddDog&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;男&quot;</span>, <span class="string">&quot;土耳其&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;插入前&quot;</span>+user);</span><br><span class="line">mapper.insertUser2(user);</span><br><span class="line">System.out.println(<span class="string">&quot;插入后&quot;</span>+user);</span><br></pre></td></tr></table></figure>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>当我们要根据不同的条件，来执行不同的sql语句的时候，需要用到动态sql</p>
<h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p><strong>查询时与Where搭配</strong></p>
<p>where标签相当于 where 1=1，但是如果没有条件，就不会拼接where关键字</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            and username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改时与set搭配</strong></p>
<p>set标签在更新的时候，自动加上set关键字，然后去掉最后一个条件的逗号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday!=null&quot;</span>&gt;</span></span><br><span class="line">            birthday = #&#123;birthday&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!=null&quot;</span>&gt;</span></span><br><span class="line">            sex = #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address!=null&quot;</span>&gt;</span></span><br><span class="line">            address = #&#123;address&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>用来循环遍历，属性介绍：</p>
<ul>
<li>collection：代表要遍历的集合元素 </li>
<li>open：代表语句的开始部分 </li>
<li>close：代表结束部分 </li>
<li>item：代表遍历集合的每个元素，生成的变量名 </li>
<li>sperator：代表分隔符</li>
</ul>
<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getByIds</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<p>collection属性值为：collection 或者 list</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;collection&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getByIds</span><span class="params">(<span class="keyword">int</span>[] ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml</strong></p>
<p>collection属性值为：array</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByIds2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他地方引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p><strong>plugins标签</strong> </p>
<p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封 装，使用简单的方式即可获得分页的相关数据</p>
<p><strong>①导入通用PageHelper的坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>②在mybatis核心配置文件中配置PageHelper插件</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>③测试分页数据获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(stream);</span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 获取 代理对象</span></span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 设置分页</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行分页查询</span></span><br><span class="line">    List&lt;User&gt; userList = mapper.getAllUser();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取分页相关信息，</span></span><br><span class="line">    PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo(userList);</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示长度：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否最后一页：&quot;</span>+pageInfo.isIsLastPage());</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><strong>ResutlMap属性 : 建立对象关系映射</strong></p>
<ul>
<li>resultType 如果实体的属性名与表中字段名一致，将查询结果自动封装到实体类中 </li>
<li> ResutlMap 如果实体的属性名与表中字段名不一致，可以使用ResutlMap实现手动封装到实体类中</li>
</ul>
<p><strong>实现手动映射封装</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一般把多对一看成是一对一。</p>
<p><strong>需求</strong>   查询所有订单，与此同时查询出每个订单所属的用户</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders o <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">USER</span> u <span class="keyword">ON</span> o.uid <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure>
<p><strong>Order实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> User user; <span class="comment">// 添加字段，表示当前订单属于哪个用户</span></span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  多表查询:一对一  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ordersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property=&quot;user&quot; 封装实体的属性名</span></span><br><span class="line"><span class="comment">            javaType=&quot;user&quot; 封装实体的属性类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersWithUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ordersMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM orders o</span><br><span class="line">    LEFT JOIN USER u ON o.uid = u.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>  查询所有用户，与此同时查询出该用户具有的订单</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, o.id <span class="keyword">AS</span> oid, o.ordertime, o.total</span><br><span class="line">        <span class="keyword">FROM</span> <span class="keyword">USER</span> u</span><br><span class="line">                 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> u.id <span class="operator">=</span> o.uid</span><br></pre></td></tr></table></figure>
<p><strong>User实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Orders&gt; ordersList;<span class="comment">// 添加字段，表示当前用户的所有订单</span></span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多表查询 : 一对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                property=&quot;ordersList&quot; 封装到集合的属性名</span></span><br><span class="line"><span class="comment">                ofType=&quot;order&quot; 封装集合的泛型类型</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;ordersList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*, o.id AS oid, o.ordertime, o.total</span><br><span class="line">    FROM USER u</span><br><span class="line">    LEFT JOIN orders o ON u.id = o.uid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用。在任一一方其实都可以看成是一对多。多对多一般有一张中间表，如:</p>
<p><a href="https://imgtu.com/i/WgZHb9"><img src="https://z3.ax1x.com/2021/07/25/WgZHb9.png" alt="WgZHb9.png"></a></p>
<p><strong>需求</strong>    查询所有用户同时查询出该用户的所有角色</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, r.id <span class="keyword">AS</span> rid, r.rolename, r.roleDesc</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">USER</span> u</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys_user_role ur <span class="keyword">ON</span> u.id <span class="operator">=</span> ur.userid</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys_role r <span class="keyword">ON</span> ur.roleid <span class="operator">=</span> r.id</span><br></pre></td></tr></table></figure>
<p><strong>Order实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Role&gt; roleList;<span class="comment">// 添加字段，表示当前用户的所有角色信息</span></span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml 映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  多表查询 : 多对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_role_map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;rid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;rolename&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_role_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*, r.id AS rid, r.rolename, r.roleDesc</span><br><span class="line">    FROM USER u</span><br><span class="line">    LEFT JOIN sys_user_role ur ON u.id = ur.userid</span><br><span class="line">    LEFT JOIN sys_role r ON ur.roleid = r.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<ul>
<li>多对一（一对一）配置：使用resultMap+association做配置 </li>
<li>一对多配置：使用resultMap+collection做配置 </li>
<li>多对多配置：使用resultMap+collection做配置 </li>
<li>多对多的配置跟一对多很相似，难度在于SQL语句的编写。</li>
</ul>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>嵌套查询就是将原来多表查询中的联合查询语句拆成单个表的查询，再使用mybatis的语法嵌套在一 起。</p>
<h3 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h3><p><strong>需求</strong>   查询一个订单，与此同时查询出该订单所属的用户</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询订单</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- 再根据订单uid外键，查询用户</span></span><br><span class="line">SELECT * FROM `user` WHERE id = #&#123;订单的uid&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrderMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  嵌套查询:一对一  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderWithUser&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			根据订单中uid外键，查询用户表</span></span><br><span class="line"><span class="comment">			select:	调用 namespace+id 处sql</span></span><br><span class="line"><span class="comment">			column: 将当前查询结果的某个值传递给 select 处的sql</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.hui.entity.User&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.UserMapper.getUserById&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersWithUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderWithUser&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM orders</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过id查询</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  通过id查询  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> &gt;</span> </span><br><span class="line">    SELECT * FROM USER WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>   查询所有用户，与此同时查询出该用户具有的订单</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">-- 再根据用户id主键，查询订单列表</span></span><br><span class="line">SELECT * FROM orders where uid = #&#123;用户id&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   嵌套查询 : 一对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_order_map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据用户id，查询订单表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;ordersList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Orders&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.OrderMapper.getOrdersByUid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_order_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据uid查询</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersByUid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  根据uid查询  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersByUid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM orders WHERE uid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h3><p><strong>需求</strong>  查询用户 同时查询出该用户的所有角色</p>
<p><strong>Sql语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">-- 再根据用户id主键，查询角色列表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> role r <span class="keyword">INNER</span> <span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> r.`id` <span class="operator">=</span> ur.`rid`</span><br><span class="line">WHERE ur.`uid` = #&#123;用户id&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  嵌套查询 : 多对多  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_role_map2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hui.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据用户id，查询角色列表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hui.entity.Role&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.hui.mapper.RoleMapper.getRoleByUserid&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_role_map2&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户id获取角色信息</span></span><br><span class="line"><span class="function">List&lt;Role&gt; <span class="title">getRoleByUserid</span><span class="params">(<span class="keyword">int</span> userid)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper.xml映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRoleByUserid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM sys_role r INNER JOIN sys_user_role ur ON r.id = ur.roleid WHERE ur.userid = #&#123;userid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<ul>
<li>一对一配置：使用resultMap+association做配置，通过column条件，执行select查询</li>
<li>一对多配置：使用resultMap+collection做配置，通过column条件，执行select查询 </li>
<li>多对多配置：使用resultMap+collection做配置，通过column条件，执行select查询 </li>
</ul>
<p><strong>优点</strong>：简化多表查询操作</p>
<p><strong>缺点</strong>：执行多次sql语句，浪费数据库性能</p>
<h1 id="加载策略"><a href="#加载策略" class="headerlink" title="加载策略"></a>加载策略</h1><p><strong>延迟加载</strong>   在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。</p>
<p><strong>优点</strong>  先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表 速度要快。 </p>
<p><strong>缺点</strong>   因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时 间，所以可能造成用户等待时间变长，造成用户体验下降。</p>
<p> 一对多，多对多：通常情况下采用延迟加载 </p>
<p>一对一（多对一）：通常情况下采用立即加载 </p>
<p><strong>注意</strong>      延迟加载是基于嵌套查询来实现的</p>
<h2 id="局部延迟加载"><a href="#局部延迟加载" class="headerlink" title="局部延迟加载"></a>局部延迟加载</h2><p>在association和collection标签中都有一个fetchType属性，通过修改它的值，可以修改局部的加载策 略。例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	fetchType</span></span><br><span class="line"><span class="comment">		lazy : 延迟加载(懒加载)</span></span><br><span class="line"><span class="comment">		eager: 立即加载</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;com.lagou.dao.OrderMapper.findByUid&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局延迟加载"><a href="#全局延迟加载" class="headerlink" title="全局延迟加载"></a>全局延迟加载</h2><p>在Mybatis的核心配置文件中可以使用setting标签修改全局的加载策略。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>局部的加载策略优先级高于全局的加载策略</p>
<h2 id="设置触发延迟加载的方法"><a href="#设置触发延迟加载的方法" class="headerlink" title="设置触发延迟加载的方法"></a>设置触发延迟加载的方法</h2><p>调用当前对象的 equals、clone、hashCode、toString方法时也会触发关联对象的查询。可以在配置文件中使用lazyLoadTriggerMethods配置项覆盖掉上面四个方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有方法都会延迟加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;toString()&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数， 从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是SqlSession级别的缓存，是默认开启的。</p>
<p>参数和Sql语句完全一样的情况下，使用SelSession第一次查询后，MyBatis会将其放在缓存中，之后再次查询时，如果缓存没有刷新且没有超时，SqlSession会取缓存中的数据，而不是查询数据库。</p>
<p>可以通过log4j打印日志查看sql语句是否执行了。</p>
<p><strong>刷新缓存</strong></p>
<p>一级缓存是SqlSession范围的缓存，执行SqlSession的C（增加）U（更新）D（删除）操作，或者调 用clearCache()、commit()、close()方法，都会清空缓存。</p>
<p><strong>关闭一级缓存</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 每次查询时，都会清除缓存 --&gt;</span></span><br><span class="line">&lt; select flushCache=&quot;true&quot;&gt;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>   单条语句关闭一级缓存</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存是namspace级别（跨sqlSession）的缓存，是默认不开启的 二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的</p>
<ul>
<li>配置核心配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。</span></span><br><span class="line"><span class="comment">        为true代表开启二级缓存；为false代表不开启二级缓存。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--当前映射文件开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		useCache=”true”代表当前这个statement要使用二级缓存.</span></span><br><span class="line"><span class="comment">		如果不用就设置成 useCache=”false”</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>刷新缓存</strong></p>
<ul>
<li><p>只有SqlSession对象调用close()或commit()方法后，一级缓存中的数据会刷新到二级缓存中</p>
</li>
<li><p>映射语句文件中的所有select语句将会被缓存。  </p>
</li>
<li><p>映射语句文件中的所有insert、update和delete语句会刷新缓存。</p>
</li>
</ul>
<p><strong>注意问题（脏读）</strong> </p>
<p>mybatis的二级缓存因为是namespace级别，所以在进行多表查询时会产生脏读问题。</p>
<p><strong>小结</strong></p>
<ul>
<li> mybatis的缓存，都不需要我们手动存储和获取数据。mybatis自动维护的</li>
<li>mybatis开启了二级缓存后，那么查询顺序：二级缓存–》一级缓存–》数据库</li>
<li>mybatis的二级缓存会存在脏读问题，需要使用第三方的缓存技术解决问题。如  redis</li>
</ul>
<h1 id="Mybatis注解"><a href="#Mybatis注解" class="headerlink" title="Mybatis注解"></a>Mybatis注解</h1><p>Mybatis也可以使用注解开发方式，这样我们就可以减少编写 Mapper映射文件了。</p>
<p>只需要把代码写到Mapper接口中</p>
<h2 id="简单CRUD操作"><a href="#简单CRUD操作" class="headerlink" title="简单CRUD操作"></a>简单CRUD操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;insert into user (username,birthday,sex,address)values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用注解实现复杂映射开发"><a href="#使用注解实现复杂映射开发" class="headerlink" title="使用注解实现复杂映射开发"></a>使用注解实现复杂映射开发</h2><ul>
<li><p>@Results：可以与@Result 一起使用，封装多个结果集，代替了 resultMap</p>
</li>
<li><p>@Result：实现结果集封装，代替了   result  与  id</p>
</li>
<li><p>@One：实现一对一结果集封装，代替了   association</p>
</li>
<li><p>@Many：实现一对多结果集封装，代替了  collection</p>
</li>
</ul>
<h3 id="一对一（多对一）"><a href="#一对一（多对一）" class="headerlink" title="一对一（多对一）"></a>一对一（多对一）</h3><p><strong>需求</strong>     查询订单数据，并 将对应的用户信息查询出来</p>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    注解:一对一</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from orders&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id = true, property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;ordertime&quot;, column = &quot;ordertime&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;total&quot;, column = &quot;total&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;uid&quot;, column = &quot;uid&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.hui.mapper.UserMapper.getUserById&quot;, fetchType = FetchType.EAGER)),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrdersWithUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="一对多-2"><a href="#一对多-2" class="headerlink" title="一对多"></a>一对多</h3><p><strong>需求</strong>  查询用户数据，并将对应的订单数据查询出来</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解:一对多</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id = true,property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;username&quot;,column = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;birthday&quot;,column = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;sex&quot;,column = &quot;sex&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;address&quot;,column = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;ordersList&quot;,javaType = List.class,column = &quot;id&quot;,many = @Many(select = &quot;com.hui.mapper.OrderMapper.getOrderByUserid&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>OrdersMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    根据userid查询</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from orders where uid = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Orders&gt; <span class="title">getOrderByUserid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="多对多-2"><a href="#多对多-2" class="headerlink" title="多对多"></a>多对多</h3><p><strong>需求</strong>  查询用户时，将用户对应的角色信息查询出来</p>
<p><strong>UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解: 多对多</span></span><br><span class="line"><span class="meta">@Select(value=&quot;select * from user&quot; )</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(id=true,property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;username&quot;,column = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;birthday&quot;,column = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;sex&quot;,column = &quot;sex&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;address&quot;,column = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;roleList&quot;,javaType = List.class,column = &quot;id&quot;,many = @Many(select = &quot;com.hui.mapper.RoleMapper.getRoleByUserid&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserWithRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>RoleMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据userid获取角色信息</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM sys_role r INNER JOIN sys_user_role ur ON r.id = ur.roleid WHERE userid = #&#123;userid&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Role&gt; <span class="title">getRoleByUserid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="注解的二级缓存"><a href="#注解的二级缓存" class="headerlink" title="注解的二级缓存"></a>注解的二级缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Mapper接口中使用注解配置二级缓存</span></span><br><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解的延迟加载"><a href="#注解的延迟加载" class="headerlink" title="注解的延迟加载"></a>注解的延迟加载</h3><p>在 @One 与 @Many 注解中有 fetchType属性</p>
<ul>
<li><p>fetchType = FetchType.LAZY   表示懒加载</p>
</li>
<li><p>fetchType = FetchType.EAGER   表示立即加载 </p>
</li>
<li><p>fetchType = FetchType.DEFAULT  表示使用全局配置</p>
</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。 </li>
<li>从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。</li>
</ul>
<h1 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h1><p> MybatisPlus是一款Mybatis增强工具，用于简化开发，提高效率。  它在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 </p>
<p>​    官网： <a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a> </p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li><p><strong>数据库创建(略)</strong></p>
</li>
<li><p><strong>依赖</strong></p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>实体类</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>配置数据库信息</strong></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mp_db?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>创建Mapper接口</strong></li>
</ol>
<p>创建Mapper接口并继承BaseMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseMapper接口中已经提供了很多常用方法。所以我们只需要直接从容器中获取Mapper就可以进行操作了，不需要自己去编写Sql语句。</p>
<ol start="6">
<li><strong>创建启动类, 配置Mapper扫描</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.sangeng.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><strong>获取Mapper进行测试</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(userMapper.selectList(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h2><h3 id="设置表映射规则"><a href="#设置表映射规则" class="headerlink" title="设置表映射规则"></a>设置表映射规则</h3><p>​    默认情况下MP操作的表名就是实体类的类名，但是如果表名和类名不一致就需要我们自己设置映射规则。</p>
<h4 id="单独设置"><a href="#单独设置" class="headerlink" title="单独设置"></a>单独设置</h4><p>​    可以在实体类的类名上加上@TableName注解进行标识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局设置表名前缀"><a href="#全局设置表名前缀" class="headerlink" title="全局设置表名前缀"></a>全局设置表名前缀</h4><p>​    一般一个项目表名的前缀都是统一风格的，这个时候如果一个个设置就太麻烦了。我们可以通过配置来设置全局的表名前缀。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#表名前缀 sys_</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">sys_</span></span><br></pre></td></tr></table></figure>
<h3 id="设置主键生成策略"><a href="#设置主键生成策略" class="headerlink" title="设置主键生成策略"></a>设置主键生成策略</h3><p>​    默认情况下使用MP插入数据时，如果没有设置主键生成策略的情况下默认的策略是基于雪花算法的自增id</p>
<h4 id="单独设置-1"><a href="#单独设置-1" class="headerlink" title="单独设置"></a>单独设置</h4><p>​    如果我们需要使用别的策略可以在定义实体类时，在代表主键的字段上加上<code>@TableId</code>注解，使用其<code>type</code>属性指定主键生成策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    全部主键策略定义在了枚举类<code>IdType</code>中，<code>IdType</code>有如下的取值</p>
<ul>
<li><p><code>AUTO</code> : 数据库ID自增，<strong>依赖于数据库</strong>。该类型请确保数据库设置了 ID自增 否则无效</p>
</li>
<li><p><code>NONE</code> : 未设置主键类型。若在代码中没有手动设置主键，则会根据<strong>主键的全局策略</strong>自动生成（默认的主键全局策略是基于雪花算法的自增ID）</p>
</li>
<li><p><code>INPUT</code> : 需要手动设置主键，若不设置。插入操作生成SQL语句时，主键这一列的值会是<code>null</code>。</p>
</li>
<li><p><code>ASSIGN_ID</code> : 当没有手动设置主键，即实体类中的主键属性为空时，才会自动填充，使用雪花算法</p>
</li>
<li><p><code>ASSIGN_UUID</code> : 当实体类的主键属性为空时，才会自动填充，使用UUID</p>
</li>
</ul>
<h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># id生成策略 auto为数据库自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>
<h3 id="设置字段映射关系"><a href="#设置字段映射关系" class="headerlink" title="设置字段映射关系"></a>设置字段映射关系</h3><p>数据库的列表和实体类的属性名不一致了我们可以使用<code>@TableField</code>注解的<code>value</code>属性去设置映射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(&quot;address&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String addressStr;</span><br></pre></td></tr></table></figure>
<h3 id="设置字段和列名的驼峰映射"><a href="#设置字段和列名的驼峰映射" class="headerlink" title="设置字段和列名的驼峰映射"></a>设置字段和列名的驼峰映射</h3><p>​    默认情况下MP会开启字段名列名的驼峰映射, 如果需要关闭我们可以使用如下配置进行关闭。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">  	<span class="comment"># 关闭驼峰命名</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>​    如果需要打印MP操作对应的SQL语句等，可以配置日志输出。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>


<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>根据api的提示使用,不难</p>
<p><strong>插入数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">&quot;三更草堂333&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;7777888&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> r = userMapper.insert(user);</span><br><span class="line">    System.out.println(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ids.add(<span class="number">5</span>);</span><br><span class="line">    ids.add(<span class="number">6</span>);</span><br><span class="line">    ids.add(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteById(<span class="number">8</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteByMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;提姆&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更新操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//把id为2的用户的年龄改为14</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">2L</span>);</span><br><span class="line">    user.setAge(<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="条件构造器Wrapper"><a href="#条件构造器Wrapper" class="headerlink" title="条件构造器Wrapper"></a>条件构造器Wrapper</h2><p>​    我们在实际操作数据库的时候会涉及到很多的条件。所以MP为我们提供了一个功能强大的条件构造器 <code>Wrapper</code> 。使用它可以让我们非常方便的构造条件。</p>
<p>​    其继承体系如下：</p>
<p>​    <a href="https://imgtu.com/i/bQZLh6"><img src="https://s4.ax1x.com/2022/03/01/bQZLh6.png" alt="bQZLh6.png"></a></p>
<p>​    在其子类<code>AbstractWrapper</code>中提供了很多用于构造Where条件的方法。</p>
<ul>
<li><p>QueryWrapper则额外提供了用于针对Select语法的<code>select</code>方法。可以用来设置查询哪些列。</p>
</li>
<li><p>UpdateWrapper则额外提供了用于针对SET语法的<code>set</code>方法。可以用来设置对哪些列进行更新。</p>
</li>
</ul>
<p>​    完整的AbstractWrapper方法可以参照：<a href="https://baomidou.com/guide/wrapper.html#abstractwrapper">https://baomidou.com/guide/wrapper.html#abstractwrapper</a></p>
<h3 id="AbstractWrapper常用方法"><a href="#AbstractWrapper常用方法" class="headerlink" title="AbstractWrapper常用方法"></a>AbstractWrapper常用方法</h3><blockquote>
<p>eq：equals，等于<br>gt：greater than ，大于 &gt;<br>ge：greater than or equals，大于等于≥<br>lt：less than，小于&lt;<br>le：less than or equals，小于等于≤<br>between：相当于SQL中的BETWEEN<br>like：模糊匹配。like(“name”,”黄”)，相当于SQL的name like ‘%黄%’<br>likeRight：模糊匹配右半边。likeRight(“name”,”黄”)，相当于SQL的name like ‘黄%’<br>likeLeft：模糊匹配左半边。likeLeft(“name”,”黄”)，相当于SQL的name like ‘%黄’<br>notLike：notLike(“name”,”黄”)，相当于SQL的name not like ‘%黄%’<br>isNull<br>isNotNull<br>and：SQL连接符AND<br>or：SQL连接符OR</p>
<p>in: in(“age”,{1,2,3})相当于 age in(1,2,3)</p>
<p>groupBy: groupBy(“id”,”name”)相当于 group by id,name</p>
<p>orderByAsc :orderByAsc(“id”,”name”)相当于 order by id ASC,name ASC</p>
<p>orderByDesc :orderByDesc (“id”,”name”)相当于 order by id DESC,name DESC</p>
</blockquote>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>SQL语句如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">	USER </span><br><span class="line">WHERE </span><br><span class="line">	age &gt; 18 AND address &#x3D; &#39;狐山&#39;</span><br></pre></td></tr></table></figure>
<p>Wrapper写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrapper01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper wrapper = <span class="keyword">new</span> QueryWrapper();</span><br><span class="line">    wrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    wrapper.eq(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;狐山&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">	USER </span><br><span class="line">WHERE </span><br><span class="line">	id IN(1,2,3) AND </span><br><span class="line">	age BETWEEN 12 AND 29 AND </span><br><span class="line">	address LIKE &#39;%山%&#39;</span><br></pre></td></tr></table></figure>
<p>Wrapper写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrapper02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.in(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    wrapper.between(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>,<span class="number">29</span>);</span><br><span class="line">    wrapper.like(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;山&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">	USER </span><br><span class="line">WHERE </span><br><span class="line">	id IN(1,2,3) AND </span><br><span class="line">	age &gt; 10 </span><br><span class="line">ORDER BY </span><br><span class="line">	age DESC</span><br></pre></td></tr></table></figure>
<p>Wrapper写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrapper03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.in(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    queryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><pre><code> QueryWrapper的 select 可以设置要查询的列。
</code></pre>
<h4 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h4><blockquote>
<p>select(String… sqlSelect) 方法的测试为要查询的列名</p>
</blockquote>
<p><strong>SQL语句如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name</span><br><span class="line">FROM </span><br><span class="line">	USER </span><br></pre></td></tr></table></figure>
<p><strong>MP写法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;user_name&quot;</span>); </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h4><blockquote>
<p>select(Class<T> entityClass, Predicate<TableFieldInfo> predicate)</p>
</blockquote>
<p>方法的第一个参数为实体类的字节码对象，第二个参数为Predicate类型，可以使用lambda的写法，过滤要查询的字段 (主键除外) 。</p>
<p><strong>SQL语句如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name</span><br><span class="line">FROM </span><br><span class="line">	USER </span><br></pre></td></tr></table></figure>
<p><strong>MP写法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.select(User.class, <span class="keyword">new</span> Predicate&lt;TableFieldInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(TableFieldInfo tableFieldInfo)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只查询 &#x27;user_name&#x27;字段(&#x27;id&#x27;字段会默认查询)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;user_name&quot;</span>.equals(tableFieldInfo.getColumn());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例三-1"><a href="#示例三-1" class="headerlink" title="示例三"></a>示例三</h4><blockquote>
<p>select(Predicate<TableFieldInfo> predicate)</p>
</blockquote>
<p>方法第一个参数为Predicate类型，可以使用lambda的写法，过滤要查询的字段 (主键除外) 。</p>
<p><strong>SQL语句如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name,PASSWORD,NAME,age </span><br><span class="line">FROM </span><br><span class="line">	USER</span><br></pre></td></tr></table></figure>
<p><strong>MP写法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;(<span class="keyword">new</span> User()); <span class="comment">// 要传入一个实体类</span></span><br><span class="line">    queryWrapper.select(<span class="keyword">new</span> Predicate&lt;TableFieldInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(TableFieldInfo tableFieldInfo)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 除了&#x27;address&#x27;字段,其他都查询</span></span><br><span class="line">            <span class="keyword">return</span> !<span class="string">&quot;address&quot;</span>.equals(tableFieldInfo.getColumn());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p>​        我们前面在使用update方法时需要创建一个实体类对象传入，用来指定要更新的列及对应的值。但是如果需要更新的列比较少时，创建这么一个对象显的有点麻烦和复杂。</p>
<p>​        我们可以使用UpdateWrapper的set方法来设置要更新的列及其值。同时这种方式也可以使用Wrapper去指定更复杂的更新条件。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE </span><br><span class="line">	USER</span><br><span class="line">SET </span><br><span class="line">	age &#x3D; 99</span><br><span class="line">where </span><br><span class="line">	id &gt; 1</span><br></pre></td></tr></table></figure>
<p>MP写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWrapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">    updateWrapper.set(<span class="string">&quot;age&quot;</span>,<span class="number">99</span>);  <span class="comment">// set age=99</span></span><br><span class="line">    updateWrapper.gt(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);	  <span class="comment">// where id&gt;1</span></span><br><span class="line">    userMapper.update(<span class="keyword">null</span>,updateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda条件构造器"><a href="#Lambda条件构造器" class="headerlink" title="Lambda条件构造器"></a>Lambda条件构造器</h3><p>​    我们前面在使用条件构造器时列名都是用字符串的形式去指定。这种方式无法在编译期确定列名的合法性。</p>
<p>​    所以MP提供了一个Lambda条件构造器可以让我们直接以实体类的方法引用的形式来指定列名。这样就可以弥补上述缺陷。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>要执行的查询对应的SQL如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">	USER </span><br><span class="line">WHERE </span><br><span class="line">	age &gt; 18 AND address &#x3D; &#39;狐山&#39;</span><br></pre></td></tr></table></figure>
<p>Lambda条件构造器写法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLambdaWrapper2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.gt(User::getAge,<span class="number">18</span>);</span><br><span class="line">    queryWrapper.eq(User::getAddress,<span class="string">&quot;狐山&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h2><p>​    因为MP是对mybatis做了增强，所以还是支持之前Mybatis的方式去自定义方法。</p>
<p>​    同时也支持在使用Mybatis的自定义方法时使用MP的<strong>条件构造器</strong>帮助我们进行条件构造。</p>
<h3 id="Mybatis方式"><a href="#Mybatis方式" class="headerlink" title="Mybatis方式"></a>Mybatis方式</h3><p>​    在Mapper接口中定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findMyUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    配置xml文件的存放目录</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>
<p>​    创建xml映射文件 , 编写对应的SQL语句</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.sangeng.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;findMyUser&quot;</span> resultType=<span class="string">&quot;com.sangeng.domian.User&quot;</span>&gt;</span><br><span class="line">       select * from user where id = #&#123;id&#125; </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Mybatis方式结合条件构造器"><a href="#Mybatis方式结合条件构造器" class="headerlink" title="Mybatis方式结合条件构造器"></a>Mybatis方式结合条件构造器</h3><p>①方法定义中添加Warpper类型的参数</p>
<p>​    添加Warpper类型的参数，并且要注意给其指定参数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findMyUserByWrapper</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;User&gt; wrapper)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②在SQL语句中获取Warpper拼接的SQL片段进行拼接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findMyUserByWrapper&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sangeng.domian.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：不能使用#{}应该用${}</p>
<h2 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h2><h3 id="基本分页查询"><a href="#基本分页查询" class="headerlink" title="基本分页查询"></a>基本分页查询</h3><p>①配置分页查询拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3.4.0之前的版本</span></span><br><span class="line">   <span class="comment">/* @Bean</span></span><br><span class="line"><span class="comment">    public PaginationInterceptor paginationInterceptor()&#123;</span></span><br><span class="line"><span class="comment">        return  new PaginationInterceptor();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.4.0之后版本</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">       MybatisPlusInterceptor mybatisPlusInterceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">       mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor());</span><br><span class="line">       <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②进行分页查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IPage&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;();</span><br><span class="line">    <span class="comment">//设置每页条数</span></span><br><span class="line">    page.setSize(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置查询第几页</span></span><br><span class="line">    page.setCurrent(<span class="number">1</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 查询后的信息会保存到 page 中</span></span><br><span class="line">    System.out.println(page.getRecords());<span class="comment">//获取当前页的数据</span></span><br><span class="line">    System.out.println(page.getTotal());<span class="comment">//获取总记录数</span></span><br><span class="line">    System.out.println(page.getCurrent());<span class="comment">//当前页码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多表分页查询"><a href="#多表分页查询" class="headerlink" title="多表分页查询"></a>多表分页查询</h3><p>​    如果需要在多表查询时进行分页查询的话，需自定义接口，接口接收Page对象参数</p>
<ol>
<li>定义方法,接收 page 类型参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Orders</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">IPage&lt;Orders&gt; <span class="title">findAllOrders</span><span class="params">(Page&lt;Orders&gt; page)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在xml中不需要关心分页操作，MP会帮我们完成</p>
</li>
<li><p>调用方法测试</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrdersMapper ordersMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrdersPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Page&lt;Orders&gt; page = <span class="keyword">new</span> Page&lt;&gt;();</span><br><span class="line">    <span class="comment">//设置每页大小</span></span><br><span class="line">    page.setSize(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置当前页码</span></span><br><span class="line">    page.setCurrent(<span class="number">2</span>);</span><br><span class="line">    ordersMapper.findAllOrders(page);</span><br><span class="line">    System.out.println(page.getRecords()); <span class="comment">// 获取查询数据</span></span><br><span class="line">    System.out.println(page.getTotal());   <span class="comment">// 获取总数据条数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Service-层接口"><a href="#Service-层接口" class="headerlink" title="Service 层接口"></a>Service 层接口</h2><p>​    MP也为我们提供了Service层的实现。我们只需要编写一个service接口，继承<code>IService</code>，并创建一个接口实现类并继承<code>ServiceImpl</code></p>
<p><strong>service接口继承 IService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现类继承 ServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>,<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSeervice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; list = userService.list();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>​    MP提供了一个代码生成器，可以让我们一键生成实体类，Mapper接口，Service，Controller等全套代码 。使用方式如下</p>
<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatisplus代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成</li>
</ol>
<p>​    修改相应配置后执行以下代码即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AutoGenerator generator = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 全局配置</span></span><br><span class="line">		GlobalConfig config = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">		String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">		<span class="comment">// 设置输出到的目录</span></span><br><span class="line">		config.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">		config.setAuthor(<span class="string">&quot;hui&quot;</span>);</span><br><span class="line">		<span class="comment">// 生成结束后是否打开文件夹</span></span><br><span class="line">		config.setOpen(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 全局配置添加到 generator 上</span></span><br><span class="line">		generator.setGlobalConfig(config);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数据源配置</span></span><br><span class="line">		DataSourceConfig dataSourceConfig = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">		dataSourceConfig.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mp_db?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">		dataSourceConfig.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		dataSourceConfig.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		dataSourceConfig.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数据源配置添加到 generator</span></span><br><span class="line">		generator.setDataSource(dataSourceConfig);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 包配置, 生成的代码放在哪个包下</span></span><br><span class="line">		PackageConfig packageConfig = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">		packageConfig.setParent(<span class="string">&quot;com.hui.generator&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 包配置添加到 generator</span></span><br><span class="line">		generator.setPackageInfo(packageConfig);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 策略配置</span></span><br><span class="line">		StrategyConfig strategyConfig = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">		<span class="comment">// 下划线驼峰命名转换</span></span><br><span class="line">		strategyConfig.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">		strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">		<span class="comment">// 开启lombok</span></span><br><span class="line">		strategyConfig.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// 开启RestController</span></span><br><span class="line">		strategyConfig.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">		generator.setStrategy(strategyConfig);</span><br><span class="line">		generator.setTemplateEngine(<span class="keyword">new</span> FreemarkerTemplateEngine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始生成</span></span><br><span class="line">		generator.execute();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><p>​    一般表中有<strong>更新时间</strong>，<strong>创建时间</strong>，<strong>创建人，更新人</strong>等字段。</p>
<p>​    我们可以使用 <code>@TableField</code> 的 <code>fill</code>  属性来设置字段的自动填充。让我们能更方便的更新相关字段。</p>
<ol>
<li><strong>在对应字段上增加注解</strong></li>
</ol>
<p>​    使用TableField注解的fill属性来标注哪些字段需要在自动填充，加了注解MP才会在对应的SQL中为我们预留字段。而属性值代表我们在什么进行什么操作时需要预留字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新时间,插入或修改时自动填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建时间,插入时自动填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>自定义填充处理器  MetaObjectHandler</strong> </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入语句时要进行的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改语句时要进行的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>​    MP也支持逻辑删除的处理。我们只需要配置好逻辑删除的实体字段名，代表删除的字段值和代表未删除的字段值后即可。</p>
<p>​    注意：如果3.3.0版本之前还需要在对应的字段上加上<code>@TableLogic</code>注解</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">delFlag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure>
<p>添加了以上配置,</p>
<ul>
<li>在删除数据时, 执行的SQL语句是 update 操作,将 delFlag设置为1 .</li>
<li>在查询数据时,会添加条件 : where delFlag = 0</li>
</ul>
<p>over…</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>SSM</tag>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2021/07/27/spring/</url>
    <content><![CDATA[<p>Spring是分层的 Java SE/EE应用  full-stack(全栈式) 轻量级开源框架。 提供了表现层 SpringMVC和持久层 Spring JDBC Template以及 业务层 事务管理等众多的企业级应用 技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框 架。<a id="more"></a> </p>
<p><strong>两大核心</strong>      IOC（Inverse Of Control：控制反转）     AOP（Aspect Oriented Programming：面向 切面编程）   </p>
<p><strong>spring优势</strong></p>
<p>1）方便解耦，简化开发 </p>
<p>​        Spring就是一个容器，可以将所有对象创建和关系维护交给Spring管理 什么是耦合度？对象之间的关系，通常说当一个模块(对象)更改时也需要更改其他模块(对象)，这就是 耦合，耦合度过高会使代码的维护成本增加。要尽量解耦 </p>
<p>2）AOP编程的支持 </p>
<p>​        Spring提供面向切面编程，方便实现程序进行权限拦截，运行监控等功能。 </p>
<p>3）声明式事务的支持 </p>
<p>​        通过配置完成事务的管理，无需手动编程 </p>
<p>4）方便测试，降低JavaEE API的使用</p>
<p>​         Spring对Junit4支持，可以使用注解测试 </p>
<p>5）方便集成各种优秀框架 </p>
<p>​        不排除各种优秀的开源框架，内部提供了对各种优秀框架的直接支持</p>
<p><strong>Spring体系结构</strong></p>
<p><a href="https://imgtu.com/i/WhbcaF"><img src="https://z3.ax1x.com/2021/07/27/WhbcaF.png" alt="WhbcaF.png"></a></p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC概述"><a href="#IOC概述" class="headerlink" title="IOC概述"></a>IOC概述</h3><p><strong>控制反转</strong>（Inverse Of Control）不是什么技术，而是一种设计思想。它的目的是指导我们设计出更 加松耦合的程序。 </p>
<ul>
<li><strong>控制</strong>：在java中指的是对象的控制权限（创建、销毁） </li>
<li><strong>反转</strong>：指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 传统方式</span><br><span class="line">	之前我们需要一个userDao实例，需要开发者自己手动创建 new UserDao();</span><br><span class="line">* IOC方式</span><br><span class="line">	现在我们需要一个userDao实例，直接从spring的IOC容器获得，对象的创建权交给了spring控制</span><br></pre></td></tr></table></figure>
<h3 id="自定义IOC容器"><a href="#自定义IOC容器" class="headerlink" title="自定义IOC容器"></a>自定义IOC容器</h3><p><strong>需求</strong>    实现service层与dao层代码解耦合</p>
<p><strong>步骤</strong></p>
<ol>
<li><p>创建java项目，导入自定义IOC相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Dao接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDaoImpl:保存成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写Service接口和实现类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		UserDao userDao = <span class="keyword">new</span> UserDaoImpl();  <span class="comment">// 创建dao层接口</span></span><br><span class="line">        userDao.save();  <span class="comment">// 调用dao层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 直接new创建对象</span></span><br><span class="line">      UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">      userService.save();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>问题</strong> </p>
<p>当前service对象和dao对象耦合度太高，而且每次new的都是一个新的对象，导致服务器压力过大。</p>
<p><code>解耦合的原则是编译期不依赖，而运行期依赖就行了。</code></p>
<p><strong>解决思路</strong></p>
<p>我们可以通过反射创建对象，这样可以一定程度降低耦合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService userService = (UserService) Class.forName(<span class="string">&quot;com.com.hui.service.impl.UserServiceImpl&quot;</span>).getConstructor().newInstance();</span><br></pre></td></tr></table></figure>
<p>但是这样依旧会每次都创建对象，并且存在硬编码问题。</p>
<p>我们可以定义一个容器，用来保存需要用到的对象，需要用时就从容器中获取，有点像单例模式。</p>
<p>对于硬编码问题，我们可以定义配置文件。</p>
<p><strong>编写自定义beans.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义，将需要创建的对象编写到bean中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写MyBeanFactory工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存对象的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 静态代码块，只执行一次。</span></span><br><span class="line">    <span class="comment">// 读取配置文件,利用反射创建相关的对象，保存到容器中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            InputStream stream = MyBeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;Bean.xml&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建SAXReader对象，解析配置文件</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(stream);</span><br><span class="line">            <span class="comment">// 通过 xpath 获取所有的 bean 标签</span></span><br><span class="line">            List&lt;Element&gt; list = document.selectNodes(<span class="string">&quot;//bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Element element : list) &#123;</span><br><span class="line">                String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String className = element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                <span class="comment">// 利用反射创建对象,并放入 IOC容器 种</span></span><br><span class="line">                Object o = Class.forName(className).getConstructor().newInstance();</span><br><span class="line">                ioc.put(id, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从ioc容器中获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ioc.get(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改UserServiceImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 从容器中获取</span></span><br><span class="line">        userDao = (UserDao) BeanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 使用自定义IOC容器获取对象</span></span><br><span class="line">      UserService userService = (UserService) MyBeanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">      userService.save();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring基本使用"><a href="#Spring基本使用" class="headerlink" title="Spring基本使用"></a>Spring基本使用</h2><p><strong>需求</strong>   借助spring的IOC实现service层与dao层代码解耦合</p>
<p><strong>1）创建项目，导入spring依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2) 编写service层 与 dao层的接口与实现类</strong>  (省略，上面有)</p>
<p><strong>3）创建spring核心配置文件,并配置需要容器管理的对象</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>4)测试，使用spring相关API获得Bean实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    UserDao userDao = (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring相关API"><a href="#Spring相关API" class="headerlink" title="Spring相关API"></a>Spring相关API</h2><p><strong>API继承体系介绍</strong></p>
<p>Spring的API体系异常庞大，我们现在只关注两个BeanFactory和ApplicationContext</p>
<p><a href="https://imgtu.com/i/W4AhDO"><img src="https://z3.ax1x.com/2021/07/27/W4AhDO.png" alt="W4AhDO.png"></a></p>
<h3 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h3><p>BeanFactory是 IOC 容器的核心接口，它定义了IOC的基本功能。</p>
<p><strong>特点</strong>     在第一次调用getBean()方法时，创建指定对象的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    UserService userService = (UserService) factory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h3><p>代表应用上下文对象，可以获得spring中IOC容器的Bean对象。 </p>
<p><strong>特点</strong>    在spring容器启动时，加载并创建所有对象的实例</p>
<p><strong>常用实现类</strong></p>
<ol>
<li>ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种。 </li>
<li> FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 </li>
<li> AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</li>
</ol>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;C:\\applicationContext.xml&quot;</span>);</span><br><span class="line">UserService userService = (UserService)context.getBean(<span class="string">&quot;useService&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object getBean(String name)</td>
<td>根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</td>
</tr>
<tr>
<td>T getBean(Class requiredType)</td>
<td>根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</td>
</tr>
<tr>
<td>T getBean(String name,Class requiredType)</td>
<td>根据Bean的id和类型获得Bean实例，解决容器中相同类型Bean有多个情况。</td>
</tr>
</tbody></table>
<h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><h3 id="Bean标签基本属性"><a href="#Bean标签基本属性" class="headerlink" title="Bean标签基本属性"></a>Bean标签基本属性</h3><p><strong>id</strong>             Bean实例在Spring容器中的唯一标识 </p>
<p><strong>class</strong>        Bean的全限定名</p>
<p><strong>scope</strong>      属性指对象的作用范围，取值如下：</p>
<table>
<thead>
<tr>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认值，单例。当应用加载，创建容器时，对象就被创建了；销毁容器时，对象就被销毁了</td>
</tr>
<tr>
<td>prototype</td>
<td>多例。当对象被使用时，创建新对象实例。当对象长时间不用时，被 Java 的垃圾回收器回收了</td>
</tr>
<tr>
<td>request</td>
<td>WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td>session</td>
<td>WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td>global</td>
<td>sessionWEB项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession 相当于 session</td>
</tr>
</tbody></table>
<p><strong>init-method</strong>          指定类中的初始化方法名称</p>
<p><strong>destroy-method</strong>    指定类中销毁方法名称</p>
<h3 id="Bean实例化三种方式"><a href="#Bean实例化三种方式" class="headerlink" title="Bean实例化三种方式"></a>Bean实例化三种方式</h3><p><strong>无参构造方法实例化</strong> </p>
<p>它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>工厂静态方法实例化</strong> </p>
<p>应用场景 ：依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁使用 B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类 中的m1方法，直接从IOC容器获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.A&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;m1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>工厂普通方法实例化</strong></p>
<p>应用场景 ： 依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁使用 B对象， 此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1 方法，直接从IOC容器获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.A&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;a&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;m1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Bean依赖注入"><a href="#Bean依赖注入" class="headerlink" title="Bean依赖注入"></a>Bean依赖注入</h3><p><strong>依赖注入 DI（Dependency Injection）</strong>    它是 Spring 框架核心 IOC 的具体实现。</p>
<p>通过框架把一个对象传入到另一个对象中，程序之间的依赖交给Spring来维护。</p>
<h4 id="构造方法依赖注入"><a href="#构造方法依赖注入" class="headerlink" title="构造方法依赖注入"></a>构造方法依赖注入</h4><p><strong>在UserServiceImpl中创建有参构造</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要注入的对象</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DI 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();<span class="comment">// 调用dao层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置Spring容器调用有参构造时进行注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  DI 构造方法注入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过参数的顺序注入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;constructor-arg index=&quot;0&quot; type=&quot;com.hui.dao.UserDao&quot; ref=&quot;userDao&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--直接通过名称注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="set方法依赖注入"><a href="#set方法依赖注入" class="headerlink" title="set方法依赖注入"></a>set方法依赖注入</h4><p><strong>在UserServiceImpl中创建set方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置Spring容器调用set方法进行注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  DI set方法注入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>set方法还有一种方式：P命名空间注入</strong></p>
<p>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件 中，如下：</p>
<ol>
<li><p>首先，需要引入P命名空间</p>
<p><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
</li>
<li><p>其次，需要修改注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Bean依赖注入的数据类型"><a href="#Bean依赖注入的数据类型" class="headerlink" title="Bean依赖注入的数据类型"></a>Bean依赖注入的数据类型</h4></li>
</ol>
<p>注入数据的三种数据类型</p>
<p><strong>引用数据类型</strong> </p>
<p>上面操作，注入bean对象都是引用数据类型，也是最常用的</p>
<p><strong>普通数据类型</strong> </p>
<p>直接给property标签中的value赋值即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lagou.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>集合数据类型</strong></p>
<ul>
<li>List集合</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--    List    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;aaaaaa&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Set集合</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--    Set   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;bbbbb&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Array数组</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--    Array    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&quot;ccc&quot;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Map集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--    map    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>properties配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.User&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    properties    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置文件模块化"><a href="#配置文件模块化" class="headerlink" title="配置文件模块化"></a>配置文件模块化</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分 配置拆解到其他配置文件中，也就是所谓的配置文件模块化。</p>
<p><strong>并列的多个配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载配置文件时读取多个</span></span><br><span class="line">ApplicationContext act = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;beans1.xml&quot;</span>,<span class="string">&quot;beans2.xml&quot;</span>,<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>主从配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--主配置文件中引入从配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  </p>
<ul>
<li><p>同一个xml中不能出现相同名称的bean,如果出现会报错 </p>
</li>
<li><p>多个xml如果出现相同名称的bean，不会报错，但是后加载的会覆盖前加载的bean</p>
</li>
</ul>
<h2 id="Spring整合DbUtils"><a href="#Spring整合DbUtils" class="headerlink" title="Spring整合DbUtils"></a>Spring整合DbUtils</h2><p><strong>需求</strong>   基于Spring的xml配置实现账户的查询案例</p>
<p><strong>1.准备数据库环境</strong>    省略</p>
<p><strong>2.创建java项目，导入坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.编写Account实体类</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner; <span class="comment">// 需要注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueryRunner</span><span class="params">(QueryRunner queryRunner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queryRunner = queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;select * from account where id = ?&quot;</span>;</span><br><span class="line">            Account query = queryRunner.query(sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), id);</span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao; <span class="comment">// 需要注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.getAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.编写spring核心配置文件</strong> </p>
<p>applicationContext.xm</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_db&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  queryRunner,使用构造方法注入 DataSource对象  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  accountDao  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queryRunner&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  accountService  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>7.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载spring 配置文件</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对象</span></span><br><span class="line">    Account  accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">   	<span class="comment">// 执行查询操作，并输出</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8.抽取jdbc配置文件</strong></p>
<p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。 </p>
<p>首先，需要引入context命名空间和约束路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命名空间：</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">约束路径：</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context	</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改主配置文件，使用  <strong>context:property-placeholder</strong> 标签引入JDBC数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  导入 JDBC 数据源，建议加上  classpath:  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代 替xml配置文件可以简化配置，提高开发效率。</p>
<h3 id="Spring常用注解"><a href="#Spring常用注解" class="headerlink" title="Spring常用注解"></a>Spring常用注解</h3><p>Spring常用注解主要是替代 Bean 的配置</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Controller</td>
<td>使用在web层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Service</td>
<td>使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Repository</td>
<td>使用在dao层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用,根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Resource</td>
<td>相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td>@Value</td>
<td>注入普通属性</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>使用在方法上标注该方法是Bean的初始化方法</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody></table>
<p><strong>说明</strong>      JDK11以后完全移除了javax扩展导致不能使用@resource注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要maven引入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包 下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring常用注解整合DBUtils"><a href="#Spring常用注解整合DBUtils" class="headerlink" title="Spring常用注解整合DBUtils"></a>Spring常用注解整合DBUtils</h3><p><strong>修改AccountDaoImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Qualifier(&quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;select * from account where id = ?&quot;</span>;</span><br><span class="line">            Account query = queryRunner.query(sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), id);</span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改AccountServiceImpl实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Qualifier(&quot;accountDao&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.getAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--删除accountDao与accountService的bean标签--&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解方式加载配置</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对下个</span></span><br><span class="line">    AccountService accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询操作，并输出结果</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h3><p>使用上面的注解还不能全部替代xml配置文件，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 非自定义的Bean的配置：&lt;bean&gt;</span><br><span class="line">* 加载properties文件的配置：&lt;context:property-placeholder&gt;</span><br><span class="line">* 组件扫描的配置：&lt;context:component-scan&gt;</span><br><span class="line">* 引入其他文件：&lt;import&gt;</span><br></pre></td></tr></table></figure>
<p>这时要用到新的注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Configuration</td>
<td>用于指定当前类是一个Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>用于加载 properties 文件中的配置</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring 在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Import</td>
<td>用于导入其他配置类</td>
</tr>
</tbody></table>
<h3 id="Spring纯注解整合DBUtils"><a href="#Spring纯注解整合DBUtils" class="headerlink" title="Spring纯注解整合DBUtils"></a>Spring纯注解整合DBUtils</h3><p><strong>编写Spring核心配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 标记为spring配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hui&quot;)</span> <span class="comment">// context:component-scan 标签，用于扫描注解包</span></span><br><span class="line"><span class="meta">@Import(DataSourceConfig.class)</span>  <span class="comment">// 引入数据库配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;queryRunner&quot;)</span> <span class="comment">//id属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">getQueryRunner</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写数据库配置信息类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:JDBC.properties&quot;)</span>  <span class="comment">// context:property-placeholder 标签，引入外部资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>纯注解测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解方式加载配置</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationContext.class);</span><br><span class="line">    <span class="comment">// 从IOC容器中获取AccountService对下个</span></span><br><span class="line">    AccountService accountService = (AccountService) context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行查询操作，并输出结果</span></span><br><span class="line">    System.out.println(accountService.getAccountById(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><p>在普通的测试类中，需要开发者手动加载配置文件并创建Spring容器，然后通过Spring相关API获得 Bean实例；如果不这么做，那么无法从容器中获得对象。</p>
<p>我们可以让SpringJunit负责创建Spring容器来简化这个操作，开发者可以直接在测试类注入Bean实 例；但是需要将配置文件的名称告诉它。</p>
<p><strong>1.导入spring集成Junit的坐标</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.创建测试类</strong></p>
<ul>
<li><p>使用@Runwith注解替换原来的运行器</p>
</li>
<li><p>使用@ContextConfiguration指定配置文件或配置类</p>
</li>
<li><p>使用@Autowired注入需要测试的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换原来的运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;) </span></span><br><span class="line"><span class="comment">// 引入配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;ApplicationContext.class&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService; <span class="comment">// 可以直接从IOC容器中获取</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = accountService.getAccountById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="实现传统的转账案例"><a href="#实现传统的转账案例" class="headerlink" title="实现传统的转账案例"></a>实现传统的转账案例</h2><p><strong>需求</strong>  使用spring框架整合DBUtils技术，实现用户转账功能</p>
<h3 id="实现基础功能"><a href="#实现基础功能" class="headerlink" title="实现基础功能"></a>实现基础功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建java项目，导入坐标</span><br><span class="line">2. 编写Account实体类</span><br><span class="line">3. 编写AccountDao接口和实现类</span><br><span class="line">4. 编写AccountService接口和实现类</span><br><span class="line">5. 编写spring核心配置文件</span><br><span class="line">6. 编写测试代码</span><br></pre></td></tr></table></figure>
<p><strong>1.创建java项目，导入坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.编写Account实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">// setter getter....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">            queryRunner.update(sql, money, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">&quot;update account set money=money-? where name=?&quot;</span>;</span><br><span class="line">            queryRunner.update(sql, money, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName,String inName,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载jdbc配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--把数据库连接池交给IOC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--把QueryRunner交给IOC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>6.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100d</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>上面的代码事务在dao层，转出转入操作都是一个独立的事务，但实际开发，应该把业务逻辑控制在 一个事务中，所以应该将事务挪到service层。</p>
<h3 id="实现传统事务"><a href="#实现传统事务" class="headerlink" title="实现传统事务"></a>实现传统事务</h3><p><strong>给上面业务层的转账操作添加事务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 编写线程绑定工具类</span><br><span class="line">2. 编写事务管理器</span><br><span class="line">3. 修改service层代码</span><br><span class="line">4. 修改dao层代码</span><br></pre></td></tr></table></figure>
<p><strong>1.编写线程绑定工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接工具类，从数据源中获取一个连接，并将实现和当前线程的绑定</span></span><br><span class="line"><span class="meta">@Component(&quot;connectionUtils&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal是当前线程上的本地存储，也能把它当作一个Map集合，只不过key值是当前线程</span></span><br><span class="line">    <span class="comment">// ThreadLocal类有get() 、set(Object obj) 、remove()方法</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程上的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = threadLocal.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次获取该值为空，要从连接池中获取，并放入 threadLocal 中以便后续使用</span></span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection = dataSource.getConnection();</span><br><span class="line">                threadLocal.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除当前线程上的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.编写事务管理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务管理器工具类，包含：开启事务、提交事务、回滚事务、释放资源</span></span><br><span class="line"><span class="comment">// connectionUtils.getThreadConnection();  方法都是在同一个线程中调用，所以获取的连接都是同一个</span></span><br><span class="line"><span class="meta">@Component(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 从IOC容器中获取连接工具类</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取消自动提交</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = connectionUtils.getThreadConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启自动提交，把原先的手动提交改回自动提交</span></span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 当前线程绑定的连接返还给连接池</span></span><br><span class="line">            connectionUtils.getThreadConnection().close();</span><br><span class="line">            <span class="comment">// 解除当前线程的绑定</span></span><br><span class="line">            connectionUtils.removeThreadConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.修改service层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 从IOC容器中获取事务管理器工具类</span></span><br><span class="line"><span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转账</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        transactionManager.beginTransaction();</span><br><span class="line">        <span class="comment">// 执行原先的业务代码</span></span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        transactionManager.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 回滚事务</span></span><br><span class="line">        transactionManager.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        transactionManager.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.修改dao层代码</strong></p>
<p>queryRunner对象执行sql可以在第一个参数中传递一个连接，表示用该连接去执行sql，我们可以使用连接工具类connectionUtils获取当前线程的连接，这样就能保证两条sql使用的是同一条连接。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"><span class="comment">// 入账</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">        <span class="comment">// 第一个参数可传递一个 连接 ，从 connectionUtils 中获取，因为是同一条线程，这样就能获取同一条连接</span></span><br><span class="line">        queryRunner.update(connectionUtils.getThreadConnection(), sql, money, name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>上面代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了 一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦 合了，违背了面向对象的开发思想。</p>
<h2 id="Proxy优化转账案例"><a href="#Proxy优化转账案例" class="headerlink" title="Proxy优化转账案例"></a>Proxy优化转账案例</h2><p>我们可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样 就不会对业务层产生影响，解决了耦合性的问题</p>
<p><strong>常用的动态代理技术</strong></p>
<p><strong>JDK 代理</strong>  基于接口的动态代理技术：利用拦截器（必须实现invocationHandler）加上反射机制生成 一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理，从而实现方法增强 </p>
<p><strong>CGLIB代理</strong>  基于父类的动态代理技术：动态生成一个要代理的子类，子类重写要代理的类的所有不是 final的方法。在子类中采用方法拦截技术拦截所有的父类方法的调用，顺势织入横切逻辑，对方法进行 增强</p>
<p><a href="https://imgtu.com/i/WLwQ6U"><img src="https://z3.ax1x.com/2021/07/30/WLwQ6U.png" alt="WLwQ6U.png"></a></p>
<h3 id="JDK-代理"><a href="#JDK-代理" class="headerlink" title="JDK 代理"></a>JDK 代理</h3><p><strong>编写JDK动态代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;jDKProxyAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 AccountServiceImpl 的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceImplProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 开启事务</span></span><br><span class="line">                    transactionManager.beginTransaction();</span><br><span class="line">                    <span class="comment">// 调用原来的方法</span></span><br><span class="line">                    method.invoke(accountService, args);</span><br><span class="line">                    <span class="comment">// 提交事务</span></span><br><span class="line">                    transactionManager.commit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 回滚事务</span></span><br><span class="line">                    transactionManager.rollback();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    transactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JDKProxyFactory jdkProxyFactory;</span><br><span class="line"><span class="comment">// 测试JDK动态代理 事务控制</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountService proxy = jdkProxyFactory.createAccountServiceImplProxy();</span><br><span class="line">    proxy.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p><strong>编写CGLIB代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;cGLIBProxyFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountServiceImpl <span class="title">createAccountServiceImplProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数一：目标对象的字节码对象   参数二：动作类，实现增强功能</span></span><br><span class="line">        <span class="keyword">return</span> (AccountServiceImpl) Enhancer.create(accountService.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 开启事务</span></span><br><span class="line">                    transactionManager.beginTransaction();</span><br><span class="line">                    <span class="comment">// 调用原来的方法</span></span><br><span class="line">                    method.invoke(accountService, objects);</span><br><span class="line">                    <span class="comment">// 提交事务</span></span><br><span class="line">                    transactionManager.commit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 回滚事务</span></span><br><span class="line">                    transactionManager.rollback();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    transactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CGLIBProxyFactory cglibProxyFactory;</span><br><span class="line"><span class="comment">// 测试CGLIB动态代理 事务控制</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountServiceImpl proxy = cglibProxyFactory.createAccountServiceImplProxy();</span><br><span class="line">    proxy.transfer(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程 AOP 是 OOP（面向对象编程） 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内 容，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高 程序的可重用性，同时提高了开发的效率。</p>
<p><strong>优点</strong></p>
<ul>
<li>在程序运行期间，在不修改源码的情况下对方法进行功能增强 </li>
<li>逻辑清晰，开发核心业务的时候，不必关注增强业务的代码  </li>
<li>减少重复代码，提高开发效率，便于后期维护</li>
</ul>
<p><strong>AOP底层实现</strong> </p>
<p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<ul>
<li>当bean有实现接口时，会用JDK代理模式 </li>
<li>当bean没有实现接口，用cglib实现（ 可以强制使用cglib，在aop:aspectj-autoproxy标签中加入 proxyt-target-class=”true“）</li>
</ul>
<p><strong>AOP相关术语</strong></p>
<ul>
<li>Target（目标对象）：代理的目标对象 </li>
<li>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 </li>
<li>Joinpoint（连接点）：所谓连接点是指那些可以被拦截到的点。在spring中,这些点指的是方法，因为 spring只支持方法类型的连接点 </li>
<li>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 </li>
<li>Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 <ul>
<li>前置通知、后置通知、异常通知、最终通知、环绕通知 </li>
</ul>
</li>
<li>Aspect（切面）：是切入点和通知（引介）的结合 </li>
<li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织 入，而AspectJ采用编译期织入和类装载期织入</li>
</ul>
<p><strong>我们需要做的</strong></p>
<ol>
<li>编写核心业务代码（目标类的目标方法） 切入点 </li>
<li>把公用代码抽取出来，制作成通知（增强功能方法） 通知 </li>
<li>在配置文件中，声明切入点与通知间的关系，即切面</li>
</ol>
<h2 id="基于xml的AOP"><a href="#基于xml的AOP" class="headerlink" title="基于xml的AOP"></a>基于xml的AOP</h2><p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入（切点表达式需要用到该jar包） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写目标类与通知类</strong>（省略）</p>
<p><strong>在applicationContext.xml中配置aop（需导入aop命名空间）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  通知类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.advice.MyAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  目标类  -&gt;</span></span><br><span class="line"><span class="comment">    &lt;bean id=&quot;accountService&quot; class=&quot;com.hui.service.AccountServiceImpl&quot;/&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!--  AOP配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    配置切面，引入通知类    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 符合切点表达式的方法执行时，使用通知类中的before()方法经行前置增强 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* * com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>切点表达式</strong></p>
<p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.访问修饰符可以省略</span><br><span class="line">2.返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意</span><br><span class="line">3.包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</span><br><span class="line">4.参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</span><br><span class="line">如:</span><br><span class="line">execution(public void com.hui.service.impl.AccountServiceImpl.transfer())</span><br><span class="line">execution(void com.hui.service.impl.AccountServiceImpl.*(..))</span><br><span class="line">execution(* com.hui.service.impl.*.*(..))</span><br><span class="line">execution(* com.hui.service..*.*(..))  &#x2F;&#x2F; 最常用</span><br></pre></td></tr></table></figure>
<p><strong>切点表达式抽取</strong></p>
<p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--抽取的切点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>通知类型</strong></p>
<p><code>&lt;aop:通知类型 method=“通知类中方法名” pointcut=“切点表达式&quot; /&gt;</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>&lt;aop:before&gt;</td>
<td>指定增强的方法在切入点方法之前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td>&lt;aop:afterReturning&gt;</td>
<td>指定增强的方法在切入点方法之后执行</td>
</tr>
<tr>
<td>异常通知</td>
<td>&lt;aop:afterThrowing&gt;</td>
<td>指定增强的方法出现异常后执行</td>
</tr>
<tr>
<td>最终通知</td>
<td>&lt;aop:after&gt;</td>
<td>无论切入点方法执行时是否有异常，都会执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td>&lt;aop:around&gt;</td>
<td>开发者可以手动控制增强代码在什么时候执行</td>
</tr>
</tbody></table>
<p>注意：通常情况下，环绕通知都是独立使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环绕通知，开发者通过代码手动控制各种通知</span></span><br><span class="line"><span class="comment">// ProceedingJoinPoint jp   表示正在执行的连接点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">    Object proceed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行当前方法,要将返回对象返回出去</span></span><br><span class="line">        proceed = jp.proceed();</span><br><span class="line">        <span class="comment">//  int i =1/0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h2><p><strong>配置文件中不用编写&lt;aop.config&gt;标签，注解在通知类中使用注解配置织入关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAdvice&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 该类升级为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.hui.service.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在配置文件中开启组件扫描和 AOP 的自动代理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lagou&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  开启aop自动代理，其中 proxy-target-class=&quot;true&quot;表示都采用CGLIB代理模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>切点表达式抽取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAdvice&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 该类升级为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将切入点提取出来</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.hui.service.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyPointCut</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;MyAdvice.MyPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解通知类型</strong></p>
<p><code>@Before</code> <code>@AfterReturning </code>  <code>@AfterThrowing </code>   <code>@After</code>  <code>@Around</code> </p>
<p>  <strong>注意</strong>   </p>
<p>当前四个通知组合在一起时，执行顺序如下：（aop中的一个小bug） </p>
<p>@Before -&gt; @After -&gt; @AfterReturning（如果有异常：@AfterThrowing）</p>
<p>如果是采用注解配置环绕通知，就不会出现这样的状况。</p>
<p><strong>纯注解配置</strong></p>
<p>在 主配置类上添加<code>@EnableAspectJAutoProxy</code>  注解，代替  <strong>&lt;aop:aspectj-autoproxy/&gt;</strong></p>
<h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><p>JdbcTemplate是spring框架中提供的一个模板对象，是对原始繁琐的Jdbc API对象的简单封装。用法类似与DBUtils</p>
<p><strong>核心对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(DataSource dataSource);</span><br></pre></td></tr></table></figure>
<p><strong>核心方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int update()</td>
<td>执行增、删、改语句</td>
</tr>
<tr>
<td>List&lt;T&gt; query()</td>
<td>查询多个</td>
</tr>
<tr>
<td>T queryForObject()</td>
<td>查询一个</td>
</tr>
</tbody></table>
<p>查询时如果要对返回结果经行封装，可以传递一个BeanPropertyRowMapper对象，该对像类似于DBUtils中的ResultSetHandler接口，实现ORM映射封装,创建该对象时续传递要封装类型的字节码</p>
<p>如 <code>jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class));</code></p>
<h2 id="Spring整合JdbcTemplate"><a href="#Spring整合JdbcTemplate" class="headerlink" title="Spring整合JdbcTemplate"></a>Spring整合JdbcTemplate</h2><p><strong>需求</strong>  实现转账案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建java项目，导入坐标</span><br><span class="line">2. 编写Account实体类</span><br><span class="line">3. 编写AccountDao接口和实现类</span><br><span class="line">4. 编写AccountService接口和实现类</span><br><span class="line">5. 编写spring核心配置文件</span><br><span class="line">6. 编写测试代码</span><br></pre></td></tr></table></figure>
<p><strong>1.导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入（切点表达式需要用到该jar包） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring中的事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.编写Account实体类</strong>(省略)</p>
<p><strong>3.编写AccountDao接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 出账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">    <span class="comment">// 入账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money-? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String name, Double money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money=money+? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.编写AccountService接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName,String inName,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outName, String inName, Double money)</span> </span>&#123;</span><br><span class="line">        accountDao.outMoney(outName, money);</span><br><span class="line"><span class="comment">//        int i = 1 / 0;</span></span><br><span class="line">        accountDao.inMoney(inName, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写spring核心配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  引入JDBC配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注解包扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>6.编写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jerry&quot;</span>,<span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring中的事务"><a href="#Spring中的事务" class="headerlink" title="Spring中的事务"></a>Spring中的事务</h1><p>Spring的事务控制可以分为编程式事务控制和声明式事务控制。 </p>
<p><strong>编程式</strong> 开发者直接把事务的代码和业务代码耦合到一起，在实际开发中不用。 </p>
<p><strong>声明式</strong> 开发者采用配置的方式来实现的事务控制，业务代码与事务代码实现解耦合，使用的AOP思想。</p>
<h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><h3 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h3><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>PlatformTransactionManager接口，是spring的事务管理器，里面提供了我们常用的操作事务的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransactionStatus getTransaction(TransactionDefinition definition)</td>
<td>获取事务的状态信息</td>
</tr>
<tr>
<td>void commit(TransactionStatus status)</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback(TransactionStatus status)</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<p><strong>PlatformTransactionManager接口实现类</strong></p>
<ul>
<li>Dao层技术是jdbcTemplate或mybatis时： DataSourceTransactionManager </li>
<li>Dao层技术是hibernate时： HibernateTransactionManager </li>
<li>Dao层技术是JPA时： JpaTransactionManager</li>
</ul>
<h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>TransactionDefinition接口提供事务的定义信息（事务隔离级别、事务传播行为等等）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int isolationLevel</td>
<td>事务的隔离级别</td>
</tr>
<tr>
<td>int propagationBehavior</td>
<td>事务的传播行为</td>
</tr>
<tr>
<td>int timeout</td>
<td>超时时间。默认值是-1,表示没有超时限制；如果有，以秒为单位进行设置</td>
</tr>
<tr>
<td>boolean readOnly</td>
<td>是否只读，建议查询时设置为只读 true</td>
</tr>
</tbody></table>
<p><strong>事务隔离级别</strong></p>
<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读（幻读）</p>
<ul>
<li>ISOLATION_DEFAULT   使用数据库默认级别</li>
<li>ISOLATION_READ_UNCOMMITTED   读未提交</li>
<li>ISOLATION_READ_COMMITTED   读已提交</li>
<li>ISOLATION_REPEATABLE_READ   可重复读</li>
<li>ISOLATION_SERIALIZABLE   串行化</li>
</ul>
<p><strong>事务传播行为</strong></p>
<p>事务传播行为指的就是当一个业务方法【被】另一个业务方法调用时，应该如何进行事务控制。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>REQUIRED</strong></td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</td>
</tr>
<tr>
<td><strong>SUPPORTS</strong></td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常</td>
</tr>
<tr>
<td>REQUERS_NEW</td>
<td>新建事务，如果当前在事务中，把当前事务挂起</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式运行，如果当前存在事务，抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作</td>
</tr>
</tbody></table>
<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>TransactionStatus 接口提供的是事务具体的运行状态。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNewTransaction()</td>
<td>是否是新事务</td>
</tr>
<tr>
<td>boolean hasSavepoint()</td>
<td>是否是回滚点</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>事务是否回滚</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>事务是否完成</td>
</tr>
</tbody></table>
<p>简单的理解三者的关系</p>
<p><strong>事务管理器（PlatformTransactionManager）</strong>通过读取<strong>事务定义参数（TransactionDefinition）</strong>进行事务管理，然后会产生一系列的<strong>事务状态（TransactionStatus ）</strong></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><strong>配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务管理器交给IOC，这里持久层是使用的是JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>业务层的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事务定义对象</span></span><br><span class="line">        DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        <span class="comment">// 设置是否只读，false支持事务</span></span><br><span class="line">        def.setReadOnly(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置事务隔离级别，可重复读mysql默认级别</span></span><br><span class="line">        def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);</span><br><span class="line">        <span class="comment">// 设置事务传播行为，必须有事务</span></span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        <span class="comment">// 配置事务管理器</span></span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转账</span></span><br><span class="line">            accountDao.out(outUser, money);</span><br><span class="line">            accountDao.in(inUser, money);</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于xml的声明式事务"><a href="#基于xml的声明式事务" class="headerlink" title="基于xml的声明式事务"></a>基于xml的声明式事务</h2><p><strong>需求</strong> 对上面的jdbcTemplate转账案例经行事务控制</p>
<p><strong>主配置文件，需引入tx命名空间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  引入JDBC配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:JDBC.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注解包扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  dataSource  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  事务管理器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  通知增强  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  事务管理器AOP配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.hui.service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>&lt;tx:method /&gt; 标签详情</strong></p>
<ul>
<li>name：切点方法名称 ，可以使用*通配符</li>
<li>isolation:事务的隔离级别 </li>
<li>propagation：事务的传播行为 </li>
<li>timeout：超时时间 </li>
<li>read-only：是否只读</li>
</ul>
<p><strong>CRUD常用配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h2><p><strong>修改service层，增加事务注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在方法或类上添加事务注解</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED, timeout = -1, readOnly = false)</span></span><br></pre></td></tr></table></figure>
<p><strong>修改spring核心配置文件，开启事务注解支持</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  注解方式配置声明式事务控制,需要开启事务注解支持  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>纯注解形式</strong></p>
<ul>
<li><p>数据源配置类(省略)</p>
</li>
<li><p>核心配置类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// spring主配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hui&quot;)</span>  <span class="comment">// 包扫描</span></span><br><span class="line"><span class="meta">@Import(DataSourceConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务支持注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;jdbcTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring集成JavaWeb"><a href="#Spring集成JavaWeb" class="headerlink" title="Spring集成JavaWeb"></a>Spring集成JavaWeb</h1><p>应用上下文对象<strong>ApplicationContext</strong>是通过 <strong>new ClasspathXmlApplicationContext(spring配置文件)</strong> 方式获取的，但是每次从容器中获得<strong>Bean</strong>时都要编写 new ClasspathXmlApplicationContext(spring配置文件) 来获取上下文， 这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p><strong>解决思路</strong></p>
<p>在Web项目中，可以使用<strong>ServletContextListener</strong>监听Web应用的启动，我们可以在Web应用启动 时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域 <strong>servletContext</strong>域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p>
<p><strong>Spring提供获取应用上下文的工具</strong></p>
<p>上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到<strong>ServletContext</strong>域中，提供 了一个客户端工具<strong>WebApplicationContextUtils</strong>供使用者获得应用上下文对象。</p>
<p>所以我们只需要导入相关的<strong>依赖</strong>，并在web.xml中配置<strong>ContextLoaderListener</strong>监听器，就可以使用<strong>WebApplicationContextUtils</strong>工具类在任意地方获取<strong>ApplicationContext</strong>上下文对象</p>
<p><strong>1.导入Spring集成web的坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.配置ContextLoaderListener监听器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数，固定写法，告诉监听器去哪里寻找配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.通过工具获得应用上下文对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">Object obj = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这也就是spring整合spring-mvc,spring会创建一个IOC容器，spring-mvc也会创建一个IOC容器，spring创建的为父容器，mvc创建的为子容器。子容器可以访问父容器中的bean，但父容器不能访问子容器中的bean，即Controller层可以调用service层，而service层不能调用controller层。</p>
<h1 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h1><p>将mybatis接口代理对象的创建权交给spring管理，我们就可以把dao的代理对象注入到service中， 此时也就完成了spring与mybatis的整合了。</p>
<p>因为SqlSessionFactory对象是安全的，所以把它交给spring管理。整合的过程其实是将mybatis主配置文件的内容全部移到spring配置文件中。如果需要用到mybatis主配置文件也是可以的。</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis整合spring坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring整合mybatis--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入JDBC数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--SqlSessionFactory创建交给spring的IOC容器，mybatis中的所有配置可以在里面配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--与mapper.xml文件的映射(如果在同一个目录下可省略)--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类型别名配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lagou.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果要引入mybatis主配置文件，可以通过如下配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置pageHelper分页，需导入依赖    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置方言   --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>helperDialect=mysql<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--映射接口扫描配置，由spring创建代理对象，交给IOC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lagou.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置好了，可以不用mybatis主配置文件，在service层注入dao层的接口其实是spring创建的代理对象。</p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="MD5-的使用"><a href="#MD5-的使用" class="headerlink" title="MD5 的使用"></a>MD5 的使用</h2><p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MD5依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>添加自定义工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 盐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String md5key = <span class="string">&quot;hui&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * MD5方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> text 明文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 密文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String text, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加密后的字符串</span></span><br><span class="line">        String encodeStr= DigestUtils.md5Hex(text+key);</span><br><span class="line">        System.out.println(<span class="string">&quot;MD5加密后的字符串为:encodeStr=&quot;</span>+encodeStr);</span><br><span class="line">        <span class="keyword">return</span> encodeStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * MD5验证方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> text 明文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> md5 密文</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String text, String key, String md5)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据传入的密钥进行验证</span></span><br><span class="line">        String md5Text = md5(text, key);</span><br><span class="line">        <span class="keyword">if</span>(md5Text.equalsIgnoreCase(md5))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MD5验证通过&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-MVC</title>
    <url>/2021/08/02/spring-MVC/</url>
    <content><![CDATA[<p>SpringMVC 是一种基于 Java 的实现 MVC 设计模式的轻量级 Web 框架，属于SpringFrameWork 的 后续产品，已经融合在 Spring Web Flow 中。<a id="more"></a></p>
<p> SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2， 成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现 任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<h1 id="SpringMVC基本用法"><a href="#SpringMVC基本用法" class="headerlink" title="SpringMVC基本用法"></a>SpringMVC基本用法</h1><p><strong>MVC模式</strong></p>
<p>MVC是软件工程中的一种软件架构模式，它是一种分离业务逻辑与显示界面的开发思想。</p>
<ul>
<li>M（model）模型：处理业务逻辑，封装实体 </li>
<li>V（view） 视图：展示内容 </li>
<li>C（controller）控制器：负责调度分发（1.接收请求、2.调用模型、3.转发到视图）</li>
</ul>
<p><a href="https://imgtu.com/i/f9mk2F"><img src="https://z3.ax1x.com/2021/08/02/f9mk2F.png" alt="f9mk2F.png"></a></p>
<p>SpringMVC的框架就是封装了原来Servlet中的共有行为；例如：参数封装，视图转发等</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>1.创建web项目，导入SpringMVC相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置为web工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springMVC坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.在web.xml中配置前端控制器DispatcherServlet</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前端控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> 		</span><br><span class="line">        <span class="tag">&lt;<span class="name">servletclass</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载SpringMVc配置文件，固定写法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正数表示立即加载，而不是客户端访问了该sevlet就加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- /表示拦截所有，但是不包括*.jsp这样的url，/*才会拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.编写Controller类与视图</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quick running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;success&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h3&gt;请求成功！&lt;/h3&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>4.配置SpringMVC核心配置文件spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lagou.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动tomcat后访问 <a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/quick">http://localhost:8080/项目名/quick</a></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><strong>代码层面</strong>     所有的请求都给<strong>前端控制器</strong>管理，由<strong>前端控制器</strong>根据地址执行响应的controller代码</p>
<p><a href="https://imgtu.com/i/f9KUaR"><img src="https://z3.ax1x.com/2021/08/02/f9KUaR.png" alt="f9KUaR.png"></a></p>
<h1 id="SpringMVC组件"><a href="#SpringMVC组件" class="headerlink" title="SpringMVC组件"></a>SpringMVC组件</h1><h2 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h2><p><strong>组件层面</strong></p>
<p><a href="https://imgtu.com/i/f9M2XF"><img src="https://z3.ax1x.com/2021/08/02/f9M2XF.png" alt="f9M2XF.png"></a></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet。 </li>
<li> DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如 果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView。 </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li>
<li>ViewReslover解析后返回具体View。 </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet将渲染后的视图响应响应用户。</li>
</ol>
<h2 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h2><p><strong>1.前端控制器：DispatcherServlet</strong> </p>
<p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的 中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>2.处理器映射器：HandlerMapping</strong> </p>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器 实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </p>
<p><strong>3.处理器适配器：HandlerAdapter</strong> </p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型 的处理器进行执行。 </p>
<p><strong>4.处理器：Handler【开发者编写】</strong> </p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 </p>
<p><strong>5.视图解析器：ViewResolver</strong> </p>
<p>ViewResolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物 理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给 用户。 </p>
<p><strong>6.视图：View 【开发者编写】</strong> </p>
<p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、 pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展 示给用户，需要由程序员根据业务需求开发具体的页面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器映射器和处理器适配器配置，功能增强，对json格式的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器,配置前缀与后缀--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p><strong>@Controller</strong></p>
<p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器 中，如果使用@Controller注解标注的话，就需要使用注解扫描：</p>
<p><code>&lt;context:component-scan base-package=&quot;com.hui.controller&quot;/&gt;</code></p>
<p><strong>@RequestMapping</strong></p>
<p>用于建立请求 URL 和处理请求方法之间的对应关系，可放在类上与方法上。</p>
<ul>
<li>value属性：用于指定请求的URL。它和path属性的作用是一样的 </li>
<li>method属性：用来限定请求的方式 ，如RequestMethod.GET、RequestMethod.POST</li>
<li>params属性：用来限定请求参数的条件，如<ul>
<li>params={“accountName”} 表示请求参数中必须有accountName </li>
<li>pramss={“money!100”} 表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
<h1 id="SpringMVC请求"><a href="#SpringMVC请求" class="headerlink" title="SpringMVC请求"></a>SpringMVC请求</h1><h2 id="获取请求参数类型"><a href="#获取请求参数类型" class="headerlink" title="获取请求参数类型"></a>获取请求参数类型</h2><p>springMVC可以接受以下类型的参数</p>
<p><strong>基本类型参数</strong>     <strong>对象类型参数</strong>      <strong>数组类型参数</strong>      <strong>集合类型参数</strong></p>
<p>Controller中的业务方法的参数名要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换,还能对POJO对象自动映射封装。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pojoParam</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/queryParam&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    list集合,第一个元素&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].id&quot;</span> placeholder=<span class="string">&quot;编号&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].username&quot;</span> placeholder=<span class="string">&quot;姓名&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    map集合,第一个元素&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userMap[&#x27;u1&#x27;].id&quot;</span> placeholder=<span class="string">&quot;编号&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userMap[&#x27;u1&#x27;].username&quot;</span> placeholder=<span class="string">&quot;姓名&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;复杂类型&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; userMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/queryParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryParam</span><span class="params">(QueryVo queryVo)</span> </span>&#123;</span><br><span class="line">    System.out.println(queryVo);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中文乱码过滤器"><a href="#中文乱码过滤器" class="headerlink" title="中文乱码过滤器"></a>中文乱码过滤器</h2><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filterclass</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h2><p>SpringMVC 默认已经提供了一些常用的类型转换器，还提供了自 定义类型转换器，方便开发者自定义处理。如 日期格式类型要求为：yyyy/MM/dd，如果客户端传过来的是 yyyy-MM-dd格式，要把它转换成日期格式就会报错，这时需要使用自定义类型转换器。</p>
<p><strong>编写一个类，实现Converter&lt;?,?&gt;接口，重写convert方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将日期字符串转换成日期对象，并返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置pringMVC配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器映射器和适配器增强,并添加转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotationdriven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义转换器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可配置多个自定义转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lagou.converter.DateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="请求相关注解"><a href="#请求相关注解" class="headerlink" title="请求相关注解"></a>请求相关注解</h2><p><strong>@RequestParam</strong></p>
<p>当请求的参数name名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定</p>
<ul>
<li>name 匹配页面传递参数的名称 </li>
<li>defaultValue 设置参数默认值</li>
<li>required 设置是否必须传递该参数，默认值为true；如果设置了defaultValue ，值自动改为false</li>
</ul>
<p><strong>@RequestHeader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求头的数据,获取请求头中的所有cookie信息</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/requestHead&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestHead</span><span class="params">(<span class="meta">@RequestHeader(&quot;cookie&quot;)</span> String cookie)</span> </span>&#123;</span><br><span class="line">    System.out.println(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@CookieValue</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取cookie中的数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cookieValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cookieValue</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jesessionId)</span> </span>&#123;</span><br><span class="line">    System.out.println(jesessionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC响应"><a href="#SpringMVC响应" class="headerlink" title="SpringMVC响应"></a>SpringMVC响应</h1><p><strong>注意</strong>    在WEB-INF下的jsp页面不能直接访问，所以只能通过转发访问，重定向则不行</p>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><h3 id="void原始ServletAPI"><a href="#void原始ServletAPI" class="headerlink" title="void原始ServletAPI"></a>void原始ServletAPI</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过request、response对象实现响应</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/returnVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过request实现转发</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;怪狗狗&quot;</span>);</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="comment">// 通过response实现重定向，WEB-INF下的jsp页面不能重定向</span></span><br><span class="line">    response.sendRedirect(request.getContextPath() + <span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回字符串逻辑视图"><a href="#返回字符串逻辑视图" class="headerlink" title="返回字符串逻辑视图"></a>返回字符串逻辑视图</h3><p><strong>直接返回字符串</strong></p>
<p>此种方式会将返回的<strong>字符串</strong>与<strong>视图解析器</strong>的前后缀拼接后跳转到指定页面，这种方式本质是<strong>转发</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/page/hello.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>forward转发</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 则路径必须写成实际视图url，不能写逻辑视图</span></span><br><span class="line"><span class="comment">// model是用来传递数据给前端，相当于 request 域</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;拉勾招聘&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>redirect重定向</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WEB-INF下的jsp页面不能重定向经行访问</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;拉勾教育&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p><strong>Model</strong>    模型 作用封装数据<br><strong>View</strong>       视图 作用展示数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/returnModelAndView1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">returnModelAndView1</span><span class="params">(ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  直接声明或则直接创建ModelAndView都一样</span></span><br><span class="line">    <span class="comment">//  ModelAndView modelAndView = new ModelAndView();</span></span><br><span class="line">    <span class="comment">//设置模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>, <span class="string">&quot; lagou&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称，逻辑视图，转发</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@SessionAttributes注解</strong></p>
<p>定义在类上，会将request域范围的数据提升到session范围，这样多个请求就能共享数据了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//向request域存入的key为username时，同步到session域中</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;username&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;怪狗狗&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><p><strong>1.直接返回字符串数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过response直接响应数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/returnVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;拉勾网&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.将对象或集合转为json返回</strong>(AJAX异步交互中会介绍)</p>
<h1 id="静态资源访问的开启"><a href="#静态资源访问的开启" class="headerlink" title="静态资源访问的开启"></a>静态资源访问的开启</h1><p>当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文 件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是 /   ,代表对所有的 静态资源都进行处理操作，这样就不会执行Tomcat内置的DefaultServlet处理，而是DispatcherServlet把该路径当作我们自己写的一个方法(RequestMapping)。我们可以在springMVC配置文件中配置指定放行静态资源：</p>
<p><strong>方式一</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定放行资源，mapping:放行的映射路径，location:静态资源所在的目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>方式二</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--放行全部的静态资源，开启DefaultServlet处理静态资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="AJAX异步交互"><a href="#AJAX异步交互" class="headerlink" title="AJAX异步交互"></a>AJAX异步交互</h1><p>Springmvc默认用MappingJackson2HttpMessageConverter对json数据进行转换，需要加入 jackson的包；同时还需使用<strong>&lt;mvc:annotation-driven /&gt;</strong> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@RequestBody与@ResponseBody</strong></p>
<ul>
<li><p>RequestBody  用于Controller的方法的形参声明，当使用ajax提交并指定contentType为json形式时，通过 HttpMessageConverter接口转换为对应的POJO对象。</p>
</li>
<li><p>ResponseBody  用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数 据如：json,xml等，通过Response响应给客户端。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@RequestMapping(produces = &quot;application/json;charset=utf-8&quot;) </span></span><br><span class="line"><span class="comment">	响应返回数据的mime类型和编码，默认为json</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 处理ajax的json数据</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test6&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//返回的对象转换成JSON格式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">test6</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h1><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用 于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机 制等。</p>
<p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动 词如下： </p>
<p><strong>GET</strong>：读取（Read）     <strong>POST</strong>：新建（Create）     <strong>PUT</strong>：更新（Update）    <strong>DELETE</strong>：删除（Delete）</p>
<table>
<thead>
<tr>
<th>客户端请求</th>
<th>原来风格URL地址</th>
<th>RESTful风格URL地址</th>
</tr>
</thead>
<tbody><tr>
<td>查询所有</td>
<td>/user/findAll</td>
<td>GET /user</td>
</tr>
<tr>
<td>根据ID查询</td>
<td>/user/findById?id=1</td>
<td>GET /user/{1}</td>
</tr>
<tr>
<td>新增</td>
<td>/user/save</td>
<td>POST /user</td>
</tr>
<tr>
<td>修改</td>
<td>/user/update</td>
<td>PUT /user</td>
</tr>
<tr>
<td>删除</td>
<td>/user/delete?id=1</td>
<td>DELETE /user/{1}</td>
</tr>
</tbody></table>
<p><strong>@PathVariable</strong> 用来接收RESTful风格请求地址中占位符的值 </p>
<p><strong>@RestController</strong> RESTful风格多用于前后端分离项目开发，前端通过ajax与服务器进行异步交互，我们处理器通常返 回的是json数据,所以使用@RestController来替代@Controller和@ResponseBody两个注解。</p>
<p>其中@RequestMapping中的method属性可以设置不同的请求方式,可以简写成</p>
<p>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;user&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getAllUser&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据Id查询</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserById&quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><strong>文件上传三要素</strong> </p>
<ul>
<li>表单项 type=”file” </li>
<li>表单的提交方式 method=”POST” </li>
<li>表单的enctype属性是多部分表单形式 enctype=“multipart/form-data”</li>
</ul>
<h2 id="1-导入fileupload和io坐标"><a href="#1-导入fileupload和io坐标" class="headerlink" title="1.导入fileupload和io坐标"></a>1.导入fileupload和io坐标</h2><p>springMVC文件上传就是对fileupload的封装</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-配置文件上传解析器"><a href="#2-配置文件上传解析器" class="headerlink" title="2.配置文件上传解析器"></a>2.配置文件上传解析器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传解析器，注意id一定是 multipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定文件上传的最大值为5MB，5*1024*1024 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242880&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编写文件上传代码"><a href="#3-编写文件上传代码" class="headerlink" title="3.编写文件上传代码"></a>3.编写文件上传代码</h2><p><strong>单文件上传</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/fileUpload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;单文件上传&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单文件上传</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fileUpload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(String username, MultipartFile filePic)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    String filename = filePic.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 保存文件</span></span><br><span class="line">    filePic.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;c://upload/&quot;</span> + filename));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多文件上传</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/filesUpload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件一:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    文件二:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;filePic&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;多文件上传&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件上传</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/filesUpload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filesUpload</span><span class="params">(String username, MultipartFile[] filePic)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 遍历文件类型数组</span></span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : filePic) &#123;</span><br><span class="line">        <span class="comment">// 获取文件名，并保存</span></span><br><span class="line">        String filename = file.getOriginalFilename();</span><br><span class="line">        file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;c://upload/&quot;</span> + filename));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>SpringMVC的异常处理机制，dao、service、controller出现异常都通过<strong>throws Exception</strong>向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p>
<p><a href="https://imgtu.com/i/fCemGT"><img src="https://z3.ax1x.com/2021/08/02/fCemGT.png" alt="fCemGT.png"></a></p>
<h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><p><strong>创建异常处理器类实现HandlerExceptionResolver接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Exception e表示当前的异常</span></span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;error&quot;</span>,e.getMessage());</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringMVC.xml配置异常处理器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myException&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.exception.MyException&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>编写异常页面</strong>(省略)</p>
<h2 id="web的处理异常机制"><a href="#web的处理异常机制" class="headerlink" title="web的处理异常机制"></a>web的处理异常机制</h2><p>web.xml文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理500异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--处理404异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p>
<p><strong>拦截器interceptor和过滤器filter区别</strong></p>
<p><a href="https://imgtu.com/i/fCmIje"><img src="https://z3.ax1x.com/2021/08/02/fCmIje.png" alt="fCmIje.png"></a></p>
<p><strong>拦截器使用步骤</strong></p>
<ul>
<li>创建拦截器类实现HandlerInterceptor接口,根据需求重写方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行之前 拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandler。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在目标方法执行之后,视图对象返回之前 执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandler。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>springMVC.xml中配置拦截器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  拦截器  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span>  <span class="comment">&lt;!--拦截所有handler--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hui.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>拦截器中的方法说明如下</strong></p>
<p><a href="https://imgtu.com/i/fCnevF"><img src="https://z3.ax1x.com/2021/08/02/fCnevF.png" alt="fCnevF.png"></a></p>
<p><strong>拦截器链</strong> </p>
<p>开发中拦截器可以单独使用，也可以同时使用多个拦截器形成一条拦截器链，与过滤器链类似。开发步骤和单个拦截器 是一样的，只不过注册的时候注册多个，注意这里注册的顺序就代表拦截器执行的顺序。</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2021/08/13/nginx/</url>
    <content><![CDATA[<p>Nginx（发音同 engine x）是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。<a id="more"></a>由俄罗斯的程序设计师Igor Sysoev(伊戈尔·西索夫)所开发，供俄国大型的入口网站及搜索引擎Rambler(漫步者)（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、 腾讯等。</p>
<p><strong>优点</strong></p>
<ol>
<li>占用内存少，并发能力强</li>
<li>Nginx专为性能优化而开发, 在高连接并发的情况下，能够支持高达 50,000 个并发连接数的响应.</li>
<li>Nginx支持热部署, 可以在不间断服务的情况下,对软件版本进行升级.</li>
</ol>
<p><strong>应用场景</strong></p>
<ol>
<li><p><strong>http服务器</strong>: Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</p>
</li>
<li><p><strong>虚拟主机</strong>: 可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</p>
</li>
<li><p><strong>反向代理，负载均衡</strong> :  当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况</p>
</li>
</ol>
<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><p>下载nginx, 官方网站：<a href="http://nginx.org/">http://nginx.org/</a></p>
<p>这里使用的版本是1.17.8版本。</p>
<p>Nginx在Linux下安装,只提供了源代码,所以我们需要进行编译.</p>
<h2 id="安装环境配置"><a href="#安装环境配置" class="headerlink" title="安装环境配置"></a>安装环境配置</h2><ol>
<li>因为Nginx是C语言编写的,所以需要配置C语言编译环境 (一定要在联网状态下安装)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要安装gcc的环境。执行命令: </span><br><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>注意: 如果执行命令出现这样的提示:</p>
<p><a href="https://imgtu.com/i/fDwRiR"><img src="https://z3.ax1x.com/2021/08/13/fDwRiR.jpg" alt="fDwRiR.jpg"></a></p>
<p>解决办法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题是 yum在锁定状态中,强制关掉yum进程即可</span><br><span class="line">rm -f &#x2F;var&#x2F;run&#x2F;yum.pid</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>第三方的开发包, 在编译之前需要安装这些第三方包。</li>
</ol>
<ul>
<li><p><code>PCRE</code></p>
<ul>
<li>nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure></li>
<li><p><code>zlib</code></p>
<ul>
<li>nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li>
<li><p><code>openssl</code></p>
<ul>
<li>OpenSSL 是一个强大的安全套接字层密码库,nginx不仅支持http协议，还支持https,所以需要在linux安装openssl库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装命令:</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<h2 id="安装Nginx-步骤"><a href="#安装Nginx-步骤" class="headerlink" title="安装Nginx 步骤"></a>安装Nginx 步骤</h2></li>
</ul>
<ol>
<li><p>将Nginx的源码包上传到 Linux</p>
</li>
<li><p>解压Nginx</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.17.8.tar </span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>进入到解压之后的目录 nginx-1.17.8</p>
</li>
<li><p>执行命令下方的 configure,生成 Mikefile 文件 </p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<p>执行命令后, 生成了MakeFile文件 </p>
<ol start="5">
<li>创建临时文件目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>执行make命令,进行编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完毕后，nginx在 /usr/loacl/ 目录下</p>
<h2 id="启动并访问-Nginx"><a href="#启动并访问-Nginx" class="headerlink" title="启动并访问 Nginx"></a>启动并访问 Nginx</h2><ol>
<li>进入到nginx 安装目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入到 sbin目录,执行 <code>nginx</code> 命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx 启动</span><br><span class="line">.&#x2F;nginx -s reload 重启</span><br><span class="line">.&#x2F;nginx -s stop 关闭</span><br><span class="line">ps aux | grep nginx 查看进程</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>通过浏览器进行访问  ,默认端口 80  (注意：是否关闭防火墙。)</li>
</ol>
<h2 id="nginx核心配置文件"><a href="#nginx核心配置文件" class="headerlink" title="nginx核心配置文件"></a>nginx核心配置文件</h2><p>/usr/local/nginx/conf/nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes  1; #work的进程数，默认为1</span><br><span class="line"><span class="meta">#</span><span class="bash">配置 影响nginx服务器与用户的网络连接</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; #单个work 最大并发连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> http块是配置最频繁的部分 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能</span></span><br><span class="line">http &#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 引入mime类型定义文件</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65; # 超时时间</span><br><span class="line">	</span><br><span class="line"><span class="meta">	#</span><span class="bash">server 配置虚拟主机的相关参数 可以有多个,一个server就是一个虚拟主机</span></span><br><span class="line">    server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash"> 监听的端口</span></span><br><span class="line">        listen       80; </span><br><span class="line"><span class="meta">		#</span><span class="bash">监听地址</span></span><br><span class="line">        server_name  localhost;         </span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 默认请求配置</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # 默认网站根目录</span><br><span class="line">            index  index.html index.htm; # 欢迎页</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 错误提示页面</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx启动失败"><a href="#nginx启动失败" class="headerlink" title="nginx启动失败"></a>nginx启动失败</h2><p>重启linux服务器，可能会到nginx启动失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid&quot; failed (2:No such file or directory)</span><br></pre></td></tr></table></figure>
<p>导致本次错误的原因，是没有修改pid文件的路径，编辑nginx的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid;</span><br></pre></td></tr></table></figure>
<p>再次启动nginx即可。</p>
<h1 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h1><p>虚拟主机指的是,在一台服务器中,我们使用Nginx,来配置多个网站.</p>
<p>如何区分不同的网站:</p>
<ol>
<li>端口不同</li>
<li>域名不同</li>
</ol>
<h2 id="通过端口区分不同的虚拟主机"><a href="#通过端口区分不同的虚拟主机" class="headerlink" title="通过端口区分不同的虚拟主机"></a>通过端口区分不同的虚拟主机</h2><p>1.配置nginx.conf,  在配置文件中添加一个 新的server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原来的server</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    # 配置新的server,主要需改 listen</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       81; # 修改端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html2; # 重新制定一个目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2.复制一份 html目录，来观察不同的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r html html2</span><br></pre></td></tr></table></figure>
<p>3.重新加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s relaod </span><br></pre></td></tr></table></figure>
<p>4.访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1   访问第一个server</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:81&#x2F;  访问第二个server</span><br></pre></td></tr></table></figure>
<h2 id="通过域名区分不同的虚拟主机"><a href="#通过域名区分不同的虚拟主机" class="headerlink" title="通过域名区分不同的虚拟主机"></a>通过域名区分不同的虚拟主机</h2><p><strong>域名绑定</strong></p>
<ul>
<li>一个域名对应一个ip地址，一个ip地址可以被多个域名绑定。</li>
<li>通过 DNS服务器去解析域名</li>
</ul>
<p><strong>配置域名映射</strong></p>
<ul>
<li>本地测试可以修改hosts文件。修改window的hosts文件：（C:\Windows\System32\drivers\etc）</li>
</ul>
<ul>
<li>可以配置域名和ip的映射关系，如果hosts文件中配置了域名和ip的对应关系，不需要走dns服务器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1  www.hui1.com</span><br><span class="line">127.0.0.1  www.hui2.com</span><br></pre></td></tr></table></figure>
<p><strong>配置 nginx.xml</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过域名区分虚拟主机,主要修改 server_name</span></span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui1.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui2.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html2;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.hui1.com</span><br><span class="line">www.hui2.com</span><br></pre></td></tr></table></figure>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据再发送给客户机。</p>
<p><strong>正向代理</strong></p>
<p>正向代理代理的是客户端, 服务端不知道实际发起请求的客户端。例如翻墙就是正向代理用的最广泛的地方</p>
<p><a href="https://imgtu.com/i/fDIhse"><img src="https://z3.ax1x.com/2021/08/13/fDIhse.jpg" alt="fDIhse.jpg"></a></p>
<p><strong>反向代理</strong></p>
<p>反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器。</strong></p>
<p><a href="https://imgtu.com/i/fDIqRf"><img src="https://z3.ax1x.com/2021/08/13/fDIqRf.jpg" alt="fDIqRf.jpg"></a></p>
<p><strong>Nginx实现反向代理</strong></p>
<p>Nginx作为反向代理服务器安装在服务端，Nginx的功能就是把请求转发给后面的应用服务器.</p>
<p><a href="https://imgtu.com/i/fDonoR"><img src="https://z3.ax1x.com/2021/08/13/fDonoR.jpg" alt="fDonoR.jpg"></a></p>
<p>1.启动两个tomcat，端口号分别是8080、8081，模拟两个网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;115.45.129.213:8080&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;115.45.129.213:8081&#x2F;</span><br></pre></td></tr></table></figure>
<p>2.反向代理服务器的配置  nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">反向代理配置</span> </span><br><span class="line"><span class="meta">	#</span><span class="bash">upstream中的server是真正处理请求的应用服务器地址</span></span><br><span class="line">	upstream hui01&#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">		server 115.45.129.213:8080;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui1.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        	# 利用 proxy_ pass可以将请求代理到upstream命名的HTTP服务</span><br><span class="line">            proxy_pass http://hui01;  #转发到的地址</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	upstream hui02&#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">		server 115.45.129.213:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hui2.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://hui02; </span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>记得在host文件中添加域名和ip的映射关系</p>
<ul>
<li>在浏览器输入域名, 访问Nginx代理服务器, Nginx根据域名将请求转发给对应的目标服务器。</li>
<li>作为用户的我们看到的是服务器的响应结果页面,在整个过程中目标服务器相对于客户端是不可见的,服务端向外暴露的就是Nginx的地址.</li>
</ul>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>反向代理服务器，合理分配请求到目标服务器的过程就叫做负载均衡</p>
<p>负载均衡主要是为了分担访问量，将请求合理分发给不同的服务器, 避免临时的网络堵塞</p>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p><strong>轮询</strong></p>
<ul>
<li><p>默认策略, 每个请求按照时间顺序逐一分配到不同的服务器,如果某一个服务器下线,能自动剔除</p>
</li>
<li><p>配置nginx.conf</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream hui&#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">	server 115.45.129.213:8080;</span><br><span class="line">	server 115.45.129.213:8081;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  www.hui.com; #当前访问的域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://hui;  #转发到的地址</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样访问 <a href="http://www.hui.com/">www.hui.com</a> 时，有时会访问 8080 端口的tomcat，有时会访问到8081端口的tomcat</p>
<p><strong>weight</strong></p>
<ul>
<li>可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1。</li>
<li>配置nginx.conf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在后面加 weight 即可</span></span><br><span class="line">upstream hui&#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash">用server定义HTTP地址</span></span><br><span class="line">	server 115.45.129.213:8080 weight=1;</span><br><span class="line">	server 115.45.129.213:8081 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目的部署与发布"><a href="#项目的部署与发布" class="headerlink" title="项目的部署与发布"></a>项目的部署与发布</h1><h2 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1.需要安装的软件</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JDK</strong></td>
<td>11</td>
</tr>
<tr>
<td><strong>Tomcat</strong></td>
<td>8.5</td>
</tr>
<tr>
<td><strong>MySQL</strong></td>
<td>5.7</td>
</tr>
<tr>
<td><strong>Nginx</strong></td>
<td>1.17.8</td>
</tr>
</tbody></table>
<p>2.开启8080端口</p>
<p>3.使用SQLYoga连接Linux上的数据库，导入SQL脚本</p>
<h3 id="项目打包发布"><a href="#项目打包发布" class="headerlink" title="项目打包发布"></a>项目打包发布</h3><p>在平常开发的过程中，不同的环境中项目的相关配置也会有相关的不同，我们在不同的环境中部署就要手动修改为对应环境的配置，这样太麻烦了以及这样也会很容易出错。 接下来我们就通过maven的相关配置来在打包时指定各个环境对应配置文件</p>
<h4 id="dao模块创建配置文件"><a href="#dao模块创建配置文件" class="headerlink" title="dao模块创建配置文件"></a>dao模块创建配置文件</h4><p>在ssm-dao项目的src/main/resources 下面创建<strong>filter</strong>目录, 再创建 <strong>development.properties</strong> ,  <strong>product.properties</strong> 两个文件</p>
<ul>
<li>development是开发配置内容，配置本地的Mysql</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JDBC.driver=com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url=jdbc:mysql:<span class="comment">///ssm_lagou_edu?characterEncoding=UTF-8</span></span><br><span class="line">JDBC.username=root</span><br><span class="line">JDBC.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>product是正式配置内容，配置远程服务器的Mysql</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JDBC.driver=com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url=jdbc:mysql:<span class="comment">//*.*.*.*:3306/ssm_lagou_edu?characterEncoding=UTF-8</span></span><br><span class="line">JDBC.username=root</span><br><span class="line">JDBC.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h4 id="配置jdbc-properties-文件"><a href="#配置jdbc-properties-文件" class="headerlink" title="配置jdbc.properties 文件"></a>配置jdbc.properties 文件</h4><p>jdbc.properties中的内容不再写死,而是从上面两个文件中获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">JDBC.url&#x3D;$&#123;JDBC.url&#125;</span><br><span class="line">JDBC.username&#x3D;$&#123;JDBC.username&#125;</span><br><span class="line">JDBC.password&#x3D;$&#123;JDBC.password&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：${jdbc.url} 等需要直接对应上面配置的development.properties或product.properties文件中的名称</p>
</blockquote>
<h4 id="配置dao模块的的-pom-xml文件"><a href="#配置dao模块的的-pom-xml文件" class="headerlink" title="配置dao模块的的 pom.xml文件"></a>配置dao模块的的 pom.xml文件</h4><p>添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>development<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 正式环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>product<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>web<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/resources/filter/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>filter/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>profile说明</strong></p>
<ul>
<li>profile可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果</li>
<li>默认启用的是dev环境配置:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>development<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 正式环境 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">env</span>&gt;</span>product<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定数据库配置文件路径，此路径可以自定义:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/resources/filter/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定资源目录路径</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 资源根目录排除各环境的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>filter/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ul>
<li>命令打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打本地包 mvn -Pdev install 或者mvn install(因为本例activeByDefault配的为true)</span><br><span class="line">打产品包 mvn -Pprod install</span><br><span class="line"></span><br><span class="line">结果：src&#x2F;main&#x2F;resources&#x2F;config&#x2F;jdbc.properties根据 mvn -P 参数决定值</span><br></pre></td></tr></table></figure>
<ul>
<li>使用idea打包</li>
</ul>
<p><a href="https://imgtu.com/i/fraYKU"><img src="https://z3.ax1x.com/2021/08/13/fraYKU.jpg" alt="fraYKU.jpg"></a></p>
<p><strong>打包后的文件</strong></p>
<ul>
<li><p>war包在web模块中的target目录中，我们就是需要该war包</p>
</li>
<li><p>打开这个war包,我们会发现 其他子模块都已经被打成jar包,放到了lib文件夹下</p>
</li>
</ul>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ul>
<li><p>修改一下项目名称 ssm-web.war</p>
</li>
<li><p>上传到Linux中tomcat的webapp目录下,启动测试 <code>./startup.sh</code></p>
</li>
<li><p>在部署tomcat的 webapps目录下创建一个 upload文件夹,用于保存图片 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir upload</span><br></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;*.*.*.*:8080&#x2F;ssm-web&#x2F;user&#x2F;login?phone&#x3D;18211111111&amp;password&#x3D;123456</span><br></pre></td></tr></table></figure>
<h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li>生产环境配置文件,配置后台URL</li>
</ul>
<p><code>.env.production</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_NAME &#x3D; Edu Boss</span><br><span class="line">VUE_APP_TITLE &#x3D; Lagou Edu Boss (Dev)</span><br><span class="line"></span><br><span class="line">VUE_APP_STORAGE_PREFIX &#x3D; lagou_edu_boss_dev</span><br><span class="line"></span><br><span class="line">#VUE_APP_API_FAKE &#x3D; &#x2F;front</span><br><span class="line">VUE_APP_API_FAKE &#x3D; http:&#x2F;&#x2F;47.115.139.213:8080&#x2F;ssm-web</span><br><span class="line"></span><br><span class="line">#VUE_APP_API_BASE &#x3D; &#x2F;boss</span><br><span class="line">VUE_APP_API_BASE &#x3D; http:&#x2F;&#x2F;47.115.139.213:8080&#x2F;ssm-web</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义配置文件,配置打包相关信息 </li>
</ul>
<p>将下面内容拷贝到 <strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;/edu-boss/&quot;</span> : <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    indexPath: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    lintOnSave: process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8081</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打包操作"><a href="#打包操作" class="headerlink" title="打包操作"></a>打包操作</h3><ul>
<li>打包命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<ul>
<li>在项目下会生成一个 dist 目录 ,该目录就是我们所需的文件</li>
</ul>
<h3 id="发布前端项目"><a href="#发布前端项目" class="headerlink" title="发布前端项目"></a>发布前端项目</h3><ul>
<li>在Linux系统上复制一个新的tomcat，端口号改为 8081</li>
<li>将dist目录放到tomcat的webapp下，并重命名  <code>edu-boss</code></li>
<li>运行tomcat，即可访问前端项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;startup.sh </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态查看日志</span><br><span class="line">tail -f logs&#x2F;catalina.out </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问</span><br><span class="line">http:&#x2F;&#x2F;47.115.139.213:8081&#x2F;edu-boss&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="修改tomcat默认访问项目"><a href="#修改tomcat默认访问项目" class="headerlink" title="修改tomcat默认访问项目"></a>修改tomcat默认访问项目</h2><p>打开tomcat中的server.xml配置文件，找到 <code>host</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入以下内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;edu-boss&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attr">privileged</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启tomcat即可，只需要直接访问 8081即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;47.115.139.213:8081&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="配置nginx反向代理"><a href="#配置nginx反向代理" class="headerlink" title="配置nginx反向代理"></a>配置nginx反向代理</h2><p>1.修改本地hosts, 配置域名映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">47.115.139.213  www.edu-boss.com</span><br></pre></td></tr></table></figure>
<p>2.配置nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置ssm项目 反向代理</span></span><br><span class="line">	upstream lagouedu&#123;</span><br><span class="line">		server 47.115.139.213:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.edu-boss.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://lagouedu;  #转发的地址</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3.访问 <a href="http://www.edu-boss.com/">www.edu-boss.com</a> 即可</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2021/08/15/zookeeper/</url>
    <content><![CDATA[<p>在大数据技术生态圈中，有 zookeeper（动物管理员），Hadoop（大象），Hive（蜜蜂）， Pig（猪）等技术。Zookeeper是一个开源的分布式（多台服务器干一件事）的，为分布式应用提供协调服务的 Apache项目。<a id="more"></a></p>
<p><strong>工作机制</strong></p>
<ul>
<li>Zookeeper从设计模式角度来理解：是一个基于观察者模式（一个人干活，有人盯着他）设计的分 布式服务管理框架 </li>
<li>它负责 存储 和 管理 大家都关心的数据 <ul>
<li>然后接受观察者的<strong>注册</strong>，一旦这些数据的发生变化 </li>
<li>Zookeeper就将负责<strong>通知</strong>已经注册的那些观察者做出相应的反应 </li>
<li>从而实现集群中类似Master/Slave管理模式 </li>
</ul>
</li>
<li>Zookeeper = 文件系统 + 通知机制</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li>是一个leader和多个follower来组成的集群（狮群中，一头雄狮，N头母狮） </li>
<li>集群中只要有半数以上的节点存活，Zookeeper就能正常工作（5台服务器挂2台，没问题；4台服 务器挂2台，就停止） </li>
<li>全局数据一致性，每台服务器都保存一份相同的数据副本，无论client连接哪台server，数据都是 一致的 </li>
<li>数据更新原子性，一次数据要么成功，要么失败（不成功便成仁） </li>
<li>实时性，在一定时间范围内，client能读取到最新数据 </li>
<li>更新的请求按照顺序执行，会按照发送过来的顺序，逐一执行（发来123，执行123，而不是321 或者别的）</li>
</ol>
<p><strong>数据结构</strong></p>
<ul>
<li>ZooKeeper数据模型的结构与linux文件系统很类似，有一个根节点 / ,整体上可以看作是一棵树，每个节点称做一 个ZNode（ZookeeperNode）。 </li>
<li>每一个ZNode默认能够存储1MB的数据（元数据），每个ZNode的路径都是唯一的 <ul>
<li>元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、 资源查找、文件记录等功能</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等</p>
<h1 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h1><p>镜像库地址：<a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a></p>
<p>这里使用的是 apache-zookeeper-3.6.0-bin.tar.gz 版本，已经自带所需要的各种jar包</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.需要jdk环境</p>
<p>2.拷贝apache-zookeeper-3.6.0-bin.tar.gz到opt目录，并解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.重命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-zookeeper-3.6.0-bin zookeeper</span><br></pre></td></tr></table></figure>
<p>4.在/opt/zookeeper/这个目录上创建zkData和zkLog目录</p>
<p>5.在 /opt/zookeeper/conf 路径下，复制一份zoo_sample.cfg配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>6.编辑 zoo.cfg 配置文件，以后就用该配置，修改 dataDir 与 dataLogDir 路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkData</span><br><span class="line">dataLogDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkLog</span><br></pre></td></tr></table></figure>
<h2 id="zoo-cfg配置参数解读"><a href="#zoo-cfg配置参数解读" class="headerlink" title="zoo.cfg配置参数解读"></a>zoo.cfg配置参数解读</h2><ul>
<li>tickTime =2000：通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒 <ul>
<li>Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就 是每个tickTime时间就会发送一个心跳，时间单位为毫秒。 </li>
</ul>
</li>
<li>initLimit =10：LF初始通信时限 <ul>
<li>集群中的Follower跟随者服务器与Leader领导者服务器之间，启动时能容忍的最多心跳数 </li>
<li>10*2000（10个心跳时间）如果领导和跟随者没有发出心跳通信，就视为失效的连接，领导 和跟随者彻底断开 </li>
</ul>
</li>
<li>syncLimit =5：LF同步通信时限 <ul>
<li>集群启动后，Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime-&gt;10秒，Leader就认为Follwer已经死掉，会将Follwer从服务器列表中删除 </li>
</ul>
</li>
<li>dataDir：数据文件目录+数据持久化路径 。主要用于保存Zookeeper中的数据。 </li>
<li>dataLogDir：日志文件目录 </li>
<li>clientPort =2181：客户端连接端口 </li>
</ul>
<h2 id="操作Zookeeper"><a href="#操作Zookeeper" class="headerlink" title="操作Zookeeper"></a>操作Zookeeper</h2><p>1.启动 zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>2.关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh stop</span><br></pre></td></tr></table></figure>
<p>3.查看进程是否启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>QuorumPeerMain：是zookeeper集群的启动入口类，是用来加载配置启动QuorumPeer线程的</p>
<p>4.查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>
<p>5.启动客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>6.退出客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper内部原理"><a href="#zookeeper内部原理" class="headerlink" title="zookeeper内部原理"></a>zookeeper内部原理</h1><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><ul>
<li><p><strong>半数机制</strong>：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</p>
</li>
<li><p>虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为 Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的</p>
</li>
</ul>
<p>如果这里有3台服务器，zookeeper集群启动后：</p>
<p>server1先给自己投票，发现票数没过半，就会 把自己的票投给server2;</p>
<p>server2也给自己投一票，此时server2有两票，如果票数过半了，server2就是Leader;</p>
<p>server3也给自己投，但是也只是一票，只好听天由命，承认Server3是 leader</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul>
<li>持久型（persistent）： <ul>
<li><strong>持久化目录节点</strong>（persistent）客户端与zookeeper断开连接后，该节点依旧存在 </li>
<li><strong>持久化顺序编号目录节点</strong>（persistent_sequential）客户端与zookeeper断开连接后，该节 点依旧存在，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调 递增的计数器，由父节点维护，例如：Znode001，Znode002… </li>
</ul>
</li>
<li>短暂型（ephemeral）： <ul>
<li><strong>临时目录节点</strong>（ephemeral）客户端和服务器端断开连接后，创建的节点自动删除 </li>
<li><strong>临时顺序编号目录节点</strong>（ephemeral_sequential）客户端与zookeeper断开连接后，该节点 被删除，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增 的计数器，由父节点维护，例如：Znode001，Znode002…</li>
</ul>
</li>
</ul>
<h2 id="监听原理"><a href="#监听原理" class="headerlink" title="监听原理"></a>监听原理</h2><p><a href="https://imgtu.com/i/fgZ8e0"><img src="https://z3.ax1x.com/2021/08/15/fgZ8e0.png" alt="fgZ8e0.png"></a></p>
<ol>
<li>在main方法中创建Zookeeper客户端的同时就会创建两个线程，一个负责网络连接通信，一个负 责监听 </li>
<li>监听事件就会通过网络通信发送给zookeeper </li>
<li>zookeeper获得注册的监听事件后，立刻将监听事件添加到监听列表里 </li>
<li>zookeeper监听到 数据变化 或 路径变化，就会将这个消息发送给监听线程<ul>
<li>常见的监听 <ol>
<li>监听节点数据的变化：get path [watch] </li>
<li>监听子节点增减的变化：ls path [watch] </li>
</ol>
</li>
</ul>
</li>
<li>监听线程就会在内部调用process方法（需要我们实现process方法内容）</li>
</ol>
<h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><p><a href="https://imgtu.com/i/fgZ9RH"><img src="https://z3.ax1x.com/2021/08/15/fgZ9RH.png" alt="fgZ9RH.png"></a></p>
<ol>
<li>Client 想向 ZooKeeper 的 Server1 上写数据，必须的先发送一个写的请求 </li>
<li>如果Server1不是Leader，那么Server1 会把接收到的请求进一步转发给Leader。 </li>
<li>这个Leader 会将写请求广播给各个Server，各个Server写成功后就会通知Leader。 </li>
<li>当Leader收到半数以上的 Server 数据写成功了，那么就说明数据写成功了。 </li>
<li>随后，Leader会告诉Server1数据写成功了。 </li>
<li>Server1会反馈通知 Client 数据写成功了，整个流结束</li>
</ol>
<h1 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h1><p>准备好三台Linux服务器，都安装好 zookeeper</p>
<h2 id="配置服务器编号"><a href="#配置服务器编号" class="headerlink" title="配置服务器编号"></a>配置服务器编号</h2><p>1.在/opt/zookeeper/zkData创建myid文件</p>
<p>2.在文件中添加与server对应的编号：1 </p>
<p>3.其余两台服务器分别对应2和3</p>
<h2 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每台服务器上都添加如下配置</span></span><br><span class="line">server.1=192.168.204.141:2888:3888</span><br><span class="line">server.2=192.168.204.142:2888:3888</span><br><span class="line">server.3=192.168.204.143:2888:3888</span><br></pre></td></tr></table></figure>
<p><strong>配置参数解读 server.A=B:C:D</strong> </p>
<ul>
<li><strong>A</strong>：一个数字，表示第几号服务器 集群模式下配置的/opt/zookeeper/zkData/myid文件里面的数据就是A的值 </li>
<li><strong>B</strong>：服务器的ip地址 </li>
<li><strong>C</strong>：与集群中Leader服务器交换信息的端口 </li>
<li><strong>D</strong>：选举时专用端口，万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选 出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</li>
</ul>
<p>启动3台服务器，可通过   <code>./zkServer.sh status</code> 查看状态。</p>
<p><strong>注意</strong>  启动时没过半数以上，集群会失败。超过半数时才会成功，并且已经选举出了 leader</p>
<h1 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h1><ul>
<li>显示所有操作命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前znode中所包含的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看当前节点详细数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -s &#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li>cZxid：创建节点的事务 <ul>
<li>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。 </li>
<li>事务ID是ZooKeeper中所有修改总的次序。 </li>
<li>每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。 </li>
</ul>
</li>
<li>ctime：被创建的毫秒数(从1970年开始) </li>
<li>mZxid：最后更新的事务zxid </li>
<li>mtime：最后修改的毫秒数(从1970年开始) </li>
<li>pZxid：最后更新的子节点zxid </li>
<li>cversion：创建版本号，子节点修改次数 </li>
<li>dataVersion：数据变化版本号 </li>
<li>aclVersion：权限版本号 </li>
<li>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点 则是0。 </li>
<li>dataLength：数据长度 </li>
<li>numChildren：子节点数</li>
</ul>
</li>
<li><p>创建节点</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &#x2F;china   # 创建普通节点</span><br><span class="line">create &#x2F;usa &quot;pujing&quot;   # 创建节点并添加数据</span><br><span class="line">create -e &#x2F;hui		# 创建临时节点</span><br><span class="line">create -e -s &#x2F;dog	# 创建临时且带序号节点，序号从0开始递增。</span><br></pre></td></tr></table></figure>
<ul>
<li>获取节点的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;usa</span><br></pre></td></tr></table></figure>


<ul>
<li>修改节点数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set &#x2F;usa &quot;hhh&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>监听 节点的值变化 或 子节点变化（路径变化）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在server1添加监听</span><br><span class="line">addwatch &#x2F;china</span><br><span class="line"># 在server2中修改数据</span><br><span class="line">set &#x2F;china &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p> Server3会立刻响应 </p>
<p>WatchedEvent state:SyncConnected type:<strong>NodeDataChanged</strong> path:/china</p>
<p>如果在china下添加子节点，会响应</p>
<p>WatchedEvent state:SyncConnected type:<strong>NodeCreatedpath</strong>:/china/city</p>
<ul>
<li>删除节点(空节点)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &#x2F;china&#x2F;city</span><br></pre></td></tr></table></figure>
<ul>
<li>递归删除节点 （非空节点，节点下有子节点）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deleteall &#x2F;china</span><br></pre></td></tr></table></figure>
<h1 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h1><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建log4j.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO, stdout</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br><span class="line"></span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.File&#x3D;target&#x2F;zk.log</span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure>
<p><strong>创建ZooKeeper客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接zookeeper客户端的ip地址与端口</span></span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="comment">// 集群ip设置</span></span><br><span class="line">    <span class="comment">//    private String connectString = &quot;47.115.139.213:2181,47.115.139.214:2181,47.115.139.215:2181&quot;;</span></span><br><span class="line">    <span class="comment">// 超时时间，两分钟</span></span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper 客户端</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 监听器</span></span><br><span class="line">        Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已监听。。。&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;监听类型:&quot;</span>+watchedEvent.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建 zookeeper实例</span></span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建节点</strong></p>
<ul>
<li>节点权限类似linux的文件权限，不同的是共有5种操作：CREATE、READ、WRITE、DELETE、 ADMIN(对应更改ACL的权限) <ul>
<li>OPEN_ACL_UNSAFE：创建开放节点，允许任意操作 （用的最多，其余的权限用的很 少） </li>
<li>READ_ACL_UNSAFE：创建只读节点 </li>
<li>CREATOR_ALL_ACL：创建者才有全部权限</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：要创建的节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：节点数据</span></span><br><span class="line">    <span class="comment">// 参数3：节点权限</span></span><br><span class="line">    <span class="comment">// 参数4：节点的类型</span></span><br><span class="line">    String s = zoo.create(<span class="string">&quot;/hui&quot;</span>, <span class="string">&quot;isMe&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    <span class="comment">// 返回的数据是该节点的一些状态信息</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查询节点的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNodeDate</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    <span class="comment">// 参数3：不知道</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = zoo.getData(<span class="string">&quot;/hui&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Stat());</span><br><span class="line">    System.out.println(<span class="string">&quot;数据为:&quot;</span>+ <span class="keyword">new</span> String(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改节点的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNodeDate</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：修改的数据</span></span><br><span class="line">    <span class="comment">// 参数3：当前节点的数据变化版本号 dataVersion</span></span><br><span class="line">    Stat stat = zoo.setData(<span class="string">&quot;/hui&quot;</span>, <span class="string">&quot;hhhhhh&quot;</span>.getBytes(), <span class="number">0</span>);</span><br><span class="line">    System.out.println(stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：当前节点的数据变化版本号 dataVersion</span></span><br><span class="line">    zoo.delete(<span class="string">&quot;/fuck&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取子节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>监听子节点变化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让程序暂停在此处，如果节点发生变化，就会执行 watcher监听器（初始化zookeeper时传递的）</span></span><br><span class="line">    Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判断节点是否存在</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exist</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：节点的路径</span></span><br><span class="line">    <span class="comment">// 参数2：是否开启监听</span></span><br><span class="line">    Stat stat = zoo.exists(<span class="string">&quot;/hui2&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat==<span class="keyword">null</span>?<span class="string">&quot;不存在&quot;</span>:<span class="string">&quot;存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="案例-模拟美团上下线"><a href="#案例-模拟美团上下线" class="headerlink" title="案例-模拟美团上下线"></a>案例-模拟美团上下线</h2><p><strong>需求</strong></p>
<ul>
<li><p>模拟美团服务平台，商家营业通知，商家打烊通知 </p>
</li>
<li><p>提前在根节点下，创建好 /meituan 节点</p>
</li>
</ul>
<p><strong>商家类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String shopName = <span class="string">&quot;FKC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop();</span><br><span class="line">        <span class="comment">// 连接zookeeper （联系美团）</span></span><br><span class="line">        shop.connect();</span><br><span class="line">        <span class="comment">// 创建节点  （入驻美团）</span></span><br><span class="line">        shop.createShop(shopName);</span><br><span class="line">        <span class="comment">// 执行业务逻辑 （营业）</span></span><br><span class="line">        shop.doing(shopName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点，节点为临时有序节点，都已 shop 命名，节点的数据就是商店的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createShop</span><span class="params">(String shopName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo.create(<span class="string">&quot;/meituan/shop&quot;</span>, shopName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+shopName+<span class="string">&quot;]已开张！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行业务逻辑 （营业）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(String shopName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+shopName+<span class="string">&quot;]火爆营业中。。。。&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">&quot;47.115.139.213:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        <span class="comment">// 连接zookeeper (用户打开美团)</span></span><br><span class="line">        customer.connect();</span><br><span class="line">        <span class="comment">// 获取所有节点数据 (获取所有已开张的商店)</span></span><br><span class="line">        customer.getAllShop();</span><br><span class="line">        <span class="comment">// 执行逻辑代码 (浏览商家)</span></span><br><span class="line">        customer.doing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 zookeeper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zoo = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 重新获取所有数据</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getAllShop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有节点数据 (获取所有已开张的商店)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllShop</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 /meituan 下的所有节点，并开启监听</span></span><br><span class="line">        List&lt;String&gt; children = zoo.getChildren(<span class="string">&quot;/meituan&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 保存商店名</span></span><br><span class="line">        List&lt;String&gt; shopList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的数据，并放入shopList中</span></span><br><span class="line">            <span class="keyword">byte</span>[] shopName = zoo.getData(<span class="string">&quot;/meituan/&quot;</span>+child, <span class="keyword">false</span>, <span class="keyword">new</span> Stat());</span><br><span class="line">            shopList.add(<span class="keyword">new</span> String(shopName));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前营业商家:&quot;</span>+shopList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行逻辑代码 (浏览商家)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在浏览商家。。&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行客户类就会得到商家列表，如果某一个商家上线或下线，客户类的控制台上都会得到最新的商家列表。</p>
<h2 id="案例-分布式锁"><a href="#案例-分布式锁" class="headerlink" title="案例-分布式锁"></a>案例-分布式锁</h2><p>使用传统的锁引会发的 “羊群效应” ：1000个人创建节点，只有一个人能成功，999 人需要等待,当锁释放时，其余的999人都会去抢这个锁，这样会变得非常散乱。</p>
<p><a href="https://imgtu.com/i/fg8yJ1"><img src="https://z3.ax1x.com/2021/08/15/fg8yJ1.png" alt="fg8yJ1.png"></a></p>
<p><strong>避免“羊群效应”，zookeeper采用分布式锁</strong></p>
<p><a href="https://imgtu.com/i/fgG9Wq"><img src="https://z3.ax1x.com/2021/08/15/fgG9Wq.png" alt="fgG9Wq.png"></a></p>
<ol>
<li>所有请求进来，在/lock下创建 临时顺序节点 ，放心，zookeeper会帮你编号排序 </li>
<li>判断自己是不是/lock下最小的节点 <ol>
<li>是，获得锁（创建节点）</li>
<li> 否，对前面小我一级的节点进行监听</li>
</ol>
</li>
<li>获得锁请求，处理完业务逻辑，释放锁（删除节点），后一个节点得到通知（比你年轻的走了，你 成为最小的了）</li>
</ol>
<h3 id="搭建一个SSM工程"><a href="#搭建一个SSM工程" class="headerlink" title="搭建一个SSM工程"></a>搭建一个SSM工程</h3><p>对<strong>商品表</strong>和<strong>订单表</strong>操作，如果当前商品库存为0就不能继续购买了,如果大于0 就生成订单.</p>
<p><strong>业务层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductMapper productMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceStock</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取库存</span></span><br><span class="line">        Product product = productMapper.getProduct(id);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(product.getStock() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;已抢光！&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.减库存</span></span><br><span class="line">        <span class="keyword">int</span> i = productMapper.reduceStock(id);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 3.生成订单</span></span><br><span class="line">            Order order = <span class="keyword">new</span> Order();</span><br><span class="line">            order.setId(UUID.randomUUID().toString());</span><br><span class="line">            order.setPid(id);</span><br><span class="line">            order.setUserid(<span class="number">101</span>);</span><br><span class="line">            orderMapper.insert(order);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;减库存失败，请重试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>控制层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/reduce&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        orderService.reduceStock(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其余代码省略</strong></p>
<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p><strong>1.启动两个tomcat工程，端口号分别8001和8002</strong></p>
<p><strong>2.使用nginx做负载均衡</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream hui&#123;</span><br><span class="line">    server 192.168.204.1:8001;</span><br><span class="line">    server 192.168.204.1:8002;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://hui;</span><br><span class="line">		root html;</span><br><span class="line">		index index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.使用 JMeter 模拟1秒内发出10个http请求</strong></p>
<p>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p><a href="https://imgtu.com/i/fgYxTe"><img src="https://z3.ax1x.com/2021/08/15/fgYxTe.md.png" alt="fgYxTe.md.png"></a></p>
<p><a href="https://imgtu.com/i/fgt9fA"><img src="https://z3.ax1x.com/2021/08/15/fgt9fA.png" alt="fgt9fA.png"></a></p>
<ol>
<li>查看测试结果，10次请求全部成功 </li>
<li>查看数据库，stock库存从5变成 -5 （并发导致的数据结果错误）</li>
</ol>
<h3 id="使用分布式锁"><a href="#使用分布式锁" class="headerlink" title="使用分布式锁"></a>使用分布式锁</h3><p>基于zookeeper原生态的客户端类实现分布式是非常麻烦的，我们使用apahce提供了一个zookeeper客 户端来实现。Curator：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 网友投票最牛逼版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>在控制层加入分布式锁的逻辑代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String connectString =<span class="string">&quot;192.168.204.141:2181&quot;</span>;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/reduce&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduce</span><span class="params">( <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 重试策略 （1000毫秒试1次，最多试3次）</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//1.创建curator工具对象</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retryPolicy);</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//2.根据工具对象创建“内部互斥锁”</span></span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">&quot;/product_&quot;</span>+id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.加锁</span></span><br><span class="line">            lock.acquire();</span><br><span class="line">            <span class="comment">// 执行原来的业务逻辑操作</span></span><br><span class="line">            productService.reduceStock(id);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException)&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//4.释放锁</span></span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/2021/08/17/dubbo/</url>
    <content><![CDATA[<ul>
<li>Dubbo是分布式服务框架，是阿里巴巴的开源项目，现交给apache进行维护 </li>
<li>Dubbo致力于提高性能和透明化的<strong>RPC</strong>远程服务调用方案，以及<strong>SOA</strong>服务治理方案 </li>
<li>简单来说，dubbo是个服务框架，如果没有分布式的需求，是不需要用的</li>
</ul>
<a id="more"></a>

<h1 id="dubbo的基本概述"><a href="#dubbo的基本概述" class="headerlink" title="dubbo的基本概述"></a>dubbo的基本概述</h1><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式</p>
<p><strong>RPC基本的通信原理</strong></p>
<ol>
<li>在客户端将对象进行序列化 </li>
<li>底层通信框架使用netty（基于tcp协议的socket），将序列化的对象发给服务方提供方 </li>
<li>服务提供方通过socket得到数据文件之后，进行反序列化，获得要操作的对象 </li>
<li>对象数据操作完毕，将新的对象序列化，再通过服务提供方的socket返回给客户端 </li>
<li>客户端获得序列化数据，再反序列化，得到最新的数据对象，至此，完成一次请求</li>
</ol>
<p><a href="https://imgtu.com/i/fh22lR"><img src="https://z3.ax1x.com/2021/08/17/fh22lR.png" alt="fh22lR.png"></a></p>
<p><strong>RPC两个核心模块</strong>：通讯（socket） 、  序列化。</p>
<h2 id="dubbo的运行流程"><a href="#dubbo的运行流程" class="headerlink" title="dubbo的运行流程"></a>dubbo的运行流程</h2><p><strong>节点角色</strong></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>服务的提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>服务的消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>监控服务的统计中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p><a href="https://imgtu.com/i/fhWeKI"><img src="https://z3.ax1x.com/2021/08/17/fhWeKI.png" alt="fhWeKI.png"></a></p>
<p><strong>调用关系</strong></p>
<ol start="0">
<li><p>服务容器负责启动，加载，运行服务提供者； </p>
</li>
<li><p>服务提供者在启动时，向注册中心注册自己提供的服务； </p>
</li>
<li><p>服务消费者在启动时，向注册中心订阅自己所需的服务； </p>
</li>
<li><p>在注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给 消费者； </p>
</li>
<li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败， 再选另一台调用； </p>
</li>
<li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中 心；</p>
</li>
</ol>
<h1 id="系统架构演变"><a href="#系统架构演变" class="headerlink" title="系统架构演变"></a>系统架构演变</h1><h2 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h2><ul>
<li>当网站流量很小时，只需要一个应用，将所有的功能部署到一起（所有业务都放在一个tomcat 里），从而减少部署节点和成本； </li>
<li>此时，用于简化 增删改查 工作量的数据访问框架 （ORM）是关键；</li>
<li>例如：某个超市的收银系统，某个公司的员工管理系统</li>
</ul>
<p><a href="https://imgtu.com/i/fhfUld"><img src="https://z3.ax1x.com/2021/08/17/fhfUld.png" alt="fhfUld.png" style="zoom: 80%;" /></a></p>
<p><strong>ORM</strong>：对象关系映射（Object Relational Mapping）</p>
<p><strong>优点</strong></p>
<p>小项目开发快 、成本低、 架构简单 、易于测试、 易于部署</p>
<p><strong>缺点</strong></p>
<ul>
<li>大项目模块耦合严重 不易开发 维护 沟通成本高 </li>
<li>新增业务困难 </li>
<li>核心业务与边缘业务混合在一块，出现问题互相影响</li>
</ul>
<h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h2><ul>
<li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成几个互不相干的几个应 用,以提高效率； </li>
<li>大模块按照mvc分层模式，进行拆分成多个互不相关的小模块，并且每个小模块都有独立的服务器 </li>
<li>此时，用于加速前端页面开发的web框架（MVC）是关键；因为每个小应用都有独立的页面</li>
</ul>
<p><a href="https://imgtu.com/i/fhfgpQ"><img src="https://z3.ax1x.com/2021/08/17/fhfgpQ.png" alt="fhfgpQ.png" style="zoom:80%;" /></a></p>
<p><strong>MVC</strong>：模型视图控制器 （Model View Controller）</p>
<p><strong>缺点</strong>： 模块之间不可能完全没有交集，公用模块无法重复利用，开发性的浪费</p>
<h2 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h2><ul>
<li>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的业务，逐渐形成 稳健的服务中心，使前端应用能更快速的响应多变的市场需求； </li>
<li>此时，用户提高业务复用及整合的分布式服务框架（RPC）远程调用是关键</li>
</ul>
<p><a href="https://imgtu.com/i/fhhM9g"><img src="https://z3.ax1x.com/2021/08/17/fhhM9g.png" alt="fhhM9g.png" style="zoom:80%;" /></a></p>
<p><strong>RPC</strong>：独立的应用服务器之间，要依靠RPC（Romote Procedure Call）才能调用</p>
<p><strong>缺点</strong>：不能做到资源优化调配，如物流服务不忙，有100台服务器； 商品服务特别忙，也是100台服务器；</p>
<h2 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h2><ul>
<li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐呈现，此时需增加一个调度中心基于 访问压力实时管理集群容量，提高集群利用率； </li>
<li>此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键；</li>
</ul>
<p><a href="https://imgtu.com/i/fhhtEV"><img src="https://z3.ax1x.com/2021/08/17/fhhtEV.png" alt="fhhtEV.png" style="zoom:80%;" /></a></p>
<p><strong>SOA</strong>：面向服务架构（Service-Oriented Architecture），简单理解就是“服务治理”，例如：公交车站 的“调度员”</p>
<h1 id="dubbo快速入门"><a href="#dubbo快速入门" class="headerlink" title="dubbo快速入门"></a>dubbo快速入门</h1><p><strong>官网</strong>   <a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p><strong>zookeeper</strong></p>
<ul>
<li>官方推荐使用zookeeper注册中心； </li>
<li>注册中心负责服务地址的注册与查找，相当于目录服务； </li>
<li>服务提供者和消费者只在启动时与注册中心交互，注册中不转发请求，压力较小； </li>
<li>Zookeeper是apache hadoop的子项目，是一个树形的目录服务，支持变更推送，适合作为 dubbo的服务注册中心，工业强度较高，可用于生产环境；</li>
</ul>
<p><strong>需要在Linux上安装并启动zookeeper服务（详情步骤略）</strong></p>
<h2 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h2><p>1、一个空的maven项目 </p>
<p>2、提供一个服务接口即可</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>(各种依赖请严格按照下面的版本)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.6.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dubbo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8001<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 打包完成后,运行服务 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务方接口及实现类"><a href="#服务方接口及实现类" class="headerlink" title="服务方接口及实现类"></a>服务方接口及实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是alibaba提供的 service 注解</span></span><br><span class="line"><span class="meta">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name + <span class="string">&quot;!!!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务方的配置文件spring-xml"><a href="#服务方的配置文件spring-xml" class="headerlink" title="服务方的配置文件spring.xml"></a>服务方的配置文件spring.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.服务提供方在zookeeper中的“别名”--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;dubbo-server&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.注册中心的地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.204.141:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.扫描类（将什么包下的类作为服务提供类）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;com.hui.service.impl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务方的web-xml"><a href="#服务方的web-xml" class="headerlink" title="服务方的web.xml"></a>服务方的web.xml</h3><p>因为要远程调用，所以都是war项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listenerclass</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><p>与服务方一致，只需要修改tomcat的端口为8002</p>
<h3 id="消费方的Controller"><a href="#消费方的Controller" class="headerlink" title="消费方的Controller"></a>消费方的Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该注解表示从HelloService是从远程调用的</span></span><br><span class="line">    <span class="meta">@com</span>.alibaba.dubbo.config.annotation.Reference</span><br><span class="line">    <span class="keyword">private</span> HelloService hs;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">( String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hs.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费方的接口"><a href="#消费方的接口" class="headerlink" title="消费方的接口"></a>消费方的接口</h3><p>controller中要依赖HelloService，所以我们创建一个接口； 这里是消费方，不需要实现，因为实现会让服务方为我们搞定！该接口要与消费方的保存一致。</p>
<h3 id="消费方的配置文件springmvc-xml"><a href="#消费方的配置文件springmvc-xml" class="headerlink" title="消费方的配置文件springmvc.xml"></a>消费方的配置文件springmvc.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Dubbo的应用名称，通常使用项目名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;dubbo-consumer&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Dubbo的注册中心地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.204.141:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Dubbo扫描类，将这个类作为服务进行发布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;com.hui.controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="消费方的web-xml"><a href="#消费方的web-xml" class="headerlink" title="消费方的web.xml"></a>消费方的web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servletclass</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务测试"><a href="#启动服务测试" class="headerlink" title="启动服务测试"></a>启动服务测试</h2><p>首先启动服务方，再启动消费方。 </p>
<p>访问：<a href="http://localhost:8002/hello?name=james">http://localhost:8002/hello?name=james</a></p>
<h1 id="监控中心"><a href="#监控中心" class="headerlink" title="监控中心"></a>监控中心</h1><p>我们在开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。 </p>
<p>我们可以通过部署一个web应用版的管理中心来实现图形化显示注册中心的服务列表 </p>
<h2 id="服务管理器"><a href="#服务管理器" class="headerlink" title="服务管理器"></a>服务管理器</h2><p>1.下载 <strong>dubbo-admin-master.zip</strong>，并解压</p>
<p>2.修改配置文件 dubbo-admin-master/dubbo-admin/src/main/resource/application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 管理端的端口</span><br><span class="line">server.port&#x3D;7001</span><br><span class="line"># 注册中心的地址</span><br><span class="line">dubbo.regestry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.31.78:2181</span><br></pre></td></tr></table></figure>
<p>3.返回 dubbo-admin-master/dubbo-admin目录，打开cmd，使用maven打包: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>4.打包完毕后，进入target目录，执行jar文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin-0.0.1-SNAPASHOT.jar</span><br></pre></td></tr></table></figure>
<p>5.此时打开浏览器输入：<a href="http://localhost:7001/">http://localhost:7001/</a> ； 第一次访问时，需要登录，帐号密码都是root</p>
<h2 id="监控统计中心"><a href="#监控统计中心" class="headerlink" title="监控统计中心"></a>监控统计中心</h2><p><strong>Monitor</strong>：统计中心 ，记录服务被调用多少次等</p>
<p>1.下载并解压<strong>dubbo-monitor-simple-2.5.3.zip</strong> </p>
<p>2.修改dubbo-monitor-simple-2.5.3\conf\dubbo.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 管理端的端口</span><br><span class="line">dubbo.jetty.port&#x3D;8080</span><br><span class="line"># 注册中心的地址</span><br><span class="line">dubbo.regestry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.31.78:2181</span><br></pre></td></tr></table></figure>
<p>3.双击运行dubbo-monitor-simple-2.5.3\bin\start.bat </p>
<p>4.此时打开浏览器输入：<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p><strong>注意</strong>  需要修改dubbo-server和dubbo-consumer的spring.xml，加入下面标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 让监控 去注册中心 自动找服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="常用的配置说明"><a href="#常用的配置说明" class="headerlink" title="常用的配置说明"></a>常用的配置说明</h1><h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><ul>
<li>启动时会在注册中心检查依赖的服务是否可用，不可用时会抛出异常 </li>
<li>在消费方编写初始化容器的main方法启动（tomcat启动方式，必须访问一次action才能初始化 spring）</li>
</ul>
<p>系统级别日志，需要配合log4j才输出，在resources下添加log4j.properties，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">dubbo.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">error, stdout,file</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>可在消费方配置是否抛异常</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认是true:抛异常；false:不抛异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h2><ul>
<li>由于网络或服务端不可靠，会导致调用过程中出现不确定的阻塞状态（超时） </li>
<li>为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间 </li>
<li>在服务提供者添加如下配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置超时时间为2秒，默认为1秒--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可在服务提供方加入<code>Thread.sleep(3000)</code>模拟的网络延迟进行测试 , 超时会报错。</p>
<p><strong>配置原则</strong></p>
<p>dubbo推荐在Provider上尽量多配置Consumer端属性： </p>
<ul>
<li>作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试 次数，等等 </li>
<li>在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可 以作消费者的<strong>缺省值</strong>。</li>
</ul>
<h2 id="重试次数"><a href="#重试次数" class="headerlink" title="重试次数"></a>重试次数</h2><ul>
<li>当出现失败，自动切换并重试其它服务器，dubbo重试的缺省值是2次，我们可以自行设置 </li>
<li>在provider提供方配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 消费方连接第1次不算，再来重试3次，总共重试4次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>并不是所有的方法都适合设置重试次数 </p>
<ul>
<li>幂等方法：适合（当参数一样，无论执行多少次，结果是一样的，例如：查询，修改）</li>
<li> 非幂等方法：不适合（当参数一样，执行结果不一样，例如：删除，添加）</li>
</ul>
</li>
<li><p>单独设置某个方法</p>
<p>在接口中多添加几个方法,在消费方配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayNo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 不重试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  消费方的controller中不能使用  <strong>@Reference</strong>  注解了，此注解已经在xml文件中被顶替，所以使用  <strong>@Autowired</strong>  自动注入 即可</p>
</li>
</ul>
<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><ul>
<li><p>一个接口，多个（版本的）实现类，可以使用定义版本的方式引入 </p>
</li>
<li><p>为HelloService接口定义两个实现类，提供者修改配置：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.HelloServiceImpl01&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.hui.service.impl.HelloServiceImpl02&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消费者就可以根据version的版本，选择具体的服务版本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayNo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当消费者的版本修改为 version=”*”，那么就会随机调用服务提供者的版本</li>
</ul>
<h2 id="本地存根"><a href="#本地存根" class="headerlink" title="本地存根"></a>本地存根</h2><p>先在消费者处理一些业务逻辑，再调用提供者的过程，就是“本地存根”。</p>
<p> 在消费方需要创建一个HelloServiceStub类并且实现HelloService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceStub</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line">    <span class="comment">// 该对象为一个代理对象，表示远程的 HelloService 实现类</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须使用构造方法的方式注入helloService</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServiceStub</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验失败就直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(name==<span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;请输入正确格式！！！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用原先的方法</span></span><br><span class="line">        <span class="keyword">return</span> helloService.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">no</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.no();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改消费者配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">stub</span>=<span class="string">&quot;com.hui.stub.HelloServiceStub&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayNo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ul>
<li>负载均衡（Load Balance）, 其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作 任务。</li>
<li> 简单的说，好多台服务器，不能总是让一台服务器干活，应该“雨露均沾” </li>
<li>dubbo一共提供4种策略，默认为 random 随机分配调用</li>
</ul>
<p><a href="https://imgtu.com/i/fhLBFA"><img src="https://z3.ax1x.com/2021/08/17/fhLBFA.png" alt="fhLBFA.png"></a></p>
<p><strong>修改提供者配置, 并启动3个提供者，让消费者对其进行访问</strong></p>
<ul>
<li>tomcat端口8001，8002，8003 </li>
<li>provider端口20881，20882，20883</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20881&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认是 random随机分配调用</p>
<p><strong>消费方可修改策略</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.hui.service.HelloService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayNo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>可在管理端修改权重</strong></p>
<p><a href="https://imgtu.com/i/fhOju8"><img src="https://z3.ax1x.com/2021/08/17/fhOju8.png" alt="fhOju8.png"></a></p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据 </li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 </li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong> </li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用 </li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p>先正常发送请求，然后关闭 zookeeper <code>./zkServer.sh stop</code> ，消费者仍然可以正常消费</p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务降级，就是根据实际的情况和流量，对一些服务有策略的停止或换种简单的方式处理，从而释 放服务器的资源来保证核心业务的正常运行</p>
<p><strong>为什么要服务降级</strong></p>
<ul>
<li><p>防止分布式服务发生<strong>雪崩效应</strong></p>
</li>
<li><p>雪崩就是蝴蝶效应，当一个请求发生超时，一直等待着服务响应，那么在高并发情况下， 很多请求都是因为这样一直等着响应，直到服务资源耗尽产生宕机，而宕机之后会导致分布式其他 服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪，这就是雪崩。</p>
</li>
</ul>
<p><strong>服务降级实现方式</strong></p>
<ul>
<li><strong>屏蔽</strong>：mock=force:return+null 表示消费方对该服务的方法调用都 直接返回 null 值，不发起远程 调用。用来屏蔽不重要服务不可用时对调用方的影响。 </li>
<li><strong>容错</strong>：mock=fail:return+null 表示消费方对该服务的方法调用在 失败后，再返回 null 值，不抛异 常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<p><strong>在管理控制台配置服务降级</strong></p>
<p><a href="https://imgtu.com/i/fhjkid"><img src="https://z3.ax1x.com/2021/08/17/fhjkid.png" alt="fhjkid.png"></a></p>
<h1 id="整合MyBatis实现用户注册"><a href="#整合MyBatis实现用户注册" class="headerlink" title="整合MyBatis实现用户注册"></a>整合MyBatis实现用户注册</h1><p><strong>sql 创建users表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    uid <span class="type">INT</span>(<span class="number">11</span>) AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    PASSWORD <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    createtime <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="lagou-dubbo-parent"><a href="#lagou-dubbo-parent" class="headerlink" title="lagou-dubbo-parent"></a>lagou-dubbo-parent</h2><p>父工程，聚合项目：定义所有模块用的依赖版本。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lagou-dubbo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>lagou-dubbo-entity<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>lagou-dubbo-dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>lagou-dubbo-interface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>lagou-dubbo-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>lagou-dubbo-web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.6.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP相关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dubbo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="lagou-dubbo-entity"><a href="#lagou-dubbo-entity" class="headerlink" title="lagou-dubbo-entity"></a>lagou-dubbo-entity</h2><p>实体工程，jar项目</p>
<p><strong>注意</strong>  所有的实体类都需要实现序列化</p>
<h2 id="lagou-dubbo-dao"><a href="#lagou-dubbo-dao" class="headerlink" title="lagou-dubbo-dao"></a>lagou-dubbo-dao</h2><p>数据访问层工程，jar项目 </p>
<p>需要依赖 lagou-dubbo-entity 模块，只需关注spring与mybatis的整合。</p>
<h2 id="lagou-dubbo-interface"><a href="#lagou-dubbo-interface" class="headerlink" title="lagou-dubbo-interface"></a>lagou-dubbo-interface</h2><p>服务接口定义工程，jar项目</p>
<p>需依赖lagou-dubbo-dao模块，间接依赖 lagou-dubbo-entity 模块。</p>
<p>该模块只需定义业务层的接口，无其他别的操作。</p>
<h2 id="lagou-dubbo-service"><a href="#lagou-dubbo-service" class="headerlink" title="lagou-dubbo-service"></a>lagou-dubbo-service</h2><p>privoder服务提供者工程，war项目</p>
<p>依赖lagou-dubbo-interface模块与lagou-dubbo-dao模块，实现 lagou-dubbo-interface 中的接口。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lagou-dubbo-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hui<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lagou-dubbo-dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8001<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 打包完成后,运行服务 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-service.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  服务提供方在zookeeper中的“别名”  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;lagou-dubbo-server&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注册中心的地址  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://47.115.139.213:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  包扫描（将什么包下的类作为服务提供类）  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;service.Impl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  超时时间为60秒  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;60000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--监听器加载spring配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    注意，需要扫描 spring-service.xml与spring-dao.xml    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="lagou-dubbo-web"><a href="#lagou-dubbo-web" class="headerlink" title="lagou-dubbo-web"></a>lagou-dubbo-web</h2><p>consumer服务消费者工程，war项目</p>
<p>依赖lagou-dubbo-interface模块，pom.xml中也要加入tomcat7插件。 </p>
<p><strong>spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  json转换器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;application/json&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;features&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteMapNullValue<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteDateUseDateFormat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  放行静态资源  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  服务提供方在zookeeper中的“别名”  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;lagou-dubbo-consumer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  注册中心的地址  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://47.115.139.213:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  包扫描（将什么包下的类作为服务提供类）  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决post乱码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>charset<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>charset<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  前端控制器，并加载springmvc配置文件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2021/08/18/redis/</url>
    <content><![CDATA[<p>Redis 是一种运行速度很快，并发性能很强，并且运行在内存上的NoSql（not only sql）数据库。NoSql数据库还有 Memcache 、MongoDB 等。Redis的常用使用场景：缓存、排行榜、计算器\限速器、好友关系、简单消息队列、Session共享。<a id="more"></a></p>
<p><strong>分布式数据库CAP原理</strong></p>
<ul>
<li>传统的关系型数据库事务具备ACID： <ul>
<li>A：原子性 </li>
<li>C：一致性 </li>
<li>I：独立性 </li>
<li>D：持久性 </li>
</ul>
</li>
<li>分布式数据库的CAP:<ul>
<li>C（Consistency）：<strong>强一致性</strong> <ul>
<li>“all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所 有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统 中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问 题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 </li>
</ul>
</li>
<li>A（Availability）：<strong>高可用性</strong> <ul>
<li>可用性指“Reads and writes always succeed”，即服务一直可用，而且要是正常的响应 时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问 超时等用户体验不好的情况。</li>
</ul>
</li>
<li>P（Partition tolerance）：<strong>分区容错性</strong> <ul>
<li>即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性或可用性 的服务。 </li>
<li>分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转 正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器 还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>CAP理论</strong></p>
<ul>
<li>CAP理论提出就是针对分布式数据库环境的，所以，P这个属性必须容忍它的存在，而且是必须具 备的。 </li>
<li>因为P是必须的，那么我们需要选择的就是A和C。 大家知道，在分布式环境下，为了保证系统可用性，通常都采取了复制的方式，避免一个节点损 坏，导致系统不可用。那么就出现了每个节点上的数据出现了很多个副本的情况，而数据从一个节 点复制到另外的节点时需要时间和要求网络畅通的，所以，当P发生时，也就是无法向某个节点复 制数据时，这时候你有两个选择： <ul>
<li>选择可用性 A，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能 保证是同步的了（失去了C属性）。 </li>
<li>选择一致性C，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过 程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。 </li>
</ul>
</li>
</ul>
<p><strong>分区是常态，不可避免，三者不可共存</strong></p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大 类： </p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 </li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 </li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>redis官网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a>  , 下载 <strong>redis-5.0.4.tar.gz</strong> 版本</p>
<p>图形工具：<a href="https://redisdesktop.com/download">https://redisdesktop.com/download</a></p>
<p>Redis虽然可以在安装在windows操作系统，但是官方不推荐，所以我们一如既往的安装在linux上，图形工具则是Windos版本。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.上传tar.gz包，并解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-5.0.4.tar.gz</span><br></pre></td></tr></table></figure>
<p>2.安装gcc（必须有网络）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>
<p>忘记是否安装过，可以使用 gcc -v 命令查看gcc版本，如果没有安装过，会提示命令不存在 </p>
<p>3.进入redis目录，进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>4.编译之后，开始安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装成功后，所有的Redis命令在  <code>/usr/local/bin</code> 目录下，主配置文件为 <code>/opt/redis-5.0.4/redis.conf</code></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>启动Redis</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p><strong>后台运行方式</strong></p>
<p>redis默认不会使用后台运行，如果需要，则修改配置文件<strong>redis.conf</strong> 中  <code>daemonize=yes</code>，当你后台服务启动的 时候，会写成一个进程文件运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以配置文件启动</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">redis-server &#x2F;opt&#x2F;redis-5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p><strong>关闭Redis</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单实例关闭</span><br><span class="line">redis-cli shutdown</span><br><span class="line"># 多实例关闭</span><br><span class="line">redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure>
<p><strong>连接Redis客户端</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">ping  # 测试，返回PONG表示正常连接</span><br></pre></td></tr></table></figure>
<p><strong>其他命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检测6379端口是否在监听</span><br><span class="line">netstat -lntp | grep 6379</span><br><span class="line"># 检测后台进程是否存在</span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>
<p><strong>性能测试</strong></p>
<ul>
<li>按 ctrl + c ，退出 redis 客户端</li>
<li>执行<code>/usr/local/bin</code>下的测试命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-benchmark</span><br></pre></td></tr></table></figure>
<ul>
<li>执行命令后，命令不会自动停止，需要我们手动ctrl+c停止测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# redis-benchmark</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; PING_INLINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">100000 requests completed in 1.80 seconds # 1.8秒处理了10万个请求，性能要看服务器的配置高低</span><br><span class="line">50 parallel clients</span><br><span class="line">3 bytes payload</span><br><span class="line">keep alive: 1</span><br><span class="line">87.69% &lt;&#x3D; 1 milliseconds</span><br><span class="line">99.15% &lt;&#x3D; 2 milliseconds</span><br><span class="line">99.65% &lt;&#x3D; 3 milliseconds</span><br><span class="line">99.86% &lt;&#x3D; 4 milliseconds</span><br><span class="line">99.92% &lt;&#x3D; 5 milliseconds</span><br><span class="line">99.94% &lt;&#x3D; 6 milliseconds</span><br><span class="line">99.97% &lt;&#x3D; 7 milliseconds</span><br><span class="line">100.00% &lt;&#x3D; 7 milliseconds</span><br><span class="line">55524.71 requests per second # 每秒处理的请求数量</span><br></pre></td></tr></table></figure>
<p><strong>设置密码</strong></p>
<ul>
<li><p>临时</p>
<ul>
<li>启动redis,进入redis-cli</li>
<li>查看是否已经设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure>
<ul>
<li>若没有就设置新的验证密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set requirepass &quot;youpassword&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>永久(推荐)</p>
<ul>
<li>修改 redis.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># requirepass foobared</span><br><span class="line">requirepass yourpassword  &#x2F;&#x2F;此处注意，行前不能有空格</span><br></pre></td></tr></table></figure></li>
<li><p>*注意**</p>
</li>
<li><p>设置了密码后,进入redis-cli 需带密码 <code>redis-cli -a [password]</code></p>
</li>
<li><p><code>redis-cli shutdown</code>命令将无效,要进入redis-cli,执行<code>shutdown</code>才能关闭redis</p>
</li>
</ul>
<h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p>操作文档：<a href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<p>redis默认16个数据库，下标从0开始，15结束。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><strong>切换数据库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 15  		# 切换到15号数据库</span><br></pre></td></tr></table></figure>
<p><strong>当前数据库键值的数量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>
<p><strong>清空数据库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushdb         # 清空当前数据库</span><br><span class="line">flushall		# 清空所有（16个）库，慎用！</span><br></pre></td></tr></table></figure>
<p><strong>模糊查询key</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##  *：通配任意多个字符</span><br><span class="line">keys *			# 查询所有的键</span><br><span class="line">keys k*			# 模糊查询k开头</span><br><span class="line">keys *k			# 模糊查询k结尾</span><br><span class="line">keys *k*		# 查询包含k的键</span><br><span class="line"></span><br><span class="line">##  ?：通配单个字符</span><br><span class="line">keys k??   		# 以k开头，后面有任意两个字符</span><br><span class="line"></span><br><span class="line">## []：通配括号内的某一个字符</span><br><span class="line">keys r[ae]dis 	# 记得其他字母，就第二个字母可能是a或e</span><br></pre></td></tr></table></figure>
<p><strong>查询键是否存在</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exists k1	# k1是否存在，返回1表示存在，0表示不存在</span><br></pre></td></tr></table></figure>
<p><strong>移动（剪切）键到几号库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move x1 8 	# 将x1移动到8号库</span><br></pre></td></tr></table></figure>
<p><strong>生命周期:expire key 秒</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expire k1 10	# 设置k1的过期时间为10秒（10秒后自动销毁）</span><br></pre></td></tr></table></figure>
<p><strong>查看键还有多久过期:ttl key(-1永不过期，-2已过期，time to live 还能活多久)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttl x1</span><br></pre></td></tr></table></figure>
<p><strong>查看键的数据类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type k1</span><br></pre></td></tr></table></figure>
<h2 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h2><ul>
<li>set/get/del/append/strlen</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set k1 v1		# 保存数据</span><br><span class="line">get k1 			# 获取数据</span><br><span class="line">del K1			# 删除数据</span><br><span class="line">append k1 abc 	# 往k1中追加abc</span><br><span class="line">strlen k1 		# 返回k1值的长度（字符数量）</span><br></pre></td></tr></table></figure>
<ul>
<li>incr/decr/incrby/decrby：加减操作，操作的必须是数字类型 <ul>
<li>incr：意思是increment，增加 </li>
<li>decr：意思是decrement，减少</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set k1 1		# 初始化k1的值为1</span><br><span class="line">incr k1			# k1++</span><br><span class="line">decr k1 		# k1&#x3D;&#x3D;</span><br><span class="line">incrby k1 3		# k1+&#x3D;3</span><br><span class="line">decrby k1 3		# k1-&#x3D;3</span><br></pre></td></tr></table></figure>
<ul>
<li>getrange/setrange：类似between…and… <ul>
<li>range：范围</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getrange k1 0 -1 	# 查询k1全部的值</span><br><span class="line">getrange k1 0 3 	# 查询k1的值，范围是下标0~下标3（包含0和3，共返回4个字符）</span><br><span class="line">setrange k1 1 xxx 	# 替换k1的值，从下标1开始,替换为xxx</span><br></pre></td></tr></table></figure>
<ul>
<li><p>setex/setnx</p>
<ul>
<li><strong>set</strong> with <strong>ex</strong>pir：添加数据的同时设置生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setex k1 5 v1  # 添加k1 v1数据的同时，设置5秒的声明周期</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>set</strong> if <strong>n</strong>ot e<strong>x</strong>ist：添加数据的时候判断是否已经存在，防止已存在的数据被覆盖掉</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setnx k1 sun 	# 添加失败，因为k1已经存在</span><br></pre></td></tr></table></figure></li>
<li><p>mset/mget/msetnx </p>
<ul>
<li>m：more更多</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mset k1 v1 k2 v2 		# mset可以一次添加多条数据</span><br><span class="line">mget k2 k3 			# 一次获取多条数据</span><br><span class="line">msetnx k4 v4 k5 v5 	# 一次添加多条数据时，如果添加的数据中都不存在的，则成功</span><br></pre></td></tr></table></figure>
<ul>
<li>getset：先get后set</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getset k6 vv6  # 先获取k6的值，然后修改k6的值为vv6,如果没有就返回null</span><br></pre></td></tr></table></figure>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p><strong>push</strong> : 压入数据       <strong>pop</strong> : 弹出数据</p>
<ul>
<li>lpush/rpush/lrange <ul>
<li>l：left 自左向右→添加 （从上往下添加） </li>
<li>r：right 自右向左←添加（从下往上添加）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpush list01 1 2 3 4 5 # 从上往下添加</span><br><span class="line">rpush list02 1 2 3 4 5 # 从下往上添加</span><br><span class="line">lrange list01 0 -1 # 查询list01中的全部数据0表示开始，-1表示结尾</span><br></pre></td></tr></table></figure>
<ul>
<li>lpop/rpop：移除第一个元素（上左下右）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpop list02 	# 从左（上）边移除第一个元素</span><br><span class="line">rpop list02 	# 从右（下）边移除第一个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>lindex：根据下标查询元素（从左向右，自上而下）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lindex list01 2 # 从上到下数，下标为2的值</span><br></pre></td></tr></table></figure>
<ul>
<li>llen：返回集合长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llen list01</span><br></pre></td></tr></table></figure>
<ul>
<li>lrem：删除n个value<ul>
<li>lrem key n value</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrem list01 2 3	 	# 从list01中移除2个3</span><br></pre></td></tr></table></figure>
<ul>
<li>ltrim：截取指定范围的值，别的全扔掉<ul>
<li>ltrim key begindex endindex</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ltrim list01 3 6 # 截取下标3~6的值，别的全扔掉</span><br></pre></td></tr></table></figure>
<ul>
<li>rpoplpush：从一个集合搞一个元素到另一个集合中（右出一个，左进一个）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpoplpush list01 list02   # list01右边出一个，从左进入到list02的第一个位置</span><br></pre></td></tr></table></figure>
<ul>
<li>lset：改变某个下标的某个值 <ul>
<li>lset key index value</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lset list02 0 x # 将list02中下标为0的元素修改成x</span><br></pre></td></tr></table></figure>
<ul>
<li>linsert：插入元素（指定某个元素之前/之后） <ul>
<li>linsert key before/after oldvalue newvalue</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linsert list02 before 2 java   # 从左边进入，在list02中的2元素之前插入java</span><br></pre></td></tr></table></figure>
<p><strong>性能总结</strong>：类似添加火车皮一样，头尾操作效率高，中间操作效率惨；</p>
<h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><p>和java中的set特点类似，不允许重复,无序</p>
<ul>
<li>sadd/smembers/sismember：添加/查看/判断是否存在</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd set01 1 2 2 3 3 3  # 添加元素（自动排除重复元素）</span><br><span class="line">smembers set01 			# 查询set01集合</span><br><span class="line">sismember set01 2		# 查询set01中2元素是否存在，存在返回1，否则0</span><br></pre></td></tr></table></figure>
<ul>
<li>scard：获得集合中的元素个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scard set01  	# 获取set01的长度</span><br></pre></td></tr></table></figure>
<ul>
<li>srem：删除集合中的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srem set01 2 	# 移除set01中的元素2</span><br></pre></td></tr></table></figure>
<ul>
<li>srandmember：从集合中随机获取几个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srandmember set01 3 	# 从set01中随机获取3个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>spop：随机出栈（移除）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spop set01 		# 随机移除一个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>smove：移动元素：将key1某个值赋值给key2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smove set01 set02 3 	# 将set01中的元素3移动到set02中</span><br></pre></td></tr></table></figure>
<ul>
<li>数学集合类 <ul>
<li>交集：sinter </li>
<li>并集：sunion </li>
<li>差集：sdiff</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sinter set01 set02  # set01和set02共同存在的元素</span><br><span class="line">sunion set01 set02  # 将set01和set02中所有元素合并起来（排除重复的）</span><br><span class="line">sdiff set01 set02 	# 在set01中存在，在set02中不存在</span><br><span class="line">sdiff set02 set01 	# 在set02中存在，在set01中不存在</span><br></pre></td></tr></table></figure>
<h2 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h2><p>类似java里面的Map。Redis中的 KV模式不变，但V是一个键值对</p>
<ul>
<li>hset/hget/hmset/hmget/hgetall/hdel：添加/得到/多添加/多得到/得到全部/删除属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hset user id 1001 		# 添加user，值为id&#x3D;1001</span><br><span class="line">hget user id 			# 查询user，必须指明具体的字段</span><br><span class="line">hmset student id 101 name tom age 22 # 添加学生student，属性一堆</span><br><span class="line">hmget student name age 	# 获取学生与年龄</span><br><span class="line">hgetall student 		# 获取学生全部信息</span><br><span class="line">hdel student age 		# 删除学生年龄属性</span><br></pre></td></tr></table></figure>
<ul>
<li>hlen：返回元素的属性个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hlen student	# student属性的数量，id和name，共两个属性</span><br></pre></td></tr></table></figure>
<ul>
<li>hexists：判断元素是否存在某个属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexists student name 	# student中是否存在name属性</span><br></pre></td></tr></table></figure>
<ul>
<li>hkeys/hvals：获得属性的所有key/获得属性的所有value</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hkeys student 	# 获取student所有的属性名</span><br><span class="line">hvals student 	# 获取student所有属性的值（内容）</span><br></pre></td></tr></table></figure>
<ul>
<li>hincrby/hincrbyfloat：自增（整数）/自增（小数）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hincrby student age 2 			# 自增整数2</span><br><span class="line">hincrbyfloat student age 5.5 	# 自增小数5.5</span><br></pre></td></tr></table></figure>
<ul>
<li>hsetnx：添加的时候，先判断是否存在</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hsetnx student age 18  # 添加时，判断age是否存在，存在就不添加</span><br></pre></td></tr></table></figure>
<h2 id="有序集合Zset"><a href="#有序集合Zset" class="headerlink" title="有序集合Zset"></a>有序集合Zset</h2><p>可以给每一个数据添加一个分数(score)</p>
<ul>
<li>zadd/zrange （withscores）：添加/查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加数据，前一个值为分数(权重)，后一个才是正在的数据</span><br><span class="line">zadd zset01 10 vip1 20 vip2 30 vip3 40 vip4 50 vip5</span><br><span class="line">zrange zset01 0 -1 	# 查询所有数据</span><br><span class="line">zrange zset01 0 -1 withscores # 带着分数查询数据</span><br></pre></td></tr></table></figure>
<ul>
<li>zrangebyscore：模糊查询<ul>
<li>( ： 不包含 </li>
<li>limit：跳过几个截取几个</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrangebyscore zset01 20 40 		# 20 &lt;&#x3D; score &lt;&#x3D; 40</span><br><span class="line">zrangebyscore zset01 20 (40 	# 20 &lt;&#x3D; score &lt; 40</span><br><span class="line">zrangebyscore zset01 (20 (40 	# 20 &lt; score &lt; 40</span><br><span class="line"># 10 &lt;&#x3D; score &lt;&#x3D;40，跳过前2个，取1个</span><br><span class="line">zrangebyscore zset01 10 40 limit 2 1</span><br></pre></td></tr></table></figure>
<ul>
<li>zrem：删除元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrem zset01 vip5 	# 移除vip5</span><br></pre></td></tr></table></figure>
<ul>
<li>zcard/zcount/zrank/zscore：集合长度/范围内元素个数/得元素下标/通过值得分数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zcard zset01 			# 集合中元素的个数</span><br><span class="line">zcount zset01 20 30 	# 分数在20~40之间，共有几个元素</span><br><span class="line">zrank zset01 vip3 		# vip3在集合中的下标（从上向下）</span><br><span class="line">zscore zset01 vip2 		# 通过元素获得对应的分数</span><br></pre></td></tr></table></figure>
<ul>
<li>zrevrank：逆序找下标（从下向上）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrevrank zset01 vip3</span><br></pre></td></tr></table></figure>
<ul>
<li>zrevrange：逆序查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrange zset01 0 -1 # 顺序查询</span><br></pre></td></tr></table></figure>
<ul>
<li>zrevrangebyscore：逆序范围查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrevrangebyscore zset01 30 20 </span><br><span class="line"># 逆序查询分数在30~20之间的（注意，先写大值，再写小值，不然会报错）</span><br></pre></td></tr></table></figure>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><strong>R</strong>edis <strong>D</strong>ata<strong>B</strong>ase</p>
<ul>
<li>在指定的时间间隔内，将内存中的数据集的快照写入磁盘； </li>
<li>默认保存在/usr/local/bin中，文件名dump.rdb;</li>
</ul>
<h3 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h3><ul>
<li><p>redis是内存数据库，当我们每次用完redis，关闭linux时，按道理来说，内存释放，redis中的数 据也会随之消失。</p>
</li>
<li><p>但是每次关闭redis时，redis会自动将数据备份到一个文件中 ：/usr/local/bin/dump.rdb</p>
</li>
<li><p>启动redis时，会从/usr/local/bin/dump.rdb中读取数据，并加载</p>
</li>
</ul>
<p>在 redis.conf 配置文件中可以查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> save <span class="string">&quot;&quot;</span></span></span><br><span class="line">save 900 1 # 900秒内，至少变更1次，才会自动备份</span><br><span class="line">save 120 10 # 120秒内，至少变更10次，才会自动备份</span><br><span class="line">save 60 10000 # 60秒内，至少变更10000次，才会自动备份</span><br></pre></td></tr></table></figure>
<p>如果只是用Redis的缓存功能，不需要持久化，可以注释掉所有的 save 行来停用保 存功能。可以直接一个空字符串来实现停用：save “”</p>
<h3 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h3><ul>
<li>之前自动备份，必须更改好多数据，才会自动备份；</li>
<li> 可以执行命令 <code>save</code> 就会立刻备份,不管更改了多少数据</li>
</ul>
<h3 id="RDB相关配置"><a href="#RDB相关配置" class="headerlink" title="RDB相关配置"></a>RDB相关配置</h3><ul>
<li>stop-writes-on-bgsave-error：进水口和出水口，出水口发生故障与否继续进水 <ul>
<li>yes：当后台备份时候反生错误，前台停止写入 </li>
<li>no：不管死活，就是往里怼 </li>
</ul>
</li>
<li>rdbcompression：对于存储到磁盘中的快照，是否启动LZF压缩算法，一般都会启动，因为这点 性能，多买一台电脑，完全搞定N个来回了。 <ul>
<li>yes：启动 </li>
<li>no：不启动（不想消耗CPU资源，可关闭） </li>
</ul>
</li>
<li>rdbchecksum：在存储快照后，是否启动CRC64算法进行数据校验； <ul>
<li>开启后，大约增加10%左右的CPU消耗； </li>
<li>如果希望获得最大的性能提升，可以选择关闭； </li>
</ul>
</li>
<li>dbfilename：快照备份文件名字  , 默认   <code>dump.rdb</code></li>
<li>dir：快照备份文件保存的目录，默认为当前目录  <code>./</code></li>
</ul>
<p><strong>优势</strong>：适合大规模数据恢复，对数据完整性和一致行要求不高； </p>
<p><strong>劣势</strong>：一定间隔备份一次，意外down掉，就失去最后一次快照的所有修改</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><strong>A</strong>ppend <strong>O</strong>nly <strong>F</strong>ile </p>
<ul>
<li>以日志的形式记录每个写操作； </li>
<li>将redis执行过的写指令全部记录下来（读操作不记录）； </li>
<li>只许追加文件，不可以改写文件； </li>
<li>redis在启动之初会读取该文件从头到尾执行一遍，这样来重新构建数据；</li>
</ul>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>1.修改 redis.conf 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes					# 开启</span><br><span class="line">appendfilename appendonly.aof  	# 保存的文件名</span><br></pre></td></tr></table></figure>
<p>2.重新启动redis，指定配置文件启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server &#x2F;usr&#x2F;local&#x2F;redis5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p>3.进入客户端，随便的增删改数据，退出</p>
<p>4.会多处一个appendonly.aof文件，vim进去查看,保存的都是写操作</p>
<p>5.只需要重新连接，数据恢复成功。</p>
<h3 id="AOF与RDB共存"><a href="#AOF与RDB共存" class="headerlink" title="AOF与RDB共存"></a>AOF与RDB共存</h3><p>AOF和RDB两种备份策略可以同时开启，那系统会选择优先载入AOF，因为AOF比RDB数据保存的完整性更高！</p>
<p><strong>测试</strong>：随机修改appendonly.aof文件的内容，然后启动Redis，redis会报错。</p>
<p><strong>修复AOF文件，杀光不符合redis语法规范的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">reids-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>
<h3 id="AOF相关配置"><a href="#AOF相关配置" class="headerlink" title="AOF相关配置"></a>AOF相关配置</h3><ul>
<li>appendonly：开启aof模式 </li>
<li>appendfilename：aof的文件名字，最好别改！ </li>
<li>appendfsync：追写策略 <ul>
<li>always：每次数据变更，就会<strong>立即记录</strong>到磁盘，性能较差，但数据完整性好 </li>
<li>everysec：默认设置，异步操作，<strong>每秒记录一次</strong>，如果一秒内宕机，会有数据丢失 </li>
<li>no：不追写 </li>
</ul>
</li>
<li>no-appendfsync-on-rewrite：重写时是否运用Appendfsync追写策略；用默认no即可，保证数据 安全性。 <ul>
<li>AOF采用文件追加的方式，文件会越来越大，为了解决这个问题，增加了重写机制，redis会 自动记录上一次AOF文件的大小，当AOF文件大小达到预先设定的大小时，redis就会启动 AOF文件进行内容压缩，只保留可以恢复数据的最小指令集合 </li>
</ul>
</li>
<li>auto-aof-rewrite-percentage：如果AOF文件大小已经超过原来的100%，也就是一倍，才重写压 缩 </li>
<li>auto-aof-rewrite-min-size：如果AOF文件已经超过了64mb，才重写压缩</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>RDB：只用作后备用途，建议15分钟备份一次就好 </li>
<li>AOF： <ul>
<li>在最恶劣的情况下，也只丢失不超过2秒的数据，数据完整性比较高，但代价太大，会带来持 续的IO </li>
<li>对硬盘的大小要求也高，默认64mb太小了，企业级最少都是5G以上； </li>
<li>后面要学习的master/slave才是最好的选择！！</li>
</ul>
</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>可以一次执行多个命令，是一个命令组，一个事务中，所有命令都会序列化（排队），不会被插 队；</p>
<p><strong>三特性</strong> </p>
<ul>
<li>隔离性：所有命令都会按照顺序执行，事务在执行的过程中，不会被其他客户端送来的命令 打断 </li>
<li>没有隔离级别：队列中的命令没有提交之前都不会被实际的执行，不存在“事务中查询要看到 事务里的更新，事务外查询不能看到”这个头疼的问题 </li>
<li>不保证原子性：冤有头债有主，如果一个命令失败，但是别的命令可能会执行成功，没有回 滚</li>
</ul>
<p><strong>与关系型数据库事务相比</strong> </p>
<ul>
<li>multi：可以理解成关系型事务中的 begin </li>
<li>exec ：可以理解成关系型事务中的 commit </li>
<li>discard ：可以理解成关系型事务中的 rollback</li>
</ul>
<p><strong>提交</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED # 加入队列</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED # 加入队列</span><br><span class="line">127.0.0.1:6379&gt; exec # 执行，一起成功！</span><br></pre></td></tr></table></figure>
<p><strong>回滚</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1111</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2222</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard # 放弃操作</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>开启事务后，如果是语法的错误，那么该事务就会取消。</p>
<p>如果不是语法的错误，而是逻辑的错误，类似与java中的编译通过，提交事务后正确的逻辑正常执行，错误的逻辑语句会报错。</p>
<p><strong>watch监控</strong></p>
<p>事务中要修改的数据被监控了，那么该数据如果被别处修改，该事务就会提交失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch meoney 	# 监控meoney</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi			# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby meoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil) # 在exec之前，我开启了另一个窗口（线程），对监控的meoney做了修改，所以本次的事务将</span><br><span class="line">被打断（失效），类似于“乐观锁”</span><br></pre></td></tr></table></figure>
<p><strong>unwatch</strong>：取消watch命令对所有key的操作 </p>
<ul>
<li>一旦执行了exec命令，那么之前加的所有监控自动失效！</li>
</ul>
<h1 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h1><p>进程间的一种消息通信模式：<strong>发送者(pub)</strong> 发送消息，<strong>订阅者(sub)</strong>  接收消息。例如：微信订阅号 订阅一个或多个频道。</p>
<p><strong>subscribe订阅</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##开启一个窗口，订阅消息</span><br><span class="line">subscribe cctv1 cctv5 cctv6 	##订阅三个频道</span><br></pre></td></tr></table></figure>
<p><strong>publish发布</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##开启另一个窗口，发布消息</span><br><span class="line">publish cctv5 NBA 	##发送消息给cctv5</span><br></pre></td></tr></table></figure>
<p>这时subscribe就会接收到消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;message&quot; 	##cctv5接收到推送过来的信息</span><br><span class="line">2) &quot;cctv5&quot;</span><br><span class="line">3) &quot;NBA&quot;</span><br></pre></td></tr></table></figure>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li>redis集群的策略。 </li>
<li>配从（库）不配主（库）：小弟可以选择谁是大哥，但大哥没有权利去选择小弟 </li>
<li>读写分离：主机写，从机读</li>
</ul>
<h2 id="实现redis集群主从复制"><a href="#实现redis集群主从复制" class="headerlink" title="实现redis集群主从复制"></a>实现redis集群主从复制</h2><p>1.准备三台Linux服务器，并修改redis.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bing 0.0.0.0   # 允许所有ip访问</span><br></pre></td></tr></table></figure>
<p>2.启动每台服务器的redis，并查看每台机器的角色，都是master</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>
<p>3.其余两台机器，复制（找大哥）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.204.141 6379</span><br></pre></td></tr></table></figure>
<p>这样，就实现了一主二仆。主只能写，仆只能读，主中的数据会同步到仆。</p>
<ul>
<li><p>主机shutdown，从机如何？</p>
<ul>
<li>两个从机仍然是slave，并显示他们的master已离线</li>
</ul>
</li>
<li><p>主机重启，从机又如何？</p>
<ul>
<li>两个从机仍然是slave，并显示他们的master已赏上线</li>
</ul>
</li>
<li><p>从机死了，主机如何？从机归来身份是否变化?</p>
<ul>
<li>主机没有变化，只是显示少了一个slave</li>
<li>主机和从机没有变化，而重启归来的从机自立门户成为了master，不和原来的集群在一 起了,如果要重新变成从机，重新执行<code>slaveof 192.168.204.141 6379</code></li>
</ul>
</li>
</ul>
<p><strong>血脉相传</strong></p>
<ul>
<li>一个主机理论上可以多个从机，但是这样的话，这个主机会很累 </li>
<li>我们可以使用java面向对象继承中的传递性来解决这个问题，减轻主机的负担 </li>
<li>形成祖孙三代：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##2号执行</span><br><span class="line">127.0.0.1:6379&gt; slaveof 192.168.204.141 6379 # 142跟随141</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##3号执行</span><br><span class="line">127.0.0.1:6379&gt; slaveof 192.168.204.142 6379 # 143跟随142</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><strong>谋权篡位</strong></p>
<ul>
<li>1个主机，2个从机，当1个主机挂掉了，只能从2个从机中再次选1个主机 </li>
<li>手动选老大 :</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof no one 		# 2上执行，表示不服从别人，自己成为master</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.204.142 6379   # 3上执行，表示3跟随2号</span><br></pre></td></tr></table></figure>
<ul>
<li>当1再次回归，会怎样？ <ul>
<li>2和3已经形成新的集群，和1没有任何的关系了。所以1成为了光杆司令</li>
</ul>
</li>
</ul>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p><a href="https://imgtu.com/i/fL7nq1"><img src="https://z3.ax1x.com/2021/08/20/fL7nq1.png" alt="fL7nq1.png"></a></p>
<ul>
<li><strong>全量复制</strong>：Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份slave接收到数据 文件后，存盘，并加载到内存中；（步骤1234） </li>
<li><strong>增量复制</strong>：Slave初始化后，开始正常工作时主服务器发生的写操作同步到从服务器的过程；（步骤56）</li>
</ul>
<p><strong>Redis主从同步策略</strong>：</p>
<ul>
<li>主从刚刚连接的时候，进行全量同步；</li>
<li>全同步结束后，进行增量同步。 </li>
<li>如果有需要，slave 在任何时候都可以发起全量同步。 </li>
<li>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>自动版的谋权篡位</p>
<ul>
<li>Sentinel是Redis的高可用性解决方案：<ul>
<li>由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及所有从服务 器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级 为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求</li>
</ul>
</li>
</ul>
<p><strong>模拟测试</strong></p>
<p>1.准备好3台服务器，1主，2和3从</p>
<p>2.每一台服务器中创建一个配置文件<strong>sentinel.conf</strong>，名字绝不能错，并编辑sentinel.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##sentinel monitor 被监控主机名（自定义） ip port 票数</span><br><span class="line">sentinel monitor redis01 192.168.204.141 6379 1</span><br></pre></td></tr></table></figure>
<p>3.启动3台服务器（先启动主服务器，再启动从服务器）</p>
<p>4.启动<strong>sentinel</strong>监听（三台redis都要启动）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>
<p>5.将1号老大挂掉<code>shutdown</code>，后台自动发起激烈的投票，最后3号成为master</p>
<p>6.如果之前的老大再次归来呢？ </p>
<ul>
<li>1号再次归来，自己成为了master，和3平起平坐 ；</li>
<li>过了几秒之后，被哨兵检测到了1号机的归来，重新加入集群，但只能当小弟。</li>
</ul>
<p><strong>主从复制缺点</strong></p>
<ul>
<li>由于所有的写操作都是在master上完成的；</li>
<li>然后再同步到slave上，所以两台机器之间通信会有延迟； </li>
<li>当系统很繁忙的时候，延迟问题会加重； </li>
<li>slave机器数量增加，问题也会加重</li>
</ul>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>java和redis打交道的API客户端</p>
<p><strong>前提</strong></p>
<ul>
<li><p>注释掉redis.conf中bind 127.0.0.1或者改成bind 0.0.0.0</p>
</li>
<li><p>protected-mode yes 改为 protected-mode no </p>
</li>
</ul>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>连接redis</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记得修改redis.conf [ bind 0.0.0.0 ] 允许任何ip访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;47.115.139.213&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    String pong = jedis.ping();</span><br><span class="line">    System.out.println(<span class="string">&quot;pong = &quot;</span> + pong);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本API使用"><a href="#基本API使用" class="headerlink" title="基本API使用"></a>基本API使用</h2><p><strong>String类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// string</span></span><br><span class="line">    jedis.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String k : keys) &#123;</span><br><span class="line">        System.out.println(k+<span class="string">&quot;==&gt;&quot;</span>+jedis.get(k));</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean k2Exists = jedis.exists(<span class="string">&quot;k2&quot;</span>); <span class="comment">// 查看k2是否存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;k2Exists = &quot;</span> + k2Exists);</span><br><span class="line">    System.out.println( jedis.ttl(<span class="string">&quot;k1&quot;</span>) );<span class="comment">// 查看k1的过期时间</span></span><br><span class="line">    jedis.mset(<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;v4&quot;</span>,<span class="string">&quot;k5&quot;</span>,<span class="string">&quot;v5&quot;</span>);</span><br><span class="line">    System.out.println( jedis.mget(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;k5&quot;</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>List类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// list</span></span><br><span class="line">    jedis.lpush(<span class="string">&quot;list01&quot;</span>, <span class="string">&quot;l1&quot;</span>,<span class="string">&quot;l2&quot;</span>,<span class="string">&quot;l3&quot;</span>,<span class="string">&quot;l4&quot;</span>,<span class="string">&quot;l5&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list01 = jedis.lrange(<span class="string">&quot;list01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : list01)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Set类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.sadd(<span class="string">&quot;order&quot;</span>,<span class="string">&quot;jd001&quot;</span>);</span><br><span class="line">    jedis.sadd(<span class="string">&quot;order&quot;</span>,<span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; set = jedis.smembers(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    jedis.srem(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">    System.out.println( jedis.smembers(<span class="string">&quot;order&quot;</span>).size() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Map类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 添加单个字段</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;username&quot;</span>,<span class="string">&quot;james&quot;</span>);  </span><br><span class="line">    System.out.println( jedis.hget(<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;username&quot;</span>) );</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 添加多个字段</span></span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">    jedis.hmset(<span class="string">&quot;user2&quot;</span>, map); </span><br><span class="line">    List&lt;String&gt; list = jedis.hmget(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;phone&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s: list)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Zset类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testZset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">60d</span>, <span class="string">&quot;zs1&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;zs2&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; zset = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s: zset)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>模拟转账操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;47.115.139.213&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// tom给jerry转账</span></span><br><span class="line">        Integer tomMoney = Integer.parseInt(jedis.get(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;tom余额为:&quot;</span> + tomMoney);</span><br><span class="line">        jedis.watch(<span class="string">&quot;tom&quot;</span>);  <span class="comment">// 监控tom的余额</span></span><br><span class="line">        Integer money = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 网络延迟5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">if</span> (tomMoney &gt; money) &#123;</span><br><span class="line">            Transaction transaction = jedis.multi();  <span class="comment">// 开启事务</span></span><br><span class="line">            transaction.decrBy(<span class="string">&quot;tom&quot;</span>, money);    <span class="comment">// 出账</span></span><br><span class="line">            transaction.incrBy(<span class="string">&quot;jerry&quot;</span>, money);  <span class="comment">// 入账</span></span><br><span class="line">            transaction.exec();                     <span class="comment">// 提交事务</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jedis.unwatch(); <span class="comment">//解除监控</span></span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了监听，如果监听的数据发生变化就不会继续执行。</p>
<h2 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h2><p>redis的连接池技术 。详情：<a href="https://help.aliyun.com/document_detail/98726.html">https://help.aliyun.com/document_detail/98726.html</a></p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-pool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JedisPoolUtil工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// redis连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式，获取连接池对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    config.setMaxTotal(<span class="number">1000</span>); <span class="comment">// 资源池中的最大连接数</span></span><br><span class="line">                    config.setMaxIdle(<span class="number">30</span>); <span class="comment">// 资源池允许的最大空闲连接数</span></span><br><span class="line">                    config.setMaxWaitMillis(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 当资源池连接用尽后，调用者的最大等待时间（单位为毫秒）</span></span><br><span class="line">                    config.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//向资源池借用连接时是否做连接有效性检测(业务量很大时候建议设置为false，减少一次ping的开销)</span></span><br><span class="line">                    <span class="comment">//  创建连接池对象</span></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">&quot;47.115.139.213&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Jedis对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis = getInstance().getResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis1 = JedisPoolUtil.getJedis(); <span class="comment">// 连接1</span></span><br><span class="line">    Jedis jedis2 = JedisPoolUtil.getJedis(); <span class="comment">// 连接2</span></span><br><span class="line">    System.out.println(jedis1==jedis2);</span><br><span class="line">    System.out.println(jedis1.get(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">    System.out.println(jedis2.get(<span class="string">&quot;jerry&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>需求: 抢购手机，初始化数量20.</p>
<h2 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h2><p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实现分布式锁的工具类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring操作redis的工具类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--redis客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--json解析工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8001<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 打包完成后,运行服务 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">              http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">              http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">              http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">              http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  包扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  redis模板，需注入连接工厂connectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stringRedisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  连接工厂  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;47.115.139.213&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>controller层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能解决一个tomcat的并发问题：synchronized锁的一个进程下的线程并发，如果分布式环境，多个进程并发，这种方案就失效了！</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sell&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取“phone”的数量</span></span><br><span class="line">        Integer count = Integer.valueOf(stringRedisTemplate.opsForValue().get(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;  <span class="comment">// 商品--，表示购买</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;phone&quot;</span>, count + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;剩余商品:&quot;</span> + count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动该项项目，并使用jmeter测试，1秒发送100给请求。没问题！</p>
<p>但这只是一个tomcat服务器，synchronized锁只能锁定当前代码块，如果启动多个tomcat就会出现问题。</p>
<h2 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h2><p>1.启动两次工程，端口号分别8001和8002 </p>
<p>2.使用nginx做负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream hui&#123;</span><br><span class="line">    server window电脑上的ip地址:8001;</span><br><span class="line">    server window电脑上的ip地址:8002;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;hui;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动nginx</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<p>3.使用 JMeter 模拟1秒内发出100个http请求，会发现同一个商品会被两台服务器同时抢购！</p>
<h2 id="实现分布式锁的思路"><a href="#实现分布式锁的思路" class="headerlink" title="实现分布式锁的思路"></a>实现分布式锁的思路</h2><ol>
<li>因为redis是单线程的，所以命令也就具备原子性，使用setnx命令实现锁，保存k-v <ul>
<li>如果k不存在，保存（当前线程加锁），执行完成后，删除k表示释放锁 </li>
<li>如果k已存在，阻塞线程执行，表示有锁 </li>
</ul>
</li>
<li>如果加锁成功，在执行业务代码的过程中出现异常，导致没有删除k（释放锁失败），那么就会造 成死锁（后面的所有线程都无法执行）！ <ul>
<li>设置过期时间，例如10秒后，redis自动删除 </li>
</ul>
</li>
<li>高并发下，由于时间段等因素导致服务器压力过大或过小，每个线程执行的时间不同 <ul>
<li>第一个线程，执行需要13秒，执行到第10秒时，redis自动过期了k（释放锁） </li>
<li>第二个线程，执行需要7秒，加锁，执行第3秒锁 , 被释放了( 为什么，是被第一个线程的 finally主动deleteKey释放掉了） </li>
<li>。。。连锁反应，当前线程刚加的锁，就被其他线程释放掉了，周而复始，导致锁会永久失 效 </li>
<li>给每个线程加上唯一的标识UUID随机生成，释放的时候判断是否是当前的标识即可 </li>
</ul>
</li>
<li>过期时间如果设定？ <ul>
<li>如果10秒太短不够用怎么办？ </li>
<li>设置60秒，太长又浪费时间 </li>
<li>可以开启一个定时器线程，当过期时间小于总过期时间的1/3时，增长总过期时间（吃仙丹续 命！） </li>
</ul>
</li>
</ol>
<p>自己实现分布式锁，太难了！一般情况下不会自己去实现分布式锁。</p>
<h2 id="使用Redisson分布式锁"><a href="#使用Redisson分布式锁" class="headerlink" title="使用Redisson分布式锁"></a>使用Redisson分布式锁</h2><ul>
<li>Redis 其实并没有对 Java 提供原生支持。若想在程序中集成 Redis，必须使用 Redis 的第三方库。 </li>
<li>Redisson 就是用于在 Java 程序中操作 Redis 的库，它使得我们可以在程序中轻松地使用 Redis。 </li>
<li>Redisson 在 java.util 中常用接口的基础上，为我们提供了一系列具有分布式特性的工具类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Redisson redisson;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sell&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key = <span class="string">&quot;phone-1&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取分布式锁</span></span><br><span class="line">        RLock lock = redisson.getLock(key);<span class="comment">// 底层源码就是集成了setnx，过期时间等操作</span></span><br><span class="line">        <span class="comment">// 上锁,30秒</span></span><br><span class="line">        lock.lock(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取“phone”的数量</span></span><br><span class="line">            Integer count = Integer.valueOf(stringRedisTemplate.opsForValue().get(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;  <span class="comment">// 商品--，表示购买</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;phone&quot;</span>, count + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;剩余商品:&quot;</span> + count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Redisson并接入IOC容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        <span class="comment">// 使用单个服务器</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://47.115.139.213:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 使用集群redis</span></span><br><span class="line">        <span class="comment">// config.useClusterServers().setScanInterval(2000).addNodeAddress(&quot;redis://192.168.204.141:6379&quot;,&quot;redis://192.168.204.142:6379&quot;,&quot;redis://192.168.204.143:6379&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现分布式锁的方案其实有很多，我们之前用过的zookeeper的特点就是高可靠性，现在我们用的 redis特点就是高性能。 </li>
<li>目前分布式锁，应用最多的仍然是“Redis”</li>
</ul>
<h1 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h1><h2 id="redis是单线程的吗-那他是怎么支持高并发请求的？"><a href="#redis是单线程的吗-那他是怎么支持高并发请求的？" class="headerlink" title="redis是单线程的吗 那他是怎么支持高并发请求的？"></a>redis是单线程的吗 那他是怎么支持高并发请求的？</h2><p><strong>官方解释</strong>:因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的 大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单 线程的方案了。</p>
<p>redis 内部使用了一个叫 <strong>文件事件处理器（ file event handler）</strong>的东西，这个文件事件处理器是 单线程的，所以才有了 redis 是单线程的这一说法。它采用IO多路复用机制来同时 监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。</p>
<p><a href="https://imgtu.com/i/hUFGUs"><img src="https://z3.ax1x.com/2021/08/31/hUFGUs.png" alt="hUFGUs.png"></a></p>
<p><strong>优点</strong></p>
<ul>
<li>Redis采用了单线程的模型，保证了每个操作的原子性，也避免了不必要的上下文切换和竞争条 件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释 放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在 IO上，所以读取速度快。</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在高并发下，大量的缓存key在同一时间失效，导致大量的请求落到数据库上，如活动系统里面同时进 行着非常多的活动，但是在某个时间点所有的活动缓存全部过期。 </p>
<p><strong>解决方案</strong> </p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中</li>
<li>设置热点数据永远不过期。</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>访问一个不存在的key（查询 userid = -10），缓存不起作用，请求会穿透到DB，流量大时DB会挂掉</p>
<p><strong>解决方案</strong> </p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效 时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反 复用同一个id暴力攻击</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>一个存在的key，在缓存过期的那一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请 求量大、压力骤增</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁：业界比较常用的做法。简单地来说，就是在缓存失效的时候（判断拿出来的值是否为 空），不立即去加载数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis 的SETNX）去set一个mutex key，当操作返回成功时，再进行加载数据库的操作并回设缓存；否 则，就重试整个get缓存的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//加锁，设置3分钟的超时，防止删除操作失败的时候，下次缓存过期不能一直加载数据库</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex， <span class="number">1</span>， <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123; <span class="comment">//代表设置成功</span></span><br><span class="line">            String value = db.get(key); <span class="comment">// 去加载数据库</span></span><br><span class="line">            redis.set(key， value， expire_secs); <span class="comment">// 将数据库的数据放在redis中，并设置过期时间</span></span><br><span class="line">            redis.del(key_mutex); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> get(key); <span class="comment">//重试,记得返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总配置redis-conf详解-了解即可"><a href="#总配置redis-conf详解-了解即可" class="headerlink" title="总配置redis.conf详解(了解即可)"></a>总配置redis.conf详解(了解即可)</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis 配置文件示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意单位: 当需要配置内存大小时, 可能需要指定像1k,5GB,4M等常见格式</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1k =&gt; 1000 bytes</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 单位是对大小写不敏感的 1GB 1Gb 1gB 是相同的。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# INCLUDES 包含文件相关</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在这里包含一个或多个其他的配置文件。如果你有一个适用于所有Redis服务器的标准配置模板</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但也需要一些每个服务器自定义的设置，这个功能将很有用。被包含的配置文件也可以包含其他配置文</span></span><br><span class="line">件，</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以需要谨慎的使用这个功能。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 注意“inclue”选项不能被admin或Redis哨兵的&quot;CONFIG REWRITE&quot;命令重写。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为Redis总是使用最后解析的配置行最为配置指令的值, 你最好在这个文件的开头配置includes来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 避免它在运行时重写配置。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果相反你想用includes的配置覆盖原来的配置，你最好在该文件的最后使用include</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># include /path/to/local.conf</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> include /path/to/other.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### GENERAL 综合配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认Rdis不会作为守护进程运行。如果需要的话配置成<span class="string">&#x27;yes&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当以守护进程方式运行时，默认Redis会把进程ID写到 /var/run/redis.pid。你可以在这里修改路径。</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接受连接的特定端口，默认是6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果端口设置为0，Redis就不会监听TCP套接字。</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP listen() backlog.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> server在与客户端建立tcp连接的过程中，SYN队列的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默地将这个值减小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个值来达到想要的效果。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认Redis监听服务器上所有可用网络接口的连接。可以用<span class="string">&quot;bind&quot;</span>配置指令跟一个或多个ip地址来实现</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监听一个或多个网络接口</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 示例:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定用来监听Unix套套接字的路径。没有默认值， 所以在没有指定的情况下Redis不会监听Unix套接字</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># unixsocket /tmp/redis.sock</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> unixsocketperm 755</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP keepalive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用的：</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1）能够检测无响应的对端</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2）让该连接中间的网络设备知道这个连接还存活</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：要关闭这个连接需要两倍的这个时间值。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在其他内核上这个时间间隔由内核配置决定</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 这个选项的一个合理值是60秒</span></span></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定服务器调试等级</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能值：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug （大量信息，对开发/测试有用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> verbose （很多精简的有用信息，但是不像debug等级那么多）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice （适量的信息，基本上是你生产环境中需要的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning （只有很重要/严重的信息会记录下来）</span></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指明日志文件名。也可以使用<span class="string">&quot;stdout&quot;</span>来强制让Redis把日志信息写到标准输出上。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意:如果Redis以守护进程方式运行，而设置日志显示到标准输出的话，日志会发送到/dev/null</span></span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要使用系统日志记录器，只要设置 <span class="string">&quot;syslog-enabled&quot;</span> 为 <span class="string">&quot;yes&quot;</span> 就可以了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后根据需要设置其他一些syslog参数就可以了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-enabled no</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指明syslog身份</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-ident redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指明syslog的设备。必须是user或LOCAL0 ~ LOCAL7之一。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-facility local0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据库个数。默认数据库是 DB 0，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过select &lt;dbid&gt; (0 &lt;= dbid &lt;= <span class="string">&#x27;databases&#x27;</span> - 1 ）来为每个连接使用不同的数据库。</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### SNAPSHOTTING 快照，持久化操作配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 把数据库存到磁盘上:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 会在指定秒数和数据变化次数之后把数据库写到磁盘上。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 下面的例子将会进行把数据写入磁盘的操作:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 900秒（15分钟）之后，且至少1次变更</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 300秒（5分钟）之后，且至少10次变更</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60秒之后，且至少10000次变更</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 像下面的例子：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> save <span class="string">&quot;&quot;</span></span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果后台保存进程能重新开始工作，Redis将自动允许写操作</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 硬盘，权限等出问题了Redis也能够像平时一样正常工作，</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当导出到 .rdb 数据库时是否用LZF压缩字符串对象？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认设置为 <span class="string">&quot;yes&quot;</span>，因为几乎在任何情况下它都是不错的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你想节省CPU的话你可以把这个设置为 <span class="string">&quot;no&quot;</span>，但是如果你有可压缩的key和value的话，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那数据文件就会更大了。</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查</span></span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 持久化数据库的文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作目录</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 累加文件也放这里。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 注意你这里指定的必须是目录，不是文件名。</span></span></span><br><span class="line">dir ./</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################ REPLICATION 主从复制的配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主从同步。通过 slaveof 指令来实现Redis实例的备份。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不同的端口。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果master设置了密码保护（通过 <span class="string">&quot;requirepass&quot;</span> 选项来配置），那么slave在开始同步之前必须</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行身份验证，否则它的同步请求会被拒绝。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># masterauth &lt;master-password&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能是正常数据，也可能是还没获得值的空数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 如果 slave-serve-stale-data 设置为 <span class="string">&quot;no&quot;</span>，slave会回复<span class="string">&quot;正在从master同步</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （SYNC with master <span class="keyword">in</span> progress）<span class="string">&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">slave-serve-stale-data yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入</span></span><br><span class="line">salve</span><br><span class="line"><span class="meta">#</span><span class="bash"> 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 从Redis2.6默认所有的slave为只读</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护</span></span></span><br><span class="line">层。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用<span class="string">&#x27;renamecommand&#x27;</span>来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 隐藏所有的管理和危险命令来增强只读slave的安全性</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> slave根据指定的时间间隔向master发送ping请求。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间间隔可以通过 repl_ping_slave_period 来设置。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认10秒。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-ping-slave-period 10</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下选项设置同步的超时时间</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1）slave在与master SYNC期间有大量数据传输，造成超时</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2）在slave角度，master超时，包括数据、ping等</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3）在master角度，slave超时，当master发送REPLCONF ACK pings</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-timeout 60</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY ？</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到</span></span></span><br><span class="line">slave</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上有延迟，Linux内核的默认配置会达到40毫秒</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果你选择了 &quot;no&quot; 数据传输到salve的延迟将会减少但要使用更多的带宽</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，把这个选项设置为“yes”</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是个不错的选择。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间内slave丢失的部分数据传送给它。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># backlog只分配一次并且至少需要一个slave连接</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-backlog-size 1mb</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slave断开开始计时多少秒后，backlog缓冲将会释放。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 0表示永不释放backlog</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-backlog-ttl 3600</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个slave提升=升为master。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵将挑选优先级最小数字为10的slave。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵挑选提升为master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 默认优先级为100</span></span></span><br><span class="line">slave-priority 100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># N个slave需要是“oneline”状态</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始计数。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This option does not GUARANTEES that N replicas will accept the write, but</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will <span class="built_in">limit</span> the window of exposure <span class="keyword">for</span> lost writes <span class="keyword">in</span> <span class="keyword">case</span> not enough slaves</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are available, to the specified number of seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 例如至少需要3个延时小于等于10秒的slave用下面的指令：</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># min-slaves-to-write 3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-slaves-max-lag 10</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 两者之一设置为0将禁用这个功能。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# SECURITY 安全相关配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要求客户端在处理任何命令时都要验证身份和密码。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个功能在有你不信任的其它客户端能够访问redis服务器的环境里非常有用。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 为了向后兼容的话这段应该注释掉。而且大多数人不需要身份验证(例如:它们运行在自己的服务器上)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个高强度的密码，否则破解太容易了。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># requirepass foobared</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令重命名</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样内部的工具仍然可以使用，而普通的客户端将不行。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 例如：</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 也可以通过改名为空字符串来完全禁用一个命令</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################## LIMITS 范围配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为Redis服务器保留了一些文件描述符作为内部使用）</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 一旦达到这个限制，Redis会关闭所有新连接并发送错误&#x27;max number of clients reached&#x27;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxclients 10000</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemmory-policy）删除key</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 的时候，这个选项通常事很有用的。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 警告：当有多个slave连上达到内存上限的实例时，master为同步slave的输出缓冲区所需</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内存不计算在使用内存中。这样当驱逐key时，就不会因网络问题 / 重新同步事件触发驱逐key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 的循环，反过来slaves的输出缓冲区充满了key被驱逐的DEL命令，这将触发删除更多的key，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直到这个数据库完全被清空为止</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 总之...如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 的内存作为slave的输出缓存区(但是如果最大内存策略设置为<span class="string">&quot;noeviction&quot;</span>的话就没必要了)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory &lt;bytes&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选：</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-lru -&gt; 根据LRU算法删除任何key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-random -&gt; 根据过期设置来随机删除key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-&gt;random -&gt; 无差别随机删。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> noeviction -&gt; 谁也不删，直接在写操作时返回错误。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 目前为止涉及的命令：set setnx setex append</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> getset mset msetnx <span class="built_in">exec</span> sort</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 默认值如下：</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory-policy volatile-lru</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory-samples 3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################# APPEND ONLY MODE AOF模式配置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 能只丢失1秒的写操作。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># AOF和RDB持久化能同时启动并且不会有问题。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 请查看 http://redis.io/topics/persistence 来获取更多信息.</span></span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 纯累加文件名字（默认：<span class="string">&quot;appendonly.aof&quot;</span>）</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Redis支持三种不同的模式：</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> always：每次写操作都立刻写入到aof文件。慢，但是最安全。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec：每秒写一次。折中方案。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。根据你的理解来</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 决定，如果你能放宽该配置为<span class="string">&quot;no&quot;</span> 来获取更好的性能(但如果你能忍受一些数据丢失，可以考虑使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认的快照持久化模式)，或者相反，用“always”会比较慢但比everysec要更安全。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 请查看下面的文章来获取更多的细节</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果不能确定，就用 &quot;everysec&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果AOF的同步策略设置成 <span class="string">&quot;always&quot;</span> 或者 <span class="string">&quot;everysec&quot;</span>，并且后台的存储进程（后台存储或写入AOF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止</span></span></span><br><span class="line">fsync()。</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。</span></span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动重写AOF文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大</span></span></span><br><span class="line">小）</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 指定百分比为0会禁用AOF自动重写特性。</span></span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### LUA SCRIPTING ###############################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置lua脚本的最大运行时间，单位为毫秒，redis会记个<span class="built_in">log</span>，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# SLOW LOG ###################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是redis用于记录慢查询执行时间的日志系统。由于slowlog只保存在内存中，因此slowlog的效率很高，完全不用担心会影响到redis的性能。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只有query执行时间大于slowlog-log-slower-than的才会定义成慢查询，才会被slowlog进行记录。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单位是微妙</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"><span class="meta">#</span><span class="bash"> slowlog-max-len表示慢查询最大的条数</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########################### EVENT NOTIFICATION ##############################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况，所以在默认配置下，该功能处于关闭状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> K 键空间通知，所有通知以 __keyspace@__ 为前缀</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> E 键事件通知，所有通知以 __keyevent@__ 为前缀</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $ 字符串命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> l 列表命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s 集合命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> h 哈希命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> z 有序集合命令的通知</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x 过期事件：每当有过期键被删除时发送</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> A 参数 g<span class="variable">$lshzxe</span> 的别名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications</span></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################## ADVANCED CONFIG ###############################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单位字节:数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplistentries用<span class="built_in">hash</span></span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line"><span class="meta">#</span><span class="bash"> value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用<span class="built_in">hash</span>。</span></span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据量小于等于list-max-ziplist-entries用ziplist(压缩列表)，大于list-max-ziplistentries用list。</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line"><span class="meta">#</span><span class="bash"> value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。</span></span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用<span class="built_in">set</span>。</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line"><span class="meta">#</span><span class="bash"> value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。</span></span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基数统计的算法 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置HyeperLogLog的字节数限制，这个值通常在0~15000之间，默认为3000，基本不超过16000。value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-maxbytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置<span class="built_in">hash</span>。 Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的<span class="built_in">hash</span>表进行重新<span class="built_in">hash</span>，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。</span></span><br><span class="line">activerehashing yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于Redis服务器的输出（也就是命令的返回值）来说，其大小通常是不可控制的。有可能一个简单的命令，能够产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，这是也会导致服务器堆积大量消息，从而导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于强制断开出于某些原因而无法以足够快的速度从服务器读取数据的客户端的连接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">对于normal client，包括monitor。第一个0表示取消hard <span class="built_in">limit</span>，第二个0和第三个0表示取消soft <span class="built_in">limit</span>，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash">对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</span></span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line"><span class="meta">#</span><span class="bash">对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</span></span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis执行任务的频率</span></span><br><span class="line">hz 10</span><br><span class="line"><span class="meta">#</span><span class="bash"> aof rewrite过程中,是否采取增量<span class="string">&quot;文件同步&quot;</span>策略,默认为<span class="string">&quot;yes&quot;</span>,而且必须为yes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rewrite过程中,每32M数据进行一次文件同步,这样可以减少<span class="string">&quot;aof大文件&quot;</span>写入对磁盘的操作次数.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<ul>
<li>通常情况下，默认的配置足够你解决问题！ </li>
<li>没有极特殊的要求，不要乱改配置！</li>
</ul>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>noSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS分布式文件系统</title>
    <url>/2021/08/23/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li><strong>分布式文件系统</strong>  （Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与  <strong>节点(可简单的理解为一台计算机)</strong>  相连。</li>
<li>分布式文件系统的设计基于客户机/<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=70492152&ss_c=ssc.citiao.link">服务器模式</a>。一个典型的网络可能包括多个供多用户访问的服务器。<a id="more"></a></li>
</ul>
<h1 id="主流的分布式文件系统"><a href="#主流的分布式文件系统" class="headerlink" title="主流的分布式文件系统"></a>主流的分布式文件系统</h1><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ul>
<li>(Hadoop Distributed File System)Hadoop 分布式文件系统； </li>
<li>高容错的系统，适合部署到廉价的机器上； </li>
<li>能提供高吞吐量的数据访问，非常适合大规模数据应用； </li>
<li>HDFS采用主从结构，一个HDFS是由一个name节点和N个data节点组成； </li>
<li>name节点储存元数据，一个文件分割成N份存储在不同的data节点上。</li>
</ul>
<h2 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h2><ul>
<li>Google File System 可扩展的分布式文件系统，用于大型的，分布式的，对大量数据进行访问的应用； </li>
<li>运行于廉价的普通硬件上，可以提供容错功能； </li>
<li>它可以给大量的用户提供总体性能较高的服务； </li>
<li>GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver（分块服务器）组成； </li>
<li>一个文件被分割若干块，分散储存到多个分块server中</li>
</ul>
<h2 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h2><ul>
<li>由淘宝资深架构师余庆编写并开源；</li>
<li>专为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能 等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务； </li>
<li>HDFS，GFS等都是通用的文件系统，他们的优点是开发体验好，但是系统的复杂度较高，性能也 一般； </li>
<li>相比之下，专用的分布式文件系统体验差，但是复杂度低，性能也高，尤其fastDFS特别适合图 片，小视频等小文件，因为fastDFS对文件是不分割的，所以没有文件合并的开销； </li>
<li>网络通信用socket，速度快。</li>
</ul>
<h1 id="FastDFS工作原理"><a href="#FastDFS工作原理" class="headerlink" title="FastDFS工作原理"></a>FastDFS工作原理</h1><ul>
<li>fastDFS包含Tracker Server和Storage Server； </li>
<li>客户端请求Tracker Server进行文件的上传与下载； </li>
<li>Tracker Server调度Storage Server最终完成上传与下载。</li>
</ul>
<p><a href="https://imgtu.com/i/hC5DGn"><img src="https://z3.ax1x.com/2021/08/23/hC5DGn.png" alt="hC5DGn.png"></a></p>
<p><strong>Tracker</strong> （译：追踪者） </p>
<ul>
<li>作用是负载均衡和调度，它管理着存储服务（Storage Server），可以理解为：“大管家，追 踪者，调度员”； </li>
<li>Tracker Server可以集群，实现高可用，策略为“轮询”。</li>
</ul>
<p> <strong>Storage</strong> （译：仓库; 贮存器） </p>
<ul>
<li>作用是文件存储，客户端上传的文件最终存储到storage服务器上； </li>
<li>storage集群采用分组的方式，同组内的每台服务器是平等关系，数据同步，目的是实现数据 备份，从而高可用，而不同组的服务器之间是不通信的； </li>
<li>同组内的每台服务器的存储量不一致的情况下，会选取容量最小的那个，所以同组内的服务 器之间软硬件最好保持一致。 </li>
<li>Storage Server会连接集群中的所有Tracker Server，定时向他们汇报自己的状态，例如：剩 余空间，文件同步情况，文件上传下载次数等信息。</li>
</ul>
<h2 id="上传-下载原理"><a href="#上传-下载原理" class="headerlink" title="上传/下载原理"></a>上传/下载原理</h2><p><a href="https://imgtu.com/i/hCOOdx"><img src="https://z3.ax1x.com/2021/08/23/hCOOdx.png" alt="hCOOdx.png"></a></p>
<p><a href="https://imgtu.com/i/hCOxJO"><img src="https://z3.ax1x.com/2021/08/23/hCOxJO.png" alt="hCOxJO.png"></a></p>
<ul>
<li>客户端上传文件后，storage会将文件id返回给客户端 </li>
<li>group1/M00/02/11/aJxAeF21O5wAAAAAAAAGaEIOA12345.sh <ul>
<li>group1/ 组名：文件上传后，在storage组的名称，文件上传成功后，由storage返回，需要客户端自 行保存。 </li>
<li>M00/ 虚拟磁盘路径：<ul>
<li> storage配置的虚拟路径，在磁盘选项storage_path对应。 </li>
<li>storage_path0对应M00， </li>
<li>storage_path1对应M01， </li>
</ul>
</li>
<li>02/11/ 数据两级目录： storage在虚拟磁盘下自行创建的目录。 </li>
<li>aJxAeF21O5wAAAAAAAAGaEIOA12345.sh  文件名： 与上传时不同，是用storage根据特定信息生成的，里面包含：storage服务器的ip，创建时 间戳，大小，后缀名等信息</li>
</ul>
</li>
</ul>
<h1 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h1><p><strong>前提</strong></p>
<ul>
<li>安装gcc（编译时需要）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc gcc-c++</span><br></pre></td></tr></table></figure>
<ul>
<li>安装libevent（运行时需求）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install libevent</span><br></pre></td></tr></table></figure>
<h2 id="安装-libfastcommon"><a href="#安装-libfastcommon" class="headerlink" title="安装 libfastcommon"></a>安装 libfastcommon</h2><p>libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。</p>
<p>1.上传 libfastcommon-master.zip 到 /opt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装解压zip包的命令: yum install -y unzip</span><br><span class="line">解压包: unzip libfastcommon.zip</span><br><span class="line">进入目录: cd libfastcommon-master</span><br></pre></td></tr></table></figure>
<p>2.编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;make.sh</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果：make.sh的权限不够，则需要授权（可执行的权利）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 make.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;make.sh install</span><br></pre></td></tr></table></figure>
<ul>
<li>libfastcommon安装好后会在/usr/lib64 目录下生成 libfastcommon.so 库文件</li>
</ul>
<p>4.拷贝库文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;lib64</span><br><span class="line">cp libfastcommon.so &#x2F;usr&#x2F;lib</span><br></pre></td></tr></table></figure>
<h2 id="安装Tracker"><a href="#安装Tracker" class="headerlink" title="安装Tracker"></a>安装Tracker</h2><p>下载 FastDFS_v5.05.tar.gz，并上传到 /opt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压: tar -zxvf FastDFS_v5.05.tar.gz</span><br><span class="line">进去: cd FastDFS</span><br><span class="line">编译: .&#x2F;make.sh</span><br><span class="line">安装: .&#x2F;make.sh install</span><br></pre></td></tr></table></figure>
<p>安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;opt&#x2F;FastDFS&#x2F;conf&#x2F;* &#x2F;etc&#x2F;fdfs&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Tracker配置"><a href="#Tracker配置" class="headerlink" title="Tracker配置"></a>Tracker配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">端口号</span></span><br><span class="line">port=22122</span><br><span class="line"><span class="meta">#</span><span class="bash">基础目录（Tracker运行时会向此目录存储storage的管理数据）（基础目录不存在的话，需要自行创建 mkdir /home/fastdfs）</span></span><br><span class="line">base_path=/home/fastdfs</span><br></pre></td></tr></table></figure>
<h3 id="Storage配置"><a href="#Storage配置" class="headerlink" title="Storage配置"></a>Storage配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置组名</span></span><br><span class="line">group_name=group1</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=23000</span><br><span class="line"><span class="meta">#</span><span class="bash">向tracker心跳间隔（秒）</span></span><br><span class="line">heart_beat_interval=30</span><br><span class="line"><span class="meta">#</span><span class="bash">storage基础目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">目录不存在，需要自行创建</span></span><br><span class="line">base_path=/home/fastdfs</span><br><span class="line"><span class="meta">#</span><span class="bash">store存放文件的位置(store_path)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以理解一个磁盘一个path，多个磁盘，多个store_path</span></span><br><span class="line"><span class="meta">#</span><span class="bash">fdfs_storage目录不存在，需要自行创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash">mkdir /home/fastdfs/fdfs_storage</span></span><br><span class="line">store_path0=/home/fastdfs/fdfs_storage</span><br><span class="line"><span class="meta">#</span><span class="bash">如果有多个挂载磁盘则定义多个store_path，如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash">store_path1=..... (M01)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">store_path2=..... (M02)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置tracker服务器:IP</span></span><br><span class="line">tracker_server=10.1.220.247:22122</span><br><span class="line"><span class="meta">#</span><span class="bash">如果有多个则配置多个tracker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tracker_server=10.1.220.x:22122</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><ul>
<li>启动tracker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf restart</span><br></pre></td></tr></table></figure>
<ul>
<li>启动storage</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf restart</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有运行的端口:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntlp      # 22122 与 23000 端口要正在运行</span><br></pre></td></tr></table></figure>
<h1 id="FastDFS的简单使用"><a href="#FastDFS的简单使用" class="headerlink" title="FastDFS的简单使用"></a>FastDFS的简单使用</h1><p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--fastdfs的java客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##fastdfs-client.properties</span><br><span class="line">fastdfs.connect_timeout_in_seconds &#x3D; 5</span><br><span class="line">fastdfs.network_timeout_in_seconds &#x3D; 30</span><br><span class="line">fastdfs.charset &#x3D; UTF-8</span><br><span class="line">fastdfs.http_anti_steal_token &#x3D; false</span><br><span class="line">fastdfs.http_secret_key &#x3D; FastDFS1234567890</span><br><span class="line">fastdfs.http_tracker_http_port &#x3D; 80</span><br><span class="line">fastdfs.tracker_servers &#x3D; ip地址:22122</span><br></pre></td></tr></table></figure>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        ClientGlobal.initByProperties(<span class="string">&quot;config/fastdfs-client.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建tracker客户端</span></span><br><span class="line">        TrackerClient trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">        <span class="comment">// 通过tracker客户端获取tracker的连接服务并返回</span></span><br><span class="line">        TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">        <span class="comment">// 声明storage服务</span></span><br><span class="line">        StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建storage客户端</span></span><br><span class="line">        StorageClient1 client = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义文件元信息</span></span><br><span class="line">        NameValuePair[] list = <span class="keyword">new</span> NameValuePair[<span class="number">1</span>];</span><br><span class="line">        list[<span class="number">0</span>]= <span class="keyword">new</span> NameValuePair(<span class="string">&quot;fileName&quot;</span>,<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件上传</span></span><br><span class="line">        String fileId = client.upload_file1(<span class="string">&quot;C:\\Users\\oddDog\\Desktop\\jerry.jpg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;fileId=&quot;</span>+fileId);</span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        trackerServer.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件查询"><a href="#文件查询" class="headerlink" title="文件查询"></a>文件查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  client 为storage客户端，上面有</span></span><br><span class="line">FileInfo fileInfo = client.query_file_info1(<span class="string">&quot;group1/M00/00/00/rBI2wGEglumAZva6AABwz89wnRU920.jpg&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;fileInfo=&quot;</span>+fileInfo);</span><br><span class="line"><span class="comment">// 关闭服务</span></span><br><span class="line">trackerServer.close();</span><br></pre></td></tr></table></figure>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = client.download_file1(<span class="string">&quot;group1/M00/00/00/rBI2wGEglumAZva6AABwz89wnRU920.jpg&quot;</span>);</span><br><span class="line"><span class="comment">// 创建输出流,并写出去</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\oddDog\\Desktop\\jerry222.jpg&quot;</span>));</span><br><span class="line">out.write(bytes);</span><br><span class="line">System.out.println(<span class="string">&quot;下载完毕！！！&quot;</span>);</span><br><span class="line">out.close();</span><br><span class="line">trackerServer.close();</span><br></pre></td></tr></table></figure>
<h1 id="搭建图片服务器"><a href="#搭建图片服务器" class="headerlink" title="搭建图片服务器"></a>搭建图片服务器</h1><h2 id="Nginx模块安装-（Storage）"><a href="#Nginx模块安装-（Storage）" class="headerlink" title="Nginx模块安装 （Storage）"></a>Nginx模块安装 （Storage）</h2><ol>
<li>上传 fastdfs-nginx-module_v1.16.tar.gz 到 /opt </li>
<li>解压nginx模块</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf fastdfs-nginx-module_v1.16.tar.gz</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改 src/config 文件，将文件中的 /usr/local/ 路径改为 /usr/。（有三处需要修改）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;fastdfs-nginx-module&#x2F;src</span><br><span class="line">vim config</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>将 fastdfs-nginx-module/src下的 mod_fastdfs.conf 拷贝至 /etc/fdfs 下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp mod_fastdfs.conf &#x2F;etc&#x2F;fdfs&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改 /etc/fdfs/mod_fastdfs.conf</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">base_path=/home/fastdfs</span><br><span class="line">tracker_server=10.1.220.247:22122</span><br><span class="line"><span class="meta">#</span><span class="bash">(n个tracker配置n行)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tracker_server=10.1.220.x:22122</span></span><br><span class="line"><span class="meta">#</span><span class="bash">url中包含group名称</span></span><br><span class="line">url_have_group_name=true</span><br><span class="line"><span class="meta">#</span><span class="bash">指定文件存储路径（上面配置的store路径）</span></span><br><span class="line">store_path0=/home/fastdfs/fdfs_storage</span><br></pre></td></tr></table></figure>
<ol start="6">
<li> 将 libfdfsclient.so 拷贝至 /usr/lib 下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib64&#x2F;libfdfsclient.so &#x2F;usr&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>创建nginx/client目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client</span><br></pre></td></tr></table></figure>
<h2 id="Nginx安装-（Tracker）"><a href="#Nginx安装-（Tracker）" class="headerlink" title="Nginx安装 （Tracker）"></a>Nginx安装 （Tracker）</h2><ol>
<li>将 nginx-1.14.0.tar.gz上传到/opt（安装过nginx，此步省略） </li>
<li>解压：tar -zxvf nginx-1.14.0.tar.gz（安装过nginx，此步省略） </li>
<li> 安装依赖库（安装过nginx，此步省略）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pcre</span><br><span class="line">yum install pcre-devel</span><br><span class="line">yum install zlib</span><br><span class="line">yum install zlib-devel</span><br><span class="line">yum install openssl</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>进入nginx解压的目录下 cd /opt/nginx-1.14.0</p>
</li>
<li><p>安装</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure \</span><br><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \</span><br><span class="line">--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \</span><br><span class="line">--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \</span><br><span class="line">--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \</span><br><span class="line">--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \</span><br><span class="line">--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \</span><br><span class="line">--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \</span><br><span class="line">--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \</span><br><span class="line">--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgi \</span><br><span class="line">--add-module&#x3D;&#x2F;opt&#x2F;fastdfs-nginx-module&#x2F;src</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上边将临时文件目录指定为 /var/temp/nginx，需要在 /var 下创建 temp 及 nginx 目录：mkdir /var/temp/nginx</p>
<ol start="6">
<li>编译：<code>make </code></li>
<li>安装：<code>make install </code></li>
<li>拷贝配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;FastDFS&#x2F;conf</span><br><span class="line">cp http.conf mime.types &#x2F;etc&#x2F;fdfs&#x2F;</span><br><span class="line">是否覆盖：yes(两次)</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>修改nginx配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name 10.1.220.247;</span><br><span class="line">	</span><br><span class="line">	location /group1/M00 &#123;</span><br><span class="line">		root /home/fastdfs/fdfs_storage/data;</span><br><span class="line">		ngx_fastdfs_module;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>关闭nginx，并启动nginx</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkill -9 nginx</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>访问nginx并查看图片</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 访问nginx</span><br><span class="line">http:&#x2F;&#x2F;10.1.220.247</span><br><span class="line">&#x2F;&#x2F; 访问图片</span><br><span class="line">http:&#x2F;&#x2F;10.1.220.247&#x2F;group1&#x2F;M00&#x2F;00&#x2F;00&#x2F;CgHc918f8l6AFYp0AAWICfQnHuk889.jpg</span><br></pre></td></tr></table></figure>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p><strong>创建前端页面</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--上传文件，文件与文字相比较起来，属于内容较大，必须使用post方式提交--%&gt;</span><br><span class="line">&lt;%--上传文件，和普通文件有区别，action接收参数也会区别对待，所以声明带文件提交的表单为“多部件表单”--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;upload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;fname&quot;</span>&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p><strong>fastdfs-client.properties（上面有，略）</strong></p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 因为有jsp页面，所以引用servlet依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面提交过来的请求，使用springmvc来处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- java连接fastDFS的客户端工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图片上传到FastDFS需要用的到IO工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图片保存到web服务器需要用到的IO工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用来转换java对象和json字符串，注意，2.7以上版本必须搭配spring5.0以上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8001<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servletclass</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描注解的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--处理器映射器和处理器适配器配置，功能增强，对json格式的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上传文件的解析器（规定上传文件的大小限制）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上传文件最大限制：2GB--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2048000000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>控制层（重点）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、先把文件保存到web服务器上</span></span><br><span class="line"><span class="comment">// 2、再从web服务器上将文件 上传 到 FastDFS上</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="comment">//MultipartHttpServletRequest：是httpservletRequest的强化版本，不仅可以装文本信息，还可以装图片文件信息</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">FileSystem <span class="title">upload</span><span class="params">(MultipartHttpServletRequest request)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1、把文件保存到web服务器*/</span></span><br><span class="line">        <span class="comment">// 从页面请求中，获取上传的文件对象</span></span><br><span class="line">        MultipartFile file = request.getFile(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="comment">// 从文件对象中获取 文件的原始名称</span></span><br><span class="line">        String oldFileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 通过字符串截取的方式，从文件原始名中获取文件的后缀   jpg</span></span><br><span class="line">        String hou = oldFileName.substring(oldFileName.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 为了避免文件因为同名而覆盖，生成全新的文件名</span></span><br><span class="line">        String newFileName = UUID.randomUUID().toString() + <span class="string">&quot;.&quot;</span> + hou;</span><br><span class="line">        <span class="comment">// 创建web服务器保存文件的目录(预先创建好D:/upload目录，否则系统找不到路径，会抛异常)</span></span><br><span class="line">        File toSaveFile = <span class="keyword">new</span> File(<span class="string">&quot;D:/upload/&quot;</span> + newFileName);</span><br><span class="line">        <span class="comment">// 将路径转换成文件（保存到web服务器）</span></span><br><span class="line">        file.transferTo(toSaveFile);</span><br><span class="line">        <span class="comment">// 获取服务器的绝对路径</span></span><br><span class="line">        String newFilePath = toSaveFile.getAbsolutePath();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* 2、把文件从web服务器上传到FastDFS*/</span></span><br><span class="line">        ClientGlobal.initByProperties(<span class="string">&quot;config/fastdfs-client.properties&quot;</span>);</span><br><span class="line">        TrackerClient trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="keyword">new</span> StorageClient1(trackerServer,storageServer);</span><br><span class="line">        <span class="comment">// 定义源信息    </span></span><br><span class="line">        NameValuePair[] list = <span class="keyword">new</span> NameValuePair[<span class="number">1</span>];</span><br><span class="line">        list[<span class="number">0</span>] = <span class="keyword">new</span> NameValuePair(<span class="string">&quot;fileName&quot;</span>,oldFileName);</span><br><span class="line">        <span class="comment">// 上传</span></span><br><span class="line">        String fileId = client.upload_file1(newFilePath, hou, list);</span><br><span class="line">        trackerServer.close();</span><br><span class="line">        <span class="comment">// 封装fileSystem数据对象</span></span><br><span class="line">        FileSystem fileSystem = <span class="keyword">new</span> FileSystem();</span><br><span class="line">        fileSystem.setFileId(fileId);</span><br><span class="line">        fileSystem.setFileName(oldFileName);</span><br><span class="line">        fileSystem.setFilePath(fileId); <span class="comment">//已经上传到FastDFS上，通过fileId来访问图片，所以fileId即为文件路径</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列之RabbitMQ</title>
    <url>/2021/08/27/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BRabbitMQ/</url>
    <content><![CDATA[<p><strong>MQ（Message Queue）消息队列</strong>  消息队列中间件，是分布式系统中的重要组件。主要解决: 异步处理，应用解耦，流量削峰等问题。 从而实现高性能，高可用，可伸缩和最终一致性的架构 。<a id="more"></a>使用较多的消息队列产品：RabbitMQ，RocketMQ，ActiveMQ，ZeroMQ，Kafka等。</p>
<p><strong>异步处理</strong></p>
<p>场景 : 用户注册后，需要发送验证邮箱和手机验证码</p>
<p><a href="https://imgtu.com/i/hK7MMq"><img src="https://z3.ax1x.com/2021/08/27/hK7MMq.png" alt="hK7MMq.png"></a></p>
<p><strong>应用解耦</strong></p>
<p>场景：订单系统需要通知库存系统。 如果库存系统异常，则订单调用库存失败，导致下单失败</p>
<p><a href="https://imgtu.com/i/hK77Fg"><img src="https://z3.ax1x.com/2021/08/27/hK77Fg.png" alt="hK77Fg.png"></a></p>
<ul>
<li><p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户，下单成功；</p>
</li>
<li><p>库存系统：订阅下单的消息，获取下单信息，库存系统根据下单信息，再进行库存操作；</p>
</li>
<li><p>假如：下单的时候，库存系统不能正常运行，也不会影响下单，因为下单后，订单系统写入消息队 列就不再关心其他的后续操作了，实现了订单系统和库存系统的应用解耦；</p>
</li>
<li><p>所以说，消息队列是典型的：<strong>生产者消费者模型</strong></p>
</li>
</ul>
<p><strong>流量晓峰</strong></p>
<p>场景：抢购，秒杀等业务，针对高并发的场景</p>
<p><a href="https://imgtu.com/i/hKbT2j"><img src="https://z3.ax1x.com/2021/08/27/hKbT2j.png" alt="hKbT2j.png"></a></p>
<ul>
<li><p>因为流量过大，暴增会导致应用挂掉，为解决这个问题，在前端加入消息队列</p>
</li>
<li><p>用户的请求，服务器接收后，首先写入消息队列，如果超过队列的长度，就抛弃，甩一个秒杀结束 的页面！</p>
</li>
<li><p>说白了，秒杀成功的就是进入队列的用户；</p>
</li>
</ul>
<h1 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h1><p><strong>AMQP高级消息队列协议</strong></p>
<ul>
<li>即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协 议 </li>
<li>协议：数据在传输的过程中必须要遵守的规则 </li>
<li>基于此协议的客户端可以与消息中间件传递消息 </li>
<li>并不受产品、开发语言等条件的限制</li>
</ul>
<p><strong>JMS</strong> </p>
<ul>
<li>Java Message Server，Java消息服务应用程序接口， 一种规范，和JDBC担任的角色类似 </li>
<li>是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消 息，进行异步通信</li>
</ul>
<p><strong>AMQP与JMS的联系</strong></p>
<ul>
<li>JMS是定义了统一接口，统一消息操作；AMQP通过协议统一数据交互格式 </li>
<li>JMS必须是java语言；AMQP只是协议，与语言无关</li>
</ul>
<p><strong>JMS vs AMQP</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>Java</td>
<td>api</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Model</td>
<td>提供两种消息模型/模式：（1）、Peer-2- Peer（2）、Pub/sub</td>
<td>提供了五种消息模型：（1）、direct exchange（2）、fanout exchange（3）、topic change（4）、headers exchange（5）、system exchange本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路 由机制上做了更详细的划分；</td>
</tr>
<tr>
<td>支持消 息类型</td>
<td>多种消息类型：TextMessage、 MapMessage、BytesMessage、 StreamMessage、ObjectMessage、 Message （只有消息头和属性）</td>
<td>byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送</td>
</tr>
<tr>
<td>综合评 价</td>
<td>JMS 定义了JAVA API层面的标准；在java 体系中，多个client均可以通过JMS进行交 互，不需要应用修改代码，但是其对跨平 台的支持较差；</td>
<td>AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性</td>
</tr>
</tbody></table>
<p><strong>ErLang语言</strong></p>
<ul>
<li>Erlang（[‘ə:læŋ]）是一种通用的面向并发的编程语言，它由瑞典电信设备制造商爱立信所辖的CSLab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境 </li>
<li>最初是由爱立信专门为通信应用设计的，比如控制交换机或者变换协议等，因此非常适合构建分布 式，实时软并行计算系统 </li>
<li>Erlang运行时环境是一个虚拟机，有点像Java的虚拟机，这样代码一经编译，同样可以随处运行</li>
</ul>
<p><strong>为什么使用RabbitMQ</strong></p>
<ul>
<li><p>Erlang语言开发，AMQP的最佳搭档，安装部署简单，上手门槛低。</p>
</li>
<li><p>有强大的WEB管理页面；强大的社区支持，为技术进步提供动力；支持消息持久化、支持消息确认机制、灵活的任务分发机制等，支持功能非常丰富；集群扩展很容易，并且可以通过增加节点实现成倍的性能提升。</p>
</li>
<li><p>总结：如果你希望使用一个可靠性高、功能强大、易于管理的消息队列系统那么就选择RabbitMQ；如果你想用一个性能高，但偶尔丢点数据不是很在乎，可以使用kafka或者zeroMQ 。kafka和zeroMQ的性能爆表，绝对可以压RabbitMQ一头！</p>
</li>
</ul>
<p><strong>消息队列产品对比</strong></p>
<p><a href="https://imgtu.com/i/4rG5ee"><img src="https://z3.ax1x.com/2021/09/25/4rG5ee.png" alt="4rG5ee.png"></a></p>
<p><strong>RabbitMQ各组件功能</strong></p>
<p><a href="https://imgtu.com/i/hKOy24"><img src="https://z3.ax1x.com/2021/08/27/hKOy24.png" alt="hKOy24.png"></a></p>
<ul>
<li><strong>Broker</strong>：消息队列服务器实体 </li>
<li><strong>Virtual Host</strong>：虚拟主机 <ul>
<li>标识一批交换机、消息队列和相关对象，形成的整体 </li>
<li>虚拟主机是共享相同的身份认证和加密环境的独立服务器域 </li>
<li>每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制 </li>
<li>vhost是AMQP概念的基础，RabbitMQ默认的vhost是 /，必须在链接时指定 </li>
</ul>
</li>
<li><strong>Exchange</strong>：交换器（路由） <ul>
<li>用来接收生产者发送的消息并将这些消息路由给服务器中的队列 </li>
</ul>
</li>
<li><strong>Queue</strong>：消息队列 <ul>
<li>用来保存消息直到发送给消费者。 </li>
<li>它是消息的容器，也是消息的终点。 </li>
<li>一个消息可投入一个或多个队列。 </li>
<li>消息一直在队列里面，等待消费者连接到这个队列将其取走。 </li>
</ul>
</li>
<li><strong>Banding</strong>：绑定，用于消息队列和交换机之间的关联。 </li>
<li><strong>Channel</strong>：通道（信道）<ul>
<li>多路复用连接中的一条独立的双向数据流通道。 </li>
<li>信道是建立在真实的TCP连接内的 虚拟链接 AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信 道完成的 </li>
<li>因为对于操作系统来说，建立和销毁TCP连接都是非常昂贵的开销，所以引入了信道的概 念，用来复用TCP连接。 </li>
</ul>
</li>
<li><strong>Connection</strong>：网络连接，比如一个TCP连接。 </li>
<li><strong>Publisher</strong>：消息的生产者，也是一个向交换器发布消息的客户端应用程序。 </li>
<li><strong>Consumer</strong>：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 </li>
<li><strong>Message</strong>：消息 <ul>
<li>消息是不具名的，它是由消息头和消息体组成。 </li>
<li>消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由 键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。</li>
</ul>
</li>
</ul>
<h1 id="使用RabbitMQ"><a href="#使用RabbitMQ" class="headerlink" title="使用RabbitMQ"></a>使用RabbitMQ</h1><h2 id="RabbitMQ的下载与安装"><a href="#RabbitMQ的下载与安装" class="headerlink" title="RabbitMQ的下载与安装"></a>RabbitMQ的下载与安装</h2><p>想要安装RabbitMQ，必须先安装erlang语言环境，类似安装tomcat，必须先安装JDK 。查看匹配的版本：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p><a href="https://imgtu.com/i/hKjzvQ"><img src="https://z3.ax1x.com/2021/08/27/hKjzvQ.png" alt="hKjzvQ.png"></a></p>
<p><strong>下载</strong></p>
<p>erlang下载：<a href="https://dl.bintray.com/rabbitmq-erlang/rpm/erlang">https://dl.bintray.com/rabbitmq-erlang/rpm/erlang</a> </p>
<p>socat下载：<a href="http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm">http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</a> </p>
<p>RabbitMQ下载：<a href="https://www.rabbitmq.com/install-rpm.html#downloads">https://www.rabbitmq.com/install-rpm.html#downloads</a></p>
<p><strong>安装</strong></p>
<p>将下好的安装包放入/opt目录下，进入/opt目录，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-21.3.8.16-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.6-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>启动后台管理插件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><strong>RabbitMQ的启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server.service			# 启动</span><br><span class="line">systemctl status rabbitmq-server.service		# 查看状态</span><br><span class="line">systemctl restart rabbitmq-server.service		# 重启</span><br><span class="line">systemctl stop rabbitmq-server.service			# 停止</span><br></pre></td></tr></table></figure>
<p><strong>查看进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep rabbitmq</span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ管理工具"><a href="#RabbitMQ管理工具" class="headerlink" title="RabbitMQ管理工具"></a>RabbitMQ管理工具</h2><p>浏览器输入：<a href="http://ip:15672/">http://ip:15672</a></p>
<p>默认帐号密码：guest，guest,用户默认不允许远程连接</p>
<ol>
<li><p>创建账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user hui 123</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags hui administrator</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; hui &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前用户和角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li>
<li><p>修改用户密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl change_password hui 123123</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>管理界面介绍</strong></p>
<ul>
<li>overview：概览 </li>
<li>connections：查看链接情况 </li>
<li>channels：信道（通道）情况 </li>
<li>Exchanges：交换机（路由）情况，默认4类7个 </li>
<li>Queues：消息队列情况 </li>
<li>Admin：管理员列表 </li>
<li>端口： <ul>
<li>5672：RabbitMQ提供给编程语言客户端链接的端口 </li>
<li>15672：RabbitMQ管理界面的端口 </li>
<li>25672：RabbitMQ集群的端口</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门</h1><h2 id="java连接RabbitMQ"><a href="#java连接RabbitMQ" class="headerlink" title="java连接RabbitMQ"></a>java连接RabbitMQ</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>日志依赖log4j（可选项）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n</span><br><span class="line">log4j.appender.file&#x3D;org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.file.File&#x3D;rebbitmq.log</span><br><span class="line">log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n</span><br><span class="line">log4j.rootLogger&#x3D;debug, stdout,file</span><br></pre></td></tr></table></figure>
<p><strong>先创建好虚拟主机</strong></p>
<p><a href="https://imgtu.com/i/hMSCbd"><img src="https://z3.ax1x.com/2021/08/27/hMSCbd.png" alt="hMSCbd.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接工具类，专门与RabbitMQ获得连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2.在工厂对象中设置MQ的连接信息（ip,port,vhost,username,password）</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;47.115.139.213&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/hui&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;hui&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//3.通过工厂获得与MQ的连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;connection&quot;</span> + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ模式"><a href="#RabbitMQ模式" class="headerlink" title="RabbitMQ模式"></a>RabbitMQ模式</h2><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此我们只学习前5种 。在线手册：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><a href="https://imgtu.com/i/hMS2se"><img src="https://z3.ax1x.com/2021/08/27/hMS2se.png" alt="hMS2se.png"></a></p>
<ul>
<li>5种消息模型，大体分为两类： <ul>
<li>1和2属于点对点 </li>
<li>3、4、5属于发布订阅模式（一对多）</li>
</ul>
</li>
</ul>
<p><strong>点对点模式</strong>：P2P（point to point）</p>
<ul>
<li>模式包含三个角色： 消息队列（queue），发送者（sender），接收者（receiver） </li>
<li>每个消息发送到一个特定的队列中，接收者从中获得消息 。队列中保留这些消息，直到他们被消费或超时 </li>
<li><strong>特点</strong>： <ol>
<li>每个消息只有一个消费者，一旦消费，消息就不在队列中了 </li>
<li>发送者和接收者之间没有依赖性，发送者发送完成，不管接收者是否运行，都不会影响 消息发送到队列中</li>
<li>接收者成功接收消息之后需向对象应答成功（确认） </li>
</ol>
</li>
<li>如果希望发送的每个消息都会被成功处理，那需要P2P</li>
</ul>
<p><strong>发布订阅模式</strong>：publish（Pub）/subscribe（Sub） pub/sub</p>
<ul>
<li><p>模式包含三个角色：交换机（exchange），发布者（publisher），订阅者 （subcriber） </p>
</li>
<li><p>多个发布者将消息发送交换机，系统将这些消息传递给多个订阅者</p>
</li>
<li><p><strong>特点</strong>： </p>
<ol>
<li>每个消息可以有多个订阅者 </li>
<li>发布者和订阅者之间在时间上有依赖，对于某个交换机的订阅者，必须创建一个订阅 后，才能消费发布者的消息</li>
<li>为了消费消息，订阅者必须保持运行状态；类似于，看电视直播。 </li>
</ol>
</li>
<li><p>如果希望发送的消息被多个消费者处理，可采用本模式</p>
</li>
</ul>
<h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>RabbitMQ本身只是接收，存储和转发消息，并不会对信息进行处理！</p>
<p><a href="https://imgtu.com/i/hMiJu8"><img src="https://z3.ax1x.com/2021/08/27/hMiJu8.png" alt="hMiJu8.png"></a></p>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明消息列队，没有就新建，有的话就直接拿来使用</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1:队列的名称</span></span><br><span class="line"><span class="comment">            参数2:队列中的数据是否持久化</span></span><br><span class="line"><span class="comment">            参数3:是否排外（是否支持扩展，当前队列只能自己用，不能给别人用）</span></span><br><span class="line"><span class="comment">            参数4:是否自动删除（当队列的连接数为0时，队列会销毁，不管队列是否还存保存数据）</span></span><br><span class="line"><span class="comment">            参数5:队列参数（没有参数为null）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 向指定的队列中发送消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1:交换机名称，当前是简单模式，也就是P2P模式，没有交换机，所以名称为 &quot;&quot;</span></span><br><span class="line"><span class="comment">            参数2:目标队列的名称</span></span><br><span class="line"><span class="comment">            参数3:设置消息的属性（没有属性则为null）</span></span><br><span class="line"><span class="comment">            参数4:消息的内容(只接收字节数组)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String msg = <span class="string">&quot;hello hui!!!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue1&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;queue1 发送: &quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 从信道中获得消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//交付处理（收件人信息，包裹上的快递标签，协议的配置，消息）</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，获取消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数一: 队列名</span></span><br><span class="line"><span class="comment">            参数二: 自动消息确认</span></span><br><span class="line"><span class="comment">            参数三: consumer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消息确认机制ACK</strong></p>
<ul>
<li>如果消费者接收消息后，还没执行操作就抛异常宕机导致消费失败，但是RabbitMQ无从得 知，这样消息就丢失了 </li>
<li>因此，RabbitMQ有一个<strong>ACK机制</strong>，当消费者获取消息后，会向RabbitMQ发送回执ACK，告 知消息已经被接收 </li>
<li>ACK：(Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种 传输类控制字符。表示发来的数据已确认接收无误。例如我们在使用http请求时，http的状态码200 就是告诉我们服务器执行成功 </li>
<li>回执ACK分为两种情况： <ul>
<li>自动ACK：消息接收后，消费者立刻自动发送ACK </li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li>
</ul>
</li>
<li>两种情况如何选择，需要看消息的重要性： <ul>
<li>如果消息不太重要，丢失也没有影响，自动ACK会比较方便 </li>
<li>如果消息非常重要，最好消费完成手动ACK</li>
</ul>
</li>
</ul>
<p><strong>修改手动消息确认</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// false：手动消息确认</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">false</span>, consumer);</span><br></pre></td></tr></table></figure>
<p><strong>ACK消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerByACK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 从信道中获得消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//交付处理（收件人信息，包裹上的快递标签，协议的配置，消息）</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收:&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="comment">// 手动确认（参数一:收件人信息  参数二:是否同时确认多个消息）</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// false:手动消息确认</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h3><p>简单模式中，只有一个消费者来处理消息，如果生产者生产消息过快过多，而消费者的能 力有限，就会产生消息在队列中堆积，这时我们需要多个消费者</p>
<p><a href="https://imgtu.com/i/hMkNfs"><img src="https://z3.ax1x.com/2021/08/27/hMkNfs.png" alt="hMkNfs.png"></a></p>
<p>模拟场景: 一个烧烤师傅，两个顾客</p>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明消息列队，没有就新建，有的话就直接拿来使用</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发送100条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;羊肉串--&gt;&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work_queue&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;已烤好:&quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 消费消息的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明消息列队，没有就新建，有的话就直接拿来使用</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 能者多劳,取消平均分配  (注:必须要配合手动的ACK机制才生效)</span></span><br><span class="line">        <span class="comment">// channel.basicQos(1);</span></span><br><span class="line">        <span class="comment">// 从信道中获得消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//交付处理（收件人信息，包裹上的快递标签，协议的配置，消息）</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户1吃掉:&quot;</span> + <span class="keyword">new</span> String(body) + <span class="string">&quot;; 共吃掉&quot;</span> + ++count + <span class="string">&quot;串&quot;</span>);</span><br><span class="line">                <span class="comment">// 休息一会</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，获取消息</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queue&quot;</span>, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者2</strong></p>
<p>与消费者1代码相同，只需改变 <code>Thread.sleep(300)</code> 查看效果</p>
<p><strong>能者多劳</strong></p>
<ul>
<li><p>虽然两个消费者的消费速度不一致（线程休眠时间），但是消费的数量却是一致的，各消费50个 消息,这是<strong>平均分配模式</strong>。</p>
</li>
<li><p>为了克服这个问题，我们可以使用设置为prefetchCount = 1的basicQos方法。这告诉 RabbitMQ一次不要给一个worker发送一条以上的消息。或者，换句话说，在worker处理并 确认前一个消息之前，不要向它发送新消息。相反，它将把它分派到下一个不繁忙的 worker。</p>
</li>
<li><p>修改代码，去掉上面代码的注释即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以理解为：快递一个一个送，送完一个再送下一个，速度快的送件就多</span></span><br><span class="line"><span class="comment">// 能者多劳,取消平均分配  (注:必须要配合手动的ACK机制才生效)</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>面试题：避免消息堆积？</strong> </p>
<ol>
<li>workqueue，多个消费者监听同一个队列 </li>
<li>接收到消息后，通过线程池，异步消费</li>
</ol>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p><a href="https://imgtu.com/i/hMZ9AO"><img src="https://z3.ax1x.com/2021/08/27/hMZ9AO.png" alt="hMZ9AO.png"></a></p>
<p>P生产者发送信息给X路由，X将信息转发给绑定X的队列c1与c2</p>
<p>整个过程，必须先创建路由</p>
<ul>
<li>路由在生产者程序中创建 </li>
<li>因为路由没有存储消息的能力，当生产者将信息发送给路由后，消费者还没有运行，所以没 有队列，路由并不知道将信息发送给谁 </li>
<li>运行程序的顺序： <ol>
<li>先运行生产者—-创建路由</li>
<li>再运行消费者1和消费者2 —-经行队列绑定</li>
<li>最后运行发布者—-发出消息</li>
</ol>
</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明路由(参数一:路由名  参数二:路由类型)</span></span><br><span class="line">        <span class="comment">// fanout：不处理路由键（只需要将队列绑定到路由上，发送到路由的消息都会被转发到与该路由绑定的所有队列上）</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;exchange_fanout&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;hello 怪狗狗&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;exchange_fanout&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;exchange_fanout发送:&quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscribe1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;exchange_fanout_queue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 绑定路由</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名</span></span><br><span class="line"><span class="comment">            参数2：交换器名称</span></span><br><span class="line"><span class="comment">            参数3：路由key（暂时无用，&quot;&quot;即可）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;exchange_fanout_queue1&quot;</span>,<span class="string">&quot;exchange_fanout&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;queue1接收:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;exchange_fanout_queue1&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者2</strong></p>
<p>将消费者1代码中的1修改为2即可</p>
<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p><a href="https://imgtu.com/i/hMeGJe"><img src="https://z3.ax1x.com/2021/08/27/hMeGJe.png" alt="hMeGJe.png"></a></p>
<p>路由会根据类型进行定向分发消息给不同的队列</p>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明路由(参数一:路由名  参数二:路由类型)</span></span><br><span class="line">        <span class="comment">// direct：根据路由键进行定向分发消息</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;exchange_redirect&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;用户查询:id=15&quot;</span>;</span><br><span class="line">        <span class="comment">// 指定队列key为insert</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;exchange_redirect&quot;</span>, <span class="string">&quot;select&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;[用户系统]:&quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;exchange_redirect_queue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 绑定路由</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名</span></span><br><span class="line"><span class="comment">            参数2：交换器名称</span></span><br><span class="line"><span class="comment">            参数3：路由key（设置不同的类型）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;exchange_redirect_queue1&quot;</span>,<span class="string">&quot;exchange_redirect&quot;</span>,<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;exchange_redirect_queue1&quot;</span>,<span class="string">&quot;exchange_redirect&quot;</span>,<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;exchange_redirect_queue1&quot;</span>,<span class="string">&quot;exchange_redirect&quot;</span>,<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;exchange_redirect_queue1&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者2</strong></p>
<p>将消费者1代码中的1修改为2即可，绑定路由时，参数3的路由key随机设置</p>
<h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p><a href="https://imgtu.com/i/hMmYkT"><img src="https://z3.ax1x.com/2021/08/27/hMmYkT.png" alt="hMmYkT.png"></a></p>
<ul>
<li>和路由模式90%是一样的。 </li>
<li>唯独的区别就是路由键支持模糊匹配 </li>
<li>匹配符号 <ul>
<li>*：只能匹配一个<strong>词</strong> </li>
<li>#：匹配0个或更多个词</li>
</ul>
</li>
</ul>
<p><strong>生产者</strong></p>
<p>与路由模式一样，只需修改路由的模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明路由(参数一:路由名  参数二:路由类型)</span></span><br><span class="line"><span class="comment">// topic：模糊匹配的定向分发</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<p>与路由模式一样，绑定路由时可以使用通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueBind(<span class="string">&quot;exchange_topic_queue1&quot;</span>,<span class="string">&quot;exchange_topic&quot;</span>,<span class="string">&quot;product.#&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;exchange_topic_queue1&quot;</span>,<span class="string">&quot;exchange_topic&quot;</span>,<span class="string">&quot;order.#&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>发送消息时指定key值为 order.select 或  product.update ，该消费者都可以收到</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul>
<li>消费者的ACK确认机制，可以防止消费者丢失消息</li>
<li>万一在消费者消费之前，RabbitMQ服务器宕机了，那消息也会丢失 </li>
<li>想要将消息持久化，那么 路由和队列都要持久化 才可以</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明路由(路由名，路由类型，持久化)</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        String msg = <span class="string">&quot;商品降价&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息(第三个参数作用是让消息持久化)</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;product.price&quot;</span>,MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明队列( 第二个参数为true：支持持久化)</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Spring整合RabbitMQ"><a href="#Spring整合RabbitMQ" class="headerlink" title="Spring整合RabbitMQ"></a>Spring整合RabbitMQ</h1><ul>
<li>五种消息模型，在企业中应用最广泛的就是最后一种：定向匹配topic </li>
<li>Spring AMQP 是基于 Spring 框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象 层，提供基于消息驱动的 POJO的消息监听等，简化了我们对于RabbitMQ相关程序的开发。</li>
</ul>
<h2 id="生产端工程"><a href="#生产端工程" class="headerlink" title="生产端工程"></a>生产端工程</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-rabbitmq-producer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!--  配置连接  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;47.115.139.213&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;/hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  配置队列  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;spring-confirm-queue&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  配置rabbitAdmin：主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  配置topic类型exchange；队列绑定到交换机  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">&quot;spring-confirm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;user.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;spring-confirm-queue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!--  配置消息对象json转换类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> 	<span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  配置RabbitTemplate（消息生产者）  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">exchange</span>=<span class="string">&quot;spring-confirm&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>发消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-rabbitmq-producer.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取rabbitMQ模板对象</span></span><br><span class="line">        RabbitTemplate template = context.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;user.select&quot;</span>,map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息已发出&quot;</span>);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费端工程"><a href="#消费端工程" class="headerlink" title="消费端工程"></a>消费端工程</h2><p><strong>依赖与生产者一致</strong> </p>
<p><strong>spring-rabbitmq-consumer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置连接  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;47.115.139.213&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;/hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">                               /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置队列  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;spring-confirm-queue&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置rabbitAdmin：主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.springIOC注解扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;listener&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5.配置监听 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queues</span>=<span class="string">&quot;spring-confirm-queue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>监听队列（消费者）</strong> </p>
<ul>
<li>MessageListener接口用于spring容器接收到消息后处理消息 </li>
<li>如果需要使用自己定义的类型 来实现 处理消息时，必须实现该接口，并重写onMessage()方 法 </li>
<li>当spring容器接收消息后，会自动交由onMessage进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;consumerListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jackson提供序列化和反序列中使用最多的类，用来转换json的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonNode jsonNode = MAPPER.readTree(message.getBody());</span><br><span class="line">            String username = jsonNode.get(<span class="string">&quot;username&quot;</span>).asText();</span><br><span class="line">            String password = jsonNode.get(<span class="string">&quot;password&quot;</span>).asText();</span><br><span class="line">            System.out.println(username + <span class="string">&quot;:&quot;</span> + password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动项目</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-rabbitMQ-consumer.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 让程序一直停在这里</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息成功确认机制"><a href="#消息成功确认机制" class="headerlink" title="消息成功确认机制"></a>消息成功确认机制</h2><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><ul>
<li>AMQP协议提供的一种保证消息成功投递的方式，通过信道开启 transactional 模式 </li>
<li>并利用信道 的三个方法来实现以事务方式 发送消息，若发送失败，通过异常处理回滚事务，确保 消息成功投递 <ul>
<li>channel.txSelect()： 开启事务 </li>
<li>channel.txCommit() ：提交事务 </li>
<li>channel.txRollback() ：回滚事务 </li>
</ul>
</li>
<li>Spring已经对上面三个方法进行了封装，所以我们只能使用原始的代码演示</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_transaction&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        channel.txSelect(); <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;test_transaction&quot;</span>, <span class="string">&quot;product.price&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;商品降价1&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">// System.out.println(1/0); // 模拟异常！</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;test_transaction&quot;</span>, <span class="string">&quot;product.price&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;商品降价2&quot;</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;消息全部发出！&quot;</span>);</span><br><span class="line">            channel.txCommit(); <span class="comment">// 事务提交</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;由于系统异常，消息全部撤回！&quot;</span>);</span><br><span class="line">            channel.txRollback(); <span class="comment">// 事务回滚</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发送了错误，消费者就不会就收到消息。</p>
<h3 id="Confirm发布确认机制"><a href="#Confirm发布确认机制" class="headerlink" title="Confirm发布确认机制"></a>Confirm发布确认机制</h3><ul>
<li><p>事务效率很低，开启事务性能最大损失超过250倍，例如：10条消息，前9条成功，如果第10条失败，那么9条消息 要全部撤销回滚。</p>
</li>
<li><p>而confirm模式则采用补发第10条的措施来完成10条消息的送达</p>
</li>
</ul>
<p><strong>修改spring-rabbitmq-producer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置连接，启动生产者确认机制: publisher-confirms=&quot;true&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">host</span>=<span class="string">&quot;192.168.204.141&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">username</span>=<span class="string">&quot;hui&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">virtual-host</span>=<span class="string">&quot;/hui&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                           /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置rabbitmq的模版,添加确认回调处理类:confirmcallback=&quot;myConfirm&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">exchange</span>=<span class="string">&quot;spring_topic_exchange&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">confirm-callback</span>=<span class="string">&quot;myConfirm&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--确认机制处理类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myConfirm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;confirm.MyConfirm&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>消息确认处理类</strong></p>
<p>实现ConfirmCallback接口，并重写confirm方法。参数二：是否发送成功；参数三:发送失败的错误信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfirm</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送失败!&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;error:&quot;</span>+s);</span><br><span class="line">            <span class="comment">// 如果本条消息一定要发送到队列中，例如下订单消息，我们可以采用消息补发</span></span><br><span class="line">            <span class="comment">// 采用递归（固定次数，不可无限）或 redis+定时任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  需要在生产者发送消息类中添加 <code>Thread.sleep()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConfirmCallback是异步操作，由于资源会提前关闭，会出现错误 clean channel shutdown，所以需要等待一会</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><ul>
<li>当数据量特别大的时候，我们对生产端限流肯定是不科学的，这是用户的行为，我们是无法约束的</li>
<li>所以我们应该对消费端限流，用于保持消费端的稳定</li>
<li>RabbitMQ 提供了一种 Qos （Quality of Service，服务质量）服务质量保证功能 <ul>
<li>即在非自动确认消息的前提下，如果一定数目的消息未被确认前，不再进行消费新的消息</li>
</ul>
</li>
</ul>
<p><strong>先在生产方发出多条数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    template.convertAndSend(<span class="string">&quot;user.select&quot;</span>, map);</span><br><span class="line">    System.out.println(<span class="string">&quot;消息已发出...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费端经行限流处理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       prefetch=&quot;3&quot; 一次性消费的消息数量。会告诉 RabbitMQ 不要同时给一个消费者推送多于N 个消息，一旦有 N 个消息还没有ack，则该 consumer 将阻塞，直到消息被ack</span></span><br><span class="line"><span class="comment">       acknowledge-mode: manual 手动确认</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">prefetch</span>=<span class="string">&quot;3&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;aCKConsumerListener&quot;</span> <span class="attr">queues</span>=<span class="string">&quot;spring-confirm-queue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>消费者监听类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAdaptableMessageListener用于在spring容器接收到消息后用于处理消息的抽象基类</span></span><br><span class="line"><span class="meta">@Component(&quot;aCKConsumerListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ACKConsumerListener</span> <span class="keyword">extends</span> <span class="title">AbstractAdaptableMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jackson提供序列化和反序列中使用最多的类，用来转换json的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonNode jsonNode = MAPPER.readTree(message.getBody());</span><br><span class="line">            String username = jsonNode.get(<span class="string">&quot;username&quot;</span>).asText();</span><br><span class="line">            String password = jsonNode.get(<span class="string">&quot;password&quot;</span>).asText();</span><br><span class="line">            System.out.println(username + <span class="string">&quot;:&quot;</span> + password);</span><br><span class="line">            <span class="comment">//确认收到(参数1,参数2) 如果没确认就不会继续执行</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                参数1：RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递</span></span><br><span class="line"><span class="comment">                        增的正整数，delivery_tag 的范围仅限于 Channel</span></span><br><span class="line"><span class="comment">                参数2：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以</span></span><br><span class="line"><span class="comment">                        一次性确认 delivery_tag 小于等于传入值的所有消息</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">long</span> id = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            channel.basicAck(id, <span class="keyword">true</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><ul>
<li><p>Time To Live：生存时间、还能活多久，单位毫秒</p>
</li>
<li><p>在这个周期内，消息可以被消费者正常消费，超过这个时间，则自动删除（其实是被称为dead message并投入到死信队列，无法消费该消息） </p>
</li>
<li><p>RabbitMQ可以对消息和队列设置TTL </p>
<ul>
<li>通过队列设置，队列中所有消息都有相同的过期时间 </li>
<li>对消息单独设置，每条消息的TTL可以不同（更颗粒化）</li>
</ul>
</li>
</ul>
<h3 id="设置队列TTL"><a href="#设置队列TTL" class="headerlink" title="设置队列TTL"></a>设置队列TTL</h3><p><strong>spring-rabbitmq-producer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  声明一个ttl为5秒的队列  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;spring-confirm-ttl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  配置topic类型exchange；队列绑定到交换机  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">&quot;spring-confirm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;order.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;spring-confirm-ttl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/hMW0xK"><img src="https://z3.ax1x.com/2021/08/27/hMW0xK.png" alt="hMW0xK.png"></a></p>
<p>该条消息5秒后会自动消失</p>
<h3 id="设置消息TTL"><a href="#设置消息TTL" class="headerlink" title="设置消息TTL"></a>设置消息TTL</h3><p>只需要在创建发送消息时指定即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--先配置队列，记得绑定到交换机--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_ttl2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试某条消息的过期时间，如果队列中也设置了，以时间较小的一方为主</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-rabbitmq-producer.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取rabbitMQ模板对象</span></span><br><span class="line">        RabbitTemplate template = context.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置过期时间属性</span></span><br><span class="line">        MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        properties.setExpiration(<span class="string">&quot;6000&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;6秒后将自动删除&quot;</span>.getBytes(), properties);</span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        template.convertAndSend(<span class="string">&quot;goods.select&quot;</span>, message);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><ul>
<li>DLX（Dead Letter Exchanges）死信交换机/死信邮箱，当消息在队列中由于某些原因没有被及时 消费而变成死信（dead message）后，这些消息就会被分发到DLX交换机中，而绑定DLX交换机 的队列，称之为：“死信队列” </li>
<li>消息没有被及时消费的原因： <ul>
<li>消息被拒绝（basic.reject/ basic.nack）并且不再重新投递 requeue=false </li>
<li>消息超时未消费 </li>
<li>达到最大队列长度</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/hMfJQf"><img src="https://z3.ax1x.com/2021/08/27/hMfJQf.png" alt="hMfJQf.png"></a></p>
<p><strong>spring-rabbitmq-producer-dlx.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置连接  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;47.115.139.213&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;/hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;hui&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置rabbitAdmin：主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置RabbitTemplate（消息生产者）  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">exchange</span>=<span class="string">&quot;my-exchange&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  死信队列  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;dlx-queue&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  死信交换机  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">&quot;dlx-exchange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_ttl&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;dlx-queue&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_max&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;dlx-queue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  过期时间队列  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;ttl-queue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--超时 消息 投递给 死信交换机--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dlx-exchange&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  最大容量队列  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;max-queue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-max-length&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--超过最大容量的消息投递给死信交换机--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dlx-exchange&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定向交换机--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">&quot;my-exchange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_ttl&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;ttl-queue&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_max&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;max-queue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>消费者发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-rabbitmq-producer-dlx.xml&quot;</span>);</span><br><span class="line">        RabbitTemplate template = context.getBean(RabbitTemplate.class);</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;dlx_ttl&quot;</span>, <span class="string">&quot;超时时间...&quot;</span>.getBytes());</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;最大容量1&quot;</span>.getBytes());</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;最大容量2&quot;</span>.getBytes());</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;最大容量3&quot;</span>.getBytes());</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息后，“最大容量1” 会立刻加入到死信队列，而过5秒后，“超时时间”会加入到死信队列。</p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><ul>
<li>延迟队列：TTL + 死信队列的合体 </li>
<li>死信队列只是一种特殊的队列，里面的消息仍然可以消费 </li>
<li>在电商开发部分中，都会涉及到延时关闭订单，此时延迟队列正好可以解决这个问题</li>
</ul>
<p><strong>spring-rabbitmq-consumer.xm</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    监听死信队列    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">prefetch</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span></span></span><br><span class="line"><span class="tag">                           &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;dLXQueueListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;dlx-queue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>死信队列监听</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;dLXQueueListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXQueueListener</span> <span class="keyword">extends</span> <span class="title">AbstractAdaptableMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        System.out.println(<span class="string">&quot;msg : &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="comment">//确认收到(参数1,参数2) 如果没确认就不会继续执行</span></span><br><span class="line">        <span class="keyword">long</span> id = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        channel.basicAck(id, <span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h1><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8007</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">edu-order-boot</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hui</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hui</span></span><br><span class="line">    <span class="attr">queue:</span> <span class="string">order_queue</span></span><br></pre></td></tr></table></figure>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// rabbit模板对象</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.queue&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String queue; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试rabbitMQ</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sentMQ&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sentMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送消息，如果发送的是对象，该对象需要序列化</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queue, <span class="string">&quot;hello rabbit!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderReceive</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;$&#123;spring.rabbitmq.queue&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息:&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RabbiMQ集群"><a href="#RabbiMQ集群" class="headerlink" title="RabbiMQ集群"></a>RabbiMQ集群</h1><p>rabbitmq有3种模式，集群模式有2种。详细如下： </p>
<ul>
<li>单一模式：即单机情况不做集群，就单独运行一个rabbitmq而已。之前我们一直在用 </li>
<li>普通模式：默认模式，以两个节点（A、B）为例来进行说明 <ul>
<li>当消息进入A节点的Queue后，consumer从B节点消费时，RabbitMQ会在A和B之间创建临 时通道进行消息传输，把A中的消息实体取出并经过通过交给B发送给consumer </li>
<li>当A故障后，B就无法取到A节点中未消费的消息实体 <ul>
<li>如果做了消息持久化，那么得等A节点恢复，然后才可被消费 </li>
<li>如果没有持久化的话，就会产生消息丢失的现象 </li>
</ul>
</li>
</ul>
</li>
<li>镜像模式：非常经典的 mirror 镜像模式，保证 100% 数据不丢失。 <ul>
<li>高可靠性解决方案，主要就是实现数据的同步，一般来讲是 2 - 3 个节点实现数据同步 </li>
<li>对于 100% 数据可靠性解决方案，一般是采用 3 个节点。 </li>
<li>在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集 群模式 </li>
</ul>
</li>
<li>还有主备模式，远程模式，多活模式等，可自行查阅资料了解</li>
</ul>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>前置条件：准备两台linux，并安装好rabbitmq</p>
<p>1.修改 /etc/hosts 映射文件</p>
<ul>
<li><p>1号服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 A localhost localhost.localdomain localhost4</span><br><span class="line">localhost4.localdomain4</span><br><span class="line">::1 A localhost localhost.localdomain localhost6</span><br><span class="line">localhost6.localdomain6</span><br><span class="line">192.168.204.141 A</span><br><span class="line">192.168.204.142 B</span><br></pre></td></tr></table></figure></li>
<li><p>2号服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 B localhost localhost.localdomain localhost4</span><br><span class="line">localhost4.localdomain4</span><br><span class="line">::1 B localhost localhost.localdomain localhost6</span><br><span class="line">localhost6.localdomain6</span><br><span class="line">192.168.204.141 A</span><br><span class="line">192.168.204.142 B</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.相互通信，cookie必须保持一致，同步 rabbitmq的cookie 文件：跨服务器拷贝 .erlang.cookie （隐藏文件，使用 ls -all 显示）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie  192.168.204.142:&#x2F;var&#x2F;lib&#x2F;rabbitmq</span><br></pre></td></tr></table></figure>
<p>​    修改cookie文件，要重启服务器，reboot</p>
<p>3.启动rabbitmq服务</p>
<p>​    注意防火墙要对外开发端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>4.加入集群节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@B ~]# rabbitmqctl stop_app</span><br><span class="line">[root@B ~]# rabbitmqctl join_cluster rabbit@A</span><br><span class="line">[root@B ~]# rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
<p>5.查看节点状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@B ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<p>6.查看管理端</p>
<ul>
<li><p>搭建集群结构之后，之前创建的交换机、队列、用户都属于单一结构，在新的集群环境中是 不能用的 </p>
</li>
<li><p>所以在新的集群中重新手动添加用户即可（任意节点添加，所有节点共享）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A ~]# rabbitmqctl add_user hui 123123</span><br><span class="line">[root@A ~]# rabbitmqctl set_user_tags laosun administrator</span><br><span class="line">[root@A ~]# rabbitmqctl set_permissions -p &quot;&#x2F;&quot; laosun &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>
<p>注意：当节点脱离集群还原成单一结构后，交换机，队列和用户等数据 都会重新回来</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/hQCZ1P"><img src="https://z3.ax1x.com/2021/08/27/hQCZ1P.png" alt="hQCZ1P.png"></a></p>
<p>此时，集群搭建完毕，但是默认采用的模式“普通模式”，可靠性不高</p>
<h2 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h2><p>将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态一致</p>
<p><strong>语法</strong>：set_policy {name} {pattern} {definition}</p>
<ul>
<li><p>name：策略名，可自定义 </p>
</li>
<li><p>pattern：队列的匹配模式（正则表达式） </p>
<ul>
<li>“^” 可以使用正则表达式，比如”^queue_” 表示对队列名称以“queue_”开头的所有 队列进行镜像，而”^”表示匹配所有的队列</li>
</ul>
</li>
<li><p>definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</p>
<ul>
<li><p>ha-mode：（High Available，高可用）模式，指明镜像队列的模式，有效值为 all/exactly/nodes，当前策略模式为 all，即复制到所有节点，包含新增节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all：表示在集群中所有的节点上进行镜像</span><br><span class="line">exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br></pre></td></tr></table></figure></li>
<li><p>ha-params：ha-mode模式需要用到的参数 </p>
</li>
<li><p>ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A ~]# rabbitmqctl set_policy xall &quot;^&quot; &#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>
<p><strong>也可通过管理端设置镜像策略</strong></p>
<p><a href="https://imgtu.com/i/hQP9g0"><img src="https://z3.ax1x.com/2021/08/27/hQP9g0.png" alt="hQP9g0.png"></a></p>
<h2 id="HAProxy实现镜像队列的负载均衡"><a href="#HAProxy实现镜像队列的负载均衡" class="headerlink" title="HAProxy实现镜像队列的负载均衡"></a>HAProxy实现镜像队列的负载均衡</h2><p>在程序中访问A服务器，可以实现消息的同步，虽然在同步，但都是A服务器在接收消 息，A太累 。是否可以像Nginx一样，做负载均衡，A和B轮流接收消息，再镜像同步</p>
<h3 id="HAProxy简介"><a href="#HAProxy简介" class="headerlink" title="HAProxy简介"></a>HAProxy简介</h3><ul>
<li>HA（High Available，高可用），Proxy（代理） </li>
<li>HAProxy是一款提供高可用性，负载均衡，并且基于TCP和HTTP应用的代理软件 </li>
<li>HAProxy完全免费 </li>
<li>HAProxy可以支持数以万计的并发连接 </li>
<li>HAProxy可以简单又安全的整合进架构中，同时还保护web服务器不被暴露到网络上</li>
</ul>
<p><a href="https://imgtu.com/i/hQiQWn"><img src="https://z3.ax1x.com/2021/08/27/hQiQWn.png" alt="hQiQWn.png"></a></p>
<h3 id="HAProxy与Nginx"><a href="#HAProxy与Nginx" class="headerlink" title="HAProxy与Nginx"></a>HAProxy与Nginx</h3><p><strong>OSI</strong>  （Open System Interconnection：开放式系统互联 是把网络通信的工作分为7层,分别是物理 层,数据链路层,网络层,传输层,会话层,表示层和应用层）</p>
<p><strong>Nginx的优点</strong></p>
<ul>
<li>工作在OSI第7层，可以针对http应用做一些分流的策略 </li>
<li>Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，屹立至今的绝对优势 </li>
<li>Nginx安装和配置比较简单，测试起来比较方便； </li>
<li>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务 器</li>
</ul>
<p><strong>HAProxy的优点</strong></p>
<ul>
<li>工作在网络4层和7层，支持TCP与Http协议， 它仅仅就只是一款<strong>负载均衡软件</strong></li>
<li>单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的 </li>
<li>支持8种负载均衡策略 ，支持心跳检测</li>
</ul>
<p><strong>比较</strong></p>
<ul>
<li>性能上HA胜，功能性和便利性上Nginx胜 </li>
<li>对于Http协议，Haproxy处理效率比Nginx高。所以，没有特殊要求的时候或者一般场景，建议使 用Haproxy来做Http协议负载 </li>
<li>但如果是Web应用，那么建议使用Nginx</li>
</ul>
<h3 id="安装与配置HAProxy"><a href="#安装与配置HAProxy" class="headerlink" title="安装与配置HAProxy"></a>安装与配置HAProxy</h3><p>HAProxy下载：<a href="http://www.haproxy.org/download/1.8/src/haproxy-1.8.12.tar.gz">http://www.haproxy.org/download/1.8/src/haproxy-1.8.12.tar.gz</a></p>
<ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# tar -zxvf haproxy-1.8.12.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>make时需要使用 TARGET 指定内核及版本,如</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# uname -r</span><br><span class="line">3.10.0-514.6.2.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>​    根据内核版本选择编译参数：</p>
<p><a href="https://imgtu.com/i/hQkRxI"><img src="https://z3.ax1x.com/2021/08/27/hQkRxI.png" alt="hQkRxI.png"></a></p>
<ul>
<li>进入目录，编译和安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cd haproxy-1.8.12</span><br><span class="line">[root@localhost haproxy-1.8.12]# make TARGET=linux2628</span><br><span class="line">PREFIX=/usr/local/haproxy</span><br><span class="line">[root@localhost haproxy-1.8.12]# make install PREFIX=/usr/local/haproxy</span><br></pre></td></tr></table></figure>
<ul>
<li>安装成功后，查看版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost haproxy-1.8.12]# /usr/local/haproxy/sbin/haproxy -v</span><br></pre></td></tr></table></figure>
<ul>
<li>配置启动文件，复制haproxy文件到/usr/sbin下 ，复制haproxy脚本，到/etc/init.d下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost haproxy-1.8.12]# cp /usr/local/haproxy/sbin/haproxy /usr/sbin/</span><br><span class="line">[root@localhost haproxy-1.8.12]# cp ./examples/haproxy.init /etc/init.d/haproxy</span><br><span class="line">[root@localhost haproxy-1.8.12]# chmod 755 /etc/init.d/haproxy</span><br></pre></td></tr></table></figure>
<ul>
<li>创建系统账号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost haproxy-1.8.12]# useradd -r haproxy</span><br></pre></td></tr></table></figure>
<ul>
<li>haproxy.cfg 配置文件需要自行创建</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost haproxy-1.8.12]# mkdir /etc/haproxy</span><br><span class="line">[root@localhost haproxy-1.8.12]# vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>
<ul>
<li>添加配置信息到haproxy.cfg</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">全局配置</span></span><br><span class="line">global</span><br><span class="line">    #设置日志</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    #当前工作目录</span><br><span class="line">    chroot /usr/local/haproxy</span><br><span class="line">    #用户与用户组</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    #运行进程ID</span><br><span class="line">    uid 99</span><br><span class="line">    gid 99</span><br><span class="line">    #守护进程启动</span><br><span class="line">    daemon</span><br><span class="line">    #最大连接数</span><br><span class="line">    maxconn 4096</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">默认配置</span></span><br><span class="line">defaults</span><br><span class="line">    #应用全局的日志配置</span><br><span class="line">    log global</span><br><span class="line">    #默认的模式mode &#123;tcp|http|health&#125;，TCP是4层，HTTP是7层，health只返回OK</span><br><span class="line">    mode tcp</span><br><span class="line">    #日志类别tcplog</span><br><span class="line">    option tcplog</span><br><span class="line">    #不记录健康检查日志信息</span><br><span class="line">    option dontlognull</span><br><span class="line">    #3次失败则认为服务不可用</span><br><span class="line">    retries 3</span><br><span class="line">    #每个进程可用的最大连接数</span><br><span class="line">    maxconn 2000</span><br><span class="line">    #连接超时</span><br><span class="line">    timeout connect 5s</span><br><span class="line">    #客户端超时30秒，ha就会发起重新连接</span><br><span class="line">    timeout client 30s</span><br><span class="line">    #服务端超时15秒，ha就会发起重新连接</span><br><span class="line">    timeout server 15s</span><br><span class="line"><span class="meta">#</span><span class="bash">绑定配置</span></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">    bind 192.168.204.143:5672</span><br><span class="line">    #配置TCP模式</span><br><span class="line">    mode tcp</span><br><span class="line">    #简单的轮询</span><br><span class="line">    balance roundrobin</span><br><span class="line">    #RabbitMQ集群节点配置，每隔5秒对mq集群做检查，2次正确证明服务可用，3次失败证明服务不可用</span><br><span class="line">    server A 192.168.204.141:5672 check inter 5000 rise 2 fall 3</span><br><span class="line">    server B 192.168.204.142:5672 check inter 5000 rise 2 fall 3</span><br><span class="line"><span class="meta">#</span><span class="bash">haproxy监控页面地址</span></span><br><span class="line">listen monitor</span><br><span class="line">    bind 192.168.204.143:8100</span><br><span class="line">    mode http</span><br><span class="line">    option httplog</span><br><span class="line">    stats enable</span><br><span class="line">    # 监控页面地址 http://192.168.204.143:8100/monitor</span><br><span class="line">    stats uri /monitor</span><br><span class="line">    stats refresh 5s</span><br></pre></td></tr></table></figure>
<ul>
<li>启动HAProxy</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service haproxy start</span><br></pre></td></tr></table></figure>
<ul>
<li>访问监控中心：<a href="http://192.168.204.143:8100/monitor">http://192.168.204.143:8100/monitor</a>  (记得开放8100端口)</li>
</ul>
<p><a href="https://imgtu.com/i/hQE3h4"><img src="https://z3.ax1x.com/2021/08/27/hQE3h4.png" alt="hQE3h4.png"></a></p>
<p>项目发消息，只需要将服务器地址修改为143即可，其余不变;所有的请求都会交给HAProxy，其负载均衡给每个rabbitmq服务器</p>
<h2 id="KeepAlived搭建高可用的HAProxy集群"><a href="#KeepAlived搭建高可用的HAProxy集群" class="headerlink" title="KeepAlived搭建高可用的HAProxy集群"></a>KeepAlived搭建高可用的HAProxy集群</h2><p>如果HAProxy服务器宕机，rabbitmq服务器就不可用了。所以我们需 要对HAProxy也要做高可用的集群</p>
<h3 id="KeepAlived概念"><a href="#KeepAlived概念" class="headerlink" title="KeepAlived概念"></a>KeepAlived概念</h3><ul>
<li>Keepalived是Linux下一个轻量级别的高可用热备解决方案 </li>
<li>Keepalived的作用是检测服务器的状态，它根据TCP/IP参考模型的第三、第四层、第五层交换机 制检测每个服务节点的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测 到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作 正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉， <strong>需要人工做的只是修复故障的服务器</strong>。 </li>
<li>keepalived基于vrrp（Virtual Router Redundancy Protocol，虚拟路由冗余协议）协议，vrrp它 是一种主备（主机和备用机）模式的协议，通过VRRP可以在网络发生故障时透明的进行设备切换 而不影响主机之间的数据通信 </li>
<li>两台主机之间生成一个虚拟的ip，我们称漂移ip，漂移ip由主服务器承担，一但主服务器宕机，备 份服务器就会抢夺漂移ip，继续工作，有效的解决了群集中的单点故障 </li>
<li>说白了，将多台路由器设备虚拟成一个设备，对外提供统一ip（VIP）</li>
</ul>
<p><a href="https://imgtu.com/i/hQVyIU"><img src="https://z3.ax1x.com/2021/08/27/hQVyIU.png" alt="hQVyIU.png"></a></p>
<h3 id="安装KeepAlived"><a href="#安装KeepAlived" class="headerlink" title="安装KeepAlived"></a>安装KeepAlived</h3><ul>
<li>修改hosts文件的地址映射</li>
</ul>
<table>
<thead>
<tr>
<th>ip</th>
<th>用途</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.204.143</td>
<td>KeepAlived HAProxy</td>
<td>C</td>
</tr>
<tr>
<td>192.168.204.144</td>
<td>KeepAlived HAProxy</td>
<td>D</td>
</tr>
</tbody></table>
<ul>
<li>安装 keepalived</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C ~]# yum install -y keepalived</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件（内容大改，不如删掉，重新创建）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C ~]# rm -rf /etc/keepalived/keepalived.conf</span><br><span class="line">[root@C ~]# vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">	router_id C <span class="comment">## 非常重要，标识本机的hostname</span></span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_haproxy&#123;</span><br><span class="line">    script <span class="string">&quot;/etc/keepalived/haproxy_check.sh&quot;</span> <span class="comment">## 执行的脚本位置</span></span><br><span class="line">    interval 2 <span class="comment">## 检测时间间隔</span></span><br><span class="line">    weight -20 <span class="comment">## 如果条件成立则权重减20</span></span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER <span class="comment">## 非常重要，标识主机，备用机143改为 BACKUP</span></span><br><span class="line">    interface ens33 <span class="comment">## 非常重要，网卡名（ifconfig查看）</span></span><br><span class="line">    virtual_router_id 66 <span class="comment">## 非常重要，自定义，虚拟路由ID号（主备节点要相同）</span></span><br><span class="line">    priority 100 <span class="comment">## 优先级（0-254），一般主机的大于备机</span></span><br><span class="line">    advert_int 1 <span class="comment">## 主备信息发送间隔，两个节点必须一致，默认1秒</span></span><br><span class="line">    authentication &#123; <span class="comment">## 认证匹配，设置认证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信</span></span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">    	chk_haproxy <span class="comment">## 检查haproxy健康状况的脚本</span></span><br><span class="line">	&#125;</span><br><span class="line">    virtual_ipaddress &#123; <span class="comment">## 简称“VIP”</span></span><br><span class="line">    	192.168.204.66/24 <span class="comment">## 非常重要，虚拟ip，可以指定多个，以后连接mq就用这个虚拟ip</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.204.66 5672 &#123; <span class="comment">## 虚拟ip的详细配置</span></span><br><span class="line">    delay_loop 6 <span class="comment"># 健康检查间隔，单位为秒</span></span><br><span class="line">    lb_algo rr <span class="comment"># lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh</span></span><br><span class="line">    lb_kind NAT <span class="comment"># 负载均衡转发规则。一般包括DR,NAT,TUN 3种</span></span><br><span class="line">    protocol TCP <span class="comment"># 转发协议，有TCP和UDP两种，一般用TCP</span></span><br><span class="line">    real_server 192.168.204.143 5672 &#123; <span class="comment">## 本机的真实ip</span></span><br><span class="line">   		weight 1 <span class="comment"># 默认为1,0为失效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建执行脚本 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">COUNT=`ps -C haproxy --no-header |wc -l`</span><br><span class="line">if [ $COUNT -eq 0 ];then</span><br><span class="line">    /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then</span><br><span class="line">    	killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>在 Keepalived 主机上，开启此脚本检测 HAproxy 是否正常工作 : </p>
<ul>
<li>如正常工作，记录日志。 </li>
<li>如进程不存在，则尝试重启 HAproxy ，2秒后检测，如果还没有，则关掉主 Keepalived ，此时备 Keepalived 检测到主 Keepalived 挂掉，接管VIP，继续服务</li>
</ul>
</li>
<li><p>授权，否则不能执行</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C etc]# chmod +x /etc/keepalived/haproxy_check.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>启动keepalived（两台都启动）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C etc]# systemctl stop firewalld</span><br><span class="line">[root@C etc]# service keepalived start | stop | status | restart</span><br></pre></td></tr></table></figure>
<ul>
<li>查看状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C etc]# ps -ef | grep haproxy</span><br><span class="line">[root@C etc]# ps -ef | grep keepalived</span><br></pre></td></tr></table></figure>
<ul>
<li>查看ip情况 ip addr 或 ip a</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@C etc]# ip a</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/hQnSdx"><img src="https://z3.ax1x.com/2021/08/27/hQnSdx.png" alt="hQnSdx.png"></a></p>
<p>此时，安装完毕，按照上面的步骤就可以安装第二台了（服务器hostname和ip注意要修改）</p>
<p>常见的网络错误：子网掩码、网关等信息要一致</p>
<p><a href="https://imgtu.com/i/hQnnTP"><img src="https://z3.ax1x.com/2021/08/27/hQnnTP.png" alt="hQnnTP.png"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>查看虚拟ip ip addr 或 ip a </li>
<li>目前，C节点是主机，所以虚拟ip在C节点</li>
</ul>
<p><a href="https://imgtu.com/i/hQuG9O"><img src="https://z3.ax1x.com/2021/08/27/hQuG9O.png" alt="hQuG9O.png"></a></p>
<ul>
<li><p>停止C的keepalived，虚拟ip漂移到D节点</p>
</li>
<li><p>重新启动C节点keepalived，虚拟ip依旧在D节点，并不会由于C的回归而回归</p>
</li>
<li><p>停止D的keepalived，虚拟ip再漂移回C节点</p>
</li>
<li><p>测试vip+端口是否提供服务（在141，A服务器上测试）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@A ~]# curl 192.168.204.66:5672</span><br><span class="line">AMQP ## 正常提供AMQP服务，表示通过vip访问mq服务正常</span><br></pre></td></tr></table></figure>
<p>在项目中访问的IP改为 192.168.204.66 即可</p>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>WeChat登入与付款</title>
    <url>/2021/09/07/WeChat%E7%99%BB%E5%85%A5%E4%B8%8E%E4%BB%98%E6%AC%BE/</url>
    <content><![CDATA[<p>微信开放平台（针对开发者和公司），官网有更详细的介绍。</p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p>
<p><strong>前提</strong>：在微信开放平台注册开发者帐号，并拥有一个已审核通 过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流 程。<a id="more"></a></p>
<h1 id="微信扫码登入"><a href="#微信扫码登入" class="headerlink" title="微信扫码登入"></a>微信扫码登入</h1><p><strong>OAuth2.0协议</strong></p>
<p>OAuth(Open Authorization)协议就是为用户资源的授权提供了一个安全、开放、简易的标准。 OAuth在第三方应用与服务提供商之间设置了一个授权层，第三方应用通过授权层获取令牌，再 通过令牌获取信息。</p>
<p><strong>OAuth的四种授权模式</strong></p>
<ul>
<li>授权码模式（功能最完整、流程最严密的授权模式）</li>
<li>密码模式 </li>
<li>简化模式 </li>
<li>客户端模式 </li>
</ul>
<p><strong>四个基本参数</strong></p>
<ul>
<li>AppID    应用ID，唯一标识（身份证号） </li>
<li>AppSecret    应用的密钥（密码） </li>
<li>code    授权的临时凭证（例如：临时身份证） </li>
<li>access_token 接口调用凭证（例如：真正的身份证，虎符，令牌）</li>
</ul>
<p><strong>登录授权时序图</strong></p>
<p><a href="https://imgtu.com/i/hTe81K"><img src="https://z3.ax1x.com/2021/09/07/hTe81K.png" alt="hTe81K.png"></a></p>
<h2 id="Vue项目引入vue-wxlogin"><a href="#Vue项目引入vue-wxlogin" class="headerlink" title="Vue项目引入vue-wxlogin"></a>Vue项目引入vue-wxlogin</h2><p><strong>安装vue-wxlogin</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-wxlogin</span><br></pre></td></tr></table></figure>
<p>如果不是vue的项目，可以直接引用官方提供的js文件，来生成二维码</p>
<p>官方js：<a href="http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js">http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js</a> </p>
<p><strong>template代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 登录框 开始--&gt;</span><br><span class="line">   &lt;el-dialog</span><br><span class="line">     style&#x3D;&quot;width:800px;margin:0px auto;&quot;</span><br><span class="line">     title&#x3D;&quot;&quot;</span><br><span class="line">     :visible.sync&#x3D;&quot;dialogFormVisible&quot;</span><br><span class="line">     &gt;</span><br><span class="line">     &lt;div id&#x3D;&quot;loginForm&quot;&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;!-- 普通登入表单,略 --&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line">       &lt;!-- 微信登录图标 --&gt;</span><br><span class="line">       &lt;img</span><br><span class="line">         @click&#x3D;&quot;goToLoginWX&quot;</span><br><span class="line">         src&#x3D;&quot;http:&#x2F;&#x2F;www.lgstatic.com&#x2F;lg-passport-fed&#x2F;static&#x2F;pc&#x2F;modules&#x2F;common&#x2F;img&#x2F;icon-wechat@2x_68c86d1.png&quot;</span><br><span class="line">         alt&#x3D;&quot;&quot;</span><br><span class="line">       &#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">     &lt;!-- 二维码 --&gt;</span><br><span class="line">     &lt;wxlogin id&#x3D;&quot;wxLoginForm&quot; style&#x3D;&quot;display:none&quot;</span><br><span class="line">         :appid&#x3D;&quot;appid&quot; :scope&#x3D;&quot;scope&quot; :redirect_uri&#x3D;&quot;redirect_uri&quot;&gt;</span><br><span class="line">     &lt;&#x2F;wxlogin&gt;</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;el-dialog&gt;</span><br><span class="line">   &lt;!-- 登录框 结束--&gt;</span><br></pre></td></tr></table></figure>
<p><strong>js代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import wxlogin from &#39;vue-wxlogin&#39;; &#x2F;&#x2F; 引入</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Header&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    wxlogin &#x2F;&#x2F; 声明</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      appid:&quot;wxd99431bbff8305a0&quot;, &#x2F;&#x2F; 应用唯一标识，在微信开放平台提交应用审核通过后获得</span><br><span class="line">      scope:&quot;snsapi_login&quot;, &#x2F;&#x2F; 应用授权作用域，网页应用目前仅填写snsapi_login即可</span><br><span class="line">      redirect_uri:&quot;http:&#x2F;&#x2F;www.pinzhi365.com&#x2F;wx&#x2F;wxlogin&quot;, &#x2F;&#x2F;重定向地址，(回调地址)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 打开微信登入二维码</span><br><span class="line">    goToLoginWX() &#123;</span><br><span class="line">      &#x2F;&#x2F; 隐藏原来的登入表单</span><br><span class="line">      document.getElementById(&quot;loginForm&quot;).style.display&#x3D;&quot;none&quot;</span><br><span class="line">      &#x2F;&#x2F; 显示微信二维码</span><br><span class="line">      document.getElementById(&quot;wxLoginForm&quot;).style.display&#x3D;&quot;block&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>修改hosts文件</strong></p>
<p>因为是开发测试，<a href="http://www.pinzhi365.com是一个没用的网址,所以我们映射到本地即可./">www.pinzhi365.com是一个没用的网址，所以我们映射到本地即可。</a></p>
<p>文件位置：C:\Windows\System32\drivers\etc\hosts ；回调默认指定的是80端口，别忘记将tomcat的端口修改成80</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 www.pinzhi365.com</span><br></pre></td></tr></table></figure>
<h2 id="后端项目"><a href="#后端项目" class="headerlink" title="后端项目"></a>后端项目</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要使用HttpServletRequest获得参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要使用HttpClient发出请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="封装HttpClient"><a href="#封装HttpClient" class="headerlink" title="封装HttpClient"></a>封装HttpClient</h3><p>我们需要在java代码里请求微信官网来获取数据，我们可以自定义编写一个工具类，来发送请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行get请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建httpclient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建uri</span></span><br><span class="line">            URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">            <span class="comment">// 添加参数</span></span><br><span class="line">            <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : params.keySet()) &#123;</span><br><span class="line">                    builder.addParameter(key, params.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            URI uri = builder.build();</span><br><span class="line">            <span class="comment">// 创建http get请求</span></span><br><span class="line">            HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">            <span class="comment">// 执行请求,返回响应</span></span><br><span class="line">            response = httpClient.execute(httpGet);</span><br><span class="line">            <span class="keyword">int</span> statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line">            <span class="comment">// 状态码为200 表示成功</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// 响应的内容字符串</span></span><br><span class="line">                res = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (httpClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    httpClient.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义实体类"><a href="#定义实体类" class="headerlink" title="定义实体类"></a>定义实体类</h3><p>因为微信返回的数据是一个JSON字符串对象，我们获取字符串中的数据很麻烦，不如将他们封装从实体类；</p>
<p>这里的实体类定义是根据官网的提示编写的</p>
<p><strong>Token实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String access_token;    <span class="comment">//	接口调用凭证</span></span><br><span class="line">    <span class="keyword">private</span> String expires_in;      <span class="comment">//access_token 接口调用凭证超时时间，单位（秒）</span></span><br><span class="line">    <span class="keyword">private</span> String refresh_token;   <span class="comment">//	用户刷新 access_token</span></span><br><span class="line">    <span class="keyword">private</span> String openid;          <span class="comment">//	授权用户唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String scope;           <span class="comment">//	用户授权的作用域，使用逗号（,）分隔</span></span><br><span class="line">    <span class="keyword">private</span> String unionid;         <span class="comment">//	当且仅当该移动应用已获得该用户的 userinfo 授权时，才会出现该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WeChatUser实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String openid;      <span class="comment">//	普通用户的标识，对当前开发者帐号唯一</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;    <span class="comment">//	普通用户昵称</span></span><br><span class="line">    <span class="keyword">private</span> String sex;         <span class="comment">//	普通用户性别，1 为男性，2 为女性</span></span><br><span class="line">    <span class="keyword">private</span> String province;    <span class="comment">//	普通用户个人资料填写的省份</span></span><br><span class="line">    <span class="keyword">private</span> String city;        <span class="comment">//  普通用户个人资料填写的城市</span></span><br><span class="line">    <span class="keyword">private</span> String country;     <span class="comment">//	国家，如中国为 CN</span></span><br><span class="line">    <span class="keyword">private</span> String headimgurl;  <span class="comment">//	用户头像，最后一个数值代表正方形头像大小（有 0、46、64、96、132 数值可选，0 代表 640*640 正方形头像），用户没有头像时该项为空</span></span><br><span class="line">    <span class="keyword">private</span> String privilege;   <span class="comment">//  用户特权信息，json 数组，如微信沃卡用户为（chinaunicom）</span></span><br><span class="line">    <span class="keyword">private</span> String unionid;     <span class="comment">//	用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的 unionid 是唯一的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a>Controller代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;wx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信登入</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;wxlogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wxLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取code</span></span><br><span class="line">        String code = request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过code去官网申请令牌  token</span></span><br><span class="line">        <span class="comment">// https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span></span><br><span class="line">        String getTokenByCodeUrl = <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;appid&quot;</span>, <span class="string">&quot;wxd99431bbff8305a0&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;secret&quot;</span>, <span class="string">&quot;60f78681d063590a469f1b297feff3c4&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        params.put(<span class="string">&quot;grant_type&quot;</span>, <span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">        String tokenString = HttpClientUtil.doGet(getTokenByCodeUrl, params);</span><br><span class="line">        <span class="comment">// 将token字符串封装成实体类</span></span><br><span class="line">        Token token = JSON.parseObject(tokenString, Token.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通过access_token与openid获取获取微信用户个人信息</span></span><br><span class="line">        <span class="comment">// https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID</span></span><br><span class="line">        String getUserInfoByTokenURL = <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo&quot;</span>;</span><br><span class="line">        String userInfo = HttpClientUtil.doGet(getUserInfoByTokenURL + <span class="string">&quot;?access_token=&quot;</span> + token.getAccess_token() + <span class="string">&quot;&amp;openid=&quot;</span> + token.getOpenid());</span><br><span class="line">        <span class="comment">// 将用户信息字符串转换成实体类</span></span><br><span class="line">        WeChatUser weChatUser = JSON.parseObject(userInfo, WeChatUser.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ===== 获取了用户信息后，执行我们的流程业务 ========</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后续业务流程"><a href="#后续业务流程" class="headerlink" title="后续业务流程"></a>后续业务流程</h2><p><strong>controller代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;wx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 业务层</span></span><br><span class="line">    <span class="comment">// 当前用户微信登入的数据</span></span><br><span class="line">    <span class="keyword">private</span> UserDTO userDTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信登入</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;wxlogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wxLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       	<span class="comment">// ======= 获取到了用户数据 weChatUser =======</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ===== 执行流程业务 ========</span></span><br><span class="line">        String wxId = weChatUser.getOpenid(); <span class="comment">// 微信唯一Id</span></span><br><span class="line">        String nickName = weChatUser.getNickname();  <span class="comment">// 微信昵称</span></span><br><span class="line">        String headImgUrl = weChatUser.getHeadimgurl(); <span class="comment">// 微信头像地址</span></span><br><span class="line">        <span class="comment">// 判断微信号是否注册过来</span></span><br><span class="line">        Integer exist = userService.UserExist(wxId);</span><br><span class="line">        <span class="comment">// 没注册，就立即注册</span></span><br><span class="line">        <span class="keyword">if</span> (exist == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Openid 作为用户号和密码</span></span><br><span class="line">            Integer flag = userService.registry(wxId, wxId + <span class="string">&quot;hui&quot;</span>, nickName, headImgUrl);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                User newUser = userService.login(wxId, wxId + <span class="string">&quot;hui&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.userDTO = <span class="keyword">new</span> UserDTO(<span class="number">200</span>, <span class="string">&quot;该微信号已自动注册！&quot;</span>, newUser);</span><br><span class="line"><span class="comment">//                this.map.put(remoteAddr, new UserDTO(200, &quot;该微信号已自动注册！&quot;, newUser));</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.userDTO = <span class="keyword">new</span> UserDTO(<span class="number">300</span>, <span class="string">&quot;注册失败，请重试！！！&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//                this.map.put(remoteAddr, new UserDTO(300, &quot;注册失败，请重试！！！&quot;, null));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注册过了，走登入</span></span><br><span class="line">            User user = userService.login(wxId, wxId + <span class="string">&quot;hui&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.userDTO = <span class="keyword">new</span> UserDTO(<span class="number">300</span>, <span class="string">&quot;登入失败&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//                this.map.put(remoteAddr, new UserDTO(300, &quot;登入失败&quot;, null));</span></span><br><span class="line">            <span class="keyword">this</span>.userDTO = <span class="keyword">new</span> UserDTO(<span class="number">200</span>, <span class="string">&quot;登入成功&quot;</span>, user);</span><br><span class="line"><span class="comment">//            this.map.put(remoteAddr, new UserDTO(200, &quot;登入成功&quot;, user));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重定向到前端页面,因为这里是微信官网发过来的请求，不能像之前的ajax一样返回String</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前微信登入用户的数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;wxStatus&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDTO <span class="title">wxStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;logout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDTO = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vue代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改  </span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 获取本地用户数据</span></span><br><span class="line">    <span class="built_in">this</span>.userDTO = <span class="built_in">JSON</span>.parse( <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>) )</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.userDTO!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.isLogin=<span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 如果本地没数据，就查看微信是否登入</span></span><br><span class="line">      <span class="built_in">this</span>.axios.get(<span class="string">&quot;http://localhost:80/wx/wxStatus&quot;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 如果微信已登入</span></span><br><span class="line">        <span class="keyword">if</span>(res &amp;&amp; res.data.content)&#123;</span><br><span class="line">           <span class="comment">// 更新手机号与密码</span></span><br><span class="line">            <span class="built_in">this</span>.phone = res.data.content.phone</span><br><span class="line">            <span class="built_in">this</span>.password = res.data.content.password</span><br><span class="line">            <span class="comment">// 重新走一遍登入流程</span></span><br><span class="line">            <span class="built_in">this</span>.login()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&quot;登入失败。。&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    <span class="function"><span class="title">logout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 清空本地数据</span></span><br><span class="line">        <span class="built_in">this</span>.isLogin = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">this</span>.userDTO = <span class="literal">null</span></span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;user&quot;</span>,<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 清空服务器微信登入状态</span></span><br><span class="line">        <span class="built_in">this</span>.axios.get(<span class="string">&quot;http://localhost:80/wx/logout&quot;</span>)</span><br><span class="line">        <span class="comment">// 跳转到首页</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span> &#125;)</span><br><span class="line">        location.reload()</span><br><span class="line">        <span class="built_in">this</span>.$message.success(<span class="string">&quot;退出成功，bye。。。&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解决二维码在谷歌浏览器的bug"><a href="#解决二维码在谷歌浏览器的bug" class="headerlink" title="解决二维码在谷歌浏览器的bug"></a>解决二维码在谷歌浏览器的bug</h2><p>谷歌浏览器调试的时候，iframe标签跨域问题导致无法跳转的bug 。如果iframe未添加sandbox属性，或者sandbox属性不赋值，就代表采用默认的安全策略 ，即：iframe的页面将会被当做一个独立的源，并且不能提交表单，不能执行javascript脚本，也不 能让包含iframe的父页面导航到其他地方，所有的插件，如flash等也全部不能起作用 简单来说iframe就只剩下一个展示数据的功能，正如他的名字一样，所有的内容都被放进了一个 “单独的沙盒”</p>
<p><strong>sandbox包含的属性及作用</strong></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>allow-scripts</td>
<td>允许运行执行脚本</td>
</tr>
<tr>
<td>allow-top-navigation</td>
<td>允许iframe能够主导window.top进行页面跳转</td>
</tr>
<tr>
<td>allow-same-origin</td>
<td>允许同域请求,比如ajax,storage</td>
</tr>
<tr>
<td>allow-forms</td>
<td>允许进行提交表单</td>
</tr>
<tr>
<td>allow-popups</td>
<td>允许iframe中弹出新窗口,比如,window.open,target=”_blank”</td>
</tr>
<tr>
<td>allow-pointer-lock</td>
<td>在iframe中可以锁定鼠标，主要和鼠标锁定有关</td>
</tr>
</tbody></table>
<p>我们需要加上 sandbox=“allow-scripts allow-top-navigation allow-same-origin” 属性，即可解决 。</p>
<p>官方js：<a href="http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js">http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js</a> </p>
<p>可是无法修改微信服务器上的js文件，所以我们将js代码放在本地并进行修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    !(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">            a.self_redirect === !<span class="number">0</span></span><br><span class="line">                ? (c = <span class="string">&quot;true&quot;</span>)</span><br><span class="line">            : a.self_redirect === !<span class="number">1</span> &amp;&amp; (c = <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> d = b.createElement(<span class="string">&quot;iframe&quot;</span>),</span><br><span class="line">                e =</span><br><span class="line">                <span class="string">&quot;https://open.weixin.qq.com/connect/qrconnect?appid=&quot;</span> +</span><br><span class="line">                a.appid +</span><br><span class="line">                <span class="string">&quot;&amp;scope=&quot;</span> +</span><br><span class="line">                a.scope +</span><br><span class="line">                <span class="string">&quot;&amp;redirect_uri=&quot;</span> +</span><br><span class="line">                a.redirect_uri +</span><br><span class="line">                <span class="string">&quot;&amp;state=&quot;</span> +</span><br><span class="line">                a.state +</span><br><span class="line">                <span class="string">&quot;&amp;login_type=jssdk&amp;self_redirect=&quot;</span> +</span><br><span class="line">                c +</span><br><span class="line">                <span class="string">&quot;&amp;styletype=&quot;</span> +</span><br><span class="line">                (a.styletype || <span class="string">&quot;&quot;</span>) +</span><br><span class="line">                <span class="string">&quot;&amp;sizetype=&quot;</span> +</span><br><span class="line">                (a.sizetype || <span class="string">&quot;&quot;</span>) +</span><br><span class="line">                <span class="string">&quot;&amp;bgcolor=&quot;</span> +</span><br><span class="line">                (a.bgcolor || <span class="string">&quot;&quot;</span>) +</span><br><span class="line">                <span class="string">&quot;&amp;rst=&quot;</span> +</span><br><span class="line">                (a.rst || <span class="string">&quot;&quot;</span>);</span><br><span class="line">            (e += a.style ? <span class="string">&quot;&amp;style=&quot;</span> + a.style : <span class="string">&quot;&quot;</span>),</span><br><span class="line">                (e += a.href ? <span class="string">&quot;&amp;href=&quot;</span> + a.href : <span class="string">&quot;&quot;</span>),</span><br><span class="line">                (d.src = e),</span><br><span class="line">                (d.frameBorder = <span class="string">&quot;0&quot;</span>),</span><br><span class="line">                (d.allowTransparency = <span class="string">&quot;true&quot;</span>),</span><br><span class="line">                 <span class="comment">// 修改了这里,允许多种请求</span></span><br><span class="line">                (d.sandbox = <span class="string">&quot;allow-scripts allow-top-navigation allow-same-origin&quot;</span>),</span><br><span class="line">                (d.scrolling = <span class="string">&quot;no&quot;</span>),</span><br><span class="line">                (d.width = <span class="string">&quot;300px&quot;</span>),</span><br><span class="line">                (d.height = <span class="string">&quot;400px&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> f = b.getElementById(a.id);</span><br><span class="line">            (f.innerHTML = <span class="string">&quot;&quot;</span>), f.appendChild(d);</span><br><span class="line">        &#125;</span><br><span class="line">        a.WxLogin = d;</span><br><span class="line">    &#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之前的template代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将之前的wxlogin标签删除</span><br><span class="line">&lt;div id&#x3D;&quot;wxLoginForm&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>修改js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">// 微信登录</span></span><br><span class="line">    <span class="function"><span class="title">goToLoginWX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通的登录表单隐藏</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;loginForm&quot;</span>).style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">        <span class="comment">// 显示二维码的容器</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;wxLoginForm&quot;</span>).style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">        <span class="comment">// 去生成二维码，$nextTick : 待dom更新之后再用二维码渲染其内容</span></span><br><span class="line">        <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.createCode(); <span class="comment">// 直接调用会报错：TypeError: Cannot read property &#x27;appendChild&#x27; of null</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="comment">// 生成二维码</span></span><br><span class="line">        <span class="function"><span class="title">createCode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="keyword">new</span> WxLogin(&#123;</span><br><span class="line">                id:<span class="string">&quot;wxLoginForm&quot;</span>, <span class="comment">// 显示二维码的容器</span></span><br><span class="line">                appid: <span class="string">&quot;wxd99431bbff8305a0&quot;</span>, <span class="comment">// 应用唯一标识，在微信开放平台提交应用审核通过后获得</span></span><br><span class="line">                scope: <span class="string">&quot;snsapi_login&quot;</span>, <span class="comment">// 应用授权作用域，网页应用目前仅填写snsapi_login即可</span></span><br><span class="line">                redirect_uri: <span class="string">&quot;http://www.pinzhi365.com/wxlogin&quot;</span>, <span class="comment">//重定向地址，(回调地址)</span></span><br><span class="line">                href: <span class="string">&quot;data:text/css;base64,加密后的样式&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加密后的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.impowerBox .qrcode &#123;width: 200px;&#125;</span><br><span class="line">.impowerBox .title &#123;display: none;&#125;</span><br><span class="line">.impowerBox .info &#123;width: 200px;&#125;</span><br><span class="line">.status_icon &#123;display: none&#125;cs</span><br><span class="line">.impowerBox .status &#123;text-align: center;&#125;</span><br></pre></td></tr></table></figure>
<p>我们用站长工具对样式代码进行base64加密：<a href="http://tool.chinaz.com/Tools/Base64.aspx">http://tool.chinaz.com/Tools/Base64.aspx</a></p>
<p><a href="https://imgtu.com/i/hTQh4J"><img src="https://z3.ax1x.com/2021/09/07/hTQh4J.png" alt="hTQh4J.png"></a></p>
<h1 id="微信付款"><a href="#微信付款" class="headerlink" title="微信付款"></a>微信付款</h1><p><strong>前提</strong>：在微信开放平台注册开发者帐号，并获取获取认证的流程 </p>
<ol>
<li><p>注册公众号（类型：服务号） </p>
<p>根据营业执照类型选择以下主体注册： 个体工商户 | 企业/公司 | 政府 | 媒体 | 其他类型 </p>
</li>
<li><p>认证公众号 </p>
<p>公众号认证后才申请微信支付：300元/次 </p>
</li>
<li><p>提交材料申请微信支付 </p>
<p>登录公众平台，左侧菜单【微信支付】，开始填写资料等待审核，审核时间1~5工作日 这里需要提交的资料有营业执照！ </p>
</li>
<li><p>开户成功，登录商户平台进行验证 </p>
<p>资料审核通过后，请登录联系人邮箱查收商户号和密码，并登录商户平台填写财付通备付金打的小额资 金数额，完成账户验证。 </p>
</li>
<li><p>在线签署协议 </p>
<p>本协议为线上电子协议，签署后方可进行交易及资金结算，签署完立即生效。</p>
</li>
<li><p>公众号中查看参数</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appid</td>
<td>微信公众帐号或开放平台APP的唯一标识</td>
</tr>
<tr>
<td>partner</td>
<td>商户号（配置文件中的partner：账户）</td>
</tr>
<tr>
<td>partnerkey</td>
<td>商户密钥（密码）</td>
</tr>
<tr>
<td>sign</td>
<td>数字签名，根据微信官方提供的密钥和一套算法生成的一个加密信息，就是为了保证交易安全</td>
</tr>
</tbody></table>
<p><strong>支付流程</strong></p>
<p><a href="https://imgtu.com/i/hT3OET"><img src="https://z3.ax1x.com/2021/09/07/hT3OET.png" alt="hT3OET.png"></a></p>
<h2 id="前端创建二维码"><a href="#前端创建二维码" class="headerlink" title="前端创建二维码"></a>前端创建二维码</h2><p><strong>安装 qrcodejs2</strong> （注意：安装的是qrcodejs2，不要安装qrcode —&gt; 会报错） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install qrcodejs2 --save</span><br></pre></td></tr></table></figure>
<p><strong>页面中引入并使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog :visible.sync&#x3D;&quot;dialogFormVisible&quot; style&#x3D;&quot;width:800px;margin:0px auto;&quot; &gt;</span><br><span class="line">    &lt;h1 style&#x3D;&quot;font-size:30px;color:#00B38A&quot;&gt;微信扫一扫支付&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;qrcode&quot; style&#x3D;&quot;width:210px;margin:20px auto;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import QRCode from &#39;qrcodejs2&#39;; &#x2F;&#x2F; 引入qrcodejs</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Index&quot;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            QRCode &#x2F;&#x2F; 声明组件</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                dialogFormVisible: false, &#x2F;&#x2F; 是否显示登录框，true：显示，false：隐藏</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            &#x2F;&#x2F; 购买课程</span><br><span class="line">            buy(courseid) &#123;</span><br><span class="line">               if(this.user !&#x3D; null)&#123;</span><br><span class="line">                  this.dialogFormVisible &#x3D; true; &#x2F;&#x2F;显示提示框</span><br><span class="line">                  &#x2F;&#x2F; 待dom更新之后再用二维码渲染其内容</span><br><span class="line">                  this.$nextTick(function()&#123;</span><br><span class="line">                     &#x2F;&#x2F; 直接调用会报错：TypeError: Cannot read property &#39;appendChild&#39; of null</span><br><span class="line">                     this.createCode(); </span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    this.$message.warm(&quot;请先登入，再购买。。&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F; 生成二维码</span><br><span class="line">            createCode()&#123;</span><br><span class="line">                &#x2F;&#x2F; 经课程等信息与价格发送给后台，后台会请求微信官网获取支付连接，并返回</span><br><span class="line">                this.axios.get(&quot;http:&#x2F;&#x2F;localhost:80&#x2F;order&#x2F;createCode&quot;, &#123;</span><br><span class="line">                    params: &#123;</span><br><span class="line">                        courseid: this.course.id, &#x2F;&#x2F; 课程编号</span><br><span class="line">                        courseid: this.course.courseName, &#x2F;&#x2F; 课程名称</span><br><span class="line">                        price: this.course.discounts, &#x2F;&#x2F; 优惠价，非原价</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; 生成二维码:QRCode(存放二维码的dom元素id，二维码的属性参数)</span><br><span class="line">                    let qrcode &#x3D; new QRCode(&#39;qrcode&#39;,&#123;</span><br><span class="line">                        width:200,  &#x2F;&#x2F; 二维码的宽度</span><br><span class="line">                        height:200,  &#x2F;&#x2F; 二维码的高度</span><br><span class="line">                        text:result.data.code_url &#x2F;&#x2F; 将支付连接嵌入到二维码中</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">                    this.$message.error(&quot;二维码生成失败!&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>官网：<a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=11_1">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=11_1</a></p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.wxpay<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wxpay-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>主要使用sdk中的三个功能</strong> </p>
<p>1、获取随机字符串（生成订单编号）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WXPayUtil.generateNonceStr();</span><br></pre></td></tr></table></figure>
<p>2、将map转换成xml字符串（自动添加签名） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WXPayUtil.generateSignedXml(map,partnerKey);</span><br></pre></td></tr></table></figure>
<p>3、将xml字符串转换整map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WXPayUtil.xmlToMap(result);</span><br></pre></td></tr></table></figure>
<h3 id="JFinal-框架"><a href="#JFinal-框架" class="headerlink" title="JFinal 框架"></a>JFinal 框架</h3><ul>
<li>JFinal 是基于Java 语言的极速 web 开发框架，其核心设计目标是开发迅速、代码量少、学习简 单、功能强大、轻量级、易扩展 </li>
<li>取代HttpClient，之前我们自己封装了一个HttpClient工具类，现在有JFinal，直接调用方法即可</li>
</ul>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jfinal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jfinal<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><p><strong>支付配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//企业公众号ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String appid = <span class="string">&quot;wx8397f8696b538317&quot;</span>;</span><br><span class="line">    <span class="comment">// 财付通平台的商户帐号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String partner = <span class="string">&quot;1473426802&quot;</span>;</span><br><span class="line">    <span class="comment">// 财付通平台的商户密钥</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String partnerKey = <span class="string">&quot;8A627A4578ACE384017C997F12D68B23&quot;</span>;</span><br><span class="line">    <span class="comment">// 回调URL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String notifyurl =</span><br><span class="line">        <span class="string">&quot;http://a31ef7db.ngrok.io/WeChatPay/WeChatPayNotify&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CodeController代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;createCode&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createCode</span><span class="params">(String courseid,String coursename, String price)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解决get小乱码</span></span><br><span class="line">        coursename = <span class="keyword">new</span> String(coursename.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1.编写商户信息，这里的信息查看官网，填写必须项</span></span><br><span class="line">        Map&lt;String,String&gt; mm = <span class="keyword">new</span> HashMap();</span><br><span class="line">        mm.put(<span class="string">&quot;appid&quot;</span>,PayConfig.appid); <span class="comment">//公众账号ID</span></span><br><span class="line">        mm.put(<span class="string">&quot;mch_id&quot;</span>,PayConfig.partner);<span class="comment">//商户号</span></span><br><span class="line">        mm.put(<span class="string">&quot;nonce_str&quot;</span>,WXPayUtil.generateNonceStr());<span class="comment">//随机字符串</span></span><br><span class="line">        mm.put(<span class="string">&quot;body&quot;</span>,coursename); <span class="comment">//商品名称</span></span><br><span class="line">        String orderId = WXPayUtil.generateNonceStr();  <span class="comment">// 生成订单编号</span></span><br><span class="line">        mm.put(<span class="string">&quot;out_trade_no&quot;</span>,orderId); <span class="comment">//商户订单号</span></span><br><span class="line">        mm.put(<span class="string">&quot;total_fee&quot;</span>,price+<span class="string">&quot;&quot;</span>); <span class="comment">//订单金额,单位分</span></span><br><span class="line">        mm.put(<span class="string">&quot;spbill_create_ip&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">//终端IP</span></span><br><span class="line">        mm.put(<span class="string">&quot;notify_url&quot;</span>,PayConfig.notifyurl); <span class="comment">//通知地址</span></span><br><span class="line">        mm.put(<span class="string">&quot;trade_type&quot;</span>,<span class="string">&quot;NATIVE&quot;</span>); <span class="comment">//交易类型</span></span><br><span class="line">        <span class="comment">//2.生成数字签名,并把上面的map转换成xml格式</span></span><br><span class="line">        String xml = WXPayUtil.generateSignedXml(mm,PayConfig.partnerKey);</span><br><span class="line">        <span class="comment">//3.将数据发送给微信后台,并得到微信后台返回的数据</span></span><br><span class="line">        String url = <span class="string">&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;</span>;</span><br><span class="line">        String result = HttpKit.post(url,xml);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回的xml = &quot;</span>+result); <span class="comment">//如果报错：&lt;![CDATA[签名错误]]&gt;商户四要素的原因，重置商户API密钥。</span></span><br><span class="line">        <span class="comment">//4.将微信后台的xml格式，转成map，并添加两个参数</span></span><br><span class="line">        Map&lt;String,String&gt; resultMap = WXPayUtil.xmlToMap(result);</span><br><span class="line">        resultMap.put(<span class="string">&quot;orderId&quot;</span>,orderId); <span class="comment">// 订单号</span></span><br><span class="line">        resultMap.put(<span class="string">&quot;money&quot;</span>,price+<span class="string">&quot;&quot;</span>); <span class="comment">// 价格</span></span><br><span class="line">		resultMap.put(<span class="string">&quot;out_trade_no&quot;</span>,mm.get(<span class="string">&quot;out_trade_no&quot;</span>)); <span class="comment">// 查询订单状态需要订单编号，保存在微信后台的</span></span><br><span class="line">        <span class="comment">//5.将map返回给浏览器</span></span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查支付状态"><a href="#检查支付状态" class="headerlink" title="检查支付状态"></a>检查支付状态</h2><p><strong>controller代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查支付状态</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;checkOrderStatus&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">checkOrderStatus</span><span class="params">(String orderId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.编写商户信息</span></span><br><span class="line">    Map&lt;String,String&gt; mm = <span class="keyword">new</span> HashMap();</span><br><span class="line">    mm.put(<span class="string">&quot;appid&quot;</span>,PayConfig.appid); <span class="comment">//公众账号ID</span></span><br><span class="line">    mm.put(<span class="string">&quot;mch_id&quot;</span>,PayConfig.partner);<span class="comment">//商户号</span></span><br><span class="line">    mm.put(<span class="string">&quot;out_trade_no&quot;</span>,orderId);<span class="comment">//订单编号</span></span><br><span class="line">    mm.put(<span class="string">&quot;nonce_str&quot;</span>,WXPayUtil.generateNonceStr()); <span class="comment">//随机字符串</span></span><br><span class="line">    <span class="comment">//2.生成数字签名,并把上面的map转换成xml格式</span></span><br><span class="line">    String xml = WXPayUtil.generateSignedXml(mm, PayConfig.partnerKey);</span><br><span class="line">    <span class="comment">//3.将数据发送给微信后台,并得到微信后台返回的数据</span></span><br><span class="line">    String url = <span class="string">&quot;https://api.mch.weixin.qq.com/pay/orderquery&quot;</span>;</span><br><span class="line">    <span class="comment">//第一次询问时间</span></span><br><span class="line">    <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">//不停的去微信后台询问是否支付</span></span><br><span class="line">        String result = HttpKit.post(url, xml);</span><br><span class="line">        <span class="comment">//4.微信后台返回xml格式，转成map</span></span><br><span class="line">        Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(result);</span><br><span class="line">        <span class="comment">//如果已经成功支付，停止询问</span></span><br><span class="line">        <span class="keyword">if</span>(resultMap.get(<span class="string">&quot;trade_state&quot;</span>).equalsIgnoreCase(<span class="string">&quot;success&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> resultMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超过30秒未支付，停止询问</span></span><br><span class="line">        <span class="keyword">if</span>(System.currentTimeMillis() - beginTime &gt; <span class="number">30000</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> resultMap;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">//每隔3秒，询问一次微信后台</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>前端代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 微信支付二维码--&gt;</span><br><span class="line">&lt;el-dialog :visible.sync&#x3D;&quot;dialogFormVisible&quot; style&#x3D;&quot;width:800px;margin:0px auto;&quot; &gt;</span><br><span class="line">    &lt;h1 style&#x3D;&quot;font-size:30px;color:#00B38A&quot; &gt;微信扫一扫支付&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;qrcode&quot; style&#x3D;&quot;width:210px;margin:20px auto;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 支付状态 --&gt;</span><br><span class="line">    &lt;h2 id&#x3D;&quot;statusText&quot;&gt;&lt;&#x2F;h2&gt; </span><br><span class="line">    &lt;!-- 关闭窗口小提示 --&gt;</span><br><span class="line">    &lt;p id&#x3D;&quot;timeClose&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            orderId:null,  &#x2F;&#x2F; 保存订单编号</span><br><span class="line">            time:null &#x2F;&#x2F; 定时器</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">        &#x2F;&#x2F; 生成二维码</span><br><span class="line">        createCode()&#123;</span><br><span class="line">            &#x2F;&#x2F; 经课程等信息与价格发送给后台，后台会请求微信官网获取支付连接，并返回</span><br><span class="line">            this.axios.get(&quot;http:&#x2F;&#x2F;localhost:80&#x2F;order&#x2F;createCode&quot;,&#123;</span><br><span class="line">                params:&#123;</span><br><span class="line">                    courseid: this.course.id, &#x2F;&#x2F; 课程编号</span><br><span class="line">                    courseid: this.course.courseName, &#x2F;&#x2F; 课程名称</span><br><span class="line">                    price: this.course.discounts, &#x2F;&#x2F; 优惠价，非原价</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">                 &#x2F;&#x2F; 生成二维码:QRCode(存放二维码的dom元素id，二维码的属性参数)</span><br><span class="line">                let qrcode &#x3D; new QRCode(&#39;qrcode&#39;,&#123;</span><br><span class="line">                    width:200,  &#x2F;&#x2F; 二维码的宽度</span><br><span class="line">                    height:200,  &#x2F;&#x2F; 二维码的高度</span><br><span class="line">                    text:result.data.code_url &#x2F;&#x2F; 将支付连接嵌入到二维码中</span><br><span class="line">                &#125;);</span><br><span class="line">                &#x2F;&#x2F; 保存订单编号</span><br><span class="line">                this.orderId &#x3D; result.data.out_trade_no</span><br><span class="line">                &#x2F;&#x2F; 发送一个请求，检查订单状态</span><br><span class="line">                this.axios.get(&quot;http:&#x2F;&#x2F;localhost:80&#x2F;order&#x2F;checkOrderStatus&quot;,&#123;</span><br><span class="line">                    params:&#123;</span><br><span class="line">                        orderId: this.orderId</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">                    if(result.data.trade_state&#x3D;&#x3D;&quot;SUCCESS&quot;)&#123;</span><br><span class="line">                        document.getElementById(&quot;statusText&quot;).innerHTML &#x3D; &quot;&lt;i style&#x3D;&#39;color:#00B38A&#39;class&#x3D;&#39;el-icon-success&#39;&gt;&lt;&#x2F;i&gt; 支付成功！&quot;;</span><br><span class="line">                        this.closeQRForm(3); &#x2F;&#x2F; 倒计时3秒关闭二维码窗口</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).catch( (error)&#x3D;&gt;&#123;</span><br><span class="line">                    this.$message.error(&quot;查询订单状态失败！&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).catch( (error)&#x3D;&gt;&#123;</span><br><span class="line">                this.$message.error(&quot;生成二维码失败！&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">            &#x2F;&#x2F; 倒计时关闭二维码窗口</span><br><span class="line">            closeQRForm(second)&#123;</span><br><span class="line">                let that &#x3D; this;</span><br><span class="line">                that.time&#x3D; setInterval(function()&#123;</span><br><span class="line">                    document.getElementById(&quot;timeClose&quot;).innerHTML &#x3D; &quot;(&quot;+ second-- +&quot;)秒后关闭本窗口！&quot;;</span><br><span class="line">                    if(s &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                        clearInterval(that.time); &#x2F;&#x2F; 停止计时</span><br><span class="line">                        that.dialogFormVisible &#x3D; false; &#x2F;&#x2F; 关闭</span><br><span class="line">                        that.isBuy &#x3D; true; &#x2F;&#x2F; 解锁购买状态</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,1000);</span><br><span class="line">            &#125;,</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="保存订单并更新状态"><a href="#保存订单并更新状态" class="headerlink" title="保存订单并更新状态"></a>保存订单并更新状态</h2><p>我们可以在生成二维码后立刻发送一个请求 <strong>添加订单</strong> ，该订单状态设置为刚创建0 。</p>
<p>当发送了获取订单状态请求后，我们根据订单的状来做出相应的判断，修改我们数据库中的订单状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据订单的状来做出相应的判断</span></span><br><span class="line"><span class="keyword">if</span>(result.data.trade_state==<span class="string">&quot;SUCCESS&quot;</span>)&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;statusText&quot;</span>).innerHTML = <span class="string">&quot;&lt;i style=&#x27;color:#00B38A &#x27;class=&#x27;el-icon-success&#x27;&gt;&lt;/i&gt; 支付成功！&quot;</span>;</span><br><span class="line">    <span class="comment">// 支付成功，状态码20</span></span><br><span class="line">    <span class="built_in">this</span>.updateOrder(<span class="number">20</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(result.data.trade_state==<span class="string">&quot;NOTPAY&quot;</span>)&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;statusText&quot;</span>).innerHTML = <span class="string">&quot;&lt;i style=&#x27;color:#00B38A &#x27;class=&#x27;el-icon-success&#x27;&gt;&lt;/i&gt; 未支付！&quot;</span>;</span><br><span class="line">    <span class="comment">// 未支付，状态码10</span></span><br><span class="line">    <span class="built_in">this</span>.updateOrder(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.closeQRForm(<span class="number">3</span>); <span class="comment">// 倒计时3秒关闭二维码窗口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新订单的状态</span></span><br><span class="line"><span class="function"><span class="title">updateOrder</span>(<span class="params">statusCode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.axios.get(<span class="string">&quot;http://localhost:80/order/updateOrder&quot;</span>,&#123;</span><br><span class="line">        params:&#123;</span><br><span class="line">            orderNo:<span class="built_in">this</span>.orderNo,</span><br><span class="line">            status:statusCode,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;更新订单【&quot;</span>+<span class="built_in">this</span>.orderNo+<span class="string">&quot;】状态：&quot;</span> + statusCode);</span><br><span class="line">    &#125;).catch( <span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&quot;更新订单失败！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
        <tag>微信登入</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/09/09/SpringBoot/</url>
    <content><![CDATA[<p> Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。<a id="more"></a></p>
<p><strong>约定优于配置</strong>（Convention over Configuration），又称按约定编程，是一种软件设计范式。</p>
<p><strong>springboot优点</strong></p>
<ul>
<li><p>起步依赖</p>
<p>起步依赖本质上是一个Maven项目<strong>对象模型</strong>(Project Object Model，POM)，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的依赖坐标打包到一起，并提供一些默认的功能。</p>
</li>
<li><p>自动配置</p>
<p>springboot的自动配置，指的是springboot会自动将一些配置类的bean注册进ioc容器，我们只需要引我们想用功能的包，相关的配置我们完全不用管，springboot会自 动注入这些配置bean</p>
</li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="Spring-Boot入门案例"><a href="#Spring-Boot入门案例" class="headerlink" title="Spring Boot入门案例"></a>Spring Boot入门案例</h2><p>案例需求：请求Controller中的方法，并将返回值响应到页面</p>
<p><strong>依赖管理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">所用的springBoot项目都会直接或者间接的继承spring-boot-starter-parent</span></span><br><span class="line"><span class="comment">1.指定项目的编码格式为UTF-8</span></span><br><span class="line"><span class="comment">2.指定JDK版本为1.8</span></span><br><span class="line"><span class="comment">3.对项目依赖的版本进行管理，当前项目再引入其他常用的依赖时就需要再指定版本号，避免版本冲突的问题</span></span><br><span class="line"><span class="comment">4.默认的资源过滤和插件管理</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入Spring Web及Spring MVC相关的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以将project打包为一个可以执行的jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SpringBoot的启动类通常放在二级包中，比如：com.hui</span></span><br><span class="line"><span class="comment">* 因为SpringBoot项目在做包扫描，会扫描启动类所在的包及其子包下的所有内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//标识当前类为SpringBoot项目的启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemo1Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模板代码。参数一:当前类的字节码；参数二:main中的参数</span></span><br><span class="line">        SpringApplication.run(SpringBootDemo1Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认端口号为8080，也可以使用idea自动构建springboot项目。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p><strong>所需依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SpringJUnit4ClassRunner.class:Spring运行环境</span></span><br><span class="line"><span class="comment">* JUnit4.class:JUnit运行环境</span></span><br><span class="line"><span class="comment">* SpringRunner.class:Spring Boot运行环境</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span> <span class="comment">//@RunWith:运行器,不过新版Springboot项目不用加该注解</span></span><br><span class="line"><span class="meta">@SpringBootTest</span> <span class="comment">//标记为当前类为SpringBoot测试类，加载项目的ApplicationContext上下文环境</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springbootdemo2ApplicationTests</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//  需求：调用HelloController的hello方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloController helloController;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = helloController.hello();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>在修改完代码之后，不需要重新启动容器，就可以实现更新。</p>
<p>1）添加SpringBoot的热部署依赖启动器 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入热部署依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）开启Idea的自动编译 </p>
<ul>
<li><p>选择IDEA工具界面的【File】-&gt;【Settings】选项，打开Compiler面板设置页面</p>
</li>
<li><p>选择Build下的Compiler选项，在右侧勾选“Build project automatically”选项将项目设置为自动编 译，单击【Apply】→【OK】按钮保存设置 </p>
</li>
</ul>
<p>3）开启Idea的在项目运行中自动编译的功能</p>
<ul>
<li>在项目任意页面中使用组合快捷键“Ctrl+Shift+Alt+/”打开Maintenance选项框，选中并打开 Registry页面</li>
<li>列表中找到“compiler.automake.allow.when.app.running”，将该选项后的Value值勾选，用于指 定IDEA工具在程序运行过程中自动编译，最后单击【Close】按钮完成设置 </li>
</ul>
<h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p>全局配置文件能够对一些默认配置值进行修改。该文件存放在<strong>src/main/resource</strong>目录或者类路径 的/config，一般会选择resource目录。springBoot会自动加载配置文件</p>
<p><strong>Spring Boot配置文件的命名及其格式</strong> </p>
<ul>
<li>application.properties </li>
<li>application.yaml </li>
<li>application.yml</li>
</ul>
<p><strong>SpringBoot的三种配置文件是可以共存的</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--后加载的配置文件会覆盖前面的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="application-properties配置文件"><a href="#application-properties配置文件" class="headerlink" title="application.properties配置文件"></a>application.properties配置文件</h3><p><strong>application.properties</strong> </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改tomcat的版本号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="comment">#定义数据库的连接信息 JdbcTemplate</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/hui</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>
<h4 id="案例–将自定义配置属性注入到实体类"><a href="#案例–将自定义配置属性注入到实体类" class="headerlink" title="案例–将自定义配置属性注入到实体类"></a>案例–将自定义配置属性注入到实体类</h4><p>将application.properties配置文件中的自定义配置属性注入到 Person实体类的对应属性中。</p>
<p><strong>定义两个实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 加入IOC容器</span></span><br><span class="line"><span class="comment">//将配置文件中所有以person开头的配置信息注入当前类中</span></span><br><span class="line"><span class="comment">//前提1：必须保证配置文件中person.xx与当前Person类的属性名一致</span></span><br><span class="line"><span class="comment">//前提2：必须保证当前Person中的属性都具有set方法</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> List hobby; <span class="comment">//爱好</span></span><br><span class="line">    <span class="keyword">private</span> String[] family; <span class="comment">//家庭成员</span></span><br><span class="line">    <span class="keyword">private</span> Map map;</span><br><span class="line">    <span class="keyword">private</span> Pet pet; <span class="comment">//宠物</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ConfigurationProperties(prefix = “person”)注解的作用是将配置文件中以person开头的属性值通过 setXX()方法注入到实体类对应属性中</p>
<p><strong>自定义配置属性</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义配置信息</span></span><br><span class="line"><span class="meta">person.id</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">person.name</span>=<span class="string">王二麻子</span></span><br><span class="line"><span class="meta">person.hobby</span>=<span class="string">read,write</span></span><br><span class="line"><span class="meta">person.family</span>=<span class="string">father,mather</span></span><br><span class="line"><span class="meta">person.map.key1</span>=<span class="string">value1</span></span><br><span class="line"><span class="meta">person.map.key2</span>=<span class="string">value2</span></span><br><span class="line"><span class="meta">person.pet.type</span>=<span class="string">dog</span></span><br><span class="line"><span class="meta">person.pet.name</span>=<span class="string">哈士奇</span></span><br></pre></td></tr></table></figure>
<p>可以在测试类中注入Person，并打印出来看结果。</p>
<p><strong>使用@value注解</strong></p>
<p> Spring Boot框架从Spring框架中对@Value注解进行了默认继承，所以也可以使用@value经行注入属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  @value注解不支持注入Map集合、对象以及YAML文件格式的行内式写法的配置文件的属性，否则报错</p>
<h3 id="application-yaml配置文件"><a href="#application-yaml配置文件" class="headerlink" title="application.yaml配置文件"></a>application.yaml配置文件</h3><p>application.yaml配置文件的 工作原理和application.properties是一样的，只不过yaml格式配置文件看起来更简洁一些。</p>
<ul>
<li>YAML文件的扩展名可以使用.yml或者.yaml。 </li>
<li>application.yml文件使用 “key:（空格）value”格式配置属性，使用缩进控制层级关系。</li>
</ul>
<p><strong>yaml中不同数据类型的写法</strong></p>
<ul>
<li>普通数据类型</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不用添加引号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">	<span class="attr">servlet:</span></span><br><span class="line">		<span class="attr">context-path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组和单列集合</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法一,推荐</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">hobby:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">play</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">read</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">sleep</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法二</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">hobby:</span></span><br><span class="line">        <span class="string">play,</span></span><br><span class="line">        <span class="string">read,</span></span><br><span class="line">        <span class="string">sleep</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法三</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">hobby:</span> [<span class="string">play</span>,<span class="string">read</span>,<span class="string">sleep</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Map集合和对象</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法一，推荐</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">map:</span></span><br><span class="line">        <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">k2:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法二</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">map:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p>springboot只会自动识别application.properties/yaml/yml三个文件，我们也可以创建别的配置文件，不过需要我们手动加载。</p>
<p><strong>使用@PropertySource加载配置文件</strong></p>
<p>该注解是Spring框架已有的，在ssm中就是使用该注解来引入JDBC的相关配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类上指定自定义配置文件位置和名称</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:hui.properties&quot;)</span> </span><br></pre></td></tr></table></figure>
<h2 id="中文乱码问题解决"><a href="#中文乱码问题解决" class="headerlink" title="中文乱码问题解决"></a>中文乱码问题解决</h2><p><strong>调整文件编码格式</strong></p>
<p><a href="https://imgtu.com/i/hOmZrt"><img src="https://z3.ax1x.com/2021/09/09/hOmZrt.png" alt="hOmZrt.png"></a></p>
<p><strong>设置Tomcat及Http编码</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解决中文乱码</span></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>类中使用 @ControllerAdvice 注解,当出现异常时,就会调用该类的某些方法</p>
<p>方法添加 @ExceptionHandler注解,指定异常的class对象, 自动匹配抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">// 日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">nullPointerException</span><span class="params">(NullPointerException e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">        log.error(<span class="string">&quot;出现了异常！ &#123;&#125;&quot;</span>,e);</span><br><span class="line">        <span class="comment">//从异常对象中获取提示信息封装返回</span></span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(<span class="number">500</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">exceptionHandler</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">        log.error(<span class="string">&quot;出现了异常！ &#123;&#125;&quot;</span>,e);</span><br><span class="line">        <span class="comment">//从异常对象中获取提示信息封装返回</span></span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h1><h2 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h2><p>MyBatis 是一款优秀的持久层框架，Spring Boot官方虽然没有对MyBatis进行整合，但是MyBatis 团队自行适配了对应的启动器，进一步简化了使用MyBatis进行数据的操作 ；因为Spring Boot框架开发的便利性，所以实现Spring Boot与数据访问层框架（例如MyBatis）的 整合非常简单，主要是引入对应的依赖启动器，并进行数据库相关参数设置即可 </p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Mybatis starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--pagehelper   mybatis的分页插件依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建数据库</strong>(省略)</p>
<p><strong>使用Free Mybatis plugin创建实体类</strong></p>
<p>需下载Free Mybatis plugin组件，idea添加数据库信息，然后右击某张表–》mybaits generator</p>
<p><a href="https://imgtu.com/i/4kgCZR"><img src="https://z3.ax1x.com/2021/09/14/4kgCZR.png" alt="4kgCZR.png"></a></p>
<p><strong>启动类添加扫描注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hui.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MybatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>application.yml添加配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL数据库连接配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spirng_dbserverTimezone=UTC&amp;characterEncoding=UTF-8</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="comment"># mybatis相关配置    </span></span><br><span class="line">    <span class="attr">mybatis:</span></span><br><span class="line">        <span class="comment">#配置MyBatis的xml配置文件路径，如果是纯注解就不需要指定</span></span><br><span class="line">        <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">        <span class="comment">#配置XML映射文件中指定的实体类别名路径</span></span><br><span class="line">        <span class="attr">type-aliases-package:</span> <span class="string">com.lagou.base.pojo</span></span><br><span class="line">        <span class="comment">#开启驼峰命名匹配映射</span></span><br><span class="line">        <span class="attr">configuration:</span></span><br><span class="line">			<span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">	<span class="comment">#pageHelper配置（官网推荐配置）</span></span><br><span class="line">    <span class="attr">pagehelper:</span></span><br><span class="line">       <span class="attr">helperDialect:</span> <span class="string">mysql</span></span><br><span class="line">       <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">       <span class="attr">supportMethodsArguments:</span> <span class="literal">true</span></span><br><span class="line">       <span class="attr">params:</span> <span class="string">count=countSql</span>		</span><br></pre></td></tr></table></figure>
<p>整合完毕。。。</p>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置Redis数据库连接</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#redis配置</span></span><br><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">50</span></span><br><span class="line"><span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">3000</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">5000</span></span><br></pre></td></tr></table></figure>
<p><strong>编写Redis操作工具类</strong></p>
<p>将RedisTemplate实例包装成一个工具类，便于对redis进行数据操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">( String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value,<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 更新缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">final</span> String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 删除缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot02MybatisApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 设置数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisUtils.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRedisData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(redisUtils.get(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><p>Spring Boot不太支持常用的JSP模板，并且没有提供对应的整合配置，这是因为使用嵌入式Servlet容 器的Spring Boot应用程序对于JSP模板存在一些限制 ：</p>
<ul>
<li>在Jetty和Tomcat容器中，Spring Boot应用被打包成war文件可以支持JSP。但Spring Boot默认使 用嵌入式Servlet容器以JAR包方式进行项目打包部署，这种JAR包方式不支持JSP。 </li>
<li>如果使用Undertow嵌入式容器部署Spring Boot项目，也不支持JSP模板。（Undertow 是红帽公 司开发的一款基于 NIO 的高性能 Web 嵌入式服务器） </li>
<li>Spring Boot默认提供了一个处理请求路径“/error”的统一错误处理器，返回具体的异常信息。使用 JSP模板时，无法对默认的错误处理器进行覆盖，只能根据Spring Boot要求在指定位置定制错误页 面。</li>
</ul>
<p>上面对Spring Boot支持的模板引擎进行了介绍，并指出了整合JSP模板的一些限制。接下来，对其 中常用的Thymeleaf模板引擎进行介绍，并完成与Spring Boot框架的整合实现 </p>
<p><strong>Thymeleaf</strong></p>
<p>Thymeleaf是一种现代的基于服务器端的Java模板引擎技术，也是一个优秀的面向Java的XML、 XHTML、HTML5页面模板，它具有丰富的标签语言、函数和表达式，在使用Spring Boot框架进行页面 设计时，一般会选择Thymeleaf模板</p>
<h2 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">&quot;../../css/gtvg.css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/gtvg.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>欢迎进入Thymeleaf的学习<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中，“xmlns:th=”<a href="http://www.thymeleaf.org&quot;“/">http://www.thymeleaf.org&quot;“</a> 用于引入Thymeleaf模板引擎标签，使用关键字 “th”标注标签是Thymeleaf模板提供的标签，其中，“th:href”用于引入外联样式件，“th:text”用于动态 显示标签文本内容。</p>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><table>
<thead>
<tr>
<th>th：标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>th:insert</td>
<td>布局标签，替换内容到引入的文件</td>
</tr>
<tr>
<td>th:replace</td>
<td>页面片段包含（类似JSP中的include标签）</td>
</tr>
<tr>
<td>th:each</td>
<td>元素遍历（类似JSP中的c:forEach标签）</td>
</tr>
<tr>
<td>th:if</td>
<td>条件判断，如果为真</td>
</tr>
<tr>
<td>th:unless</td>
<td>条件判断，如果为假</td>
</tr>
<tr>
<td>th:switch</td>
<td>条件判断，进行选择性匹配</td>
</tr>
<tr>
<td>th:case</td>
<td>条件判断，进行选择性匹配</td>
</tr>
<tr>
<td>th:value</td>
<td>属性值修改，指定标签属性值</td>
</tr>
<tr>
<td>th:href</td>
<td>用于设定链接地址</td>
</tr>
<tr>
<td>th:src</td>
<td>用于设定链接地址</td>
</tr>
<tr>
<td>th:text</td>
<td>用于指定标签显示的文本内容</td>
</tr>
</tbody></table>
<h3 id="标准表达式"><a href="#标准表达式" class="headerlink" title="标准表达式"></a>标准表达式</h3><table>
<thead>
<tr>
<th>说明</th>
<th>表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>变量表达式</td>
<td>${…}</td>
</tr>
<tr>
<td>选择变量表达式</td>
<td>*{…}</td>
</tr>
<tr>
<td>消息表达式</td>
<td>#{…}</td>
</tr>
<tr>
<td>链接URL表达式</td>
<td>@{…}</td>
</tr>
<tr>
<td>片段表达式</td>
<td>~{…}</td>
</tr>
</tbody></table>
<p><strong>变量表达式 ${…}</strong></p>
<p>主要用于获取上下文中的变量值，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;title&#125;&quot;</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果上下文存在title，p标签的值为”title“；如果不存在title，p标签就显示“这是标题”，从而达到模板引擎页面数 据动态替换的效果 </p>
<p>同时，Thymeleaf为变量所在域提供了一些内置对象，具体如下所示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ctx：上下文对象</span><br><span class="line"># vars：上下文变量</span><br><span class="line"># locale：上下文区域设置</span><br><span class="line"># request：（仅限Web Context）HttpServletRequest对象</span><br><span class="line"># response：（仅限Web Context）HttpServletResponse对象</span><br><span class="line"># session：（仅限Web Context）HttpSession对象</span><br><span class="line"># servletContext：（仅限Web Context）ServletContext对象</span><br></pre></td></tr></table></figure>
<p>假设要在Thymeleaf模板引擎页面中动态获取当前国家信息，可以使用 #locale内置对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">The locale country is: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#locale.country&#125;&quot;</span>&gt;</span>US<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>选择变量表达式 *{…}</strong></p>
<p>选择变量表达式和变量表达式用法类似，一般用于从被选定对象而不是上下文中获取属性值，如果 没有选定对象，则和变量表达式一样，示例代码如下 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;book&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>titile: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;title&#125;&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>*&#123;title&#125;</code> 选择变量表达式获取当前指定对象book的title属性值</p>
<p><strong>消息表达式 #{…}</strong></p>
<p>主要用于Thymeleaf模板页面国际化内容的动态替换和展示，使用消息表达式#{…} 进行国际化设置时，还需要提供一些国际化配置文件。</p>
<p><strong>链接表达式 @{…}</strong></p>
<p>一般用于页面跳转或者资源的引入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;http://localhost:8080/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt;</span><br><span class="line">&lt;a th:href=&quot;@&#123;/order/details(orderId=$&#123;o.id&#125;,pid=$&#123;p.id&#125;)&#125;&quot;&gt;view&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上述代码中，链接表达式@{…}分别编写了绝对链接地址和相对链接地址。如果url中有参数，需要 按照@{路径(参数名称=参数值，参数名称=参数值…)}的形式编写，同时该参数的值可以使用变量表达式 来传递动态参数值 </p>
<p><strong>片段表达式 ~{…}</strong></p>
<p>用来标记一个片段模板，并根据需要移动或传递给其他模板。其中，最常见的用法是使 用th:insert或th:replace属性插入片段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;thymeleafDemo::title&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>thymeleafDemo为模板名称，Thymeleaf会自动查找“/resources/templates/”目录下的 thymeleafDemo模板，title为片段名称。</p>
<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>（1）依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）在全局配置文件中配置Thymeleaf模板的一些参数。一般Web项目都会使用下列配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.thymeleaf.cache</span> = <span class="string">true ＃启用模板缓存，默认。但是一般开发过程中会关闭</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span> = <span class="string">UTF_8 ＃模板编码</span></span><br><span class="line"><span class="meta">spring.thymeleaf.mode</span> = <span class="string">HTML5 ＃应用于模板的模板模式</span></span><br><span class="line"><span class="meta">spring.thymeleaf.prefix</span> = <span class="string">classpath:/templates/ ＃指定模板页面存放路径，默认</span></span><br><span class="line"><span class="meta">spring.thymeleaf.suffix</span> = <span class="string">.html ＃指定模板页面名称的后缀,默认</span></span><br></pre></td></tr></table></figure>
<p>（3）静态资源的访问 开发Web应用时，难免需要使用静态资源。</p>
<p>Spring boot默认设置了静态资源的访问路径。 使用Spring Initializr方式创建的Spring Boot项目，默认生成了一个resources目录，在resources目录中 新建public、resources、static三个子目录下，Spring boot默认会挨个从public、resources、static里 面查找静态资源 </p>
<p><strong>注意</strong> resource:template 中的thymeleaf模板只能通过跳转访问</p>
<h1 id="Spring-Boot项目部署"><a href="#Spring-Boot项目部署" class="headerlink" title="Spring Boot项目部署"></a>Spring Boot项目部署</h1><p>需求：将Spring Boot项目使用maven指令打成jar包并运行测试</p>
<p><strong>添加打包组件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时项目目录会出现target目录，jar包就在里面</p>
<p><strong>部署运行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar 包名</span><br></pre></td></tr></table></figure>


<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>  解决bean重复注册问题</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2021/09/14/SpringCloud/</url>
    <content><![CDATA[<p>随着互联⽹的发展，⽤户群体逐渐扩大，⽹站的流量成倍增⻓，常规的单体架构已⽆法满⾜请求压⼒ 和业务的快速迭代，架构的变化势在必⾏。<a id="more"></a></p>
<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p><strong>SOA</strong> (Service-Oriented Architecture)，即面向服务的架构。根据实际业务，把系统拆分成合适 的、独立部署的模块，模块之间相互独立（通过Webservice/Dubbo等技术进行通信）。</p>
<p><a href="https://imgtu.com/i/4AElKx"><img src="https://z3.ax1x.com/2021/09/14/4AElKx.png" alt="4AElKx.png"></a></p>
<p><strong>微服务架构</strong>  </p>
<p>可以说是<strong>SOA架构</strong>的一种拓展，这种架构模式下它拆分粒度更小、服务更独立。把应用 拆分成为一个个微小的服务，不同的服务可以使用不同的开发语言和存储，服务之间往往通过Restful等 轻量级通信。微服务架构关键在于微小、独立、轻量级通信。 </p>
<p>微服务是在 SOA 上做的升华粒度更加细致，微服务架构强调的⼀个重点是业务需要彻底的组件化和 服务化</p>
<p><a href="https://imgtu.com/i/4Akz11"><img src="https://z3.ax1x.com/2021/09/14/4Akz11.png" alt="4Akz11.png"></a></p>
<p><strong>优点</strong></p>
<ul>
<li>微服务很小，便于特定业务功能的聚焦 </li>
<li>微服务很小，每个微服务都可以被一个小团队单独实施（开发、测试、部署上线、运维），团队合 作一定程度解耦，便于实施敏捷开发 </li>
<li>微服务很小，便于重用和模块之间的组装 </li>
<li>微服务很独立，那么不同的微服务可以使用不同的语言开发，松耦合 </li>
<li>微服务架构下，我们更容易引入新技术</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>微服务架构下，分布式复杂难以管理，当服务数量增加，管理将越加复杂；</li>
<li>微服务架构下，分布式链路跟踪难等；</li>
</ul>
<h1 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h1><p>Spring Cloud其实是一套规范，是一套用于构建微服务架构的规范，而不是一个 可以拿来即用的框架。在这个规范之下第三方的Netflix公司开发了一些组件、Spring官方开发了一些框架/组件，包括第 三方的阿里巴巴开发了一套框架/组件集合Spring Cloud Alibaba，这些才是Spring Cloud规范的实现。</p>
<p><strong>SpringCloud解决的问题</strong></p>
<ul>
<li>Distributed/versioned configuration （分布式/版本化配置） </li>
<li>Service registration and discovery （服务注册和发现） </li>
<li>Routing （智能路由） </li>
<li>Service-to-service calls （服务调用）</li>
<li>Load balancing （负载均衡） </li>
<li>Circuit Breakers （熔断器） </li>
<li>Global locks （全局锁） </li>
<li>Leadership election and cluster state （ 选举与集群状态管理） </li>
<li>Distributed messaging （分布式消息传递平台）</li>
</ul>
<p><strong>Spring Cloud 核心组件</strong></p>
<p>Spring Cloud 生态圈中的组件，按照发展可以分为第一代 Spring Cloud组件和第二代 Spring Cloud组件。</p>
<table>
<thead>
<tr>
<th></th>
<th>第一代 Spring Cloud（Netflix，SCN）</th>
<th>第二代 Spring Cloud（主要就是SpringCloud Alibaba，SCA）</th>
</tr>
</thead>
<tbody><tr>
<td>注册中心</td>
<td>Netflix Eureka</td>
<td>阿里巴巴 Nacos</td>
</tr>
<tr>
<td>客户端负载均衡</td>
<td>Netflix Ribbon</td>
<td>阿里巴巴 Dubbo LB、Spring Cloud Loadbalancer</td>
</tr>
<tr>
<td>熔断器</td>
<td>Netflix Hystrix</td>
<td>阿里巴巴 Sentinel</td>
</tr>
<tr>
<td>网关</td>
<td>Netflix Zuul：性能一般，未来将退出Spring Cloud 生态圈</td>
<td>官方 Spring Cloud Gateway</td>
</tr>
<tr>
<td>配置中心</td>
<td>官方 Spring Cloud Config</td>
<td>阿里巴巴 Nacos、携程 Apollo</td>
</tr>
<tr>
<td>服务调用</td>
<td>Netflix Feign</td>
<td>阿里巴巴 Dubbo RPC</td>
</tr>
<tr>
<td>消息驱动</td>
<td>官方 Spring Cloud Stream</td>
<td></td>
</tr>
<tr>
<td>链路追踪</td>
<td>官方 Spring Cloud Sleuth/Zipkin</td>
<td></td>
</tr>
<tr>
<td>分布式事务</td>
<td></td>
<td>阿里巴巴 seata 分布式事务方案</td>
</tr>
</tbody></table>
<p><strong>Spring Cloud 体系结构（组件协同工作机制）</strong></p>
<p>Spring Cloud中的各组件协同工作，才能够支持一个完整的微服务架构</p>
<p><a href="https://imgtu.com/i/4AmSe0"><img src="https://z3.ax1x.com/2021/09/14/4AmSe0.png" alt="4AmSe0.png"></a></p>
<p><strong>Spring Cloud 与 Dubbo 对比</strong> </p>
<p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，基于RPC调用，对于目前使用率较高的 Spring Cloud Netflix来说，它是基于HTTP的，所以效率上没有Dubbo高。但问题在于Dubbo体系的组 件不全，不能够提供一站式解决方案，比如服务注册与发现需要借助于Zookeeper等实现，而Spring Cloud Netflix则是真正的提供了一站式服务化解决方案，且有Spring大家族背景。</p>
<p>前些年，Dubbo使用率高于SpringCloud，但目前Spring Cloud在服务化/微服务解决方案中已经有 了非常好的发展趋势。</p>
<p><strong>Spring Cloud 与 Spring Boot 的关系</strong></p>
<p>Spring Cloud 只是利用了Spring Boot 的特点，让我们能够快速的实现微服务组件开发，否则不使 用Spring Boot的话，我们在使用Spring Cloud时，每一个组件的相关Jar包都需要我们自己导入配置以 及需要开发人员考虑兼容性等各种情况。所以Spring Boot是我们快速把Spring Cloud微服务技术应用起 来的一种方式。</p>
<h1 id="准备案例"><a href="#准备案例" class="headerlink" title="准备案例"></a>准备案例</h1><p>本部分我们按照普通方式模拟一个微服务之间的调用，后续我们将一步步使用Spring Cloud的组件对案 例进行改造</p>
<p><a href="https://imgtu.com/i/4AWbrD"><img src="https://z3.ax1x.com/2021/09/14/4AWbrD.png" alt="4AWbrD.png"></a></p>
<p>基于SpringBoot来构造工程环境，工程模块关系如下所示：</p>
<p><a href="https://imgtu.com/i/4AWjIA"><img src="https://z3.ax1x.com/2021/09/14/4AWjIA.png" alt="4AWjIA.png"></a></p>
<p><strong>数据库环境准备</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#商品信息表</span><br><span class="line">CREATE TABLE products(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(50), #商品名称</span><br><span class="line">    price DOUBLE,</span><br><span class="line">    flag VARCHAR(2), #上架状态</span><br><span class="line">    goods_desc VARCHAR(100), #商品描述</span><br><span class="line">    images VARCHAR(400), #商品图片</span><br><span class="line">    goods_stock INT, #商品库存</span><br><span class="line">    goods_type VARCHAR(20) #商品类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h2><p>idea中创建一个普通maven工程，命名为 spring-parent</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父工程打包方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring boot 父启动器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Actuator可以帮助你监控和管理Spring Boot应用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--编译插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--打包插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="公共组件微服务"><a href="#公共组件微服务" class="headerlink" title="公共组件微服务"></a>公共组件微服务</h2><p>父工程下创建子模块   spring-service-common</p>
<p><strong>pom.xml</strong></p>
<p>主要引入数据库驱动及mybatis-plus</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Mybatis-plus--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--pojo持久化使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>生成数据库实体类：Products</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Table(name = &quot;products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Products</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String flag;</span><br><span class="line">    <span class="keyword">private</span> String goodsDesc;</span><br><span class="line">    <span class="keyword">private</span> String images;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> goodsStock;</span><br><span class="line">    <span class="keyword">private</span> String goodsType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="商品微服务"><a href="#商品微服务" class="headerlink" title="商品微服务"></a>商品微服务</h2><p>商品微服务是服务提供者，父工程下创建模块  spring-service-product</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入公共组件微服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lagou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-service-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml 配置端口、应用名、数据库连接等信息</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">9001</span>  <span class="comment"># 后期该微服务会有多个实例</span></span><br><span class="line"><span class="attr">Spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">spring-service-product</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">	<span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring_db?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">	<span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>mapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 现在使用的Mybatis-plus组件，该组件是Mybatis的加强版</span></span><br><span class="line"><span class="comment">    * 具体使用：让具体的Mapper接口继承BaseMapper即可,自动提供一些简单的CRUD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Products</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>service层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据id获取商品</span></span><br><span class="line">    <span class="function">Products <span class="title">getProductById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Products <span class="title">getProductById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>controller层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Products <span class="title">query</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hui.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="页面静态微服务"><a href="#页面静态微服务" class="headerlink" title="页面静态微服务"></a>页面静态微服务</h2><p>页面静态微服务是服务消费者，父工程下创建模块  spring-service-page</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入公共组件微服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lagou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lagou-service-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml 配置端口、应用名、数据库连接等信息</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">9101</span> </span><br><span class="line"><span class="attr">Spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">spring-service-page</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">	<span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring_db?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">	<span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>controller层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用RestTemplate发送url调用远程服务</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Products <span class="title">findDataById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        String url =<span class="string">&quot;http://localhost:9001/product/get/&quot;</span>;</span><br><span class="line">        Products products = restTemplate.getForObject(url+id,Products.class);</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>启动类，注入RestTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PageApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例代码问题"><a href="#案例代码问题" class="headerlink" title="案例代码问题"></a>案例代码问题</h2><p>我们在页面静态化微服务中使用RestTemplate调用商品微服务的商品状态接口时（Restful API 接 口）。在微服务分布式集群环境下会存在什么问题呢?</p>
<p><strong>存在的问题及SpringCloud解决方案:</strong></p>
<ul>
<li>在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护<ul>
<li>自动注册与发现</li>
</ul>
</li>
<li>在服务消费者中，不清楚服务提供者的状态。<ul>
<li>状态监管</li>
</ul>
</li>
<li>服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡<ul>
<li>服务负载均衡</li>
</ul>
</li>
<li>服务消费者调用服务提供者时候，如果出现故障能否及时发现不向用户抛出异常页面<ul>
<li>熔断</li>
</ul>
</li>
<li>RestTemplate这种请求调用方式是否还有优化空间？能不能类似于Dubbo那样玩<ul>
<li>远程过程调用</li>
</ul>
</li>
<li>这么多的微服务统一认证如何实现<ul>
<li>统一认证、网关拦截、路由转发</li>
</ul>
</li>
<li>配置文件每次都修改好多个很麻烦<ul>
<li>集中式配置管理，配置信息实时自动更新</li>
</ul>
</li>
</ul>
<h1 id="第一代核心组件SCN"><a href="#第一代核心组件SCN" class="headerlink" title="第一代核心组件SCN"></a>第一代核心组件SCN</h1><p>第一代网关组件Zuul性能一般，未来将退出Spring Cloud 生态圈，所以这里把GateWay划分到第一代Spring Cloud 核心组件这一部分，代替Zuul。</p>
<p><strong>各组件整体结构如下</strong></p>
<p>从形式上来说，Feign一个顶三，集成了相关组件，Feign = RestTemplate + Ribbon + Hystrix</p>
<p><a href="https://imgtu.com/i/4AX7bn"><img src="https://z3.ax1x.com/2021/09/14/4AX7bn.png" alt="4AX7bn.png"></a></p>
<h2 id="Eureka服务注册中心"><a href="#Eureka服务注册中心" class="headerlink" title="Eureka服务注册中心"></a>Eureka服务注册中心</h2><p>常用的服务注册中心：Eureka、Nacos、Zookeeper、Consul</p>
<h3 id="服务注册中心相关概念"><a href="#服务注册中心相关概念" class="headerlink" title="服务注册中心相关概念"></a>服务注册中心相关概念</h3><p>服务注册中心本质上是为了解耦服务提供者和服务消费者</p>
<ul>
<li>没有注册中心：服务消费者 –&gt; 服务提供者</li>
<li>有了注册中心：服务消费者 –&gt; 服务注册中心 –&gt; 服务提供者</li>
</ul>
<p><a href="https://imgtu.com/i/4AxnAI"><img src="https://z3.ax1x.com/2021/09/14/4AxnAI.png" alt="4AxnAI.png"></a></p>
<p>分布式微服务架构中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消 费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不再需要通过硬编码方式得到提供 者的地址信息。消费者只需要知道当前系统发布了那些服务，而不需要知道服务具体存在于什么位置， 这就是<strong>透明化路由</strong>。</p>
<ol>
<li>启动服务提供者 </li>
<li>服务提供者将相关服务信息主动注册到注册中心 </li>
<li>启动服务消费者，获取服务注册信息： <ul>
<li>pull模式：服务消费者可以主动拉取可用的服务提供者清单 </li>
<li>push模式：服务消费者订阅服务（当服务提供者有变化时，注册中心也会主动推送更新后的 服务清单给消费者 </li>
</ul>
</li>
<li>服务消费者直接调用服务提供者 另外，注册中心也需要完成服务提供者的健康监控，当发现服务提供者失效时需要及时剔除；</li>
</ol>
<p><strong>主流注册中心</strong></p>
<table>
<thead>
<tr>
<th>组件名</th>
<th>语言</th>
<th>CAP</th>
<th>对外暴露接口</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP（自我保护机制，保证可用）</td>
<td>HTTP</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>HTTP/DNS</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>客户端</td>
</tr>
<tr>
<td>Nacos</td>
<td>Java</td>
<td>支持AP/CP切换</td>
<td>HTTP</td>
</tr>
</tbody></table>
<p><strong>CAP原则</strong></p>
<ul>
<li>P：分区容错性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用 性的服务（一定的要满足的） </li>
<li>C：数据一致性：all nodes see the same data at the same time </li>
<li>A：高可用：Reads and writes always succeed</li>
</ul>
<p>CAP不可能同时满足三个，要么是AP，要么是CP</p>
<h3 id="Eureka相关概念"><a href="#Eureka相关概念" class="headerlink" title="Eureka相关概念"></a>Eureka相关概念</h3><p>Eureka 包含两个组件：  <strong>Eureka Server</strong>   和   <strong>Eureka Client</strong>  </p>
<ul>
<li>Eureka Client是一个Java客户端，用于简化 与Eureka Server的交互；</li>
<li>Eureka Server提供服务发现的能力，各个微服务启动时，会通过Eureka Client向Eureka Server 进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息</li>
</ul>
<p><strong>Eureka 基础架构</strong></p>
<p><a href="https://imgtu.com/i/4ES8Ts"><img src="https://z3.ax1x.com/2021/09/14/4ES8Ts.png" alt="4ES8Ts.png"></a></p>
<p><strong>Eureka 集群架构</strong></p>
<p><a href="https://imgtu.com/i/4EScfx"><img src="https://z3.ax1x.com/2021/09/14/4EScfx.png" alt="4EScfx.png"></a></p>
<ol>
<li>图中us-east-1c、us-east-1d，us-east-1e代表不同的区也就是不同的机，每一个Eureka Server都是一个集群。</li>
<li>图中Application Service作为服务提供者向Eureka Server中注册服务，Eureka Server接受到注 册事件会在集群和分区中进行数据同步，Application Client作为消费端（服务消费者）可以从Eureka Server中获取到服务注册信息，进行服务调用。</li>
<li>微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为<strong>30秒</strong>）以续约自己的信息</li>
<li>Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微 服务节点（默认<strong>90秒</strong>）</li>
<li>每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的方式完成服务 注册列表的同步</li>
<li>Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消 费者依然可以使用缓存中的信息找到服务提供者 </li>
</ol>
<p>Eureka通过心跳检测、健康检查和客户端缓存等机制，提高系统的灵活性、可伸缩性和高可用性。</p>
<h3 id="搭建单例Eureka-Server服务注册中心"><a href="#搭建单例Eureka-Server服务注册中心" class="headerlink" title="搭建单例Eureka Server服务注册中心"></a>搭建单例Eureka Server服务注册中心</h3><p><strong>实现过程</strong>：</p>
<ol>
<li>单例Eureka Server—&gt;访问管理界面 </li>
<li>服务提供者（商品微服务注册到集群） </li>
<li>服务消费者（页面静态化微服务注册到Eureka/从Eureka Server获取服务信息） </li>
<li>完成调用</li>
</ol>
<h4 id="搭建单例Eureka-Server"><a href="#搭建单例Eureka-Server" class="headerlink" title="搭建单例Eureka Server"></a>搭建单例Eureka Server</h4><p><strong>spring-parent中引入Spring Cloud依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Cloud 是一个综合的项目，下面有很多子项目，比如eureka子项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在父工程的pom文件中手动引入jaxb的jar，因为Jdk9之后默认没有加载该模块，Eureka Server使用到，所以需要手动导入，否则EurekaServer服务无法启动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Jaxb，开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.10-b140310.1920<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入Jaxb，结束--&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建子模块spring-cloud-eureka，并引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Eureka server依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置application.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9201</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-cloud-eureka</span></span><br><span class="line"><span class="comment"># eureka相关配置    </span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 客户端与EurekaServer交互的地址，如果是集群，也需要写其它Server的地址，当前是自己</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>   <span class="comment"># 向集群中注册自己，默认true（单例模式没必要）</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>         <span class="comment">#Eureka Server获取服务信息,默认为true （单例模式没必要）</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>
<p><strong>编写启动类，声明当前服务为Eureka注册中心</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 标识该项目为一个Eureka Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动项目，访问<a href="http://127.0.0.1:9201，如果看到Eureka注册中心后台，则表明EurekaServer">http://127.0.0.1:9201，如果看到Eureka注册中心后台，则表明EurekaServer</a> 发布成功</p>
<h4 id="服务提供者注册到注册中心"><a href="#服务提供者注册到注册中心" class="headerlink" title="服务提供者注册到注册中心"></a>服务提供者注册到注册中心</h4><p><strong>spring-service-product引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>yml配置Eureka服务端信息</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment">#  eureka server的路径</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9201/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></span><br></pre></td></tr></table></figure>
<p><strong>修改启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hui.mapper&quot;)</span></span><br><span class="line"><span class="comment">//@EnableEurekaClient  // 表示当前项目注册到 Eureka Server</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>   <span class="comment">// 表示当前项目注册到注册中心（包含Eureka、zookeeper等）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务消费者注册到注册中心"><a href="#服务消费者注册到注册中心" class="headerlink" title="服务消费者注册到注册中心"></a>服务消费者注册到注册中心</h4><p>与上面步骤一样，对于EurekaServer来说，服务提供者与服务消费者都是EurekaClient角色。</p>
<h4 id="完成调用"><a href="#完成调用" class="headerlink" title="完成调用"></a>完成调用</h4><p>之前消费方调用提供方，是通过RestTemplate硬编码的方式调用url，现在我们可以小小的改变一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eureka注册中心容器</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Products <span class="title">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从Eureka注册中心获取的 spring-service-product 实例集合</span></span><br><span class="line">    List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(<span class="string">&quot;spring-service-product&quot;</span>);</span><br><span class="line">    ServiceInstance instance = instanceList.get(<span class="number">0</span>);<span class="comment">// 当前不是集群环境，所以只有一个</span></span><br><span class="line">    <span class="comment">// 从实例中获取ip与端口号</span></span><br><span class="line">    String host = instance.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = instance.getPort();</span><br><span class="line">    <span class="comment">// 获取消费提供方的ip与端口经行拼接URL</span></span><br><span class="line">    String url = <span class="string">&quot;http://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;/product/get/&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url + id, Products.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搭建Eureka-Server-高可用集群"><a href="#搭建Eureka-Server-高可用集群" class="headerlink" title="搭建Eureka Server 高可用集群"></a>搭建Eureka Server 高可用集群</h3><p>在互联网应用中，服务实例很少有单个的。 在生产环境中，我们会配置Eureka Server集群实现高可用。Eureka Server集群之中的节点通过点 对点（P2P）通信的方式共享服务注册表。我们开启两台 Eureka Server 以搭建集群。 </p>
<p>由于是在个人计算机中进行测试很难模拟多主机的情况，Eureka配置server集群时需要执行host地 址。 所以需要修改个人电脑中host地址，win10操作系统下：<strong>C:\Windows\System32\drivers\etc\host</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 测试Eureka集群</span><br><span class="line">127.0.0.1  EurekaServerA</span><br><span class="line">127.0.0.1  EurekaServerB</span><br></pre></td></tr></table></figure>
<p>将spring-cloud-eureka复制一份为spring-cloud-eureka02</p>
<p><strong>修改 Eureka Server配置文件</strong></p>
<p>9201</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9201</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-cloud-eureka</span> <span class="comment"># 应用名称，会在Eureka中作为id表示，同一集群要相同</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">EurekaServerA</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 客户端与EurekaServer交互的地址，如果是集群，也需要写其它Server的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://EurekaServerB:9202/eureka/</span>  <span class="comment"># 另一个集群地址</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>   <span class="comment"># 向集群中注册自己，默认true（单例模式没必要）</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>         <span class="comment">#Eureka Server获取服务信息,默认为true （单例模式没必要）</span></span><br></pre></td></tr></table></figure>
<p>9202</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9202</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-cloud-eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">EurekaServerB</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://EurekaServerA:9201/eureka/</span>  <span class="comment"># 另一个集群地址</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>修改商品微服务eureka配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment">#  eureka server的路径，添加集群</span></span><br><span class="line">      <span class="comment">#把 eureka 集群中的所有 url 都填写了进来，也可以只写一台，因为各个 eureka server可以同步注册表</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://EurekaServerA:9201/eureka/,http://EurekaServerB:9202/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></span><br></pre></td></tr></table></figure>
<p><strong>修改页面静态微服务</strong></p>
<p>同上。</p>
<p>调用方法与单例Eureka Server一样。</p>
<h3 id="Eureka细节详情"><a href="#Eureka细节详情" class="headerlink" title="Eureka细节详情"></a>Eureka细节详情</h3><h4 id="Eureka元数据"><a href="#Eureka元数据" class="headerlink" title="Eureka元数据"></a>Eureka元数据</h4><p>Eureka的元数据有两种：标准元数据和自定义元数据。 </p>
<ul>
<li>标准元数据：主机名、IP地址、端口号等信息，这些信息都会被发布在服务注册表中，用于服务之 间的调用。 </li>
<li>自定义元数据：可以使用eureka.instance.metadata-map配置，符合KEY/VALUE的存储格式。这 些元数据可以在远程客户端中访问。</li>
</ul>
<p>例如在商品微服务中定义自定义元数据</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ipaddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></span><br><span class="line">        <span class="attr">metadata-map:</span></span><br><span class="line">            <span class="attr">ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line">            <span class="attr">user:</span> <span class="string">oddDog</span></span><br><span class="line">            <span class="attr">pwd:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>在页面微服务中获取商品微服务自定义元数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;metadata&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetadataController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>   <span class="comment">// Eureka注册中心容器</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;show&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showMetadata</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;spring-service-product&quot;</span>);</span><br><span class="line">        ServiceInstance instance = instanceList.get(<span class="number">0</span>);<span class="comment">// 当前不是集群环境，所以只有一个</span></span><br><span class="line">        <span class="comment">//获取服务元数据</span></span><br><span class="line">        Map&lt;String, String&gt; metadata = instance.getMetadata();</span><br><span class="line">        <span class="keyword">for</span> (String key : metadata.entrySet())&#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot;:&quot;</span>+metadata.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Eureka客户端详情"><a href="#Eureka客户端详情" class="headerlink" title="Eureka客户端详情"></a>Eureka客户端详情</h4><ol>
<li>当我们导入了eureka-client依赖坐标，配置Eureka服务注册中心地址 </li>
<li>服务在启动时会向注册中心发起注册请求，携带服务元数据信息</li>
<li>Eureka注册中心会把服务的信息保存在Map中。</li>
</ol>
<p><strong>服务续约详解（客户端)</strong></p>
<p>客户端每隔30秒会向注册中心续约(心跳)一次（也称为报活），如果没有续约，租约在90秒后到期， 然后服务会被失效。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#客户端设置续约，默认即可</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 租约续约间隔时间，默认30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="comment"># 租约到期，服务时效时间，默认值90秒,服务超过90秒没有发生心跳，EurekaServer会将服务从列表移除</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端获取服务列表</strong></p>
<ol>
<li>服务消费者启动时，从 EurekaServer服务列表获取只读备份，缓存到本地</li>
<li>每隔30秒，会重新获取并更新数据, 可以通过配置修改。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#客户端设置拉去服务列表时间，默认即可</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 每隔多久拉取一次服务列表</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<h4 id="Eureka服务端详情"><a href="#Eureka服务端详情" class="headerlink" title="Eureka服务端详情"></a>Eureka服务端详情</h4><p><strong>服务下线</strong></p>
<ol>
<li>当服务正常关闭操作时，会发送服务下线的REST请求给EurekaServer。</li>
<li>服务中心接受到请求后，将该服务置为下线状态</li>
</ol>
<p><strong>自我保护机制</strong></p>
<p>如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么 Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制,此时会出现 以下几种情况：</p>
<ol>
<li>Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。 </li>
<li>Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前 节点依然可用。 </li>
<li>当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。</li>
</ol>
<p>因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半 不可用的情况会导致整个集群不可用而变成瘫痪。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端设置自我保护模式，默认开启，建议开启</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">server:</span></span><br><span class="line">		<span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><h3 id="负载均衡相关概念"><a href="#负载均衡相关概念" class="headerlink" title="负载均衡相关概念"></a>负载均衡相关概念</h3><p>负载均衡一般分为 服务器端负载均衡和客户端负载均衡</p>
<p><strong>服务器端负载均衡</strong> ： 比如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据一定的 算法将请求路由到目标服务器处理。 </p>
<p><strong>客户端负载均衡</strong> ： 比如我们要说的Ribbon，服务消费者客户端会有一个服务器地址列表，调用放在请求前通过一定的负载均衡算法选择一个服务器进行访问，负载均衡算法的执行是在请求客户端进 行。 </p>
<p>Ribbon是Netflix发布的负载均衡器。Eureka一般配合Ribbon进行使用，Ribbon利用从Eureka中读 取到服务信息，在调用服务提供者提供的服务时，会根据一定的算法进行负载。</p>
<p><a href="https://imgtu.com/i/4VfpM6"><img src="https://z3.ax1x.com/2021/09/15/4VfpM6.png" alt="4VfpM6.png"></a></p>
<h3 id="Ribbon的使用"><a href="#Ribbon的使用" class="headerlink" title="Ribbon的使用"></a>Ribbon的使用</h3><p><strong>需求</strong>:  复制商品微服务spring-service-product02,修改端口:9002，在两个服务提供者中编写Controller方法，返回服务实例端口。服务消费者 spring-service-page 通过负载均衡策略调用该方法。</p>
<p>微服务中引入过eureka-client相关依赖，会自动引入 Ribbon相关依赖坐标，所以不需要导入Ribbon依赖</p>
<p><strong>服务提供方编写Controller,并复制一份微服务spring-service-product02</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前端口号请求</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;port&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务消费方注入RestTemplate时添加对应注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">// 当前项目注册到注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  注入RestTemplate</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">// Ribbon 负载均衡</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务消费方调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;port&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接通过服务的名称来访问，不需要指定ip与port  (注意：要开启Ribbon负载均衡)</span></span><br><span class="line">    String url = <span class="string">&quot;http://spring-service-product/product/port&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Ribbon负载均衡策略"><a href="#Ribbon负载均衡策略" class="headerlink" title="Ribbon负载均衡策略"></a>Ribbon负载均衡策略</h3><p>Ribbon内置了多种负载均衡策略，内部负责复杂均衡的顶级接口为 com.netflix.loadbalancer.IRule </p>
<p><a href="https://imgtu.com/i/4V5gln"><img src="https://z3.ax1x.com/2021/09/15/4V5gln.png" alt="4V5gln.png"></a></p>
<table>
<thead>
<tr>
<th>负载均衡策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule：轮询策略</td>
<td>默认超过10次获取到的server都不可用，会返回一个空的server</td>
</tr>
<tr>
<td>RandomRule：随机策略</td>
<td>如果随机到的server为null或者不可用的话，会while不停的循环选取</td>
</tr>
<tr>
<td>RetryRule：重试策略</td>
<td>一定时限内循环重试。默认继承RoundRobinRule，也支持自定义注入，RetryRule会在每次选取之后，对选举的server进行判断，是否为null，是否alive，并且在500ms内会不停的选取判断。而RoundRobinRule失效的策略是超过10次，RandomRule是没有失效时间的概念，只要serverList没都挂。</td>
</tr>
<tr>
<td>BestAvailableRule：最小连接数策略</td>
<td>遍历serverList，选取出可用的且连接数最小的一个server。该算法里面有一个LoadBalancerStats的成员变量，会存储所有server的运行状况和连接数。如果选取到的server为null，那么会调用RoundRobinRule重新选取。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule： 可用过滤策略</td>
<td>扩展了轮询策略，会先通过默认的轮询选取一个server，再去判断该server是否超时可用，当前连接数是否超限，都成功再返回。</td>
</tr>
<tr>
<td>ZoneAvoidanceRule：区域权衡策略（默认策略）</td>
<td>扩展了轮询策略，继承了2个过滤器：ZoneAvoidancePredicate和AvailabilityPredicate，除了过滤超时和链接数过多的server，还会过滤掉不符合要求的zone区域里面的所有节点， 在一个区域/机房内的服务实例中轮询。先过滤再轮询</td>
</tr>
</tbody></table>
<p><strong>修改负载均衡策略</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#针对的被调用方微服务名称,不加就是全局生效</span></span><br><span class="line"><span class="attr">spring-service-product:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#随机策略</span></span><br></pre></td></tr></table></figure>
<h3 id="Ribbon源码剖析"><a href="#Ribbon源码剖析" class="headerlink" title="Ribbon源码剖析"></a>Ribbon源码剖析</h3><p><a href="https://imgtu.com/i/4VI5ut"><img src="https://z3.ax1x.com/2021/09/15/4VI5ut.png" alt="4VI5ut.png"></a></p>
<p>SpringCloud充分利用了SpringBoot的自动装配特点，在spring-cloud-commons包中找spring.factories配置文件</p>
<p><a href="https://imgtu.com/i/4V7eAK"><img src="https://z3.ax1x.com/2021/09/15/4V7eAK.png" alt="4V7eAK.png"></a></p>
<p>进入 LoadBalancerAutoConfiguration 类中</p>
<p><a href="https://imgtu.com/i/4VHEvj"><img src="https://z3.ax1x.com/2021/09/15/4VHEvj.png" alt="4VHEvj.png"></a></p>
<p><strong>注入RestTemplate拦截器</strong>： 为RestTemplate对象设置loadBalancerInterceptor</p>
<p><a href="https://imgtu.com/i/4VHjiT"><img src="https://z3.ax1x.com/2021/09/15/4VHjiT.png" alt="4VHjiT.png"></a></p>
<p>所以，添加了注解的RestTemplate对象会被添加一个拦截器LoadBalancerInterceptor， 该拦截器就是后续拦截请求进行负载处理的。</p>
<h2 id="Hystrix熔断器"><a href="#Hystrix熔断器" class="headerlink" title="Hystrix熔断器"></a>Hystrix熔断器</h2><p>属于一种容错机制</p>
<h3 id="服务雪崩相关概念"><a href="#服务雪崩相关概念" class="headerlink" title="服务雪崩相关概念"></a>服务雪崩相关概念</h3><p><strong>服务雪崩效应</strong>：是一种因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大，导致整个系统瘫痪。</p>
<p><a href="https://imgtu.com/i/4VqP1g"><img src="https://z3.ax1x.com/2021/09/15/4VqP1g.png" alt="4VqP1g.png"></a></p>
<p>扇入大，说明该模块复用性好 ，扇出大，说明业务逻辑复杂 ；扇入大是一个好事，扇出大不一定是好事</p>
<p>最下游商品微服务响应时间过长，大量请求阻塞，大量线程不会释放，会导致服务器 资源耗尽，最终导致上游服务甚至整个系统瘫痪</p>
<p><strong>服务雪崩的过程可以分为三个阶段</strong></p>
<p><a href="https://imgtu.com/i/4VLMIP"><img src="https://z3.ax1x.com/2021/09/15/4VLMIP.png" alt="4VLMIP.png"></a></p>
<p><strong>雪崩效应解决方案</strong></p>
<ul>
<li>服务熔断<ul>
<li>熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务不可用或者响应时间太长时，熔断该节点微服务的调用，进行服务的降级，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</li>
</ul>
</li>
<li>服务降级<ul>
<li>整体资源不够用了，先将一些不关紧的服务停掉（调用服务的时候，直接返回一个预留的 值，也叫做兜底数据），待渡过难关高峰过去，再把那些服务打开。</li>
</ul>
</li>
<li>服务限流<ul>
<li>限制总并发数（比如数据库连接池、线程池） </li>
<li>限制瞬时并发数（如nginx限制瞬时并发连接数） </li>
<li>限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速 率） </li>
<li>限制远程接口调用速率、限制MQ的消费速率等</li>
</ul>
</li>
</ul>
<h3 id="Hystrix简介"><a href="#Hystrix简介" class="headerlink" title="Hystrix简介"></a>Hystrix简介</h3><p>Hystrix主 要通过以下几点实现延迟和容错。 </p>
<ul>
<li>包裹请求：使用@HystrixCommand包裹对依赖的调用逻辑。 </li>
<li>跳闸机制：当某服务的错误率超过一定的阈值时，Hystrix可以跳闸，停止请求该服务一段时间。 </li>
<li>资源隔离：Hystrix为每个依赖都维护了一个小型的线程池(舱壁模式)。如果该线程池已满， 发往该 依赖的请求就被立即拒绝，而不是排队等待，从而加速失败判定。 </li>
<li>监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝 的请求等。 </li>
<li>回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑由开发人员 自行提供，例如返回一个缺省值。 </li>
<li>自我修复：断路器打开一段时间后，会自动进入“半开”状态（探测服务是否可用，如还是不可用， 再次退回打开状态）。</li>
</ul>
<h3 id="Hystrix的使用"><a href="#Hystrix的使用" class="headerlink" title="Hystrix的使用"></a>Hystrix的使用</h3><h4 id="熔断处理"><a href="#熔断处理" class="headerlink" title="熔断处理"></a>熔断处理</h4><p>需求：页面静态化微服务调用商品微服务，如果长时间没有响应，则页面静态化微服务快速失败给用户提示</p>
<p><strong>引入依赖</strong>   </p>
<p>服务消费者（静态化微服务）中引入Hystrix依赖（也可以添加在父工程中）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--熔断器Hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>开启熔断</strong></p>
<p>启动类中添加熔断器开启注解@EnableCircuitBreaker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注解简化写法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@SpringCloudApplication</span> =</span></span><br><span class="line"><span class="comment">    	<span class="doctag">@SpringBootApplication</span>+<span class="doctag">@EnableDiscoveryClient</span>+<span class="doctag">@EnableCircuitBreaker</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">// 开启熔断</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageApplication</span> </span>&#123;<span class="comment">// 省略&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>定义服务熔断处理方法</strong></p>
<p>配置@HystrixCommand注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用@HystrixCommand注解进行熔断控制</span></span><br><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    // 线程池标识，要保持唯一，不唯一的话就共用</span></span><br><span class="line"><span class="meta">    threadPoolKey = &quot;port&quot;,</span></span><br><span class="line"><span class="meta">    // 线程池细节属性配置</span></span><br><span class="line"><span class="meta">    threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;1&quot;), // 线程并发数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;20&quot;) // 线程队列最大值，默认-1，不开启</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;) //控制队列最大阈值,默认值5,达到该值后，请求也会被拒绝，需搭配 maxQueueSize 使用</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    // 熔断的一些细节属性配置</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        // 请求超时时间</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;),</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;port&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://spring-service-product/product/port&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可在 spring-service-product提供放的product/port方法上添加一Thread.Sleep() 来模拟超时操作 </p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>使用@HystrixCommand的fallbackMethod属性关联到服务降 级处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务降级</span></span><br><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        // 请求超时时间</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) </span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    fallbackMethod = &quot;fallBack&quot; // 服务降级调用方法</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;port2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">port2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://spring-service-product/product/port02&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务降级调用方法,该方法形参和返回值与原始方法保持一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>; <span class="comment">// 返回兜底数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HysTrix舱壁模式</strong>     </p>
<p>如果不进行任何设置，添加了@HystrixCommand注解的所有熔断方法使用同一个Hystrix线程池（10个线程）,这样很容易导致线程不可以的问题。</p>
<p>为了避免问题服务请求过多导致正常服务无法访问，Hystrix 不是采用增加线程数，而是单独的为每一个 控制方法创建一个线程池的方式，这种模式叫做“舱壁模式”，也是线程隔离的手段。</p>
<p>我们只需要在@HystrixCommand里面设置  threadPoolKey 的值不唯一即可。</p>
<h3 id="Hystrix工作流程与高级应用"><a href="#Hystrix工作流程与高级应用" class="headerlink" title="Hystrix工作流程与高级应用"></a>Hystrix工作流程与高级应用</h3><p><a href="https://imgtu.com/i/4Zep1e"><img src="https://z3.ax1x.com/2021/09/15/4Zep1e.png" alt="4Zep1e.png"></a></p>
<p>1）当调用出现问题时，开启一个时间窗（10s） </p>
<p>2）在这个时间窗内，统计调用次数是否达到最小请求数？ </p>
<p>​        如果没有达到，则重置统计信息，回到第1步 如果达到了，则统计失败的请求数占所有请求数的百分比，是否达到阈值？</p>
<p>​        如果达到，则跳闸（不再请求对应服务） 如果没有达到，则重置统计信息，回到第1步 </p>
<p>3）如果跳闸，则会开启一个活动窗口（默认5s），每隔5s，Hystrix会让一个请求通过,到达那个问题服 务，看是否调用成功，如果成功，重置断路器回到第1步，如果失败，回到第3步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 8秒钟内，请求次数达到2个，并且失败率在50%以上，就跳闸</span></span><br><span class="line"><span class="comment">* 跳闸后活动窗口设置为3s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        //统计窗口时间的设置</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name =</span></span><br><span class="line"><span class="meta">                         &quot;metrics.rollingStats.timeInMilliseconds&quot;,value = &quot;8000&quot;),</span></span><br><span class="line"><span class="meta">        //统计窗口内的最小请求数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name =</span></span><br><span class="line"><span class="meta">                         &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;2&quot;),</span></span><br><span class="line"><span class="meta">        //统计窗口内错误请求阈值的设置 50%</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name =</span></span><br><span class="line"><span class="meta">                         &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;50&quot;),</span></span><br><span class="line"><span class="meta">        //自我修复的活动窗口时间</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name =</span></span><br><span class="line"><span class="meta">                         &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p><strong>以上的所有配在也可以在配置文件中完成</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置熔断策略：</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">	<span class="comment"># 连接池设置</span></span><br><span class="line">    <span class="attr">threadpool:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">            <span class="attr">coreSize:</span> <span class="number">10</span> <span class="comment">#并发执行的最大线程数，默认10</span></span><br><span class="line">            <span class="attr">maxQueueSize:</span> <span class="number">1000</span> <span class="comment">#BlockingQueue的最大队列数，默认值-1</span></span><br><span class="line">            <span class="attr">queueSizeRejectionThreshold:</span> <span class="number">800</span> <span class="comment">#即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝，默认值5</span></span><br><span class="line">    <span class="comment"># 命令设置        </span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">            <span class="attr">circuitBreaker:</span></span><br><span class="line">            	<span class="comment"># 强制打开熔断器，如果该属性设置为true，强制断路器进入打开状态，将会拒绝所有的请求。默认false关闭的</span></span><br><span class="line">                <span class="attr">forceOpen:</span> <span class="literal">false</span></span><br><span class="line">                <span class="comment"># 熔断触发最小请求次数，默认值是20</span></span><br><span class="line">            	<span class="attr">requestVolumeThreshold:</span> <span class="number">2</span></span><br><span class="line">                <span class="comment"># 触发熔断错误比例阈值，默认值50%</span></span><br><span class="line">                <span class="attr">errorThresholdPercentage:</span> <span class="number">50</span></span><br><span class="line">                <span class="comment"># 熔断后休眠时长，默认值5秒</span></span><br><span class="line">                <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">execution:</span></span><br><span class="line">            	<span class="attr">isolation:</span></span><br><span class="line">            		<span class="attr">thread:</span></span><br><span class="line">                        <span class="comment"># 熔断超时设置，默认为1秒</span></span><br><span class="line">                        <span class="attr">timeoutInMilliseconds:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<p>基于springboot的健康检查观察跳闸状态（自动投递微服务暴露健康检查细节）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># springboot中暴露健康检查等断点接口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">        <span class="attr">web:</span></span><br><span class="line">        	<span class="attr">exposure:</span></span><br><span class="line">        		<span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="comment"># 暴露健康接口的细节</span></span><br><span class="line">    <span class="attr">endpoint:</span></span><br><span class="line">        <span class="attr">health:</span></span><br><span class="line">        	<span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>访问健康检查接口：<a href="http://localhost:9100/actuator/health">http://localhost:9100/actuator/health</a></p>
<h2 id="Feign服务调用"><a href="#Feign服务调用" class="headerlink" title="Feign服务调用"></a>Feign服务调用</h2><p>Feign是Netflix开发的一个轻量级RESTful的HTTP服务客户端（用它来发起请求，远程调用），是以Java  <strong>接口注解</strong>  的方式调用Http请求，而不用像之前的RestTemplate技术中通过  <strong>封装HTTP请求报文</strong>  的方式直接调用， Feign被广泛应用在Spring Cloud 的解决方案中。 </p>
<ul>
<li><p>类似于Dubbo，服务消费者拿到服务提供者的接口，然后像调用本地接口方法一样去调用，实际发 出的是远程的请求。 </p>
</li>
<li><p>Feign可帮助我们更加便捷、优雅的调用HTTP API，SpringCloud对Feign进行了增强，使Feign支持了SpringMVC注解（OpenFeign）</p>
</li>
</ul>
<p><strong>效果</strong>：Feign = RestTemplate+Ribbon+Hystrix</p>
<h3 id="Feign的使用"><a href="#Feign的使用" class="headerlink" title="Feign的使用"></a>Feign的使用</h3><p><strong>引入依赖</strong></p>
<p>服务消费者（页面静态化微服务）中引入Feign依赖（或者父类工程）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>启动类开启Feign的支持</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">// 当前项目注册到注册中心</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//  开启Feign，需取消开启熔断，feign自动集成了熔断</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>  去掉Hystrix熔断的支持注解@EnableCircuitBreaker，包括引入的依赖，因为Feign会自动引入，而且RestTemplate也不需要注入。</p>
<p><strong>在消费者微服务中创建Feign接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name表示调用哪一个服务，唯一，所以一个模块的所有controller方法都要定义在该类中</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;spring-service-product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Products <span class="title">getProductById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前端口号请求</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/port&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">port</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ol>
<li><p>@FeignClient注解的name属性用于指定要调用的服务提供者名称，和服务提供者yml文件中 spring.application.name保持一致 </p>
</li>
<li><p>接口中的接口方法，就好比是远程服务提供者Controller中的Hander方法，可以使用@PathVariable、@RequestParam、@RequestHeader 等，这也是OpenFeign对SpringMVC注解的支持，但是需要注意value必须设置，否则会抛出异常</p>
</li>
<li><p>@FeignClient(name = “lagou-service-product”)，name在消费者微服务中只能出现一次，否则报错。所以最好将调用一个 微服务的信息都定义在一个Feign接口中。</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @FeignClient(name = &quot;spring-service-product&quot;)只能注册一次，如果在同一个项目集群中出现多次，则会报错，续添加配置解决</span></span><br><span class="line"><span class="comment">#解决bean重复注册问题</span></span><br><span class="line"><span class="attr">Spring:</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">    	<span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>改造PageController中原有的调用方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Feign接口</span></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> ProductFeign productFeign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用feign调用远程服务</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;queryById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Products <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productFeign.getProductById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getPort&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productFeign.port();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Feign对负载均衡的支持"><a href="#Feign对负载均衡的支持" class="headerlink" title="Feign对负载均衡的支持"></a>Feign对负载均衡的支持</h3><p>Feign 本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖</p>
<p>Feign默认的请求处理超时时长<strong>1s</strong>，有时候我们的业务确实执行的需要一定时间，我们就 需要调整请求处理超时时长，Feign自己有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#针对的被调用方微服务名称,不加就是全局生效</span></span><br><span class="line"><span class="attr">lagou-service-product:</span></span><br><span class="line">    <span class="attr">ribbon:</span></span><br><span class="line">        <span class="comment">#请求连接超时时间</span></span><br><span class="line">        <span class="attr">ConnectTimeout:</span> <span class="number">2000</span></span><br><span class="line">        <span class="comment">#请求处理超时时间</span></span><br><span class="line">        <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment">#对所有操作都进行重试</span></span><br><span class="line">        <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">####根据如上配置，当访问到故障请求的时候，它会再尝试访问一次当前实例（次数由MaxAutoRetries配置），</span></span><br><span class="line">        <span class="comment">####如果不行，就换一个实例进行访问，如果还不行，再换一次实例访问（更换次数由MaxAutoRetriesNextServer配置），</span></span><br><span class="line">        <span class="comment">####如果依然不行，返回失败信息。</span></span><br><span class="line">        <span class="attr">MaxAutoRetries:</span> <span class="number">0</span> <span class="comment">#对当前选中实例重试次数，不包括第一次调用</span></span><br><span class="line">        <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span> <span class="comment">#切换实例的重试次数</span></span><br><span class="line">        <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RoundRobinRule</span> <span class="comment">#负载策略调整</span></span><br></pre></td></tr></table></figure>
<h3 id="Feign对熔断器的支持"><a href="#Feign对熔断器的支持" class="headerlink" title="Feign对熔断器的支持"></a>Feign对熔断器的支持</h3><p><strong>在Feign客户端工程配置文件中需开启Feign对熔断器的支持</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启Feign的熔断功能</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">	<span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ol>
<li>开启Hystrix之后，Feign中的方法都会被hystrix管理，一旦出现问题就进入对应的回退逻辑处理 </li>
<li>针对超时这一点，当前有两个超时时间设置（Feign/hystrix），熔断的时候是根据这两个时间的最小 值来进行的</li>
</ol>
<p>hystrix设置设置时长请参考上面代码。</p>
<p><strong>自定义FallBack处理类(需要实现刚刚编写的Feign接口)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFeignFallback</span> <span class="keyword">implements</span> <span class="title">ProductFeign</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Products <span class="title">getProductById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;999999999999999999&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Feign接口中的@FeignClient注解要声明fallback</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;lagou-service-product&quot;,fallback =ProductFeignFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFeign</span> </span>&#123;<span class="comment">/*省略*/</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Feign对请求压缩和响应压缩的支持"><a href="#Feign对请求压缩和响应压缩的支持" class="headerlink" title="Feign对请求压缩和响应压缩的支持"></a>Feign对请求压缩和响应压缩的支持</h3><p>Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启feign的熔断功能</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 开启请求响应压缩</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span>  <span class="comment"># 设置压缩的数据类型，此处也是默认值</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span>  <span class="comment"># 设置触发压缩的大小下限，此处也是默认值</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>feign多参数问题</strong></p>
<p>如果是get请求，则一定要使用 @RequestParam 注解修饰，如果是post请求，@RequestBody注解只能使用一次。</p>
<h2 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h2><p><strong>网关</strong>：微服务架构中的重要组成部分 局域网中就有网关这个概念，局域网接收或者发送数据出去通过这个网关，比如用Vmware虚拟机 软件搭建虚拟机集群的时候，往往我们需要选择IP段中的一个IP作为网关地址。 而Spring Cloud GateWay只是众多网关解决方案中的一种</p>
<p><strong>网关分类</strong>：</p>
<ul>
<li><p>全局网关 ：全局性质，跟具体的后端业务没有任何关系。如 Nginx + Lua语言</p>
<ul>
<li>功能 : 全局性流控、日志统计（ELK）、防止SQL注入、防止WEB攻击（OWASP十大web应用漏洞）、屏蔽工具扫描、IP黑白名单、证书/加解密处理</li>
</ul>
</li>
<li><p>业务网关 ：针对具体的后端业务系统。如 Zuul、Zuul2、Spring Cloud Gateway</p>
<ul>
<li>功能 : 服务界别流控、服务熔断、降级、路由、负载均衡、灰度策略、过滤、聚合、发现（Eureka）、权限验证、用户等级、业务规则、参数、缓存。</li>
</ul>
</li>
</ul>
<h3 id="GateWay相关概念"><a href="#GateWay相关概念" class="headerlink" title="GateWay相关概念"></a>GateWay相关概念</h3><p>Spring Cloud GateWay 是Spring Cloud的一个全新项目，目标是取代<strong>Netflix Zuul</strong>，性能高于Zuul，官方测试，GateWay是Zuul的1.6倍，旨在为微服务架构提供一种简 单有效的统一的API路由管理方式。</p>
<p><strong>网关在架构中的位置</strong></p>
<p><a href="https://imgtu.com/i/4ZLKkq"><img src="https://z3.ax1x.com/2021/09/15/4ZLKkq.png" alt="4ZLKkq.png"></a></p>
<p><strong>核心概念</strong></p>
<p>Spring Cloud GateWay天生就是异步非阻塞的，基于Reactor模型（同步非阻塞的I/O多路复用机 制） </p>
<p>一个请求—&gt;网关根据一定的条件匹配—匹配成功之后可以将请求转发到指定的服务地址；而在这 个过程中，我们可以进行一些比较具体的控制（限流、日志、黑白名单）</p>
<ul>
<li>路由（route）： 网关最基础的部分，也是网关比较基础的工作单元。路由由一个ID、一个目标 URL（最终路由到的地址）、一系列的断言（匹配条件判断）和Filter过滤器（精细化控制）组成。 如果断言为true，则匹配该路由。 </li>
<li>断言（predicates）：参考了Java8中的断言java.util.function.Predicate，开发人员可以匹配Http 请求中的所有内容（包括请求头、请求参数等）（类似于nginx中的location匹配一样），如果断言 与请求相匹配则路由。 </li>
<li>过滤器（filter）：一个标准的Spring webFilter，使用过滤器，可以在请求之前或者之后执行业务 逻辑。</li>
</ul>
<p><strong>GateWay工作流程</strong></p>
<p><a href="https://imgtu.com/i/4ZLQhV"><img src="https://z3.ax1x.com/2021/09/15/4ZLQhV.png" alt="4ZLQhV.png"></a></p>
<h3 id="GateWay的使用"><a href="#GateWay的使用" class="headerlink" title="GateWay的使用"></a>GateWay的使用</h3><p>网关对静态化微服务进行代理，添加在静态化微服务的上游，相当于隐藏了具体微服务的信息，对外暴露的 是网关。</p>
<p><strong>创建工程lagou-cloud-gateway-server并导入依赖</strong></p>
<p>GateWay不需要使用web模块，它引入的是WebFlux（类似于SpringMVC），所以这里不继承spirng-parent项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring boot 父启动器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--GateWay 网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入webflux--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入Jaxb，开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.10-b140310.1920<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入Jaxb，结束--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Actuator可以帮助你监控和管理Spring Boot应用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--链路追踪--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring cloud依赖版本管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--编译插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--打包插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml 配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment"># 注册中心配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># Eureka Server 地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://EurekaServerA:9201/eureka/,http://EurekaServerB:9202/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-cloud-gateway</span></span><br><span class="line">  <span class="comment"># 网关配置</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service-page-router</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:9101</span></span><br><span class="line">          <span class="attr">predicates:</span>  <span class="comment">#当断言成功后，交给某一个微服务处理时使用的是转发</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/page/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service-product-router</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:9001</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span>  <span class="comment">#去掉uri中的第一部分</span></span><br><span class="line">            <span class="comment"># 所以就要求我们通过网关访问的时候，把uri的第一部分设置为product，从uri的第二部分开始才是真正的uri</span></span><br></pre></td></tr></table></figure>
<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 注册到注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GateWayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p><a href="http://127.0.0.1:9301/page/queryById/1">http://127.0.0.1:9301/page/queryById/1</a> </p>
<p><a href="http://127.0.0.1:9301/product/product/get/1">http://127.0.0.1:9301/product/product/get/1</a>   需多加上product，因为过滤器会去掉uri的第一部分</p>
<h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h3><p>Spring Cloud GateWay 帮我们内置了很多 Predicates功能，实现了各种路由匹配规则（通过 Header、请求参数等作为条件）匹配到对应的路由。</p>
<p><a href="https://imgtu.com/i/4ZXiQS"><img src="https://z3.ax1x.com/2021/09/15/4ZXiQS.png" alt="4ZXiQS.png"></a></p>
<p><strong>时间点后的匹配</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">            <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">                <span class="attr">uri:</span> <span class="string">http://127.0.0.1:9001</span></span><br><span class="line">                <span class="attr">predicates:</span></span><br><span class="line">                	<span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>
<p><strong>时间点前匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Before&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]</span><br></pre></td></tr></table></figure>
<p><strong>时间区间匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Between&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2017-01-21T17:42:47.789-07:00[America&#x2F;Denver]</span><br></pre></td></tr></table></figure>
<p><strong>指定Cookie正则匹配指定值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Cookie&#x3D;chocolate, ch.p</span><br></pre></td></tr></table></figure>
<p><strong>指定Header正则匹配指定值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Header&#x3D;X-Request-Id, \d+</span><br></pre></td></tr></table></figure>
<p><strong>请求Host匹配指定值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Host&#x3D;**.somehost.org,**.anotherhost.org</span><br></pre></td></tr></table></figure>
<p><strong>请求Method匹配指定请求方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">	- Method&#x3D;GET,POST</span><br></pre></td></tr></table></figure>
<p><strong>请求路径正则匹配(最常用)</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>请求包含某参数</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Query=green</span></span><br><span class="line">	<span class="comment"># 请求包含某参数并且参数值匹配正则表达式</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Query=red,</span> <span class="string">gree.</span></span><br></pre></td></tr></table></figure>
<p><strong>远程地址匹配</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>GateWay支持自动从注册中心中获取服务列表并访问，即所谓的动态路由</p>
<ol>
<li>pom.xml中添加注册中心客户端依赖，并编写Eureka配置（上面已引入依赖并配置了Eureka）</li>
<li>动态路由配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-cloud-gateway</span></span><br><span class="line">  <span class="comment"># 网关配置</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service-page-router</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://spring-service-page</span>  <span class="comment"># 动态路由,lb://注册中心中服务器名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/page/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service-product-router</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://spring-service-product</span> <span class="comment"># 动态路由</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：动态路由设置时，uri以 lb: //开头（lb代表从注册中心获取服务），后面是需要转发到的服务名 称</p>
<h3 id="GateWay过滤器"><a href="#GateWay过滤器" class="headerlink" title="GateWay过滤器"></a>GateWay过滤器</h3><p>从过滤器生命周期（影响时机点）的角度来说，主要有两个pre和post</p>
<ul>
<li>pre  ： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选 择 请求的微服务、记录调试信息等。 </li>
<li>post  :  这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等</li>
</ul>
<p>从过滤器类型的角度，Spring Cloud GateWay的过滤器分为GateWayFilter和GlobalFilter两种</p>
<ul>
<li>GateWayFilter     <ul>
<li>应用到单个路由路由上，如配置文件中的filters</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment"># 可以去掉product之后转发</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GlobalFilter          <ul>
<li>应用到所有的路由上，需要实现 GlobalFilter接口，重写filter方法</li>
<li>也可以实现Ordered接口，重写getOrder方法，定义过滤器的优先级</li>
</ul>
</li>
</ul>
<p><strong>案例: 自定义全局过滤器实现IP访问限制（黑白名单）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟黑名单（实际可以去数据库或者redis中查询）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; blackList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        blackList.add(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>); <span class="comment">// 模拟本机地址</span></span><br><span class="line">        blackList.add(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器核心方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 封装了request和response对象的上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain    网关过滤器链（包含全局过滤器和单路由过滤器）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        <span class="comment">// 从 request 中获取用户的主机地址</span></span><br><span class="line">        String host = request.getRemoteAddress().getHostString();</span><br><span class="line">        <span class="comment">// 如果在黑名单内，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(host)) &#123;</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 设置返回状态码:401</span></span><br><span class="line">            String data = <span class="string">&quot;Request be denied&quot;</span>;</span><br><span class="line">            <span class="comment">// 将提示写出去，具体API用法不是很懂。。。</span></span><br><span class="line">            DataBuffer wrap = response.bufferFactory().wrap(data.getBytes());</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(wrap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  返回值表示当前过滤器的顺序(优先级)，数值越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GateWay高可用"><a href="#GateWay高可用" class="headerlink" title="GateWay高可用"></a>GateWay高可用</h3><p>网关作为非常核心的一个部件，如果挂掉，那么所有请求都可能无法路由处理，因此我们需要做 GateWay的高可用。 </p>
<p>启动多个GateWay实例来实现高可用，在GateWay的上游使用 <strong>Nginx</strong>等负载均衡设备进行负载转发以达到高可用的目的。 </p>
<p><strong>Nginx配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置多个GateWay实例</span></span><br><span class="line">upstream gateway &#123;</span><br><span class="line">    server 127.0.0.1:9301; # GateWay实例1</span><br><span class="line">    server 127.0.0.1:9302; # GateWay实例2</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  47.115.139.213; #当前访问的域名</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://gateway; # 反向代理+负载均衡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud-Config-分布式配置中心"><a href="#Spring-Cloud-Config-分布式配置中心" class="headerlink" title="Spring Cloud Config 分布式配置中心"></a>Spring Cloud Config 分布式配置中心</h2><p><strong>单体应用架构</strong>，配置信息的管理、维护并不会显得特别麻烦，手动操作就可以，因为就一个工程；</p>
<p><strong>微服务架构</strong>，分布式集群环境中可能有很多个微服务，我们不可能一个一个去修改配置 然后重启生效，在一定场景下我们还需要在运行期间动态调整配置信息，比如：根据各个微服务的负载 情况，动态调整数据源连接池大小，我们希望配置内容发生变化的时候，微服务可以自动更新</p>
<p><strong>分布式配置中心应用场景</strong></p>
<ol>
<li>集中配置管理，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的 （一次修改、到处生效）</li>
<li>不同环境不同配置，比如数据源配置在不同环境（开发dev,测试test,生产prod）中是不同的</li>
<li>运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等配 置修改后可自动更新</li>
</ol>
<h3 id="搭建分布式配置中心"><a href="#搭建分布式配置中心" class="headerlink" title="搭建分布式配置中心"></a>搭建分布式配置中心</h3><p>Spring Cloud Config是一个分布式配置管理方案，包含了 Server端和 Client端两个部分</p>
<ul>
<li>Server 端：提供配置文件的存储、以接口的形式将配置文件的内容提供出去，启动类中使用 @EnableConfigServer注解</li>
<li>Client 端：通过接口获取配置数据并初始化自己的应用</li>
</ul>
<p><a href="https://imgtu.com/i/4eDJb9"><img src="https://z3.ax1x.com/2021/09/16/4eDJb9.png" alt="4eDJb9.png"></a></p>
<p><strong>前提准备</strong></p>
<ol>
<li><p>登录GitHub，创建项目hui-config</p>
</li>
<li><p>上传yml配置文件，命名规则如下： </p>
<p>{application}-{profile}.yml 或者 {application}-{profile}.properties 。其中，application为应用名称，profile指的是环境（用于区分开发环境，测试环境、生产环境 等） </p>
<p>示例：spring-service-page-dev.yml、spring-service-page-test.yml</p>
</li>
</ol>
<h4 id="构建Server服务端"><a href="#构建Server服务端" class="headerlink" title="构建Server服务端"></a>构建Server服务端</h4><p><strong>新建spring-cloud-config工程，引入依赖坐标（需要注册到Eureka）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka client 客户端依赖引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--config配置中心服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 注册中心</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">// 开启配置服务器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>application.yml配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9400</span></span><br><span class="line"><span class="comment"># 注册中心配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://EurekaServerA:9201/eureka/,http://EurekaServerB:9202/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spirng-cloud-config</span></span><br><span class="line">  <span class="comment"># config配置</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/oddDog-git/hui-config.git</span> <span class="comment"># 配置git服务https地址</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">oddDog-git</span>   <span class="comment"># git用户名</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">*****</span> <span class="comment"># git密码</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">hui-config</span>   <span class="comment"># git中的哪一个项目</span></span><br><span class="line">      <span class="comment"># 读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>访问  <a href="http://127.0.0.1/9400/master/application-dev.yml">http://127.0.0.1/9400/master/application-dev.yml</a>  ,只需指定分支名与文件名称</p>
<h4 id="构建Client客户端"><a href="#构建Client客户端" class="headerlink" title="构建Client客户端"></a>构建Client客户端</h4><p>需求：在spring-service-page微服务中动态获取config server的配置信息</p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置application.yml并修改为bootstrap.yml配置文件</strong></p>
<p>bootstrap.yml是系统级别的，优先级比application.yml高，应用启动时会检查这个配置文件， 在这个配置文件中指定配置中心的服务地址，会自动拉取所有应用配置并且启用。 （主要是把与统一配置中心连接的配置信息放到bootstrap.yml） </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9101</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span> <span class="comment">#config客户端配置,和ConfigServer</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">application</span>  <span class="comment"># 文件名</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span>       <span class="comment"># 后缀名</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span>      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://127.0.0.1:9400</span>  <span class="comment">#ConfigServer配置中心地址  </span></span><br></pre></td></tr></table></figure>
<p><strong>创建Controller获取配置信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mysql.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mysql.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">configInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;username:&quot;</span> + username + <span class="string">&quot;,password:&quot;</span> + password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动测试： <a href="http://127.0.0.1:9101/config/configInfo">http://127.0.0.1:9101/config/configInfo</a></p>
<h3 id="config配置手动刷新"><a href="#config配置手动刷新" class="headerlink" title="config配置手动刷新"></a>config配置手动刷新</h3><p>客户端取到了配置中心的值，但当我们修改GitHub上面的值时，服务端（Config Server）能 实时获取最新的值，但客户端（Config Client）读的是缓存，无法实时获取最新值。我们可以让客户端使用post去触发refresh，获取最新数据。</p>
<p><strong>添加springboot-starter-actuator依赖（父工程中已添加）</strong></p>
<p><strong>bootstrap.yml中添加配置（暴露通信端点）</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># springboot中暴露健康检查等断点接口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">refresh</span>  <span class="comment"># &quot;*&quot;表示暴露所有端口</span></span><br></pre></td></tr></table></figure>
<p><strong>在客户端使用到配置信息的类上添加@RefreshScope注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//手动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123; <span class="comment">/*省略*/</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>启动所有服务，修改git上的值，手动向Client客户端发起POST请求:</p>
<p><a href="http://localhost:9100/actuator/refresh%EF%BC%8C%E5%88%B7%E6%96%B0%E5%8D%95%E4%B8%AA%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">http://localhost:9100/actuator/refresh，刷新单个配置信息</a> (需使用postman测试)</p>
<h3 id="config配置自动刷新"><a href="#config配置自动刷新" class="headerlink" title="config配置自动刷新"></a>config配置自动刷新</h3><p>在微服务架构中，我们可以结合消息总线（Bus）实现分布式配置的自动更新（Spring Cloud Config + Spring Cloud Bus）</p>
<p><strong>消息总线Bus</strong></p>
<p>基于MQ的，支持RabbitMq/Kafka。即MQ消息代理构建一个共用的Topic，通过这个Topic连接各个微服务实例，MQ广播的消息会被所有在注册中心的微服务实例监听和消费。</p>
<p><a href="https://imgtu.com/i/4esD7d"><img src="https://z3.ax1x.com/2021/09/16/4esD7d.png" alt="4esD7d.png"></a></p>
<p>这里选择使用rabbitMq，ConfigServer和ConfigClient都添加消息总线的支持 以及与RabbitMq的连接信息</p>
<p><strong>前提准备</strong></p>
<p>在Linux服务器上安装并开启RabbitMq，通过   <strong><a href="http://ip地址:15672/">http://ip地址:15672/</a></strong>     访问是否开启成功</p>
<p><strong>Config 服务端和客户端添加消息总线支持</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>服务端和客户端都添加RabbiMq配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RabbitMq</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span>  </span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<p><strong>Config Server微服务暴露端口</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># springboot中暴露健康检查等断点接口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">bus-refresh</span>   <span class="comment"># &quot;*&quot;表示暴露所有端口</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>重启各个服务，修改git上的值后，向配置中心服务端发送POST请求:</p>
<p><a href="http://127.0.0.1:9400/actuator/bus-refresh">http://127.0.0.1:9400/actuator/bus-refresh</a>  ，所有客户端中的配置都会刷新</p>
<p>如果只想刷新单个客户端，则访问</p>
<p><a href="http://localhost:9400/actuator/bus-refresh/spring-service-page:9101">http://localhost:9400/actuator/bus-refresh/spring-service-page:9101</a> ，加上 <strong>服务名:端口号</strong> 即可</p>
<h1 id="第二代核心组件SCA"><a href="#第二代核心组件SCA" class="headerlink" title="第二代核心组件SCA"></a>第二代核心组件SCA</h1><p>Spring Cloud第一代核心组件主要以Netflix开源为主，而第二代核心组件Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服 务的必需组件。</p>
<p><a href="https://imgtu.com/i/4eyGDg"><img src="https://z3.ax1x.com/2021/09/16/4eyGDg.png" alt="4eyGDg.png"></a></p>
<p><strong>阿里开源组件</strong> </p>
<ul>
<li>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 </li>
<li>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 </li>
<li>RocketMQ：开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布 与订阅服务。 </li>
<li>Dubbo：这个就不用多说了，在国内应用非常广泛的一款高性能 Java RPC 框架。 </li>
<li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 </li>
<li>Arthas：开源的Java动态追踪工具，基于字节码增强技术，功能非常强大。</li>
</ul>
<p>Spring Cloud Alibaba 作为整套的微服务解决组件，只依靠目前阿里的开源组件是不够的，更多的是集 成当前的社区组件，所以 Spring Cloud Alibaba 可以集成 Zuul，GateWay等网关组件，也可继承 Ribbon、OpenFeign等组件。</p>
<h2 id="Nacos服务支持和配置中心"><a href="#Nacos服务支持和配置中心" class="headerlink" title="Nacos服务支持和配置中心"></a>Nacos服务支持和配置中心</h2><p>Nacos （Dynamic Naming and Configuration Service）是阿里巴巴开源的一个针对微服务架构中 服务发现、配置管理和服务管理平台。</p>
<p>Nacos就是注册中心+配置中心的组合（<strong>Nacos=Eureka + Config + Bus</strong>）</p>
<p><strong>Nacos功能</strong></p>
<ul>
<li>服务发现与健康检查 </li>
<li>动态配置管理 </li>
<li>动态DNS服务 </li>
<li>服务和元数据管理<ul>
<li>nacos有一个ui页面，可以看到注册的服务及其实例信息 （元数据信息）、动态的服务权重调整、动态服务优雅下线</li>
</ul>
</li>
</ul>
<h3 id="Nacos单例服务器部署"><a href="#Nacos单例服务器部署" class="headerlink" title="Nacos单例服务器部署"></a>Nacos单例服务器部署</h3><p><strong>下载并解压Nacos安装包，执行命令启动</strong></p>
<p>这里使用最近比较稳定的版本 nacos-server-1.2.0.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&#x2F;mac：sh startup.sh -m standalone</span><br><span class="line">windows：cmd startup.cmd  &#x2F;&#x2F; 直接双击也行</span><br></pre></td></tr></table></figure>
<p>访问nacos控制台：<a href="http://127.0.0.1:8848/nacos/#/login">http://127.0.0.1:8848/nacos/#/login</a> 或者 <a href="http://127.0.0.1:8848/nacos/index.html%EF%BC%88%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A38848%EF%BC%8C%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81">http://127.0.0.1:8848/nacos/index.html（默认端口8848，账号和密码</a> nacos/nacos）</p>
<p><a href="https://imgtu.com/i/4e6ER0"><img src="https://z3.ax1x.com/2021/09/16/4e6ER0.png" alt="4e6ER0.png"></a></p>
<h3 id="微服务注册到Nacos"><a href="#微服务注册到Nacos" class="headerlink" title="微服务注册到Nacos"></a>微服务注册到Nacos</h3><p><strong>在父pom中引入SCA依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCA --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>在商品服务提供者工程中引入nacos客户端依赖，必须去除eureka-client依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改application.yml，添加nacos配置信息</strong></p>
<p>在yml文件中需要删除调用config和eureka相关的配置，否则启动失败</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  <span class="comment">#nacos server 地址</span></span><br></pre></td></tr></table></figure>
<p><strong>启动商品微服务，观察Nacos控制台</strong></p>
<p><a href="https://imgtu.com/i/4ec74A"><img src="https://z3.ax1x.com/2021/09/16/4ec74A.png" alt="4ec74A.png" style="zoom:150%;" /></a></p>
<p><strong>保护阈值</strong>：可以设置为0-1之间的浮点数，它其实是一个比例值</p>
<p>当一个集群中  健康实例数/总实例数 &lt; 保护阈值 时，保护阈值 会被触发（状态true）</p>
<p>nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不 健康的实例，请求失败，但这样也比造成雪崩要好，牺牲了一些请求，保证了整个系统的一个可用。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Nacos客户端引入的时候，会关联引入Ribbon的依赖包，Ribbon与Hystrix都按原来方式进行配置即可</p>
<p>之前使用OpenFeign与Eureka时都会自动引入Ribbon依赖。</p>
<h3 id="Nacos-数据模型（领域模型）"><a href="#Nacos-数据模型（领域模型）" class="headerlink" title="Nacos 数据模型（领域模型）"></a>Nacos 数据模型（领域模型）</h3><p>Nacos抽象出了Namespace、Group、Service、DataId等概念，具体代表什么取决于怎么用（非 常灵活），推荐用法如下</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Namespace</td>
<td>代表不同的环境，如开发dev、测试test、生产环境prod</td>
</tr>
<tr>
<td>Group</td>
<td>代表某项目，比如拉勾云项目</td>
</tr>
<tr>
<td>Service</td>
<td>某个项目中具体xxx服务</td>
</tr>
<tr>
<td>DataId</td>
<td>某个项目中具体的xxx配置文件</td>
</tr>
</tbody></table>
<p><strong>Namespace + Group + Service  是为 了锁定服务</strong> </p>
<p><strong>Namespace + Group + DataId  是为 了锁定配置文件</strong></p>
<p>Namespace命名空间、Group分组、集群这些都是为了进行归类管理，把服务和配置文件进行归 类，归类之后就可以实现一定的效果，比如隔离</p>
<h3 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h3><p>之前使用 Spring Cloud Config + Bus ，需要用到GitHub与RabbitMq，比较繁琐</p>
<p>而Nacos分布式配置就比较的简单，只需在Nacos控制台中添加配置信息，微服务项目添加一些配置就直接就可获取</p>
<h4 id="Nacos-Server添加配置"><a href="#Nacos-Server添加配置" class="headerlink" title="Nacos Server添加配置"></a>Nacos Server添加配置</h4><p>可以创建不用环境下的命名空间，如dev、test、prod</p>
<p>在控制台配置管理中的配置列表选择命名空间，默认public，选择添加配置信息按钮</p>
<p><a href="https://imgtu.com/i/4ecTNd"><img src="https://z3.ax1x.com/2021/09/16/4ecTNd.png" alt="4ecTNd.png"></a></p>
<h4 id="微服务中获取Nacos配置信息"><a href="#微服务中获取Nacos配置信息" class="headerlink" title="微服务中获取Nacos配置信息"></a>微服务中获取Nacos配置信息</h4><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>微服务中如何锁定 Nacos Server 中的配置文件（dataId）</strong></p>
<p>通过 Namespace + Group + dataId 来锁定配置文件，Namespace不指定就默认public，Group不 指定就默认 DEFAULT_GROUP</p>
<p><strong>dataId 的完整格式如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。 </li>
<li>spring.profile.active 即为当前环境对应的 profile。 <ul>
<li>当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</li>
</ul>
</li>
<li>file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类 型。</li>
</ul>
<p><strong>添加配置，配置文件需要修改成bootstrap.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-service-page</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  <span class="comment">#nacos server 地址</span></span><br><span class="line">      <span class="comment"># 获取nacos配置</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  <span class="comment">#nacos server 地址</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">81015dac-73a9-4d39-8fb1-74230a8c46cc</span>  <span class="comment">#命名空间的ID</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span>   <span class="comment"># 如果使用的默认分组,可以不设置</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span>  <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="comment"># 获取当前命名空间的其他配置文件</span></span><br><span class="line">        <span class="string">ext-config[0]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">pageA.yaml</span>  <span class="comment"># dataId</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 组</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span>        <span class="comment"># 是否自动刷新</span></span><br><span class="line">        <span class="string">ext-config[1]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">pageB.yaml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>在Controller中测试获取远程配置</strong></p>
<p>原生注解 @RefreshScope 实现配置自动更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;config&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//手动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 从nacos的配置中获取</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;message.text&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pageA&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String pageA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pageB&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String pageB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;query&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text+<span class="string">&quot;--&quot;</span>+pageA+<span class="string">&quot;--&quot;</span>+pageB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Sentinel分布式系统流量的防卫兵"><a href="#Sentinel分布式系统流量的防卫兵" class="headerlink" title="Sentinel分布式系统流量的防卫兵"></a>Sentinel分布式系统流量的防卫兵</h2><p>Sentinel是一个面向云原生微服务的流量控制、熔断降级组件。 替代Hystrix。</p>
<p>解决问题：服务雪崩、服务降级、服务熔断、服务限流</p>
<p><strong>Hystrix</strong>   没有控制台，只能使用@HystrixCommand来配置熔断，严重的代码入侵</p>
<p><strong>Sentinel</strong>  独立部署Dashboard/控制台组件，直接通过UI界面动态完成细粒度控制</p>
<p>Sentinel 分为两个部分: </p>
<ul>
<li>核心库：（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 </li>
<li>控制台：（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等 应用容器。</li>
</ul>
<p>Sentinel 的主要特性：</p>
<p><a href="https://imgtu.com/i/4ehKcn"><img src="https://z3.ax1x.com/2021/09/16/4ehKcn.png" alt="4ehKcn.png"></a></p>
<h3 id="部署Sentinel"><a href="#部署Sentinel" class="headerlink" title="部署Sentinel"></a>部署Sentinel</h3><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a> 这里使用版本:v1.7.1 </p>
<p>启动：java -jar sentinel-dashboard-1.7.1.jar    </p>
<p>访问 <a href="http://localhost:8080/">http://localhost:8080</a> , 用户名/密码：sentinel/sentinel</p>
<h3 id="改造微服务项目"><a href="#改造微服务项目" class="headerlink" title="改造微服务项目"></a>改造微服务项目</h3><p>“静态化微服务”调用了“商品微服务”，在静态化微服务进行的熔断降级等控制，这里改造静态化微服务</p>
<p><strong>引入Sentinel核心包</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改application.yml</strong></p>
<p>删除原有hystrix配置，删除 原有OpenFeign的降级配置,依然需要暴露断点</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#解决bean重复注册问题</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># sentinel配置</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span> <span class="comment"># 指定sentinel控制台的地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span>  <span class="comment"># 在微服务启动时会启动一个Http Server,该Server的作用是与sentinel的dashboard经行交互 push</span></span><br><span class="line"><span class="comment"># springboot中暴露健康检查等断点接口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="comment"># 暴露健康接口的细节</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span> </span><br></pre></td></tr></table></figure>
<p><strong>启动静态化微服务</strong></p>
<p>控制台没有任何变化，因为懒加载，只需要随机发起一次请求触发即可</p>
<h3 id="Sentinel流量规则"><a href="#Sentinel流量规则" class="headerlink" title="Sentinel流量规则"></a>Sentinel流量规则</h3><p> <strong>Sentinel 关键概念</strong></p>
<ul>
<li>资源<ul>
<li>它可以是 Java 应用程序中的任何内容，我们请求的API接口就是资源</li>
</ul>
</li>
<li>规则<ul>
<li>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规 则。所有规则可以动态实时调整。</li>
</ul>
</li>
</ul>
<p>系统并发能力有限，比如系统A的QPS支持1个，如果太多请求过来，那么A就应该进行流量控制 了，比如直接拒绝其他请求</p>
<p><a href="https://imgtu.com/i/4eo0Re"><img src="https://z3.ax1x.com/2021/09/16/4eo0Re.png" alt="4eo0Re.png"></a></p>
<ul>
<li><p>资源名：默认请求路径 </p>
</li>
<li><p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名称，默认default（不区分来源） </p>
</li>
<li><p>阈值类型/单机阈值 </p>
<ul>
<li>QPS：（每秒钟请求数量）当调用该资源的QPS达到阈值时进行限流</li>
<li>线程数：当调用该资源的线程数达到阈值的时候进行限流 </li>
</ul>
</li>
<li><p>是否集群：是否集群限流 </p>
</li>
<li><p>流控模式： </p>
<ul>
<li>直接：资源调用达到限流条件时，直接限流 </li>
<li>关联：关联的资源调用达到阈值时候限流自己 </li>
<li>链路：只记录指定链路上的流量 </li>
</ul>
</li>
<li><p>流控效果： </p>
<ul>
<li>快速失败：直接失败，抛出异常 </li>
<li>Warm Up：根据冷加载因子（默认3）的值，从阈值/冷加载因子，经过预热时长，才达到设置的 QPS阈值 </li>
<li>排队等待：匀速排队，让请求匀速通过，阈值类型必须设置为QPS，否则无效 </li>
</ul>
</li>
</ul>
<h4 id="流控模式之关联限流"><a href="#流控模式之关联限流" class="headerlink" title="流控模式之关联限流"></a>流控模式之关联限流</h4><p><a href="https://imgtu.com/i/4eT1Ff"><img src="https://z3.ax1x.com/2021/09/16/4eT1Ff.png" alt="4eT1Ff.png" style="zoom:67%;" /></a></p>
<p>比如用户注册接口，需要调用手机短信校验接口，如果手机短信校验接口请求达到阈值，使用关联，可以对用户注册接口进行限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟注册，注册时要调用手机短信验证，如果手机短信验证出问题了，就应该对注册功能限流，防止雪崩</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;registry&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">registry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;注册&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟获取手机短信功能</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;phoneVerify&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">phoneVerify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;短信验证&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用Postman对手机短信接口密集式请求，会发现用户注册接口被限流</p>
<h4 id="流控模式之链路限流"><a href="#流控模式之链路限流" class="headerlink" title="流控模式之链路限流"></a>流控模式之链路限流</h4><p>链路指的是请求链路（调用链：A–&gt;C，B–&gt;C） </p>
<p><a href="https://imgtu.com/i/4eHcZR"><img src="https://z3.ax1x.com/2021/09/16/4eHcZR.png" alt="4eHcZR.png" style="zoom: 67%;" /></a></p>
<p>上图中来自入口 A 和 B  的请求都调用到了资源 C ，Sentinel 允许只根据某个 调用入口的统计信息对资源限流。比如链路模式下设置入口资源为 A ,表示只有从入口 A 的调用才会记录到 C 的限流统计当中，而不关心经 B 入口 到来的调用</p>
<p><a href="https://imgtu.com/i/4ebJSO"><img src="https://z3.ax1x.com/2021/09/16/4ebJSO.png" alt="4ebJSO.png" style="zoom: 67%;" /></a></p>
<h4 id="流控效果之Warm-up"><a href="#流控效果之Warm-up" class="headerlink" title="流控效果之Warm up"></a>流控效果之Warm up</h4><p>通过 Warm Up 模式（预热模式），让通过的流量缓慢增加，经过设置的<strong>预热时间</strong>以后，到达系统 处理请求速率的设定值。 </p>
<p>Warm Up 模式默认会从设置的 QPS 阈值的 1/3 开始慢慢往上增加至 QPS 设置值。</p>
<p>例如：预热时间为10s, QPS值为10，系统刚启动，在10秒内QPS值会从 10*（1/3） 变成 10，防止瞬间把系统压垮</p>
<h4 id="流控效果之排队等待"><a href="#流控效果之排队等待" class="headerlink" title="流控效果之排队等待"></a>流控效果之排队等待</h4><p>很多流量过来并超过阈值，并不是直接拒绝请求，而是请求进行排队，一个一个匀速通过（处理），请求能 等就等着被处理，如果  等待时间&gt;超时时间 ，就会被拒绝 </p>
<p>例如，QPS 配置为 5，则代表请求每 200 ms 才能通过一个，多出的请求将排队等待通过。超时时 间代表最大排队时间，超出最大排队时间的请求将会直接被拒绝。排队等待模式下，QPS 设置值不要超 过 1000（请求间隔 1 ms）。</p>
<h3 id="Sentinel降级规则"><a href="#Sentinel降级规则" class="headerlink" title="Sentinel降级规则"></a>Sentinel降级规则</h3><p>流控是对外部来的大流量进行控制，熔断降级的视角是对内部问题进行处理。</p>
<p>Sentinel 降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这 个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p>
<p>当资源被降级后， 在接下来的降级时间窗口之内，对该资源的调用都自动熔断，这里的降级其实是<strong>Hystrix中的熔断</strong>。</p>
<p>Sentinel不会像Hystrix那样放过一个请求尝试自我修复，而是明确按照时间窗口来，熔断触发 后，时间窗口内拒绝请求，时间窗口后就恢复。</p>
<h4 id="RT（平均响应时间-）"><a href="#RT（平均响应时间-）" class="headerlink" title="RT（平均响应时间 ）"></a>RT（平均响应时间 ）</h4><p><a href="https://imgtu.com/i/4eXkB4"><img src="https://z3.ax1x.com/2021/09/16/4eXkB4.png" alt="4eXkB4.png"></a></p>
<p>降级后会对该方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可 以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p>
<h4 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h4><p>异常比率的阈值范围是 [0.0, 1.0] ，代表 0% - 100%</p>
<p>在1s中请求发生异常的比例超过阈值时，资源进入降级状态</p>
<h4 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h4><p>当资源近 1 分钟的异常数目超过阈值之后会进行熔断。</p>
<p>注意由于统计时间窗口是分钟级别的，若 时间窗口小于 60s，则结束熔断状态后仍可能再进入熔断状态，所以设置 时间窗口 &gt;= 60s。</p>
<h2 id="SCA-小结"><a href="#SCA-小结" class="headerlink" title="SCA 小结"></a>SCA 小结</h2><p>SCA实际上发展了三条线 </p>
<ul>
<li>第一条线：开源出来一些组件 </li>
<li>第二条线：阿里内部维护了一个分支，自己业务线使用 </li>
<li>第三条线：阿里云平台部署一套，付费使用 </li>
</ul>
<p>从战略上来说，SCA更是为了贴合阿里云。 目前来看，开源出来的这些组件，推广及普及率不高，社区活跃度不高，稳定性和体验度上仍需进 一步提升，根据实际使用来看Sentinel的稳定性和体验度要好于Nacos。</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2021/09/21/ElasticSearch/</url>
    <content><![CDATA[<p>我们生活中的数据总体分为两种：</p>
<ul>
<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。 </li>
<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word 文档等磁盘上的文件</li>
</ul>
<a id="more"></a>

<p>机构化数据可以使用SQL语句进行查询，非结构化数据可使用 顺序扫描法(Serial Scanning) 与 全文检索(Full-text Search) 经行查询</p>
<p><strong>全文检索(Full-text Search)</strong></p>
<p>建立索引 –&gt;  检索索引</p>
<p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在 文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果 反馈给用户的检索方法。这个过程类似于通过字典的目录查字的过程。</p>
<h1 id="lucene相关概念"><a href="#lucene相关概念" class="headerlink" title="lucene相关概念"></a>lucene相关概念</h1><p>Lucene 能够实现全文检索。Lucene 是 apache 下的一个开放源代码的全文检索引擎工具包。提 供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene 的目的是 为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。</p>
<p><strong>Lucene的特性</strong></p>
<ul>
<li>稳定、索引性能高</li>
<li>高效、准确、高性能的搜索算法</li>
<li>跨平台</li>
</ul>
<p><strong>lucene架构</strong></p>
<p><a href="https://imgtu.com/i/4JOFHA"><img src="https://z3.ax1x.com/2021/09/21/4JOFHA.png" alt="4JOFHA.png"></a></p>
<p><strong>索引过程</strong></p>
<p>确定原始内容–&gt;采集文档–&gt;创建文档–&gt;分析文档–&gt;索引文档</p>
<p><strong>搜索过程</strong></p>
<p>用户通过搜索界面–&gt;创建查询–&gt;执行搜索，从索引库搜索–&gt;渲染搜索结果</p>
<p><strong>核心概念</strong></p>
<ul>
<li>Document： 一条记录 经过索引之后，就是以一个Document的形式存储在索引文件中的。用户进行搜索，也是以Document 列表的形式返回。 </li>
<li>Field :<ul>
<li> 一个Document可以包含多个信息域，这些信息域就是通过Field在Document中存储的.</li>
<li>Field有两个属性可选：<strong>存储和索引</strong>。存储属性你可以控制是否对这个Field进行存储；索引 属性你可以控制是否对该Field进行索引。 </li>
</ul>
</li>
<li>Term： Term是搜索的最小单位，它表示文档的一个词语，Term由两部分组成：它表示的词语和这个词语所 出现的Field的名称。</li>
</ul>
<p><strong>倒排索引</strong></p>
<p>倒排索引记录每个词条出现在哪些文档，及在文档中的位置，可以根据词条快速定位到包含这个词条的 文档及出现的位置。</p>
<p>创建倒排索引，分为以下几步：</p>
<p>1）创建文档列表：  lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</p>
<p><a href="https://imgtu.com/i/4JX8qH"><img src="https://z3.ax1x.com/2021/09/21/4JX8qH.png" alt="4JX8qH.png"></a></p>
<p>2）创建倒排索引列表 ：  对文档中数据进行分词，得到词条（分词后的一个又一个词）。对词条进行编号，以词条创建索引。然 后记录下包含该词条的所有文档编号（及其它信息）。</p>
<p><a href="https://imgtu.com/i/4JX6ds"><img src="https://z3.ax1x.com/2021/09/21/4JX6ds.png" alt="4JX6ds.png"></a></p>
<p>搜索的过程： 当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这 些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。然后根据 这些编号去文档列表中找到文档.</p>
<h1 id="lucene的使用"><a href="#lucene的使用" class="headerlink" title="lucene的使用"></a>lucene的使用</h1><p>需求 : 生成职位信息索引库，从索引库检索数据</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>前提: 创建数据库es，将sql脚本导入数据库执行。（详情省略）</p>
<p>第一步：创建一个SpringBoot项目 </p>
<p>第二步：导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring boot 父启动器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--pojo持久化使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入Lucene核心包及分词器包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三步：启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hui.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuceneFirstApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LuceneFirstApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步：配置properties文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/es?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 驼峰命名</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>第五步：创建实体类、mapper、service </p>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;job_info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> String companyAddr;</span><br><span class="line">    <span class="keyword">private</span> String companyInfo;</span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line">    <span class="keyword">private</span> String jobAddr;</span><br><span class="line">    <span class="keyword">private</span> String jobInfo;</span><br><span class="line">    <span class="keyword">private</span> Integer salaryMin;</span><br><span class="line">    <span class="keyword">private</span> Integer salaryMax;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobInfoMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">JobInfo</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobInfoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="function">List&lt;JobInfo&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">JobInfoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobInfoMapper jobInfoMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;JobInfo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryWrapper&lt;JobInfo&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> jobInfoMapper.selectList(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第六步：测试</p>
<p>省略</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuceneManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 用来获取数据库数据</span></span><br><span class="line">    <span class="keyword">private</span> JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建索引</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createIndexWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置索引文件所在的位置</span></span><br><span class="line">        Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;C:\\project\\javaCode\\esCode\\index&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置索引相关配置----版本、分词器</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(); <span class="comment">// 标准分词器</span></span><br><span class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(Version.LATEST, analyzer);</span><br><span class="line">        <span class="comment">// 1. 创建索引---指定位置、配置</span></span><br><span class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, indexWriterConfig);</span><br><span class="line">        indexWriter.deleteAll();<span class="comment">// 删除原先索引的数据</span></span><br><span class="line">        <span class="comment">// 2. 数据库获取源信息</span></span><br><span class="line">        List&lt;JobInfo&gt; jobInfoList = jobInfoService.getList();</span><br><span class="line">        <span class="comment">// 3. 遍历源信息，分别创建document对象</span></span><br><span class="line">        <span class="keyword">for</span> (JobInfo jobInfo : jobInfoList) &#123;</span><br><span class="line">            Document document = <span class="keyword">new</span> Document();</span><br><span class="line">            <span class="comment">// 创建Field域</span></span><br><span class="line">            document.add(<span class="keyword">new</span> LongField(<span class="string">&quot;id&quot;</span>, jobInfo.getId(), Field.Store.YES));</span><br><span class="line"></span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;companyName&quot;</span>, jobInfo.getCompanyName(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;companyAddr&quot;</span>, jobInfo.getCompanyAddr(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;companyInfo&quot;</span>, jobInfo.getCompanyInfo(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;jobName&quot;</span>, jobInfo.getJobName(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;jobAddr&quot;</span>, jobInfo.getJobAddr(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;jobInfo&quot;</span>, jobInfo.getJobInfo(), Field.Store.YES));</span><br><span class="line"></span><br><span class="line">            document.add(<span class="keyword">new</span> IntField(<span class="string">&quot;salaryMin&quot;</span>, jobInfo.getSalaryMin(), Field.Store.YES));</span><br><span class="line">            document.add(<span class="keyword">new</span> IntField(<span class="string">&quot;salaryMax&quot;</span>, jobInfo.getSalaryMax(), Field.Store.YES));</span><br><span class="line"></span><br><span class="line">            document.add(<span class="keyword">new</span> StoredField(<span class="string">&quot;url&quot;</span>, jobInfo.getUrl()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 索引添加document</span></span><br><span class="line">            indexWriter.addDocument(document);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;create index success！！！&quot;</span>);</span><br><span class="line">        <span class="comment">// 5. 关闭资源</span></span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Field详情</strong></p>
<p>Document(文档)是Field(域)的承载体, 一个Document由多个Field组成. Field由名称和值两部分组成, Field的值是要索引的内容, 也是要搜索的内容.</p>
<ul>
<li>是否分词(tokenized)   如: 订单编号, 身份证号, 是一个整体, 分词以后就失去了意义, 故不需要分词.</li>
<li>是否索引(indexed)   如: 商品图片路径, 不会作为查询条件, 不需要建立索引.</li>
<li>是否存储(stored)   如: 商品描述. 内容多格式大, 不需要直接在搜索结果页面展现, 不做存储. 需要的时候可 以从关系数据库取.</li>
</ul>
<p><strong>常用的Field类型</strong></p>
<p><a href="https://imgtu.com/i/4Jvhb4"><img src="https://z3.ax1x.com/2021/09/21/4Jvhb4.png" alt="4Jvhb4.png"></a></p>
<h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchIndexWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 指定索引文件的存储位置</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;C:\\project\\javaCode\\esCode\\index&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建读索引对象,指定位置</span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">    <span class="comment">// 创建查询索引对象,指定读索引对象</span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">    <span class="comment">// 使用term查询：指定查询的域名和关键字</span></span><br><span class="line">    Query query = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">&quot;companyName&quot;</span>, <span class="string">&quot;北&quot;</span>));</span><br><span class="line">    <span class="comment">// 执行查询操作，并获取返回结果</span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalHits = topDocs.totalHits;  <span class="comment">//查询的总数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;总条数:&quot;</span> + totalHits);</span><br><span class="line"></span><br><span class="line">    ScoreDoc[] scoreDocs = topDocs.scoreDocs; <span class="comment">//获取命中的文档</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</span><br><span class="line">        <span class="comment">// 获取文档的id</span></span><br><span class="line">        <span class="keyword">int</span> docId = scoreDoc.doc;</span><br><span class="line">        <span class="comment">// 根据id查询文档</span></span><br><span class="line">        Document document = indexSearcher.doc(docId);</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;companyName&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;companyAddr&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;companyInfo&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;jobName&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;jobAddr&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;jobInfo&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;salaryMin&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;salaryMax&quot;</span>));</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;url&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;***********************************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    indexReader.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="中文分词器的使用"><a href="#中文分词器的使用" class="headerlink" title="中文分词器的使用"></a>中文分词器的使用</h2><p>上面查看结果会发现，如果关键字是”北京”会没有数据，如果关键字是“北”就可以搜索到数据，原因是因为 中文会一个字一个字的分词，显然是不合适的，所以我们需要使用可以合理分词的分词器，其中最有名 的是IKAnalyzer分词器</p>
<p>第一步：导依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--IK中文分词器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janeluo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ikanalyzer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2012_u6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步 创建索引时使用IKanalyzer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createIndexWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置索引文件所在的位置</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;C:\\project\\javaCode\\esCode\\index&quot;</span>));</span><br><span class="line">    <span class="comment">// 设置索引相关配置----版本、分词器</span></span><br><span class="line">    <span class="comment">// Analyzer analyzer = new StandardAnalyzer(); // 标准分词器</span></span><br><span class="line">    Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer(); <span class="comment">// ik分词器</span></span><br><span class="line">    <span class="comment">// 1. 创建索引---指定位置、配置</span></span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, indexWriterConfig);</span><br><span class="line">    <span class="comment">// 。。。上面有，省略。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ElasticSearch介绍与安装"><a href="#ElasticSearch介绍与安装" class="headerlink" title="ElasticSearch介绍与安装"></a>ElasticSearch介绍与安装</h1><p>es功能： </p>
<ul>
<li>分布式的搜索引擎：百度、Google、站内搜索 </li>
<li>全文检索：提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能 </li>
<li>数据分析引擎（分组聚合）：电商网站—一周内手机销量Top10 </li>
<li>对海量数据进行近乎实时处理：水平扩展，每秒钟可处理海量事件，同时能够自动管理索引和查询在集 群中的分布方式，以实现极其流畅的操作。</li>
</ul>
<p>Elastic有一条完整的产品线：Elasticsearch、Logstash、Kibana等，前面说的三个就是大家常说的ELK 技术栈（开源实时日志分析平台）。</p>
<p><a href="https://imgtu.com/i/4Jz2BF"><img src="https://z3.ax1x.com/2021/09/21/4Jz2BF.png" alt="4Jz2BF.png"></a></p>
<p>Logstash 的作用就是一个数据收集器，将各种格式各种渠道的数据通过它收集解析之后格式化输出到 Elasticsearch ，最后再由 Kibana 提供的比较友好的 Web 界面进行汇总、分析、搜索</p>
<p>Elasticsearch官网：<a href="https://www.elastic.co/cn/products/elasticsearch">https://www.elastic.co/cn/products/elasticsearch</a></p>
<p>目前Elasticsearch最新的版本是7.x，企业内目前用的比较多是6.x，这里使用的是6.2.4，需要JDK1.8 及以上。</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>1）下载好压缩包  elasticsearch-6.2.4.zip  ，并解压</p>
<p>2）修改配置文件</p>
<p>打开 config/elasticsearch.yml 文件,修改33与37行 数据与日志存放的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.data: c:\data</span><br><span class="line"></span><br><span class="line">path.logs: c:\log</span><br></pre></td></tr></table></figure>
<p>3）进入bin目录中直接双击  elasticsearch.bat 命令</p>
<p>如果启动失败，需要修改虚拟机内存的大小 ，打开config/jvm.options文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure>
<ul>
<li>Xms 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会 导致机器暂时间变慢。 </li>
<li>Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了 这个设置值，就会抛出OutOfMemory异常。</li>
</ul>
<p><strong>访问</strong></p>
<p>可以看到绑定了两个端口: </p>
<ul>
<li>9300：集群节点间通讯接口，接收tcp协议 </li>
<li>9200：客户端访问接口，接收Http协议 </li>
</ul>
<p>我们在浏览器中访问：<a href="http://127.0.0.1:9200/">http://127.0.0.1:9200</a></p>
<h2 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h2><p>Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具,提供了操作Elasticsearch索引数据的控制台。</p>
<p><strong>注意</strong>    需安装Node.js</p>
<p>1）下载压缩包，并解压，版本要与es保持一致</p>
<p>2）修改 config/kibana.yml 配置文件,指定es服务器地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch.url: &quot;http:&#x2F;&#x2F;127.0.0.1:9200&quot;</span><br></pre></td></tr></table></figure>
<p>3）进入bin目录，双击kibana.bat 命令</p>
<p>4）访问：<a href="http://127.0.0.1:5601/">http://127.0.0.1:5601</a></p>
<h2 id="安装Ik分词器"><a href="#安装Ik分词器" class="headerlink" title="安装Ik分词器"></a>安装Ik分词器</h2><p>下载地址  <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>1）解压elasticsearch-analysis-ik-6.2.4.zip后,将解压后的文件夹拷贝到elasticsearch-6.2.4\plugins 下，并重命名文件夹为ik</p>
<p>2）重新启动ElasticSearch，即可加载IK分词器</p>
<p>​    ik分词器 有ik_max_word 与 ik_smart 两种模式</p>
<h2 id="安装Head插件"><a href="#安装Head插件" class="headerlink" title="安装Head插件"></a>安装Head插件</h2><p>elasticsearch-head是一个界面化的集群操作和管理工具，可以对集群进行傻瓜式操作。你可以通过 插件把它集成到es（首选方式）,也可以安装成一个独立webapp。</p>
<p>es-head主要有三个方面的操作： </p>
<ol>
<li>显示集群的拓扑,并且能够执行索引和节点级别操作 </li>
<li>搜索接口能够查询集群中原始json或表格格式的检索数据 </li>
<li>能够快速访问并显示集群的状态</li>
</ol>
<p><strong>elasticsearch-head 安装</strong>（基于谷歌浏览器） </p>
<ol>
<li>直接下载压缩包，地址：<a href="https://files.cnblogs.com/files/sanduzxcvbnm/elasticsearch-head.7z">https://files.cnblogs.com/files/sanduzxcvbnm/elasticsearch-head.7z</a></li>
<li>解压</li>
<li>在谷歌浏览器扩展程序中点击“加载已解压的压缩程序”，找到elasticsearch-head文件夹，点击打开即可进 行安装。</li>
<li>使用时在谷歌浏览器中直接点击 elasticsearch-head 小图标 </li>
</ol>
<h1 id="kibana的相关操作"><a href="#kibana的相关操作" class="headerlink" title="kibana的相关操作"></a>kibana的相关操作</h1><p><strong>基本概念</strong></p>
<p>1、文档 （document） </p>
<p>存入索引库原始的数据。</p>
<ul>
<li>它可以是层次的。文档中还包含新的文档，字段还可以包含其他字段和取值。\</li>
<li>它拥有灵活的结构。文档不依赖于预先定义的模式。</li>
</ul>
<p>2、类型 （type） </p>
<p>类型是文档的逻辑容器，类似于表格是行的容器。在不同的类型中，最好放入不同结构的文档。 </p>
<p>3、索引 （index） </p>
<p>索引是映射类型的容器。一个Elasticsearch索引是独立的大量的文档集合。 每个索引存储在磁盘上的同 组文件中，索引存储了所有映射类型的字段，还有一些设置。 </p>
<p>4、映射（mapping）</p>
<p>字段的数据类型、属性、是否索引、是否存储等特性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElasticSearch 与 Mysql 对比</span><br><span class="line">索引库（indices）---------------------------------Database 数据库</span><br><span class="line">类型（type）----------------------------------Table 数据表</span><br><span class="line">文档（Document）---------------------------------Row 行</span><br><span class="line">域字段（Field）--------------------------------Columns 列</span><br><span class="line">映射配置（mappings）-------------------------------每个列的约束（类型、长度）</span><br></pre></td></tr></table></figure>
<h2 id="对索引库操作"><a href="#对索引库操作" class="headerlink" title="对索引库操作"></a>对索引库操作</h2><p>Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求</p>
<p>创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;hui</span><br></pre></td></tr></table></figure>
<p>配置分片与副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;lagou</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 5,   # 分片数量，默认5</span><br><span class="line">        &quot;number_of_replicas&quot;: 1  # 副本数量，默认1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;hui</span><br></pre></td></tr></table></figure>
<h2 id="对类型与映射操作"><a href="#对类型与映射操作" class="headerlink" title="对类型与映射操作"></a>对类型与映射操作</h2><p>注意：Elasticsearch7.x取消了索引type类型的设置，不允许指定类型，默认为_doc，但字段仍然是有 的，我们需要设置字段的约束信息，叫做字段映射（mapping）</p>
<p><strong>创建字段映射</strong></p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;索引库名&#x2F;_mapping&#x2F;类型名</span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;字段名&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;类型&quot;,</span><br><span class="line">            &quot;index&quot;: true,  # 是否索引，默认为true</span><br><span class="line">            &quot;store&quot;: false, # 是否额外存储，默认为false</span><br><span class="line">            &quot;analyzer&quot;: &quot;分词器&quot;,</span><br><span class="line">            &quot;boost&quot;: 1.0    # 权重</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：添加 goods 类型 ，设置3个字段：title、images、price</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT hui&#x2F;_mapping&#x2F;goods</span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">            &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;images&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">            &quot;index&quot;: &quot;false&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;price&quot;: &#123;</span><br><span class="line">       	 	&quot;type&quot;: &quot;float&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建索引时创建字段映射</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;索引库名</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">    	&quot;索引库属性名&quot;:&quot;索引库属性值&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;类型名&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">                &quot;字段名&quot;:&#123;</span><br><span class="line">                	&quot;映射属性名&quot;:&quot;映射属性值&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;hui2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;goods&quot;: &#123;</span><br><span class="line">        	&quot;properties&quot;: &#123;</span><br><span class="line">            	&quot;title&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                    &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查看映射</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;索引库名&#x2F;_mapping    		# 查看所有</span><br><span class="line">GET &#x2F;索引库名&#x2F;_mapping&#x2F;类型名    # 查看某个类型</span><br></pre></td></tr></table></figure>
<h3 id="映射属性详解"><a href="#映射属性详解" class="headerlink" title="映射属性详解"></a>映射属性详解</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><p>String类型，又分两种</p>
<ul>
<li>text：使用文本数据类型的字段，它们会被分词，文本字段不用于排序，很少用于聚合，如 文章标题、正文。 </li>
<li>keyword：关键字数据类型，用于索引结构化内容的字段，不会被分词，必须完整匹配的内 容，如邮箱，身份证号。支持聚合</li>
</ul>
<p>但有的时候，对于一个字符串字段，我们可能希望他两种都支持，可以利用其多字段特性</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">    &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;sort&quot;:&#123;</span><br><span class="line">            	&quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;index&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Numerical：数值类型</p>
<p>long、interger、short、byte、double、float、half_float</p>
</li>
<li><p>Date：日期类型</p>
<p>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省 空间。</p>
</li>
<li><p>Array：数组类型</p>
<ul>
<li>进行匹配时，任意一个元素满足，都认为满足 </li>
<li>排序时，如果升序则用数组中的最小值来排序，如果降序则用数组中的最大值来排序</li>
</ul>
</li>
<li><p>Object：对象</p>
<ul>
<li>JSON文档本质上是分层的：文档包含内部对象，内部对象本身还包含内部对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &#123; </span><br><span class="line">        	&quot;type&quot;: &quot;long&quot; </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;person&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                    &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;,</span><br><span class="line">                    &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>是否将数据进行额外存储，默认false。</p>
<p>Elasticsearch在创建文档索引时，会将文档中的原始数据保存到 _source 的属性 中。如果 store为true，会在 _source 以外额外存储一份数据。可以将经常使用的数据经行额外保存。</p>
<h4 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h4><p>权重，默认1。新增数据时，可以指定字段的权重，权重越高，得分越高，排名越靠前。</p>
<h2 id="对文档操作"><a href="#对文档操作" class="headerlink" title="对文档操作"></a>对文档操作</h2><p><strong>添加文档</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;hui&#x2F;goods&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;小米手机&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http:&#x2F;&#x2F;image.lagou.com&#x2F;12479122.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:2699.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会随机生成id，不建议，可以指定id，一般将数据库中的id字段成为文档id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;索引库名&#x2F;类型&#x2F;id值    # 指定id添加文档</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>查看文档</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;goods&#x2F;id值</span><br></pre></td></tr></table></figure>
<p><strong>修改文档</strong></p>
<p>PUT：修改文档   POST：新增文档</p>
<p>其实PUT与POST请求都不重要，如果id存在就修改，不存在就新增</p>
<p><strong>删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;hui&#x2F;goods&#x2F;id值</span><br></pre></td></tr></table></figure>
<p><strong>智能判断</strong></p>
<p>es可以根据你输入的数据 来判断类型，动态添加数据映射。</p>
<p>例如添加的title字段，String类型数据，ES无法智能判断，它就会存入两个字段。</p>
<p> title：text类型     title.keyword：keyword类型</p>
<p>这种智能映射，底层原理是动态模板映射，如果我们想修改这种智能映射的规则，其实只要修改动态模 板即可！</p>
<p><strong>动态映射模板</strong></p>
<p>示例：创建hui索引时，添加goods类型并设置动态模板，将string类型字段转换成keyword类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT hui</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;goods&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;title&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                    &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;dynamic_templates&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;strings&quot;: &#123;     # 模板名称 ，自定义  </span><br><span class="line">                    	&quot;match_mapping_type&quot;: &quot;string&quot;,  # 匹配的类型</span><br><span class="line">                        &quot;mapping&quot;: &#123;     # 映射规则</span><br><span class="line">                            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">                            &quot;index&quot;:false,</span><br><span class="line">                            &quot;store&quot;:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果向该类型中添加文档时，添加了没指定映射的字段，如果是String类型，会自动转换成keyword类型。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;索引库名&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;查询类型&quot;:&#123;</span><br><span class="line">        	&quot;查询条件&quot;:&quot;查询条件值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的query代表一个查询对象，里面可以有不同的查询属性 </p>
<ul>
<li><p>查询类型： 例如： match_all ， match ， term ， range 等等 </p>
</li>
<li><p>查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解</p>
</li>
</ul>
<h3 id="查询所有-match-all"><a href="#查询所有-match-all" class="headerlink" title="查询所有(match_all)"></a>查询所有(match_all)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">    	&quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配查询-match"><a href="#匹配查询-match" class="headerlink" title="匹配查询(match)"></a>匹配查询(match)</h3><ul>
<li>or关系 </li>
</ul>
<p>match 类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系。</p>
<p>将小米相关的数据，与电视相关的数据都给查询出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;title&quot;:&quot;小米电视&quot;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>and关系</li>
</ul>
<p>案例中，只有同时包含 小米 和 电视 的词条才会被搜索到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">        	&quot;title&quot;:&#123;&quot;query&quot;:&quot;小米电视&quot;,&quot;operator&quot;:&quot;and&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="词条匹配-term"><a href="#词条匹配-term" class="headerlink" title="词条匹配(term)"></a>词条匹配(term)</h3><p>term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符 串,keyword类型的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;term&quot;:&#123;</span><br><span class="line">        	&quot;price&quot;:2699.00</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布尔组合-bool"><a href="#布尔组合-bool" class="headerlink" title="布尔组合(bool)"></a>布尔组合(bool)</h3><p>bool 把各种其它查询通过 must （与）、 must_not （非）、 should （或）的方式进行组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">    	&quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米&quot; &#125;&#125;,</span><br><span class="line">            &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;电视&quot; &#125;&#125;,</span><br><span class="line">            &quot;should&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;手机&quot; &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果:查询title包含小米，不包含电视，但可以包含手机(前提是title包含小米)</p>
<h3 id="范围查询-range"><a href="#范围查询-range" class="headerlink" title="范围查询(range)"></a>范围查询(range)</h3><p>查询找出那些落在指定区间内的数字或者时间</p>
<p>gt   大于、 gte  大于等于、 lt   小于、 lte   小于等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">            &quot;price&quot;: &#123;</span><br><span class="line">                &quot;gte&quot;: 1000.0,</span><br><span class="line">                &quot;lt&quot;: 2800.00</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模糊查询-fuzzy"><a href="#模糊查询-fuzzy" class="headerlink" title="模糊查询(fuzzy)"></a>模糊查询(fuzzy)</h3><p>fuzzy 查询是 term 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的 编辑距离不得超过2。（很少使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;fuzzy&quot;: &#123;</span><br><span class="line">        	&quot;title&quot;: &quot;appla&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的查询，也能查询到apple手机</p>
<h2 id="结果过滤"><a href="#结果过滤" class="headerlink" title="结果过滤"></a>结果过滤</h2><p>默认情况下，会显示_source的所有字段。 如果我们只想获取其中的部分字段，我们可以添加 _source 的过滤</p>
<h3 id="直接指定字段"><a href="#直接指定字段" class="headerlink" title="直接指定字段"></a>直接指定字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_source&quot;: [&quot;title&quot;,&quot;price&quot;],</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指定includes和excludes"><a href="#指定includes和excludes" class="headerlink" title="指定includes和excludes"></a>指定includes和excludes</h3><p>includes：来指定想要显示的字段</p>
<p>excludes：来指定不想要显示的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">    	&quot;includes&quot;:[&quot;title&quot;,&quot;price&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤（filter）"><a href="#过滤（filter）" class="headerlink" title="过滤（filter）"></a>过滤（filter）</h2><p>查询与过滤： 通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。 除此以外的情况都使用过滤（filters)。</p>
<p><strong>条件查询中进行过滤</strong></p>
<p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件 影响评分，那么就不要把过滤条件作为查询条件来用。而是使用 filter 方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot; &#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">            	&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:2000.00,&quot;lt&quot;:3800.00&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>无查询条件，直接过滤</strong></p>
<p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用 constant_score 取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;constant_score&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">            	&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:2000.00,&quot;lt&quot;:3000.00&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>可指定多字段排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot; &#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">            	&quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:200000,&quot;lt&quot;:300000&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">        &#123; &quot;price&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125; #如果价格一样就对得分排序</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>from：目标数据的偏移值（开始位置），默认from为0 </p>
<p>size：每页大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">    	&quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;from&quot;: 3,</span><br><span class="line">    &quot;size&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>服务端搜索数据，得到搜索结果 ；把搜索结果中，把搜索关键字加上前缀与后缀 ；前端页面提前写好标签的CSS样式，即可高亮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hui&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">        	&quot;title&quot;: &quot;手机&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,     # 前缀</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;&#x2F;em&gt;&quot;,   # 后缀</span><br><span class="line">        &quot;fields&quot;: &#123;  			# 需要高亮的字段</span><br><span class="line">        	&quot;title&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>聚合可以让我们极其方便的实现对数据的统计、分析</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫 桶 ，一个叫 度量 </p>
<p><strong>桶</strong></p>
<p>类似于 group by，是按照某种方式对数据进行分组，每一组数据在ES中称为一个 桶 </p>
<p>划分桶的方式：</p>
<ul>
<li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 </li>
<li>Histogram Aggregation：根据数值阶梯分组，与日期类似，需要知道分组的间隔（interval）</li>
<li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 </li>
<li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li>
<li>…….</li>
</ul>
<p><strong>度量</strong></p>
<p>相当于聚合的结果，分组完成以后，一般会对组中的数据进行聚合运算，这些在 ES中称为 度量 </p>
<p>比较常用的度量聚合方式：</p>
<ul>
<li>Avg Aggregation：求平均值 </li>
<li>Max Aggregation：求最大值 </li>
<li>Min Aggregation：求最小值 </li>
<li>Percentiles Aggregation：求百分比 </li>
<li>Stats Aggregation：同时返回avg、max、min、sum、count等 </li>
<li>Sum Aggregation：求和 </li>
<li>Top hits Aggregation：求前几 </li>
<li>Value Count Aggregation：求总数</li>
<li>……</li>
</ul>
<p><strong>注意</strong>：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词，必须使用 keyword 或 数值类型 。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>创建一个索引，并导入一些数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;car</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;orders&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;color&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;make&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照 汽车的颜色 color来 划分 桶 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;car&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,  # 查询条数，不关心搜索到的数据，只关心聚合结果，提高效率</span><br><span class="line">    &quot;aggs&quot; : &#123;   # 聚合查询，是aggregations的缩写</span><br><span class="line">        &quot;popular_colors&quot; : &#123;  # 聚合起一个名字，可任意指定。</span><br><span class="line">            &quot;terms&quot; : &#123;		  # 聚合的类型，这里选择terms</span><br><span class="line">            	&quot;field&quot; : &quot;color&quot;  # 划分桶时依赖的字段</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看结果，只分析聚合中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;aggregations&quot;: &#123;  # 聚合的结果</span><br><span class="line">    &quot;popular_colors&quot;: &#123;   # 我们自定义的聚合名称</span><br><span class="line">        &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class="line">        &quot;sum_other_doc_count&quot;: 0,</span><br><span class="line">        &quot;buckets&quot;: [  # 查找到的桶，每个不同的color字段值都会形成一个桶</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;key&quot;: &quot;红&quot;,  # 这个桶对应的color字段的值</span><br><span class="line">                &quot;doc_count&quot;: 4  # 桶对应的个数</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;key&quot;: &quot;绿&quot;,</span><br><span class="line">                &quot;doc_count&quot;: 2</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;key&quot;: &quot;蓝&quot;,</span><br><span class="line">                &quot;doc_count&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为刚刚的聚合结果添加 求价格平均值的<strong>度量</strong>，这些信息要嵌套在 桶 内， 度量 的运算会基于 桶 内的文档进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;car&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;popular_colors&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">            	&quot;field&quot; : &quot;color&quot;</span><br><span class="line">            &#125;, </span><br><span class="line">            &quot;aggs&quot;:&#123;  # 我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合.</span><br><span class="line">                &quot;avg_price&quot;: &#123;  # 聚合的名称</span><br><span class="line">                    &quot;avg&quot;: &#123;    # 度量的类型，这里是求平均值</span><br><span class="line">                    	&quot;field&quot;: &quot;price&quot;  # 度量运算的字段</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看结果,只分析桶中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;buckets&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key&quot;: &quot;红&quot;,</span><br><span class="line">        &quot;doc_count&quot;: 4,</span><br><span class="line">        &quot;avg_price&quot;: &#123;  	# 自定义度量的名称</span><br><span class="line">        	&quot;value&quot;: 32500  # 平均值度量后的结果</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key&quot;: &quot;绿&quot;,</span><br><span class="line">        &quot;doc_count&quot;: 2,</span><br><span class="line">        &quot;avg_price&quot;: &#123;</span><br><span class="line">        	&quot;value&quot;: 21000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h1><p><strong>单点的问题</strong> </p>
<ul>
<li>单台机器存储容量有限，无法实现高存储 </li>
<li>单服务器容易出现单点故障，无法实现高可用 </li>
<li>单服务的并发处理能力有限，无法实现高并发 </li>
</ul>
<p>所以，为了应对这些问题，我们需要对elasticsearch搭建集群</p>
<h2 id="集群的结构"><a href="#集群的结构" class="headerlink" title="集群的结构"></a>集群的结构</h2><p><strong>数据分片(Shard)</strong> </p>
<p>数据量太大，单点存储量有限的问题。es数据拆分成多份，每一份存储到不同机器节点（node），从而实现减少每个节点数据量大的目的，这就是数据的分布式存储。</p>
<p><a href="https://imgtu.com/i/4tbZ38"><img src="https://z3.ax1x.com/2021/09/22/4tbZ38.png" alt="4tbZ38.png"></a></p>
<p><strong>数据副本(replica)</strong> </p>
<p>如果出现单点故障，那么分片数据就不再完整。es给每个分片数据进行备份，存储到其它节点，防止数据丢失。 数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本比较高。</p>
<p>为了在高可用和成本间寻求平衡，我们可以这样做： </p>
<p>首先对数据分片，存储到不同节点 。然后对每个分片进行备份，放到对方节点，完成<strong>互相备份</strong> </p>
<p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p>
<p><a href="https://imgtu.com/i/4tbmjg"><img src="https://z3.ax1x.com/2021/09/22/4tbmjg.png" alt="4tbmjg.png"></a></p>
<h2 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h2><p>一台机器进行模拟：将我们的ES的安装包复制三份，修改端口号，data和log存放位置的不同。 </p>
<p>实际开发中：将每个ES节点放在不同的服务器上。 </p>
<p>我们计划集群名称为：hui-elastic，部署3个elasticsearch节点，分别是： </p>
<ul>
<li>node-01：http端口9201，TCP端口9301 </li>
<li>node-02：http端口9202，TCP端口9302 </li>
<li>node-03：http端口9203，TCP端口9303</li>
</ul>
<p>步骤：</p>
<p>1）复制es软件3次，分别修改名称</p>
<p>2）修改每一个节点 config下的elasticsearch.yml 配置文件,三个节点的配置文件几乎一致，除了：</p>
<p>​        node.name、path.data、path.log、http.port、 transport.tcp.port</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#允许跨域名访问</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line"><span class="comment">#当设置允许跨域，默认为*,表示支持所有域名</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="comment">#允许所有节点访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="comment"># 集群的名称，同一个集群下所有节点的集群名称应该一致</span></span><br><span class="line">cluster.name: hui-elastic</span><br><span class="line"><span class="comment">#当前节点名称 每个节点不一样</span></span><br><span class="line">node.name: node-01</span><br><span class="line"><span class="comment">#数据的存放路径 每个节点不一样，不同es服务器对应的data和log存储的路径不能一样</span></span><br><span class="line">path.data: d:\class\es-9201\data</span><br><span class="line"><span class="comment">#日志的存放路径 每个节点不一样</span></span><br><span class="line">path.logs: d:\class\es-9201\logs</span><br><span class="line"><span class="comment"># http协议的对外端口 每个节点不一样，默认：9200</span></span><br><span class="line">http.port: 9201</span><br><span class="line"><span class="comment"># TCP协议对外端口 每个节点不一样，默认：9300</span></span><br><span class="line">transport.tcp.port: 9301</span><br><span class="line"><span class="comment">#三个节点相互发现，包含自己，使用tcp协议的端口号</span></span><br><span class="line">discovery.zen.ping.unicast.hosts:</span><br><span class="line">[<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>,<span class="string">&quot;127.0.0.1:9303&quot;</span>]</span><br><span class="line"><span class="comment">#声明大于几个的投票主节点有效，请设置为（nodes / 2） + 1</span></span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"><span class="comment"># 是否为主节点</span></span><br><span class="line">node.master: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>3）启动集群 </p>
<p>把三个节点分别启动,启动时不要着急，要一个一个地启动，可使用head方便查看集群状态。</p>
<h2 id="集群工作原理"><a href="#集群工作原理" class="headerlink" title="集群工作原理"></a>集群工作原理</h2><p><strong>shad与replica机制</strong></p>
<ul>
<li>增减节点时，shard会自动在nodes中负载均衡</li>
<li>replica shard是primary shard的副本，负责容错，以及承担<strong>读请求负载</strong></li>
<li>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改</li>
<li>primary shard不能和自己的replica shard放在同一个节点上，起不到容错的作用</li>
</ul>
<p><strong>集群写入数据</strong> </p>
<ol>
<li>客户端选择一个node发送请求过去，这个node就是coordinating node (协调节点) </li>
<li>coordinating node，对document进行路由，将请求转发给对应的node。（根据一定的算法选择 对应的节点进行存储） </li>
<li>node上的primary shard处理请求，将数据保存在本地，然后将数据同步到replica node </li>
<li>coordinating node，如果发现primary node和所有的replica node都搞定之后，就会返回请求到 客户端</li>
</ol>
<p>这个路由简单的说就是取模算法，例如:有3台服务器,这个时候传过来的id是5,那么5%3=2,就 放在第2台服务器。</p>
<h1 id="ElasticSearch客户端"><a href="#ElasticSearch客户端" class="headerlink" title="ElasticSearch客户端"></a>ElasticSearch客户端</h1><p>在elasticsearch官网中提供了各种语言的客户端：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a> </p>
<p>这里安装的都是 6.2.4 版本，所以选择版本到 6.2.4，java高级REST客户端。</p>
<h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建spirngboot项目，并导入pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--google提供的处理JSON工具包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Apache开源组织提供的用于操作JAVA BEAN的工具包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ES高级Rest Client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写Product实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">// 分类</span></span><br><span class="line">    <span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> Double price; <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">private</span> String images; <span class="comment">// 图片地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建索引库及映射"><a href="#创建索引库及映射" class="headerlink" title="创建索引库及映射"></a>创建索引库及映射</h2><p>创建索引库的同时，我们也会创建type及其映射关系，但是这些操作不建议使用java客户端完成。</p>
<p>这里使用kibana提前完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;hui</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 3,</span><br><span class="line">        &quot;number_of_replicas&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;item&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;id&quot;: &#123;</span><br><span class="line">                	&quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;title&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                    &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;category&quot;: &#123;</span><br><span class="line">                	&quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;brand&quot;: &#123;</span><br><span class="line">                	&quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;images&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">                    &quot;index&quot;: false</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;price&quot;: &#123;</span><br><span class="line">                	&quot;type&quot;: &quot;double&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引数据操作"><a href="#索引数据操作" class="headerlink" title="索引数据操作"></a>索引数据操作</h2><h3 id="初始化客户端"><a href="#初始化客户端" class="headerlink" title="初始化客户端"></a>初始化客户端</h3><p>在测试类中编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化HighLevel客户端</span></span><br><span class="line">        client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                        <span class="comment">// ,new HttpHost(&quot;127.0.0.1&quot;,9201) // 集群</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增与修改文档"><a href="#新增与修改文档" class="headerlink" title="新增与修改文档"></a>新增与修改文档</h3><p>如果id不存在就是插入，否则修该</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON转换工具</span></span><br><span class="line"><span class="keyword">private</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果id不存在就是插入，否则修改</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertAndUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取文档数据</span></span><br><span class="line">    Product product = <span class="keyword">new</span> Product(<span class="number">1L</span>, <span class="string">&quot;小米手机&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">2623D</span>, <span class="string">&quot;http://xiaomi.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.将文档数据转换成JSON格式</span></span><br><span class="line">    String source = gson.toJson(product);</span><br><span class="line">    <span class="comment">// 3.创建索引请求对象 访问哪个索引库、哪个type、指定文档ID</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;hui&quot;</span>, <span class="string">&quot;item&quot;</span>, product.getId().toString());</span><br><span class="line">    request.source(source, XContentType.JSON); <span class="comment">// 放入数据，并指定为json格式</span></span><br><span class="line">    <span class="comment">// 4.发出请求</span></span><br><span class="line">    IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response); <span class="comment">// 打印结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h3><p>根据rest风格，查看应该是根据id进行get查询，难点是对结果的解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建get请求对象</span></span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;hui&quot;</span>, <span class="string">&quot;item&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求,获得响应</span></span><br><span class="line">    GetResponse response = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应</span></span><br><span class="line">    String sourceAsString = response.getSourceAsString(); <span class="comment">// 将数据转换成JSON字符串格式</span></span><br><span class="line">    <span class="comment">// 转换成Product对象</span></span><br><span class="line">    Product product = gson.fromJson(sourceAsString, Product.class);</span><br><span class="line">    System.out.println(product); <span class="comment">// 打印结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>根据id删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建delete请求</span></span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;hui&quot;</span>, <span class="string">&quot;item&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h2><h3 id="查询所有match-all"><a href="#查询所有match-all" class="headerlink" title="查询所有match_all"></a>查询所有match_all</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建搜索请求</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    <span class="comment">// 创建查询构建工具</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">// 添加查询条件，通过QueryBuilders获取各种查询</span></span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    request.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.解析数据</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 取出source数据</span></span><br><span class="line">        String sourceAsString = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 转换成Product对象</span></span><br><span class="line">        Product product = gson.fromJson(sourceAsString, Product.class);</span><br><span class="line">        <span class="keyword">if</span> (product.getId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索条件是通过 <code>sourceBuilder.query(QueryBuilders.matchAllQuery())</code> 来添加的。这个 query() 方法接受的参数是： <strong>QueryBuilder 接口</strong>类型。</p>
<p>这个接口提供了很多实现类，分别对应不同类型的查询，例如：term查询、match 查询、range查询、boolean查询等。</p>
<p>这些实现类不需要我们去 new ，官方提供了 QueryBuilders 工厂帮我们构建各种实现类：</p>
<p><a href="https://imgtu.com/i/4tOhVJ"><img src="https://z3.ax1x.com/2021/09/22/4tOhVJ.png" alt="4tOhVJ.png"></a></p>
<h3 id="关键字搜索match"><a href="#关键字搜索match" class="headerlink" title="关键字搜索match"></a>关键字搜索match</h3><p>搜索类型的变化，仅仅是利用QueryBuilders构建的查询对象不同而已，其他代码基本一致</p>
<p>因此，我们可以把这段代码封装，然后把查询条件作为参数传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装 搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseSearch</span><span class="params">(SearchSourceBuilder sourceBuilder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建搜索请求</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line"></span><br><span class="line">    request.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.解析</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 取出source数据</span></span><br><span class="line">        String sourceAsString = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 转换成Product对象</span></span><br><span class="line">        Product product = gson.fromJson(sourceAsString, Product.class);</span><br><span class="line">        <span class="keyword">if</span> (product.getId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键字搜索代码</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBaseSearch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用封装的方法,并传递查询条件</span></span><br><span class="line">    baseSearch(sourceBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="范围查询range"><a href="#范围查询range" class="headerlink" title="范围查询range"></a>范围查询range</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeSearch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    RangeQueryBuilder price = QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">    price.gte(<span class="string">&quot;3000&quot;</span>); <span class="comment">// &gt;=</span></span><br><span class="line">    price.lte(<span class="string">&quot;5000&quot;</span>); <span class="comment">// &lt;=</span></span><br><span class="line">    sourceBuilder.query(price);</span><br><span class="line">    <span class="comment">// 调用封装的方法,并传递查询条件</span></span><br><span class="line">    baseSearch(sourceBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="source过滤"><a href="#source过滤" class="headerlink" title="source过滤"></a>source过滤</h3><p>默认情况下，索引库中所有数据都会返回，如果只返回部分字段，可以通过source filter来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sourceFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchAllQuery()); <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="comment">// 过滤字段 ，参数一：显示字段 ，参数二：不显示字段</span></span><br><span class="line">    sourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;price&quot;</span>&#125;, <span class="keyword">null</span>);</span><br><span class="line">  	<span class="comment">// 调用封装的方法,并传递查询条件</span></span><br><span class="line">    baseSearch(sourceBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><p>依然是通过sourceBuilder来配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortSearch</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建查询构建工具</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">// 添加查询条件，查询所有</span></span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//排序   价格降序</span></span><br><span class="line">    sourceBuilder.sort(<span class="string">&quot;price&quot;</span>,SortOrder.DESC); </span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line">    sourceBuilder.from(<span class="number">0</span>);  <span class="comment">// 偏移量</span></span><br><span class="line">    sourceBuilder.size(<span class="number">3</span>); </span><br><span class="line">	<span class="comment">// 调用封装的方法,并传递查询条件</span></span><br><span class="line">    baseSearch(sourceBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><p>Spring Data ElasticSearch（以后简称SDE）是Spring Data项目下的一个子模块。 </p>
<p>Spring Data 的使命是给各种数据访问提供统一的编程接口。</p>
<p><strong>特征</strong> </p>
<ul>
<li>支持Spring的基于 @Configuration 的java配置方式，或者XML配置方式 </li>
<li>提供了用于操作ES的便捷工具类 ElasticsearchTemplate 。 </li>
<li>基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式，可以定义JavaBean：类 名、属性 </li>
<li>根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自 动得到实现）。当然，也支持人工定制查询</li>
</ul>
<h2 id="配置SDE"><a href="#配置SDE" class="headerlink" title="配置SDE"></a>配置SDE</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span> <span class="comment"># 集群名称，默认elasticsearch</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span> <span class="comment"># 各个节点名称,可加逗号表示多个实例</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，SDE底层使用的不是Elasticsearch提供的RestHighLevelClient， 而是TransportClient，并不采用Http协议通信，而是访问tcp端口</p>
<h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><p>修改之前的Peoduct对象，添加相应的注解信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;hui&quot;, type = &quot;product&quot;, shards = 3, replicas = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span>  </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//标题</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">// 分类</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double price; <span class="comment">// 价格</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword,index = false)</span></span><br><span class="line">    <span class="keyword">private</span> String images; <span class="comment">// 图片地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Document：声明索引库配置 </p>
<ul>
<li>indexName：索引库名称 </li>
<li>type：类型名称，默认是“docs” </li>
<li>shards：分片数量，默认5 </li>
<li>replicas：副本数量，默认1 </li>
</ul>
<p>@Id：声明实体类的id </p>
<p>@Field：声明字段属性 </p>
<ul>
<li>type：字段的数据类型 </li>
<li>analyzer：指定分词器类型 </li>
<li>index：是否创建索引</li>
</ul>
<p><strong>创建索引库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDETest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建索引</span></span><br><span class="line">        template.createIndex(Product.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h3><p>刚才的注解已经把映射关系也配置上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建类型</span></span><br><span class="line">    template.putMapping(Product.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引数据CRUD"><a href="#索引数据CRUD" class="headerlink" title="索引数据CRUD"></a>索引数据CRUD</h2><p>SDE的索引数据CRUD并没有封装在ElasticsearchTemplate中，而是有一个叫做 ElasticsearchRepository的接口。</p>
<p>我们需要自定义接口，继承ElasticsearchRespository，就可以使用很多已经集成的方法，类似于mybatis-plus。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型&lt;实体类,id类型&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Long</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建索引数据"><a href="#创建索引数据" class="headerlink" title="创建索引数据"></a>创建索引数据</h3><p><strong>保存单条数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product product = <span class="keyword">new</span> Product(<span class="number">1L</span>, <span class="string">&quot;小米手机&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;小米&quot;</span>, <span class="number">4452D</span>, <span class="string">&quot;http://xiaomi/img/1.jpg&quot;</span>);</span><br><span class="line">    productRepository.save(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>批量保存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product product1 = <span class="keyword">new</span> Product(<span class="number">2L</span>, <span class="string">&quot;华为手机&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="number">3333D</span>, <span class="string">&quot;http://xiaomi/img/1.jpg&quot;</span>);</span><br><span class="line">    Product product2 = <span class="keyword">new</span> Product(<span class="number">3L</span>, <span class="string">&quot;锤子手机&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;锤子&quot;</span>, <span class="number">2000D</span>, <span class="string">&quot;http://xiaomi/img/1.jpg&quot;</span>);</span><br><span class="line">    Product product3 = <span class="keyword">new</span> Product(<span class="number">4L</span>, <span class="string">&quot;苹果手机&quot;</span>, <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="number">9000D</span>, <span class="string">&quot;http://xiaomi/img/1.jpg&quot;</span>);</span><br><span class="line">    List&lt;Product&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(product1);</span><br><span class="line">    list.add(product2);</span><br><span class="line">    list.add(product3);</span><br><span class="line">    productRepository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询索引数据"><a href="#查询索引数据" class="headerlink" title="查询索引数据"></a>查询索引数据</h3><p><strong>根据id查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Product&gt; optional = productRepository.findById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 默认数据，如果查询数据为空，就返回该条数据，optional是java8中的新特性</span></span><br><span class="line">    Product defaultProduct = <span class="keyword">new</span> Product();</span><br><span class="line">    defaultProduct.setTitle(<span class="string">&quot;无。。。。&quot;</span>);</span><br><span class="line">    Product product = optional.orElse(defaultProduct);</span><br><span class="line">    System.out.println(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查询所有</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Product&gt; iterable = productRepository.findAll();</span><br><span class="line">    iterable.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义方法查询"><a href="#自定义方法查询" class="headerlink" title="自定义方法查询"></a>自定义方法查询</h3><p>ProductRepository提供的查询方法有限，但是它却提供了非常强大的自定义查询功能。</p>
<p>只要遵循SpringData提供的语法，我们可以任意定义方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据价格区间查询</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> from 开始价格</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> to 结束价格</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 符合条件的goods</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findByPriceBetween</span><span class="params">(Double from,Double to)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无需写实现，SDE会自动帮我们实现该方法，我们可以直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 价格范围查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Product&gt; productList = productRepository.findByPriceBetween(<span class="number">3000D</span>, <span class="number">5000D</span>);</span><br><span class="line">    productList.forEach(System.out::pringln); <span class="comment">// 输出结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDE支持的一些语法示例：</p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Sample</th>
<th>Elasticsearch Query String</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>findByNameAndPrice</td>
<td>{“bool” : {“must” : [ {“field” : {“name” : “?”}}, {“field” : {“price” : “?”}} ]}}</td>
</tr>
<tr>
<td>or</td>
<td>findByNameOrPrice</td>
<td>{“bool” : {“should” : [ {“field” : {“name” : “?”}}, {“field” : {“price” : “?”}} ]}}</td>
</tr>
<tr>
<td>is</td>
<td>findByName</td>
<td>{“bool” : {“must” : {“field” : {“name” : “?”}}}}</td>
</tr>
<tr>
<td>not</td>
<td>findByNameNot</td>
<td>{“bool” : {“must_not” : {“field” : {“name” : “?”}}}}</td>
</tr>
<tr>
<td>between</td>
<td>findByPriceBetween</td>
<td>{“bool” : {“must” : {“range” : {“price” : {“from” : ?,”to” : ?,”include_lower” : true,”include_upper” : true}}}}}</td>
</tr>
<tr>
<td>LessThanEqual</td>
<td>findByPriceLessThan</td>
<td>{“price” : {“from” : null,”to” : ?,”include_lower” : true,”include_upper” : true}}}}}</td>
</tr>
<tr>
<td>GreaterThanEqual</td>
<td>findByPriceGreaterThan</td>
<td>{“bool” : {“must” : {“range” : {“price” : {“from” : ?,”to” : null,”include_lower” : true,”include_upper” : true}}}}}</td>
</tr>
<tr>
<td>Before</td>
<td>findByPriceBefore</td>
<td>{“bool” : {“must” : {“range” : {“price” : {“from” : null,”to” : ?,”include_lower” : true,”include_upper” : true}}}}}</td>
</tr>
<tr>
<td>After</td>
<td>findByPriceAfter</td>
<td>{“bool” : {“must” : {“range” : {“price” : {“from” : ?,”to” : null,”include_lower” : true,”include_upper” : true}}}}}</td>
</tr>
<tr>
<td>Like</td>
<td>findByNameLike</td>
<td>{“bool” : {“must” : {“field” : {“name” : {“query” : “? *”,”analyze_wildcard” : true}}}}}</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByNameStartingWith</td>
<td>{“bool” : {“must” : {“field” : {“name” : {“query” : “? *”,”analyze_wildcard” : true}}}}}</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByNameEndingWith</td>
<td>{“bool” : {“must” : {“field” : {“name” : {“query” : “*?”,”analyze_wildcard” : true}}}}}</td>
</tr>
<tr>
<td>Contains/Containing</td>
<td>findByNameContaining</td>
<td>{“bool” : {“must” : {“field” : {“name” : {“query” : “**? **”,”analyze_wildcard” : true}}}}}</td>
</tr>
<tr>
<td>In</td>
<td>findByNameIn(Collectionnames)</td>
<td>{“bool” : {“must” : {“bool” : {“should” : [ {“field” : {“name” : “?”}}, {“field” : {“name” : “?”}} ]}}}}</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByNameNotIn(Collectionnames)</td>
<td>{“bool” : {“must_not” : {“bool” : {“should” : {“field” : {“name” : “?”}}}}}}</td>
</tr>
<tr>
<td>Near</td>
<td>findByStoreNear</td>
<td>Not Supported Yet !</td>
</tr>
<tr>
<td>True</td>
<td>findByAvailableTrue</td>
<td>{“bool” : {“must” : {“field” : {“available” : true}}}}</td>
</tr>
<tr>
<td>False</td>
<td>findByAvailableFalse</td>
<td>{“bool” : {“must” : {“field” : {“available” : false}}}}</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByAvailableTrueOrderByNameDesc</td>
<td>{“sort” : [{ “name” : {“order” : “desc”} }],”bool” : {“must” : {“field” : {“available” : true}}}}</td>
</tr>
</tbody></table>
<h2 id="原生查询"><a href="#原生查询" class="headerlink" title="原生查询"></a>原生查询</h2><p>SDE也支持原生查询，这个时候还是使用 ElasticsearchTemplate</p>
<p>查询条件的构建是通过一个名为 NativeSearchQueryBuilder 的类来完成的，不过这个类的底层还 是使用的原生API中的 QueryBuilders 、 AggregationBuilders 、 HighlightBuilders 等工具。</p>
<p><strong>需求</strong>： 查询title中包含小米手机的商品，以价格升序排序，分页查询：每页展示2条，查询第1页。 对查询结果进行聚合分析：获取品牌及个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nativeSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原生查询构建器</span></span><br><span class="line">    NativeSearchQueryBuilder builder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">//   source过滤</span></span><br><span class="line">    builder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;brand&quot;</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">//   搜索条件</span></span><br><span class="line">    builder.withQuery(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line">    <span class="comment">//   分页及排序条件</span></span><br><span class="line">    builder.withPageable(PageRequest.of(<span class="number">0</span>, <span class="number">3</span>, Sort.by(Sort.Direction.ASC, <span class="string">&quot;price&quot;</span>)));</span><br><span class="line">    <span class="comment">//   高亮显示(下面再编写，这里省略)</span></span><br><span class="line">    <span class="comment">// builder.withHighlightBuilder(new HighlightBuilder().field(&quot;title&quot;));</span></span><br><span class="line">    <span class="comment">//   聚合</span></span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(<span class="string">&quot;brandAgg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建查询条件，并且查询</span></span><br><span class="line">    AggregatedPage&lt;Product&gt; result = template.queryForPage(builder.build(), Product.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    <span class="comment">// 分页结果</span></span><br><span class="line">    <span class="keyword">long</span> total = result.getTotalElements();</span><br><span class="line">    <span class="keyword">int</span> pages = result.getTotalPages();</span><br><span class="line">    List&lt;Product&gt; list = result.getContent();</span><br><span class="line">    System.out.println(<span class="string">&quot;总数:&quot;</span> + total);</span><br><span class="line">    System.out.println(<span class="string">&quot;页数:&quot;</span> + pages);</span><br><span class="line">    System.out.println(<span class="string">&quot;内容:&quot;</span>);</span><br><span class="line">    list.forEach(System.out::pringln);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合结果</span></span><br><span class="line">    Aggregations aggregations = result.getAggregations();</span><br><span class="line">    Terms Terms = aggregations.get(<span class="string">&quot;brandAgg&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历桶中的数据</span></span><br><span class="line">    Terms.getBuckets().forEach(item -&gt; &#123;</span><br><span class="line">        System.out.println(item.getKeyAsString() + <span class="string">&quot;==&gt;&quot;</span> + item.getDocCount());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>高亮展示</strong></p>
<p>自定义搜索结果映射，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResultMapper</span> <span class="keyword">implements</span> <span class="title">SearchResultMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> searchResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AggregatedPage需要3给参数:List&lt;T&gt;,pageable,总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AggregatedPage&lt;T&gt; <span class="title">mapResults</span><span class="params">(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        <span class="comment">// 保存所有的记录，用与返回</span></span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取搜索结果(真正的的记录)</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        <span class="comment">// 遍历每一条记录</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hit == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一条数据映射成map对象</span></span><br><span class="line">            Map&lt;String, Object&gt; map = hit.getSourceAsMap();</span><br><span class="line">            <span class="comment">// 获取高亮字段</span></span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            <span class="comment">// 遍历高亮字段，将高亮字段覆盖原来的记录</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, HighlightField&gt; entry : highlightFields.entrySet()) &#123;</span><br><span class="line">                String key = entry.getKey(); <span class="comment">// 高亮字段key</span></span><br><span class="line">                HighlightField value = entry.getValue(); <span class="comment">// 高亮字段value</span></span><br><span class="line">                Text[] texts = value.getFragments(); <span class="comment">// 实际fragments[0]就是高亮的结果，无需遍历拼接</span></span><br><span class="line">                <span class="comment">// 因为高亮的字段必然存在于Map中，就是key值，所以这里是直接覆盖</span></span><br><span class="line">                map.put(key, texts[<span class="number">0</span>].toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将map转换成原来的对象T</span></span><br><span class="line">            T t = gson.fromJson(gson.toJson(map), aClass);</span><br><span class="line">            <span class="comment">// 将对象保存到list集合中</span></span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是带分页的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AggregatedPageImpl(list, pageable, searchResponse.getHits().getTotalHits());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高亮实现，查询时要创建 SearchResultMapper 实现类，用于接收高亮数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">highlightSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原生查询构建器</span></span><br><span class="line">    NativeSearchQueryBuilder builder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">//   搜索条件</span></span><br><span class="line">    builder.withQuery(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;手机&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   高亮显示</span></span><br><span class="line">    HighlightBuilder.Field field = <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    field.preTags(<span class="string">&quot;&lt;font style=&#x27;color:red&#x27;&gt;&quot;</span>);  <span class="comment">// 前缀</span></span><br><span class="line">    field.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>); <span class="comment">// 后缀</span></span><br><span class="line">    builder.withHighlightFields(field);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建查询条件，并且查询</span></span><br><span class="line">    AggregatedPage&lt;Product&gt; result = template.queryForPage(builder.build(), Product.class, <span class="keyword">new</span> MyResultMapper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    List&lt;Product&gt; list = result.getContent();</span><br><span class="line">    System.out.println(<span class="string">&quot;内容:&quot;</span>);</span><br><span class="line">    list.forEach(System.out::pringln);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ES在docker上部署"><a href="#ES在docker上部署" class="headerlink" title="ES在docker上部署"></a>ES在docker上部署</h1><h2 id="部署ElasticSearch"><a href="#部署ElasticSearch" class="headerlink" title="部署ElasticSearch"></a>部署ElasticSearch</h2><p><strong>拉取</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:6.5.4</span><br></pre></td></tr></table></figure>
<p><strong>开启镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -e &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; --name es_6.5.4 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type&#x3D;single-node&quot; elasticsearch:6.5.4</span><br></pre></td></tr></table></figure>
<h2 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h2><p>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<p>版本要与es版本一致，这里 下载了 elasticsearch-analysis-ik-6.5.4.zip 压缩包</p>
<p>1)上传压缩包到 /home 目录</p>
<p>2)将压缩包解压至es容器的 /usr/share/elasticsearch/plugins/ik 中   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 压缩包移动到容器中 </span><br><span class="line">docker cp &#x2F;home&#x2F;elasticsearch-analysis-ik-5.6.12.zip es:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br><span class="line"># 进入容器</span><br><span class="line">docker exec -it es &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入plugins目录</span><br><span class="line">cd &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br><span class="line"># 创建ik目录</span><br><span class="line">mkdir ik</span><br><span class="line"># 将压缩包移动到ik中</span><br><span class="line">mv elasticsearch-analysis-ik-5.6.12.zip ik&#x2F;</span><br><span class="line"># 进入目录，并解压</span><br><span class="line">cd ik&#x2F;</span><br><span class="line">unzip elasticsearch-analysis-ik-5.6.12.zip</span><br><span class="line"># 删除压缩包</span><br><span class="line">rm -rf elasticsearch-analysis-ik-5.6.12.zip</span><br></pre></td></tr></table></figure>
<p>3)退出容器，并重启容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">docker restart es</span><br></pre></td></tr></table></figure>
<p>如果启动类kibana，也要重启kibana</p>
<h2 id="部署Kibana"><a href="#部署Kibana" class="headerlink" title="部署Kibana"></a>部署Kibana</h2><p><strong>拉取</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull kibana:6.5.4</span><br></pre></td></tr></table></figure>
<p><strong>开启镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_URL&#x3D;http:&#x2F;&#x2F;192.168.200.128:9200 -p 5601:5601 -d kibana:6.5.4</span><br></pre></td></tr></table></figure>
<p>需指定ElasticSearch的位置</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>全文检索引擎</category>
      </categories>
      <tags>
        <tag>lucene</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>docker虚拟化技术</title>
    <url>/2021/09/22/docker%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p><strong>虚拟化技术</strong>是一种计算机资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储 等，予以抽象、转换后呈现出来。<a id="more"></a>虚拟化技术打破了计算机实体结构间的，不可切割的障碍。使用户可 以比原本的组态更好的方式，来应用这些资源。 </p>
<p><strong>虚拟化技术主要作用</strong></p>
<ul>
<li>高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件 </li>
<li>软件跨环境迁移问题(代码的水土不服）</li>
</ul>
<p><strong>Docker</strong> 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后 改名为Docker Inc）； </p>
<p>Docker 可以让开发者打包他们的应用，以及依赖包到一个轻量级、可移植的容器中，然后发布到任何 流行的 Linux 机器上。</p>
<p>Docker容器是完全使用<strong>沙箱机制</strong>，相互隔离，性能开销也极低。 从 17.03 版本之后，Docker分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业 版）</p>
<p>Docker通俗的讲是服务器中高性能的虚拟机，可以将一台物理机 虚拟N多台虚拟机的机器，互相之间隔 离，互不影响。</p>
<p><strong>特点</strong></p>
<ul>
<li>标准化交付：Docker将应用打包成标准化单元，用于交付、部署； </li>
<li>轻量级：容器及包含了软件运行所需的所有环境，而且非常轻量级 </li>
<li>高可靠：容器化的应用程序，可以在任何Linux环境中始终如一的运行</li>
<li>隔离性：容器化的应用程序，具备隔离性，这样多团队可以共享同一Linux系统资源</li>
</ul>
<p><strong>容器与虚拟机比较</strong> </p>
<p>下图中，可见Docker是在操作系统层面上实现虚拟 化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><a href="https://imgtu.com/i/4U9jW4"><img src="https://z3.ax1x.com/2021/09/22/4U9jW4.png" alt="4U9jW4.png"></a></p>
<p>相同点 :  容器和虚拟机都是虚拟化技术，具备资源隔离和分配优势:</p>
<p>不同点 ：Docker虚拟化的是操作系统，虚拟机虚拟化的是硬件；传统虚拟机可以运行不同的操作系统，Docker主要运行同一类操作系统(Linux)</p>
<p><strong>Docker基本概念</strong></p>
<p><a href="https://imgtu.com/i/4UPxq1"><img src="https://z3.ax1x.com/2021/09/22/4UPxq1.png" alt="4UPxq1.png"></a></p>
<ul>
<li>宿主机：安装Docker守护进程的Linux服务器，称之为宿主机； </li>
<li>镜像（Image）：Docker 镜像，就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、 库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。 </li>
<li>容器（Container）：镜像运行之后的实体，镜像和容器的关系，就像是面向对象程序设计中的类和对 象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停 等。 </li>
<li>仓库（Repository）：仓库可看成一个镜像控制中心，用来保存镜像。就像maven的中央仓库。</li>
</ul>
<h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>linux版本 ： centOS 7.7  。注意，一定安 装在CentOS 7.x及以上版本，CentOS6.x的版本中有Bug！</p>
<p>(2)查看电脑上已经已经安装Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed | grep docker</span><br></pre></td></tr></table></figure>
<p>(2)安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install docker  # 没指定版本就是安装最新版本</span><br></pre></td></tr></table></figure>
<p>(3)安装后查看docker版本 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<h2 id="守护进程相关命令"><a href="#守护进程相关命令" class="headerlink" title="守护进程相关命令"></a>守护进程相关命令</h2><p><strong>systemctl命令是系统服务管理器指令</strong></p>
<p>启动docker     <code>systemctl start docker</code></p>
<p>停止docker     <code>systemctl stop docker</code></p>
<p>重启docker   <code>systemctl restart docker</code></p>
<p>查看docker状态     <code>systemctl status docker</code></p>
<p>开机启动     <code>systemctl enable docker</code></p>
<p>查看docker概要信息     <code>docker info</code></p>
<p>查看docker帮助文档     <code>docker --help</code></p>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>默认情况，将从docker hub（<a href="https://hub.docker.com/%EF%BC%89%E4%B8%8B%E8%BD%BDdocker%E9%95%9C%E5%83%8F%E5%A4%AA%E6%85%A2%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0">https://hub.docker.com/）下载docker镜像太慢，一般都会配置镜像加</a> 速器；</p>
<p><strong>方案一: 中科大</strong></p>
<p>中国科学技术大学(ustc)是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在 用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公 共服务。地址 ： <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p>
<p>1）编辑文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>
<p>2）在该文件中输入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方案二: 阿里云</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;3ad96kxd.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须要注册，每个人分配一个免费的docker镜像加速地址，速度极快</p>
<p><strong>配置完成记得刷新配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><p><strong>查看镜像</strong>  <code>docker images</code></p>
<p><a href="https://imgtu.com/i/4UA8Qe"><img src="https://z3.ax1x.com/2021/09/22/4UA8Qe.png" alt="4UA8Qe.png"></a></p>
<p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>
<p><strong>搜索镜像</strong> <code>docker search imageName</code></p>
<p>从网络中查找需要的镜像,必须联网。</p>
<p><a href="https://imgtu.com/i/4UVpCV"><img src="https://z3.ax1x.com/2021/09/22/4UVpCV.png" alt="4UVpCV.png"></a></p>
<p><strong>拉取镜像</strong>  <code>docker pull imageName：version</code> </p>
<p>从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果不指定版本号则是下载最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</p>
<p>如 ：<code>docker pull tomcat:8.5</code></p>
<p><strong>删除镜像</strong>   <code>docker rmi imageId</code> </p>
<p>按镜像ID删除镜像, 删除之前要确认此镜像已经没有被容器在使用</p>
<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器   <code>docker ps</code></p>
<p><a href="https://imgtu.com/i/4UVhMF"><img src="https://z3.ax1x.com/2021/09/22/4UVhMF.png" alt="4UVhMF.png"></a></p>
<p>查看所有容器   <code>docker ps -a/all</code></p>
<p>查看最后一次运行的容器  <code>docker ps -l</code></p>
<p>查看停止的容器  <code>docker ps -f status=exited</code></p>
<h3 id="创建与进入容器"><a href="#创建与进入容器" class="headerlink" title="创建与进入容器"></a>创建与进入容器</h3><p>创建容器命令    <code>docker run 参数 镜像名称:镜像标签 /bin/bash</code></p>
<ul>
<li><p>镜像名称:镜像标签 可以被镜像id代替，唯一标识</p>
</li>
<li><p>/bin/bash：进入容器之后，初始化执行的命令, 可写可不写</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 命令参数详解</span><br><span class="line">-i：表示运行容器,如果不加该参数那么只是通过镜像创建容器，而不启动。</span><br><span class="line"></span><br><span class="line">-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端(如果只加it两个参数，创建后就会自动进去容器)。</span><br><span class="line"></span><br><span class="line">-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器）。</span><br><span class="line"></span><br><span class="line">--name :为创建的容器命名。</span><br><span class="line"></span><br><span class="line">-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</span><br><span class="line"></span><br><span class="line">-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射，例如：可以将Docker中Tomcat容器的8080端口映射到宿主机上的某一个端口8080，那么以后访问tomcat只需要：http:&#x2F;&#x2F;宿主机的IP：8080&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>交互式容器</strong></p>
<p>使用交互式运行容器，容器运行后直接进入到容器内部，退出容器内部后，容器直接关闭 只有第一次才会这样，以后再启动容器就是一个守护式的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><strong>守护式容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><strong>登录容器/进入容器的目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称(或者容器ID) &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>注意：这里的登陆容器之后执行的脚本  /bin/bash  必须写</p>
<p><strong>退出当前容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><p>停止容器  <code>docker stop 容器名称(或者容器ID)</code></p>
<p>启动容器  <code>docker start 容器名称(或者容器ID)</code></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除指定的容器，正在运行的容器无法删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称(或容器ID)</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f  容器ID</span><br></pre></td></tr></table></figure>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>将宿主机的文件拷贝到容器内可以使用cp命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将当前目录下的hui.html拷贝到tomcat容器的webapps目录下</span><br><span class="line">docker cp hui.html 容器id:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps</span><br></pre></td></tr></table></figure>
<p>也可以将文件从容器内拷贝出到宿主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将tomcat容器的文件拷贝带当前目录下</span><br><span class="line">docker cp 容器id:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;hui.html .&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>创建容器 添加  -v  宿主机目录:容器目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;tomcat tomcat:8.5</span><br></pre></td></tr></table></figure>
<h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>创建容器 添加  -p  宿主机端口号:容器端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -p 8080:8080 --name&#x3D;tomcat tomcat:8.5</span><br></pre></td></tr></table></figure>
<h3 id="查看容器ip地址"><a href="#查看容器ip地址" class="headerlink" title="查看容器ip地址"></a>查看容器ip地址</h3><p>输入以下命令，会出现很多容器的信息，ip地址相关在Networks中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<p>也可以直接执行下面的命令直接输出IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<h3 id="docker容器中使用vim操作"><a href="#docker容器中使用vim操作" class="headerlink" title="docker容器中使用vim操作"></a>docker容器中使用vim操作</h3><p>docker没有安装vi编辑器，需要手动安装，进入到某个容器内部：</p>
<p>1）更新软件列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update </span><br></pre></td></tr></table></figure>
<p>2)安装vim编辑器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>
<p>这里使用的是centos操作系统，如果是ubantu操作系统，请将apt-get换成yum即可</p>
<h1 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷(Volumes)"></a>数据卷(Volumes)</h1><p>数据卷是宿主机中的一个目录或文件，当容器目录和数据卷目录绑定后，对方的修改会立即同步。</p>
<p> 一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷</p>
<p><strong>数据卷作用</strong> </p>
<ul>
<li>容器数据持久化 </li>
<li>外部机器和容器间接通信 </li>
<li>容器之间数据交换</li>
</ul>
<p><a href="https://imgtu.com/i/4UK3qS"><img src="https://z3.ax1x.com/2021/09/22/4UK3qS.png" alt="4UK3qS.png" style="zoom: 50%;" /></a></p>
<p><strong>挂载数据卷</strong></p>
<p>创建启动容器时，使用 –v 参数 设置数据卷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure>
<p><strong>查看容器已挂载的数据卷</strong></p>
<p>执行 <code>docker inspect 容器名称（容器ID）</code> 命令</p>
<p><a href="https://imgtu.com/i/4UKWxx"><img src="https://z3.ax1x.com/2021/09/22/4UKWxx.png" alt="4UKWxx.png"></a></p>
<p><strong>一个容器可以挂载多个数据卷，使用多个 -v</strong> </p>
<p><strong>多个容器挂载1个数据卷，实现数据共享</strong></p>
<p><strong>多个容器挂载1个容器(这1个容器挂载1个数据卷)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##创建启动c3数据卷容器，使用 –v 参数 设置数据卷</span><br><span class="line">docker run -di --name&#x3D;c3 -v &#x2F;root&#x2F;host_data_common:&#x2F;root&#x2F;c3_data centos:7 &#x2F;bin&#x2F;bash</span><br><span class="line">##创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</span><br><span class="line">docker run -di --name&#x3D;c1 --volumes-from c3 centos:7 &#x2F;bin&#x2F;bash</span><br><span class="line">docker run -di --name&#x3D;c2 --volumes-from c3 centos:7 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/4UMpdg"><img src="https://z3.ax1x.com/2021/09/22/4UMpdg.png" alt="4UMpdg.png" style="zoom: 80%;" /></a></p>
<h1 id="Docker部署软件"><a href="#Docker部署软件" class="headerlink" title="Docker部署软件"></a>Docker部署软件</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><p>1）拉取mysql镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p>2）创建容器，设置端口映射、目录映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mysql_5.7 -p 3307:3306 -v &#x2F;root&#x2F;mysql&#x2F;logs:&#x2F;logs -v &#x2F;root&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<ul>
<li>-p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。</li>
<li>-v /root/mysql/logs:/logs：将主机目录(/root/mysql)下的 logs 目录挂载到容器中的 /logs。日志目录 </li>
<li>-v /root/mysql/data:/var/lib/mysql ：将宿主机目录(/root/mysql)下的data目录挂载到容 器的 /var/lib/mysql 。数据目录 </li>
<li>-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码</li>
</ul>
<p>部署完毕，可以使用 SQLyog进行远程连接测试。</p>
<h2 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h2><p>1）拉取tomcat镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:8-jdk8</span><br></pre></td></tr></table></figure>
<p>2)创建容器，设置端口映射、目录映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;c_tomcat -p 8080:8080 -v &#x2F;root&#x2F;tomcat&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:8-jdk8</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong> </p>
<ul>
<li>-p 8080:8080：将容器的8080端口映射到主机的8080端口 </li>
<li>-v /root/tomcat/webapps:/usr/local/tomcat/webapps：将主机目录 (/root/tomcat/webapps)挂载到容器的webapps</li>
</ul>
<p>部署完毕。可在在/root/tomcat/webapps下创建ROOT/index.html,并编辑，使用外部机器访问 8080 端口</p>
<h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><p>1）拉取nginx镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建容器，设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>部署完毕，使用外部机器访问 80 端口</p>
<h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>1）拉取redis镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建容器，设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id --name&#x3D;c_redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>
<p>部署完毕，使用外部机器连接redis。</p>
<h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><p><strong>应用场景</strong>： 开发环境中，在Docker里安装很多的容器，进行对应的配置，将Docker中的运行的容器持久化 为镜像，将对应的镜像安装到生产环境中。</p>
<p>1.将开发环境下的Docker中对应的容器持久化为镜像 </p>
<p>2.将镜像保存为一个压缩包，发送到生产环境服务器中 </p>
<p>3.生产环境中需要将压缩包–&gt;镜像–&gt;容器</p>
<p><strong>容器保存为镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit &#123;正在运行容器名称&#x2F;容器ID&#125; &#123;镜像名称&#125;:&#123;镜像标签&#125;</span><br></pre></td></tr></table></figure>
<p>举例 : 将  redis 容器持久化成镜像，镜像名为   redis ，标签为 version_hui_1.0.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit redis redis:version_hui_1.0.0</span><br></pre></td></tr></table></figure>
<p>镜像标签如果不写默认为latest , 最好是加上标签以便区分。</p>
<p><strong>镜像备份</strong></p>
<p>将镜像保存为 tar 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o &#123;压缩包存放路径&#125; &#123;镜像名称&#x2F;镜像ID&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>-o :输出到的文件</li>
</ul>
<p>举例: 将 redis:version_hui_1.0.0 镜像在当前目录压缩成 redis.tar 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o redis.tar redis:version_hui_1.0.0 </span><br></pre></td></tr></table></figure>
<p><strong>镜像恢复与迁移</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i &#123;备份的镜像文件&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>-i :指定导入的文件</li>
</ul>
<p>举例:  加载将刚刚生成的压缩包 redis.tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i redis.tar </span><br></pre></td></tr></table></figure>
<p>执行后再次查看镜像，可以看到镜像已经恢复，可以再次运行测试</p>
<h1 id="IEDA集成Docker部署微服务"><a href="#IEDA集成Docker部署微服务" class="headerlink" title="IEDA集成Docker部署微服务"></a>IEDA集成Docker部署微服务</h1><h2 id="Docker开启远程访问"><a href="#Docker开启远程访问" class="headerlink" title="Docker开启远程访问"></a>Docker开启远程访问</h2><ul>
<li>Docker默认是不允许远程访问的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改配置文件</span><br><span class="line">[root@A ~]# vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</p>
<p><a href="https://imgtu.com/i/5r7NtA"><img src="https://z3.ax1x.com/2021/10/21/5r7NtA.png" alt="5r7NtA.png"></a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重新加载配置文件</span><br><span class="line">[root@A ~]# systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启docker</span><br><span class="line">[root@A ~]# service docker restart</span><br><span class="line"></span><br><span class="line"># 查看端口是否开启</span><br><span class="line">[root@A ~]# netstat -nlpt</span><br><span class="line"></span><br><span class="line"># 验证端口是否生效</span><br><span class="line">[root@A ~]# curl http:&#x2F;&#x2F;192.168.200.20:2375&#x2F;info</span><br></pre></td></tr></table></figure>
<h2 id="IEDA集成插件"><a href="#IEDA集成插件" class="headerlink" title="IEDA集成插件"></a>IEDA集成插件</h2><p>准备: 在Plugins中搜索Docker，并安装</p>
<ul>
<li>连接</li>
</ul>
<p><a href="https://imgtu.com/i/5rHCAH"><img src="https://z3.ax1x.com/2021/10/21/5rHCAH.png" alt="5rHCAH.png" style="zoom: 67%;" /></a></p>
<ul>
<li>可添加镜像加速器  <a href="https://owi3yzzk.mirror.aliyuncs.com/">https://owi3yzzk.mirror.aliyuncs.com</a></li>
</ul>
<p><a href="https://imgtu.com/i/5rHmDS"><img src="https://z3.ax1x.com/2021/10/21/5rHmDS.png" alt="5rHmDS.png" style="zoom:67%;" /></a></p>
<ul>
<li>在services框中可查看Docker相关数据，如镜像、容器</li>
</ul>
<p><a href="https://imgtu.com/i/5rHnHg"><img src="https://z3.ax1x.com/2021/10/21/5rHnHg.png" alt="5rHnHg.png"></a></p>
<h2 id="Docker的Maven插件"><a href="#Docker的Maven插件" class="headerlink" title="Docker的Maven插件"></a>Docker的Maven插件</h2><ul>
<li>传统的过程中，要经历打包，部署，上传到linux，编写Dockerfile，构建镜像，创建容器等步骤</li>
<li>docker-maven-plugin就是帮助我们在开发构成中，<b style='color:red'>自动生成镜像并推送到仓库中</b></li>
<li>docker打包项目的插件有两种。<ul>
<li>docker-maven-plugin</li>
<li>dockerfile</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--镜像名称 hui/test-docker-demo--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>hui/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标签版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--基础镜像，相当于Dockerfile里的from--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>java<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标签版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>hui 1764501567@qq.com<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--入口点，project.build.finalName就是project标签下的build标签下的filename标签内容，test-docker-demo--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--相当于启动容器后，会自动执行java -jar/test-docker-demo.jar--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;/$&#123;project.build.finalName&#125;.jar&quot;]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--docker地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.204.141:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--复制的根目录，target--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--把哪个文件上传到docker，相当于Dockerfile里的add test-docker-demo.jar /--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段配置中，镜像名称和标签版本可以自定义，其他不用改。</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><ul>
<li>1.对项目进行打包，并构建镜像到docker上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package docker:build</span><br></pre></td></tr></table></figure>
<p><b style='color:red'>注意：构建镜像，要将项目中用到的localhost改为docker服务器的ip</b>，然后再进行构建镜像</p>
<p>命令执行完成，会自动将jar包镜像推送到docker</p>
<ul>
<li>2.对镜像构建容器，可构建多个</li>
</ul>
<p><a href="https://imgtu.com/i/5rbBdg"><img src="https://z3.ax1x.com/2021/10/21/5rbBdg.png" alt="5rbBdg.png"></a></p>
<p><a href="https://imgtu.com/i/5rbDoQ"><img src="https://z3.ax1x.com/2021/10/21/5rbDoQ.png" alt="5rbDoQ.png"></a></p>
<p><a href="https://imgtu.com/i/5rbRyV"><img src="https://z3.ax1x.com/2021/10/21/5rbRyV.png" alt="5rbRyV.png"></a></p>
<ul>
<li>如果出现以下的错误，请执行对应的命令即可，都是找不到可执行文件的原因</li>
</ul>
<p><a href="https://imgtu.com/i/5rbxTe"><img src="https://z3.ax1x.com/2021/10/21/5rbxTe.png" alt="5rbxTe.png"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A ~]# cd &#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;</span><br><span class="line">[root@A docker]# ln -s docker-proxy-current docker-proxy</span><br></pre></td></tr></table></figure>
<ul>
<li>找不到docker运行的命令</li>
</ul>
<p><a href="https://imgtu.com/i/5rqpYd"><img src="https://z3.ax1x.com/2021/10/21/5rqpYd.png" alt="5rqpYd.png"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A docker]# cd &#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;</span><br><span class="line">[root@A docker]# ln -s docker-runc-current docker-runc</span><br></pre></td></tr></table></figure>


<p>over。。。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列之Kafka</title>
    <url>/2021/09/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BKafka/</url>
    <content><![CDATA[<p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做 MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。 主要应用场景是：日志收集系统和消息系统。<a id="more"></a></p>
<p>官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<h1 id="kafka介绍"><a href="#kafka介绍" class="headerlink" title="kafka介绍"></a>kafka介绍</h1><p><strong>kafka特点</strong></p>
<p>（1）解耦。Kafka具备消息系统的优点，只要生产者和消费者数据两端遵循接口约束，就可以自行扩展或修改数据处理的业务过程。 </p>
<p>（2）高吞吐量、低延迟。即使在非常廉价的机器上，Kafka也能做到每秒处理几十万条消息，而它的延迟最低只有几毫秒。 </p>
<p>（3）持久性。Kafka可以将消息直接持久化在普通磁盘上，且磁盘读写性能优异。 </p>
<p>（4）扩展性。Kafka集群支持热扩展，Kaka集群启动运行后，用户可以直接向集群添。 </p>
<p>（5）容错性。Kafka会将数据备份到多台服务器节点中，即使Kafka集群中的某一台加新的Kafka服务节点宕机，也不会影响整个系统的功 能。 </p>
<p>（6）支持多种客户端语言。Kafka支持Java、.NET、PHP、Python等多种语言。 </p>
<p>（7） 支持多生产者和多消费者。</p>
<p><strong>kafka架构</strong></p>
<p><a href="https://imgtu.com/i/4rJ1l6"><img src="https://z3.ax1x.com/2021/09/25/4rJ1l6.png" alt="4rJ1l6.png"></a></p>
<ul>
<li>Kafka Cluster：由多个服务器组成。每个服务器单独的名字broker（掮客）。 </li>
<li>kafka broker：kafka集群中包含的服务器 </li>
<li>Kafka Producer：消息生产者、发布消息到 kafka 集群的终端或服务。 </li>
<li>Kafka consumer：消息消费者、负责消费数据。 </li>
<li>Kafka Topic: 主题，一类消息的名称。存储数据时将一类数据存放在某个topci下。</li>
<li>Partition：分区，物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的 数据和索引文件，每个partition<strong>内部是有序</strong>的</li>
</ul>
<p>注意：Kafka的元数据都是存放在zookeeper中</p>
<p><strong>Topic与Partition关系</strong> </p>
<ul>
<li>对于每一个topic， Kafka集群都会维持一个分区日志。</li>
<li>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。 </li>
<li>分区中的每一个记录都会分配一个id号来表示顺序，称之为offset，offset用来唯一的标识分区中每一条记录。</li>
</ul>
<p><a href="https://imgtu.com/i/4rJTnU"><img src="https://z3.ax1x.com/2021/09/25/4rJTnU.png" alt="4rJTnU.png"></a></p>
<h1 id="kafka集群搭建"><a href="#kafka集群搭建" class="headerlink" title="kafka集群搭建"></a>kafka集群搭建</h1><h2 id="传统集群搭建"><a href="#传统集群搭建" class="headerlink" title="传统集群搭建"></a>传统集群搭建</h2><p><strong>关系图</strong></p>
<p><a href="https://imgtu.com/i/4rYYvV"><img src="https://z3.ax1x.com/2021/09/25/4rYYvV.png" alt="4rYYvV.png"></a></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>虚拟机准备三台服务器, 安装jdk1.8 ,其中每一台虚拟机的hosts文件中都需要配置如下的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.200.11 node1</span><br><span class="line">192.168.200.12 node2</span><br><span class="line">192.168.200.13 node3</span><br></pre></td></tr></table></figure>
<p>先克隆一台虚拟机node1，记得重新生成 网络适配器中的MAC地址</p>
<p><strong>修改IP地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
<ul>
<li>bootproto=static，表示使用静态IP </li>
<li>onboot=yes，表示将网卡设置为开机启用 </li>
<li>将原有的原有IP修改为192.168.200.11</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.200.11</span><br></pre></td></tr></table></figure>
<ul>
<li>重启网络服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p><strong>修改host</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加下面内容</span><br><span class="line">192.168.200.11 node1</span><br><span class="line">192.168.200.12 node2</span><br><span class="line">192.168.200.13 node3</span><br></pre></td></tr></table></figure>
<p>重启hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;network restart</span><br></pre></td></tr></table></figure>
<p><strong>创建安装目录</strong></p>
<p>安装包存放的目录：/export/software<br>安装程序存放的目录：/export/servers<br>数据目录：/export/data<br>日志目录：/export/logs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;export&#x2F;servers&#x2F;</span><br><span class="line">mkdir -p &#x2F;export&#x2F;software&#x2F;</span><br><span class="line">mkdir -p &#x2F;export&#x2F;data&#x2F;</span><br><span class="line">mkdir -p &#x2F;export&#x2F;logs&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>安装JDK</strong></p>
<p>上传JDK文件  <strong>jdk-8u261-linux-x64.rpm</strong>,使用rpm安装,默认的安装路径是/usr/java/jdk1.8.0_261-amd64</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh jdk-8u261-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p> 配置JAVA_HOME</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line"># 文件最后添加两行</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_261-amd64</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>退出vi，使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>查看JDK是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="zookeeper集群搭建"><a href="#zookeeper集群搭建" class="headerlink" title="zookeeper集群搭建"></a>zookeeper集群搭建</h3><p>上传zookeeper-3.4.14.tar.gz , 解压并配置zookeeper（配置data目录，集群节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解压到&#x2F;opt目录</span><br><span class="line">tar -zxf zookeeper-3.4.14.tar.gz -C &#x2F;opt</span><br></pre></td></tr></table></figure>
<p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;zookeeper-3.4.14&#x2F;conf</span><br><span class="line"># 配置文件重命名后生效</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>编辑配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi zoo.cfg</span><br><span class="line"># 设置数据目录</span><br><span class="line">dataDir&#x3D;&#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;data</span><br><span class="line"># 添加</span><br><span class="line">server.1&#x3D;node1:2881:3881</span><br><span class="line">server.2&#x3D;node2:2881:3881</span><br><span class="line">server.3&#x3D;node3:2881:3881</span><br><span class="line"># 退出vim</span><br></pre></td></tr></table></figure>
<p>创建zookeeper数据目录，并标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;data</span><br><span class="line"># 当前zookeeper在集群中的标记</span><br><span class="line">echo 1 &gt; &#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line"># 添加</span><br><span class="line">export ZOOKEEPER_PREFIX&#x3D;&#x2F;opt&#x2F;zookeeper-3.4.14</span><br><span class="line">export PATH&#x3D;$PATH:$ZOOKEEPER_PREFIX&#x2F;bin</span><br><span class="line">export ZOO_LOG_DIR&#x3D;&#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;log</span><br><span class="line"># 退出vim，让配置生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p><strong>node2配置</strong></p>
<p>克隆node1虚拟机，重写生成MAC地址，修改ip地址:192.168.200.12</p>
<p>写入当前zookeeper在集群中的标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 2 &gt; &#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p><strong>node3配置</strong></p>
<p>克隆node1虚拟机，重写生成MAC地址，修改ip地址:192.168.200.13</p>
<p>写入当前zookeeper在集群中的标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 3 &gt; &#x2F;var&#x2F;lagou&#x2F;zookeeper&#x2F;data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p><strong>启动zookeeper</strong></p>
<p>三台机器都启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
<p><strong>查看状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure>
<h3 id="kafka集群搭建-1"><a href="#kafka集群搭建-1" class="headerlink" title="kafka集群搭建"></a>kafka集群搭建</h3><p><strong>下载安装包</strong></p>
<p>中文网站: <a href="http://kafka.apachecn.org/">http://kafka.apachecn.org/</a>  ，这里使用 kafka_2.11-1.0.0.tgz 版本 </p>
<p><strong>上传安装包到 /export/software 目录，解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-1.0.0.tgz -C &#x2F;export&#x2F;servers&#x2F;</span><br><span class="line">cd &#x2F;export&#x2F;servers&#x2F;</span><br><span class="line"># 重命名</span><br><span class="line">mv kafka_2.11-1.0.0 kafka</span><br></pre></td></tr></table></figure>
<p><strong>修改kafka的核心配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;export&#x2F;servers&#x2F;kafka&#x2F;config&#x2F;</span><br><span class="line">vi server.properties</span><br></pre></td></tr></table></figure>
<p>主要修改一下5个地方: </p>
<ol>
<li><p>broker.id 需要保证每一台kafka都有一个独立的broker </p>
</li>
<li><p>log.dirs 数据存放的目录 </p>
</li>
<li><p>zookeeper.connect zookeeper的连接地址信息 </p>
</li>
<li><p>host.name 主机的名称 </p>
</li>
<li><p>修改: listeners=PLAINTEXT://node1:9092</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">broker.id 标识了kafka集群中一个唯一broker。</span></span><br><span class="line">broker.id=0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 存放生产者生产的数据 数据一般以topic的方式存放</span></span><br><span class="line">log.dirs=/export/data/kafka</span><br><span class="line"><span class="meta">#</span><span class="bash"> zk的信息</span></span><br><span class="line">zookeeper.connect=node1:2181,node2:2181,node3:2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主机名称</span></span><br><span class="line">host.name=node1</span><br><span class="line"><span class="meta">#</span><span class="bash"> listeners</span></span><br><span class="line">listeners=PLAINTEXT://node1:9092</span><br></pre></td></tr></table></figure>
<p><strong>将配置好的kafka分发到其他二台主机</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;export&#x2F;servers</span><br><span class="line">scp -r kafka&#x2F; node2:$PWD</span><br><span class="line">scp -r kafka&#x2F; node3:$PWD</span><br></pre></td></tr></table></figure>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。 </p>
<p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<ul>
<li>拷贝后, 需要修改每一台的broker.id 和 host.name和listeners</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip为11的服务器: broker.id&#x3D;0 , host.name&#x3D;node1,listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;node1:9092</span><br><span class="line">ip为12的服务器: broker.id&#x3D;1 , host.name&#x3D;node2,listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;node2:9092</span><br><span class="line">ip为13的服务器: broker.id&#x3D;2 , host.name&#x3D;node3,listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;node3:9092</span><br></pre></td></tr></table></figure>
<ul>
<li>在每一台的服务器执行创建数据文件的命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;export&#x2F;data&#x2F;kafka</span><br></pre></td></tr></table></figure>
<p><strong>启动集群</strong></p>
<p>注意: zookeeper集群一定要先启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;export&#x2F;servers&#x2F;kafka&#x2F;bin</span><br><span class="line"></span><br><span class="line">#前台启动</span><br><span class="line">.&#x2F;kafka-server-start.sh &#x2F;export&#x2F;servers&#x2F;kafka&#x2F;config&#x2F;server.properties</span><br><span class="line"></span><br><span class="line">#后台启动</span><br><span class="line">nohup .&#x2F;kafka-server-start.sh &#x2F;export&#x2F;servers&#x2F;kafka&#x2F;config&#x2F;server.properties 2&gt;&amp;1 &amp;</span><br><span class="line">注意：可以启动一台broker，单机版。也可以同时启动三台broker，组成一个kafka集群版</span><br><span class="line"></span><br><span class="line">#kafka停止</span><br><span class="line">.&#x2F;kafka-server-stop.sh</span><br></pre></td></tr></table></figure>
<p>可登录zookeeper客户端查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">ls &#x2F;brokers&#x2F;ids</span><br></pre></td></tr></table></figure>
<h2 id="Docker搭建Kafka集群"><a href="#Docker搭建Kafka集群" class="headerlink" title="Docker搭建Kafka集群"></a>Docker搭建Kafka集群</h2><p><strong>架构</strong></p>
<table>
<thead>
<tr>
<th>hostname</th>
<th>ip addr</th>
<th>port</th>
<th>listener</th>
</tr>
</thead>
<tbody><tr>
<td>zoo1</td>
<td>192.168.0.11</td>
<td>2184:2181</td>
<td></td>
</tr>
<tr>
<td>zoo2</td>
<td>192.168.0.12</td>
<td>2185:2181</td>
<td></td>
</tr>
<tr>
<td>zoo3</td>
<td>192.168.0.13</td>
<td>2186:2181</td>
<td></td>
</tr>
<tr>
<td>kafka1</td>
<td>192.168.0.14</td>
<td>9092:9092</td>
<td>kafka1</td>
</tr>
<tr>
<td>kafka2</td>
<td>192.168.0.15</td>
<td>9093:9092</td>
<td>kafka1</td>
</tr>
<tr>
<td>kafka3</td>
<td>192.168.0.16</td>
<td>9094:9092</td>
<td>kafka1</td>
</tr>
<tr>
<td>kafka-manager</td>
<td>192.168.0.17</td>
<td>9000:9000</td>
<td></td>
</tr>
<tr>
<td>宿主机</td>
<td>192.168.200.20</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>克隆VM，修改ip地址：192.168.200.20</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scrpits&#x2F;ifcfg-ens33</span><br><span class="line">IPADDR&#x3D;192.168.200.20</span><br><span class="line">#退出vi，并重启网络服务</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p><strong>安装docker-compose</strong></p>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具</p>
<p>使用原来的方式操作docker，需要对zookeeper安装3次，kafka安装3次，kafka-Manage安装1次。引入Compose之后可以使用yaml格式的配置文件配置好这些信息，每个image只需要编写一个yaml文件，可以在文件中定义集群信 息、端口映射等信息，运行该文件即可创建完成集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">curl 是一种命令行工具，作用是发出网络请求，然后获取数据</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash">chmod（change mode）命令是控制用户对文件的权限的命令</span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash">查看版本</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<p><strong>拉取镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#拉取Zookeeper镜像</span><br><span class="line">docker pull zookeeper:3.4</span><br><span class="line">#拉取kafka镜像</span><br><span class="line">docker pull wurstmeister&#x2F;kafka</span><br><span class="line">#拉取kafka-manager镜像</span><br><span class="line">docker pull sheepkiller&#x2F;kafka-manager:latest</span><br></pre></td></tr></table></figure>
<p> <strong>创建集群网络</strong> </p>
<p>基于Linux宿主机而工作的，也是在Linux宿主机创建，创建之后Docker容器中的各个应用程序可以使用该网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建</span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0&#x2F;24 --gateway 192.168.0.1 kafka</span><br><span class="line">#查看</span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<p><strong>网络设置</strong> </p>
<p>新建网段之后可能会出现：WARNING: IPv4 forwarding is disabled. Networking will not work. </p>
<p>解决方式： </p>
<ol>
<li><p>在宿主机上执行：</p>
<p> echo “net.ipv4.ip_forward=1” &gt;&gt;/usr/lib/sysctl.d/00-system.conf </p>
</li>
<li><p>重启network和docker服务</p>
<p> systemctl restart network &amp;&amp; systemctl restart docker</p>
</li>
</ol>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>每个镜像一个Yml文件</p>
<p><strong>docker-compose-zookeeper.yml</strong></p>
<p>Zookeeper各个节点的信息，端口映射，集群信息，网络配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2184</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2185</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=0.0.0.0:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2186</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=0.0.0.0:2888:3888</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.13</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kafka</span></span><br></pre></td></tr></table></figure>
<p><strong>docker-compose-kafka.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka1</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">kafka1</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://kafka1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181,zoo2:2181,zoo3:2181</span></span><br><span class="line">    <span class="attr">external_links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.14</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka2</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9093</span><span class="string">:9093</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">kafka2</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://kafka2:9093</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka2:9093</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9093</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181,zoo2:2181,zoo3:2181</span></span><br><span class="line">    <span class="attr">external_links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.15</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9094</span><span class="string">:9094</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">kafka3</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://kafka3:9094</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka3:9094</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9094</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181,zoo2:2181,zoo3:2181</span></span><br><span class="line">    <span class="attr">external_links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.16</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kafka</span></span><br></pre></td></tr></table></figure>
<p><strong>docker-compose-manager.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka-manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sheepkiller/kafka-manager:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-manager</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka-manager</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">9000</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 管理zoo集群与kafka集群</span></span><br><span class="line">     <span class="attr">ZK_HOSTS:</span> <span class="string">zoo1:2181,zoo2:2181,zoo3:2181</span></span><br><span class="line">     <span class="attr">KAFKA_BROKERS:</span> <span class="string">kafka1:9092,kafka2:9092,kafka3:9092</span></span><br><span class="line">     <span class="attr">APPLICATION_SECRET:</span> <span class="string">letmein</span></span><br><span class="line">     <span class="attr">KM_ARGS:</span> <span class="string">-Djava.net.preferIPv4Stack=true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="attr">kafka:</span></span><br><span class="line">      <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.17</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kafka</span></span><br></pre></td></tr></table></figure>
<p><strong>开始部署</strong></p>
<p>使用命令：<code>docker-compose -f 文件位置 up -d</code></p>
<p>参数说明：-f 加载指定位置的yaml文件  ， up表示启动， -d表示后台运行</p>
<p>示例： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose -f &#x2F;home&#x2F;docker-compose-zookeeper.yml up -d  # 启动zookeeper集群</span><br><span class="line">docker-compose -f &#x2F;home&#x2F;docker-compose-kafka.yml up -d   	# 启动kafka集群</span><br><span class="line">docker-compose -f &#x2F;home&#x2F;docker-compose-manager.yml up -d	# 启动kafka-manager</span><br></pre></td></tr></table></figure>
<p>浏览器访问宿主机： <a href="http://192.168.200.20:9000/">http://192.168.200.20:9000/</a></p>
<p>刚启动没有如何东西，需要手动添加zoo集群，点击Cluster下拉列表–&gt;Add Cluster </p>
<p>Cluster Name ：集群名，自定义</p>
<p>Cluster Zookeeper Hosts:  zoo1:2181, zoo2:2181, zoo3:2181</p>
<p>单击save即可。</p>
<h1 id="kafka的基本操作"><a href="#kafka的基本操作" class="headerlink" title="kafka的基本操作"></a>kafka的基本操作</h1><p>docker环境中演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录到Kafka容器</span><br><span class="line">docker exec -it kafka1 &#x2F;bin&#x2F;bash</span><br><span class="line">#切换到bin目录</span><br><span class="line">cd opt&#x2F;kafka&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="1-创建topic"><a href="#1-创建topic" class="headerlink" title="(1)创建topic"></a>(1)创建topic</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper zoo1:2181 --replication-factor 3 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>
<p>–create：新建命令 </p>
<p>–zookeeper：Zookeeper节点，一个或多个 </p>
<p>–replication-factor：指定副本，每个分区有三个副本</p>
<p>–partitions：   指定分区</p>
<p>– topic ： 主题名称</p>
<h2 id="2-查看所有topic"><a href="#2-查看所有topic" class="headerlink" title="(2)查看所有topic"></a>(2)查看所有topic</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --list --zookeeper zoo1:2181,zoo2:2181,zoo3:2181</span><br></pre></td></tr></table></figure>
<p>__consumer_offsets 这个topic是由kafka自动创建的，默认50个分区，存储消费位移信息（offset），老版本架构中是存储在Zookeeper 中。</p>
<h2 id="3-生产者生产数据"><a href="#3-生产者生产数据" class="headerlink" title="(3)生产者生产数据"></a>(3)生产者生产数据</h2><p>Kafka自带一个命令行客户端，它从文件或标准输入中获取输入，并将其作为message（消息）发送到Kafka集群。 默认情况下，每行将作为单独的message发送。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#运行producer，指定topic主题</span><br><span class="line">kafka-console-producer.sh --broker-list kafka1:9092,kafka2:9093,kafka3:9094 --topic test</span><br><span class="line">#发送消息</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure>
<h2 id="4-消费者消费数据"><a href="#4-消费者消费数据" class="headerlink" title="(4) 消费者消费数据"></a>(4) 消费者消费数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer.sh --bootstrap-server kafka1:9092, kafka2:9093, kafka3:9094 --topic test --frombeginning</span><br></pre></td></tr></table></figure>
<p>在使用的时候会用到bootstrap与broker.list其实是实现一个功能，broker.list是旧版本命令。</p>
<h2 id="5-查看topic的相关详细信息"><a href="#5-查看topic的相关详细信息" class="headerlink" title="(5) 查看topic的相关详细信息"></a>(5) 查看topic的相关详细信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看topic主题详情，Zookeeper节点写一个和全部写，效果一致</span><br><span class="line">kafka-topics.sh --describe --zookeeper zoo1:2181,zoo2:2181,zoo3:2181 --topic test</span><br><span class="line">#结果列表</span><br><span class="line">Topic: test1 PartitionCount: 3 ReplicationFactor: 3 Configs:</span><br><span class="line">    Topic: test1 Partition: 0 Leader: 1001 Replicas: 1001,1003,1002 Isr: 1001,1003,1002</span><br><span class="line">    Topic: test1 Partition: 1 Leader: 1002 Replicas: 1002,1001,1003 Isr: 1002,1001,1003</span><br><span class="line">    Topic: test1 Partition: 2 Leader: 1003 Replicas: 1003,1002,1001 Isr: 1003,1002,1001</span><br></pre></td></tr></table></figure>
<p>leader：是负责给定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。 </p>
<p>replicas：显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活。 </p>
<p>isr：副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步</p>
<h2 id="6-增加topic分区数"><a href="#6-增加topic分区数" class="headerlink" title="(6) 增加topic分区数"></a>(6) 增加topic分区数</h2><p>任意kafka服务器执行以下命令可以增加topic分区数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper zkhost:port --alter --topic test --partitions 8</span><br></pre></td></tr></table></figure>
<h2 id="7-增加配置"><a href="#7-增加配置" class="headerlink" title="(7) 增加配置"></a>(7) 增加配置</h2><p>动态修改kakfa的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper zoo1:2181 --alter --topic test --config flush.messages&#x3D;1</span><br></pre></td></tr></table></figure>
<p><strong>flush.messages</strong>：此项配置指定时间间隔：强制进行fsync日志，默认值为None。</p>
<p>例如，如果这个选项设置为1，那么每条消息之后都需要进行fsync，如果设置为5，则每5条消息就需要进行一次fsync。</p>
<h2 id="8-删除配置"><a href="#8-删除配置" class="headerlink" title="(8) 删除配置"></a>(8) 删除配置</h2><p>动态删除kafka集群配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper zoo1:2181 --alter --topic test --delete-config flush.messages</span><br></pre></td></tr></table></figure>
<h2 id="9-删除topic"><a href="#9-删除topic" class="headerlink" title="(9) 删除topic"></a>(9) 删除topic</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper zoo1:2181 --delete --topic test</span><br></pre></td></tr></table></figure>
<p>目前删除topic在默认情况只是打上一个删除的标记，在重新启动kafka后才删除。</p>
<p>如果需要立即删除，则需要在所有节点的 server.properties中配置： <code>delete.topic.enable=true</code></p>
<p>一个主题会在不同的kafka节点中分配分组信息和副本信息 然后执行以下命令进行删除topic</p>
<h1 id="java-API操作Kafka"><a href="#java-API操作Kafka" class="headerlink" title="java API操作Kafka"></a>java API操作Kafka</h1><p>使用docker搭建的kafka集群经行操作</p>
<p><a href="https://imgtu.com/i/4rrsTP"><img src="https://z3.ax1x.com/2021/09/25/4rrsTP.png" alt="4rrsTP.png"></a></p>
<p><strong>修改Windows的Host文件</strong></p>
<p> 目录：C:\Windows\System32\drivers\etc (win10)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.200.20 kafka1</span><br><span class="line">192.168.200.20 kafka2</span><br><span class="line">192.168.200.20 kafka3</span><br></pre></td></tr></table></figure>
<p><strong>创建maven工程，导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- java编译插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String topic = <span class="string">&quot;hui&quot;</span>;<span class="comment">//定义主题</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 配置kafka集群及其他信息</span></span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.200.20:9092,192.168.200.20:9093,192.168.200.20:9094&quot;</span>);</span><br><span class="line">        <span class="comment">//网络传输,对key和value进行序列化</span></span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        <span class="comment">//ACK确认机制，默认1  --只要收到一个分区副本成功写入的通知就认为推送消息成功了</span></span><br><span class="line">        properties.put(ProducerConfig.ACKS_CONFIG,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">        <span class="comment">// 发送100条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;hello &quot;</span> + i;</span><br><span class="line">            <span class="comment">// 创建消息对象 ProducerRecord ，指定topic与消息</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, msg);</span><br><span class="line">            <span class="comment">// 发送</span></span><br><span class="line">            producer.send(record);</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息成功！&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 0.5秒发送一条消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.200.20:9092,192.168.200.20:9093,192.168.200.20:9094&quot;</span>);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;hui_1&quot;</span>);</span><br><span class="line">        <span class="comment">// 取消自动提交</span></span><br><span class="line">        <span class="comment">// properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,&quot;false&quot;);</span></span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">        <span class="comment">// 订阅topic，如果没有，kafka会自动创建 1个分区，1个副本的topic</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(ProducerDemo.topic));</span><br><span class="line">        <span class="comment">// 循环读取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;topic:&quot;</span>+record.topic()+<span class="string">&quot;,偏移量:&quot;</span>+ record.offset()+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;msg&quot;</span>+record.value());</span><br><span class="line">                <span class="comment">// 手动提交 ...</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    kafka    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>properties.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.20</span><span class="string">:9092</span> <span class="comment">#服务器的ip及端口，可以写多个，服务器之间用“，”间隔</span></span><br><span class="line">    <span class="attr">producer:</span> <span class="comment">#生产者配置</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer:</span> <span class="comment">#消费者配置</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">hui_1</span> <span class="comment">#设置消费者的组id</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">auto-commit-interval:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> </span>&#123;</span><br><span class="line">	<span class="comment">// kafka模板</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">   	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送消息 参数一：topic ，参数二：消息，注意上面只指定了String类型的序列化，所以这里只能是String类型</span></span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;product&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    监听服务器上的kafka是否有相关的消息发过来</span></span><br><span class="line">    <span class="comment">//    record变量代表消息本身，可以通过ConsumerRecord&lt;?,?&gt;类型的record变量来打印接收的消息的各种信息</span></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;product&quot;)</span> <span class="comment">//定义此消费者接收topic为“test_topic”的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.prinln(<span class="string">&quot;主题：&quot;</span>+record.topic());</span><br><span class="line">        System.out.prinln(<span class="string">&quot;偏移量：&quot;</span>+record.offset());</span><br><span class="line">        System.out.prinln(<span class="string">&quot;消息：&quot;</span>+record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kafka原理"><a href="#kafka原理" class="headerlink" title="kafka原理"></a>kafka原理</h1><h2 id="分区域副本机制"><a href="#分区域副本机制" class="headerlink" title="分区域副本机制"></a>分区域副本机制</h2><p>kafka有三层结构：kafka有多个主题，每个主题有多个分区，每个分区又有多条消息。</p>
<p><strong>分区机制</strong>：主要解决了单台服务器存储容量有限和单台服务器并发数限制的问题 </p>
<p>当主题数据量非常大的时候，一个服务器存放不了，就将数据分成两个或者多个部分，存放在多台服务器上。每个服务器上的数据，叫做 一个分片。</p>
<p><strong>副本</strong>：副本备份机制解决了数据存储的高可用问题</p>
<p>当数据只保存一份的时候，有丢失的风险。为了更好的容错和容灾，将数据拷贝几份，保存到不同的机器上，当某台机器挂掉后，其他follower副本也能迅 速”转正“，开始对外提供服务。</p>
<h2 id="kafka数据不丢失机制"><a href="#kafka数据不丢失机制" class="headerlink" title="kafka数据不丢失机制"></a>kafka数据不丢失机制</h2><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>消息生产者保证数据不丢失：消息确认机制（ACK机制）,参考值有三个：0,1，-1 。默认1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;producer无需等待来自broker的确认而继续发送下一批消息。</span><br><span class="line">&#x2F;&#x2F;这种情况下数据传输效率最高，但是数据可靠性确是最低的。</span><br><span class="line">properties.put(ProducerConfig.ACKS_CONFIG,&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。</span><br><span class="line">&#x2F;&#x2F;这里有一个地方需要注意，这个副本必须是leader副本。</span><br><span class="line">&#x2F;&#x2F;只有leader副本成功写入了，producer才会认为消息发送成功。</span><br><span class="line">properties.put(ProducerConfig.ACKS_CONFIG,&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ack&#x3D;-1，简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。</span><br><span class="line">properties.put(ProducerConfig.ACKS_CONFIG,&quot;-1&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>Kafka consumer默认是自动提交位移的（先更新位移，再消费消息），如果消费程序出现故障，没消费完毕，则丢失了消息，此 时，broker并不知道。</p>
<p>我们可以关闭自动提交位移  <code>enable.auto.commit=false</code> 在消息被处理完后手动提交位移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,&quot;false&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="消息存储及查询机制"><a href="#消息存储及查询机制" class="headerlink" title="消息存储及查询机制"></a>消息存储及查询机制</h2><h3 id="消息存储机制"><a href="#消息存储机制" class="headerlink" title="消息存储机制"></a>消息存储机制</h3><p>kafka 使用日志文件的方式来保存生产者消息，每条消息都有一个 offset 值来表示它在分区中的偏移量。 </p>
<p>一个分片 并不是直接对应在一个磁盘上的日志文件，而是对应磁盘上 的一个目录，这个目录的命名规则是{topic_name}_{partition_id} , 在kafka容器数据目录<code> /kafka/kafka-logs-kafka1</code>中可以找到</p>
<p><strong>log分段</strong></p>
<p>每个分片目录中，kafka 通过分段的方式将 数据分为多个 LogSegment。 </p>
<p>一个 LogSegment 对应磁盘上的一个日志文件（00000000000000000000.log）和一个索引文件( 00000000000000000000.index)</p>
<p>其中日志文件是用来记录消息的。索引文件是用来保存消息的索引。</p>
<p>LogSegment的大小可以在server.properties中配置。当超过改大小时，会写入到一个新的LogSegment中，命名规则时当前offset+1</p>
<h3 id="消息查询机制"><a href="#消息查询机制" class="headerlink" title="消息查询机制"></a>消息查询机制</h3><p>存储的结构：一个主题 –&gt; 多个分区 —-&gt; 多个日志段（多个文件）</p>
<p>第一步，查询segment file：</p>
<p>​        segment file命名规则跟offset有关，所以只要根据offset 二分查找文件列表，就可以快速定位到具体文件。</p>
<p>第二步，通过segment file查找message：</p>
<p>​        直接通过offset顺序查找即可</p>
<h2 id="生产者消息分发机制"><a href="#生产者消息分发机制" class="headerlink" title="生产者消息分发机制"></a>生产者消息分发机制</h2><p>kafka在数据生产的时候，Partitioner接口定义数据方法策略，实现类 org.apache.kafka.clients.producer.internals.DefaultPartitioner</p>
<p>如果是用户指定了partition，生产就不会调用DefaultPartitioner.partition()方法 </p>
<p><strong>DefaultPartitioner源码</strong></p>
<p>如果指定key，是取决于key的hash值</p>
<p>如果不指定key，轮询分发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster</span></span></span><br><span class="line"><span class="function"><span class="params">                     cluster)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取该topic的分区列表</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="comment">//获得分区的个数</span></span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="comment">//如果key值为null</span></span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有指定key，那么就是轮询</span></span><br><span class="line">        <span class="comment">//维护一个key为topic的ConcurrentHashMap，并通过CAS操作的方式对value值执行递增+1操作</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">        <span class="comment">//获取该topic的可用分区列表</span></span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//如果可用分区大于0</span></span><br><span class="line">            <span class="comment">//执行求余操作，保证消息落在可用分区上</span></span><br><span class="line">            <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有可用分区的话，就给出一个不可用分区</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不过指定了key，key肯定就不为null</span></span><br><span class="line">        <span class="comment">// 通过计算key的hash，确定消息分区</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者负载均衡机制"><a href="#消费者负载均衡机制" class="headerlink" title="消费者负载均衡机制"></a>消费者负载均衡机制</h2><p>同一个分区中的数据，只能被一个消费者组中的一个消费者所消费，避免重复消费</p>
<p>消费组：一个消费组中可以包含多个消费者，<code>properties.put(ConsumerConfig.GROUP_ID_CONFIG,&quot;groupName&quot;)</code>；多个消费组可以重复消费消息。</p>
<p><a href="https://imgtu.com/i/4rc6Bj"><img src="https://z3.ax1x.com/2021/09/25/4rc6Bj.png" alt="4rc6Bj.png"></a></p>
<h2 id="kafka配置文件说明"><a href="#kafka配置文件说明" class="headerlink" title="kafka配置文件说明"></a>kafka配置文件说明</h2><p>server.properties配置文件</p>
<p><strong>1、broker.id=0</strong> </p>
<p>指定集群中broker的id， 是一个不小于0的整数，各brokerId必须不同，但不必连续。如果我们想扩展kafka集群，只需引入新节点，分配一个不同的broker.id即 可。</p>
<p><strong>2、log.dir = /export/data/kafka/</strong> </p>
<p>broker持久化消息到哪里，数据目录 </p>
<p><strong>3、log.retention.hours = 168</strong> </p>
<p>log文件最小存活时间，默认是168h，即7天。相同作用的还有log.retention.minutes、log.retention.ms。。 log.retention.bytes和log.retention.hours任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖。 </p>
<p><strong>4、log.retention.bytes</strong> </p>
<p>限制单个分区的log文件的最大值，超过这个值，将删除旧的log，以满足log文件不超过这个值。默认是-1，即不限制。</p>
<p><strong>5、log.retention.check.interval.ms</strong> </p>
<p>多长时间检查一次是否有log文件要删除。默认是300000ms，即5分钟。 </p>
<p><strong>6、log.roll.hours</strong> </p>
<p>多少时间会生成一个新的log segment，默认是168h，即7天。相同作用的还有log.roll.ms、segment.ms。 </p>
<p><strong>7、log.segment.bytes</strong></p>
<p>log segment多大之后会生成一个新的log segment，默认是1073741824，即1G。 </p>
<p><strong>8、log.flush.interval.messages</strong> </p>
<p>指定broker每收到几个消息就把消息从内存刷到硬盘（刷盘）。默认是9223372036854775807 好大。 </p>
<p>kafka官方不建议使用这个配置，建议使用副本机制和操作系统的后台刷新功能，因为这更高效。这个配置可以根据不同的topic设置不同的 值，即在创建topic的时候设置值。</p>
<p><strong>9、log.flush.interval.ms</strong> </p>
<p>指定broker每隔多少毫秒就把消息从内存刷到硬盘。默认值同log.flush.interval.messages一样， 9223372036854775807。 同log.flush.interval.messages一样，kafka官方不建议使用这个配置。 </p>
<p><strong>10、delete.topic.enable=true</strong> </p>
<p>是否允许从物理上删除topic，默认false</p>
<h1 id="kafka控制与运维"><a href="#kafka控制与运维" class="headerlink" title="kafka控制与运维"></a>kafka控制与运维</h1><p><strong>kafka-eagle</strong> </p>
<p>kafka-eagle 管理工具可以很容易地发现分布在集 群中的哪些topic分布不均匀，或者是分区在整个集群分布不均匀的的情况。它支持管理多个集群、选择副本、副本重新分配以及创建 Topic。同时，这个管理工具也是一个非常好的可以快速浏览这个集群的工具，</p>
<h2 id="搭建安装-kafka-eagle"><a href="#搭建安装-kafka-eagle" class="headerlink" title="搭建安装 kafka-eagle"></a>搭建安装 kafka-eagle</h2><p>由于eagle在docker中没有镜像，所以我们在之前搭建的传统集群中操作</p>
<p>环境要求:需要安装jdk，启动zk以及kafka的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动Zookeeper</span><br><span class="line">zkServer.sh start</span><br><span class="line">#启动Kafka</span><br><span class="line">nohup .&#x2F;kafka-server-start.sh &#x2F;export&#x2F;servers&#x2F;kafka&#x2F;config&#x2F;server.properties 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>修改windows host文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.200.11 node1</span><br><span class="line">192.168.200.12 node2</span><br><span class="line">192.168.200.13 node3</span><br></pre></td></tr></table></figure>
<ol>
<li>下载kafka-eagle的源码包,下载最新的安装包即可，如 kafka-eagle-bin-1.3.2.tar.gz</li>
</ol>
<p>kafka-eagle官网： <a href="http://download.kafka-eagle.org/">http://download.kafka-eagle.org/</a></p>
<p>代码托管地址： <a href="https://github.com/smartloli/kafka-eagle/releases">https://github.com/smartloli/kafka-eagle/releases</a></p>
<ol start="2">
<li>上传安装包并解压</li>
</ol>
<p>这里将kafka-eagle安装在node3虚拟机上</p>
<p>如果要解压的是zip格式，需要先安装命令支持。 </p>
<ul>
<li>yum install unzip</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将安装包上传至 node03服务器的&#x2F;export&#x2F;softwares路径下, 然后解压</span><br><span class="line">cd &#x2F;export&#x2F;softwares&#x2F;</span><br><span class="line">unzip kafka-eagle.zip</span><br><span class="line">cd  kafka-eagle-web&#x2F;target&#x2F;</span><br><span class="line">tar -zxf kafka-eagle-web-2.0.1-bin.tar.gz -C &#x2F;export&#x2F;servers</span><br></pre></td></tr></table></figure>
<p>3）准备数据库</p>
<p>eagle需要使用一个数据库来保存一些元数据，这里在node1服务器中创建一个mysql数据库。</p>
<p>可以使用docker镜像创建一个mysql容器，进入容器后进入mysql客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database eagle;</span><br></pre></td></tr></table></figure>
<p>默认情况下MySQL只允许本机连接到MYSQL实例中，所以如果要远程访问，必须开放权限： update user set host = ‘%’ where user =’root’; //修改权限 </p>
<p>flush privileges; //刷新配置</p>
<ol start="4">
<li>修改kafka-eagle配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;export&#x2F;servers&#x2F;kafka-eagle-bin-1.3.2&#x2F;kafka-eagle-web-1.3.2&#x2F;conf</span><br><span class="line">vim system-config.properties</span><br><span class="line">#内容如下:</span><br><span class="line">kafka.eagle.zk.cluster.alias&#x3D;cluster1</span><br><span class="line">cluster1.zk.list&#x3D;node1:2181,node2:2181,node3:2181</span><br><span class="line"></span><br><span class="line">kafka.eagle.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">kafka.eagle.url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.200.11:3306&#x2F;eagle</span><br><span class="line">kafka.eagle.username&#x3D;root</span><br><span class="line">kafka.eagle.password&#x3D;123456</span><br></pre></td></tr></table></figure>
<p>5）配置环境变量</p>
<p>kafka-eagle必须配置环境变量，node03服务器执行以下命令来进行配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">#内容如下:</span><br><span class="line">export KE_HOME&#x3D;&#x2F;export&#x2F;servers&#x2F;kafka-eagle-bin-1.3.2&#x2F;kafka-eagle-web-1.3.2</span><br><span class="line">export PATH&#x3D;:$KE_HOME&#x2F;bin:$PATH</span><br><span class="line">#让修改立即生效，执行</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>启动kafka-eagle</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd kafka-eagle-web-1.3.2&#x2F;bin</span><br><span class="line">chmod u+x ke.sh</span><br><span class="line">.&#x2F;ke.sh start</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>访问主界面</li>
</ol>
<p><a href="http://node03:8048/ke/account/signin?/ke/">http://node03:8048/ke/account/signin?/ke/</a> </p>
<p>用户名：admin 密码：123456</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表</title>
    <url>/2021/09/28/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<p>如今随着互联网的发展，数据的量级也是成指数的增长，从GB到TB到PB。对数据的各种操作也是愈加 的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。<a id="more"></a></p>
<p><strong>解决方案1</strong>: 使用NoSQL数据库, 通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支 持，来获取性能上的提升。 </p>
<p><strong>解决方案2</strong>:搭建MySQL数据库集群,为了提高查询性能, 将一个数据库的数据分 散到不同的数据库中存储,.</p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>分库分表 就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库 （主机）上面，以达到分散单台设备负载的效果。</p>
<p><strong>什么情况下需要分库分表</strong> </p>
<ul>
<li>单机存储容量遇到瓶颈。单表数据量超过1000万或100G的时候, 速度就会变慢(官方测试),</li>
<li>连接数,处理能力达到上限.</li>
</ul>
<h2 id="分库分表的方式"><a href="#分库分表的方式" class="headerlink" title="分库分表的方式"></a>分库分表的方式</h2><p>分库分表包括： 垂直分库、垂直分表、水平分库、水平分表 四种方式。</p>
<p><strong>垂直分库</strong> </p>
<ul>
<li>数据库中不同的表对应着不同的业务，垂直切分是指按照业务的不同将表进行分类,分布到不同的 数据库上面</li>
</ul>
<p><a href="https://imgtu.com/i/4WjJ0K"><img src="https://z3.ax1x.com/2021/09/28/4WjJ0K.png" alt="4WjJ0K.png" style="zoom: 50%;" /></a></p>
<p><strong>垂直分表</strong> </p>
<ul>
<li>将一个表按照字段分成多表，每个表存储其中一部分字段。</li>
<li><a href="https://imgtu.com/i/4WjQp9"><img src="https://z3.ax1x.com/2021/09/28/4WjQp9.png" alt="4WjQp9.png" style="zoom: 50%;" /></a> </li>
</ul>
<p><strong>水平分库</strong></p>
<ul>
<li>将单张表的数据切分到不同的数据库中，每个数据库具有相同的库与表，只是表中数据集合不同。</li>
</ul>
<p><a href="https://imgtu.com/i/4WjeTU"><img src="https://z3.ax1x.com/2021/09/28/4WjeTU.png" alt="4WjeTU.png" style="zoom:50%;" /></a></p>
<p><strong>水平分表</strong></p>
<ul>
<li>针对数据量巨大的单张表（比如订单表），按照规则把一张表的数据切分到多张表里面去。 但是 这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。</li>
</ul>
<p><a href="https://imgtu.com/i/4WjVmV"><img src="https://z3.ax1x.com/2021/09/28/4WjVmV.png" alt="4WjVmV.png" style="zoom:60%;" /></a></p>
<p>垂直拆分带来的一些提升 </p>
<ul>
<li>解决业务层面的耦合，业务清晰 </li>
<li>能对不同业务的数据进行分级管理、维护、监控、扩展等 </li>
<li>高并发场景下，垂直分库一定程度的提高访问性能 </li>
</ul>
<p>垂直拆分没有彻底解决单表数据量过大的问题，需要水平拆分。</p>
<h1 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h1><p>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，前 端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功 能是<strong>分库分表和读写分离</strong>。</p>
<p>MyCat对于我们Java程序员来说,就是一个近似等于 MySQL 的数据库服务器，你可以用连接 MySQL 的 方式去连接 Mycat（除了端 口不同8066）</p>
<p><a href="https://imgtu.com/i/4fSWV0"><img src="https://z3.ax1x.com/2021/09/28/4fSWV0.png" alt="4fSWV0.png" style="zoom:67%;" /></a></p>
<p><strong>MyCat支持的数据库</strong></p>
<p>Oracle 、MySQL、mongoDB 、SQlServer</p>
<h2 id="MyCat的分片策略"><a href="#MyCat的分片策略" class="headerlink" title="MyCat的分片策略"></a>MyCat的分片策略</h2><p><strong>分片</strong></p>
<p>通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机） 上面，以达到分散单台设备负载的效果。</p>
<p><strong>MyCat支持两种切分模式</strong></p>
<ul>
<li>1）按照不同的表（或者Schema）来切分到不同的数据库（主机）之上，这种切可以称之 为数据的<strong>垂直（纵向）切分</strong> </li>
<li>2）根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数 据库（主机）上面，这种切分称之为数据的<strong>水平（横向）切分</strong></li>
</ul>
<p><a href="https://imgtu.com/i/4fS2bq"><img src="https://z3.ax1x.com/2021/09/28/4fS2bq.png" alt="4fS2bq.png" style="zoom: 67%;" /></a></p>
<p><strong>逻辑库(schema)</strong></p>
<p>Mycat在操作时，使用逻辑库来代表这个完整的数据库集群，便于对 整个集群操作。</p>
<p><strong>逻辑表(table)</strong></p>
<p>分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p>
<p><strong>分片节点(dataNode)</strong></p>
<p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点 (dataNode）。</p>
<p><strong>节点主机(dataHost)</strong> </p>
<p>数据切分后，每个分片节点不一定都会独占一台机器，同一机器上面可以有多个分片数据库， 这 样一个或多个分片节点所在的机器就是节点主机，为了规避单节点主机并发数限制， 尽量将读写 压力高的分片节点均衡的放在不同的节点主机dataHost。</p>
<p><strong>分片规则</strong></p>
<p>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则rule，这样按照某种业务规则把数据分到 某个分片的规则就是分片规则。数据切分选择合适的分片规则非常重要，将极大的 避免后续数据处理的难度。</p>
<h2 id="MyCat的下载和安装"><a href="#MyCat的下载和安装" class="headerlink" title="MyCat的下载和安装"></a>MyCat的下载和安装</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li>jdk: 要求jdk必须是1.7 及以上版本 </li>
<li>MySQL: 推荐mysql5.5 版本以上 </li>
<li>MyCat: Mycat的官方网站：<a href="http://www.mycat.org.cn/">http://www.mycat.org.cn/</a></li>
</ol>
<p>第一步: 搭建3台虚拟机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node1 192.168.200.11</span><br><span class="line">node2 192.168.200.12</span><br><span class="line">node3 192.168.200.13</span><br></pre></td></tr></table></figure>
<p>第二步:node1与node2安装MySQL并创建库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node1 创建 hui1 数据库</span><br><span class="line">node2 创建 hui2 和 hui3 数据库</span><br></pre></td></tr></table></figure>
<h3 id="安装MyCat"><a href="#安装MyCat" class="headerlink" title="安装MyCat"></a>安装MyCat</h3><p>在node3中安装MyCat，前提安装好JDK</p>
<ul>
<li>下载MyCat，并上传到 node3服务器</li>
</ul>
<p><a href="https://imgtu.com/i/4fCjI0"><img src="https://z3.ax1x.com/2021/09/28/4fCjI0.png" alt="4fCjI0.png" style="zoom:50%;" /></a></p>
<ul>
<li>解压，可以直接使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf ...</span><br></pre></td></tr></table></figure>
<p><strong>相关命令</strong>(bin目录下)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动命令：.&#x2F;mycat start</span><br><span class="line">停止命令：.&#x2F;mycat stop</span><br><span class="line">重启命令：.&#x2F;mycat restart</span><br><span class="line">查看状态：.&#x2F;mycat status</span><br><span class="line">带控制台启动 .&#x2F;mycat console</span><br></pre></td></tr></table></figure>
<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><h3 id="Seheme-xml"><a href="#Seheme-xml" class="headerlink" title="Seheme.xml"></a>Seheme.xml</h3><p>Schema.xml作为MyCat中重要的配置文件之一，管理着MyCat的逻辑库、表、分片规则、DataNode以 及DataSource。弄懂这些配置，是正确使用MyCat的前提。</p>
<h4 id="schema标签"><a href="#schema标签" class="headerlink" title="schema标签"></a>schema标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 逻辑库 --&gt;</span><br><span class="line">&lt;schema name&#x3D;&quot;hui&quot; checkSQLschema&#x3D;&quot;true&quot; sqlMaxLimit&#x3D;&quot;100&quot; &gt;</span><br><span class="line">&lt;&#x2F;schema&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性名</th>
<th>值</th>
<th>数量限制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>checkSQLschema</td>
<td>Boolean</td>
<td>(1)</td>
<td>执行SQL时,是否去掉表所属的库名</td>
</tr>
<tr>
<td>sqlMaxLimit</td>
<td>Integer</td>
<td>(1)</td>
<td>查询返回的记录数限制limit</td>
</tr>
<tr>
<td>dataNode</td>
<td>任意String</td>
<td>(0..1)</td>
<td>分片节点</td>
</tr>
</tbody></table>
<h4 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h4><p>table标签定义了 Mycat 中的逻辑表，所有需要拆分的表都需要在这个标签中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;hui&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;pay_order&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>数量限制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>String</td>
<td>(1)</td>
<td>逻辑表名</td>
</tr>
<tr>
<td>dataNode</td>
<td>String</td>
<td>(1..*)</td>
<td>分片节点</td>
</tr>
<tr>
<td>rule</td>
<td>String</td>
<td>(0..1)</td>
<td>分片规则</td>
</tr>
<tr>
<td>primaryKey</td>
<td>String</td>
<td>(1)</td>
<td>主键</td>
</tr>
<tr>
<td>autoIncrement</td>
<td>Boolean</td>
<td>(0..1)</td>
<td>自增长主键</td>
</tr>
</tbody></table>
<h4 id="dataNode标签"><a href="#dataNode标签" class="headerlink" title="dataNode标签"></a>dataNode标签</h4><p>dataNode标签定义了 MyCat 中的分片节点，也就是我们通常说所的数据分片。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;hui1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;hui2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;hui3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>name： 定义节点的名字，这个名字需要是唯一的，table标签上需要用到。</li>
<li>dataHost : 用于定义该分片属于哪个分片主机。</li>
<li>database： 用于定义该分片节点属于哪个具体的库。</li>
</ul>
<h4 id="dataHost标签"><a href="#dataHost标签" class="headerlink" title="dataHost标签"></a>dataHost标签</h4><p>dataHost标签在 Mycat 逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分 离配置和心跳语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 节点主机 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span><span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.11:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.12:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>String</td>
<td>节点主机名</td>
</tr>
<tr>
<td>maxCon</td>
<td>Integer</td>
<td>最大连接数</td>
</tr>
<tr>
<td>minCon</td>
<td>Integer</td>
<td>最小连接数</td>
</tr>
<tr>
<td>balance</td>
<td>Integer</td>
<td>读操作负载均衡类型</td>
</tr>
<tr>
<td>writeType</td>
<td>Integer</td>
<td>写操作负载均衡类型</td>
</tr>
<tr>
<td>dbType</td>
<td>String</td>
<td>数据库类型</td>
</tr>
<tr>
<td>dbDriver</td>
<td>String</td>
<td>数据库驱动</td>
</tr>
<tr>
<td>switchType</td>
<td>String</td>
<td>主从切换类型</td>
</tr>
</tbody></table>
<h4 id="heartbeat标签"><a href="#heartbeat标签" class="headerlink" title="heartbeat标签"></a>heartbeat标签</h4><p>heartbeat标签内指明用于和后端数据库进行心跳检查的语句。例如：MySQL 可以使用 select user()、 Oracle 可以 使用 select 1 from dual 等</p>
<h4 id="writeHost和readHost标签"><a href="#writeHost和readHost标签" class="headerlink" title="writeHost和readHost标签"></a>writeHost和readHost标签</h4><ul>
<li>writeHost和readHost标签都指定后端数据库的相关配置给 mycat，用于实例化后端连接池。 </li>
<li>writeHost 指定写实例 , readHost 指定读实例. 在一个 dataHost 内可以定义多个 writeHost 和 readHost</li>
</ul>
<p>例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;M1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.11:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;S1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.12:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span> <span class="attr">weight</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>主机名</td>
</tr>
<tr>
<td>url</td>
<td>连接字符串</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
</tr>
<tr>
<td>user</td>
<td>用户名</td>
</tr>
<tr>
<td>weight</td>
<td>权重</td>
</tr>
<tr>
<td>usingDecrypt</td>
<td>是否对密码加密，默认0</td>
</tr>
</tbody></table>
<h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><p>server.xml几乎保存了所有 mycat 需要的系统配置信息。</p>
<h4 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>hui<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>hui<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>user标签里设置了用户名和密码，可以远程访问MyCat，端口是8066</p>
<h3 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h3><p>rule.xml里面就定义了我们对表进行拆分所涉及到的规则定义。此配置文件可以不用修改，使用默认即可。</p>
<h4 id="tableRule标签"><a href="#tableRule标签" class="headerlink" title="tableRule标签"></a>tableRule标签</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span>   # 指定唯一的名字</span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span>  # 指定对物理表中的哪一列进行拆分和使用什么路由算法</span><br><span class="line">            <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span> # 指定要拆分的列名字</span><br><span class="line">            <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span>  # 使用function标签中的name属性</span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="function标签"><a href="#function标签" class="headerlink" title="function标签"></a>function标签</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>name：指定算法的名字。 </li>
<li>class：制定路由算法具体的类名字。 </li>
<li>property： 为具体算法需要用到的一些属性</li>
</ul>
<h3 id="常用的分片规则"><a href="#常用的分片规则" class="headerlink" title="常用的分片规则"></a>常用的分片规则</h3><h4 id="自动分片"><a href="#自动分片" class="headerlink" title="自动分片"></a>自动分片</h4><p>根据指定的列的范围进行分片.默认从0节点开始</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>autopartition-long.txt文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K&#x3D;1000,M&#x3D;10000.</span><br><span class="line">0-1k&#x3D;0    # 0-1000范围分配给节点1</span><br><span class="line">1k-2k&#x3D;1   # 1000-2000范围分配给节点2</span><br><span class="line">2k-3k&#x3D;2   # 2000-3000范围分配给节点3</span><br></pre></td></tr></table></figure>
<h4 id="枚举分片"><a href="#枚举分片" class="headerlink" title="枚举分片"></a>枚举分片</h4><p>把数据分类存储, 这种方法适用于取值固定的场合，例如性别和省份</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>partition-hash-int.txt文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 举例，按城市分类</span><br><span class="line">beijing&#x3D;0</span><br><span class="line">wuhan&#x3D;1</span><br><span class="line">shanghai&#x3D;2</span><br></pre></td></tr></table></figure>
<h4 id="取模分片"><a href="#取模分片" class="headerlink" title="取模分片"></a>取模分片</h4><p>根据配置中的count值进行分片，将数据分成配置的count份，然后将数据均匀的分布在各个节点上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="MyCat分库分表"><a href="#MyCat分库分表" class="headerlink" title="MyCat分库分表"></a>MyCat分库分表</h2><p>这里采用<strong>水平分库</strong>，相关配置上面都定义好了，rule规则采用自动分片 auto-sharding-long，autopartition-long.txt文件也按照上面的配置。</p>
<p>1）启动MyCat  <code>./Mycat start</code></p>
<p>2）用SQLyog等工具连接MyCat，用户名：root,密码：123456，ip：192.168.200.13，端口：8806</p>
<p>3）在MyCat中创建逻辑表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS pay_order;</span><br><span class="line"></span><br><span class="line">CREATE TABLE pay_order (</span><br><span class="line">    id BIGINT(20) PRIMARY KEY,</span><br><span class="line">    user_id INT(11) NOT NULL ,</span><br><span class="line">    product_name VARCHAR(128) ,</span><br><span class="line">    amount DECIMAL(12,2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>MyCat中创建好表之后,我们的MySQL节点中也会对应的创建表</p>
<p><a href="https://imgtu.com/i/4fQHQs"><img src="https://z3.ax1x.com/2021/09/28/4fQHQs.png" alt="4fQHQs.png" style="zoom: 80%;" /></a></p>
<p>测试: mycat中插入数据，指定id，观察具体插入到哪张表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO pay_order(id,user_id,product_name,amount) VALUES(2001,1,&quot;面试宝典&quot;,15.8);</span><br></pre></td></tr></table></figure>
<p><strong>全局序列号</strong></p>
<p>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的全局唯一。为此，Mycat 提供了全局 sequence，并且提供了包含本地配置和数据库配置等多种实现方式。</p>
<ul>
<li>配置server.xml </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 表示是表示使用本地文件方式。这里采用该方式</span><br><span class="line">1 表示的是根据数据库来生成</span><br><span class="line">2 表示时间戳的方式 ID&#x3D; 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加)</span><br></pre></td></tr></table></figure>
<ul>
<li>配置conf/sequence_conf.properties </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PAY_ORDER.HISIDS&#x3D;			# 使用过的历史分段(一般无特殊需要可不配置)，</span><br><span class="line">PAY_ORDER.MINID&#x3D;101      	# 最小 ID 值</span><br><span class="line">PAY_ORDER.MAXID&#x3D;10000000	# 最大 ID 值</span><br><span class="line">PAY_ORDER.CURID&#x3D;100			# 当前 ID 值</span><br></pre></td></tr></table></figure>
<p>此时需重启MyCat <code>./Mycat restart </code> , 插入数据时不需要指定id</p>
<h2 id="MyCat读写分离"><a href="#MyCat读写分离" class="headerlink" title="MyCat读写分离"></a>MyCat读写分离</h2><p>在实际的生产环境中, 数据的读写操作如果都在同一个数据库服务器中进行, 当遇到大量的并发读或者写 操作的时候,是没有办法满足实际需求的,数据库的吞吐量将面临巨大的瓶颈压力。</p>
<p><strong>读写分离</strong>就是让主库处理事务性操作，从库处理select查询。数据库复制被用来把事务性查询导致 的数据变更同步到从库，同时主库也可以select查询。</p>
<p><a href="https://imgtu.com/i/4f1NE6"><img src="https://z3.ax1x.com/2021/09/28/4f1NE6.png" alt="4f1NE6.png" style="zoom: 80%;" /></a></p>
<p><strong>MySQL主从复制(同步)</strong></p>
<p>MyCat的读写分离是建立在MySQL主从复制基础之上实现的，所以必须先搭建MySQL的主从复制架构。</p>
<p><strong>主从复制的用途</strong> </p>
<ul>
<li>实时灾备，用于故障切换 </li>
<li>读写分离，提供查询服务 </li>
<li>备份，避免影响业务</li>
</ul>
<p><strong>主从复制的原理</strong></p>
<ul>
<li>Mysql 中有一种日志叫做 bin 日志（二进制日志）。这个日志会记录下所有修改了数据库的SQL 语句（insert,update,delete,create/alter/drop table, grant 等等）。 </li>
<li>主从复制的原理其实就是把主服务器上的 bin 日志复制到从服务器上执行一遍，这样从服务器上的 数据就和主服务器上的数据相同了。</li>
</ul>
<p><a href="https://imgtu.com/i/4f1bV0"><img src="https://z3.ax1x.com/2021/09/28/4f1bV0.png" alt="4f1bV0.png"></a></p>
<p>主库:</p>
<ul>
<li>主库db的更新事件(update、insert、delete)被写到binlog </li>
<li>主库创建一个binlog dump thread，把binlog的内容发送到从库</li>
</ul>
<p>从库启动之后：</p>
<ul>
<li><p>发起连接，连接到主库</p>
</li>
<li><p>创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log </p>
</li>
<li><p>创建一个SQL线程，从relay log里面读取内容，执行读取到的更新事件，将更新内 容写入到slave的db</p>
</li>
</ul>
<h3 id="搭建主从复制架构"><a href="#搭建主从复制架构" class="headerlink" title="搭建主从复制架构"></a>搭建主从复制架构</h3><p>需求: node1(192.168.200.11) 作为Master ，node2 (192.168.200.12) 作为 Slave</p>
<p><strong>1) 第一步 master中创建数据库和表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE test CHARACTER SET utf8;</span><br><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">id INT(11) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20) DEFAULT NULL,</span><br><span class="line">age INT(11) DEFAULT NULL</span><br><span class="line">);</span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO users VALUES(NULL,&#39;user1&#39;,20);</span><br><span class="line">INSERT INTO users VALUES(NULL,&#39;user2&#39;,21);</span><br><span class="line">INSERT INTO users VALUES(NULL,&#39;user3&#39;,22);</span><br></pre></td></tr></table></figure>
<p><strong>2) 第二步 修改主数据库的配置文件my.cnf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure>
<p>插入下面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_case_table_names&#x3D;1</span><br><span class="line"></span><br><span class="line">server-id&#x3D;1</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">binlog-do-db&#x3D;test</span><br><span class="line">binlog_ignore_db&#x3D;mysql</span><br></pre></td></tr></table></figure>
<ul>
<li>server-id=1 中的1可以任定义，只要是唯一的就行。 </li>
<li>log-bin=mysql-bin 表示启用binlog功能，并制定二进制日志的存储目录， </li>
<li>binlog-do-db=test 是表示只备份test 数据库。 </li>
<li>binlog_ignore_db=mysql 表示忽略备份mysql。 </li>
<li>不加binlog-do-db和binlog_ignore_db，那就表示备份全部数据库。</li>
</ul>
<p><strong>3) 第三步 重启MySQL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><strong>4) 第四步 在主数据库上, 创建一个允许从数据库来访问的用户账号.</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建账号,用户名slave ，密码 123456</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;192.168.200.12&#39; IDENTIFIED BY &#39;Qwer@1234&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>5) 第五步 停止主数据库的更新操作, 并且生成主数据库的备份</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 执行以下命令锁定数据库以防止写入数据。</span><br><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
<p><strong>6) 导出数据库,恢复写操作</strong> </p>
<p>使用SQLYog导出,主数据库备份完毕，恢复写操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p><strong>7) 将刚才主数据库备份的test.sql导入到从数据库</strong> </p>
<p>导入后, 主库和从库数据会追加相平，保持同步！此过程中，若主库存在业务，并发较高，在同步的时 候要先锁表，让其不要有修改！等待主从数据追平，主从同步后在打开锁！</p>
<p><strong>8) 接着修改从数据库的 my.cnf</strong> </p>
<ul>
<li>增加server-id参数,保证唯一.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id&#x3D;2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 重启</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><strong>9) 在从数据库设置相关信息</strong></p>
<p>执行以下SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOP SLAVE;</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.200.11&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;slave&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;Qwer@1234&#39;,</span><br><span class="line">MASTER_PORT&#x3D;3306,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;0,</span><br><span class="line">MASTER_CONNECT_RETRY&#x3D;10;</span><br></pre></td></tr></table></figure>
<p><strong>10) 修改auto.cnf中的UUID,保证唯一</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 编辑auto.cnf</span><br><span class="line">vim &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;auto.cnf</span><br><span class="line"></span><br><span class="line">-- 修改UUID的值</span><br><span class="line">server-uuid&#x3D;a402ac7f-c392-11ea-ad18-000c2980a208</span><br><span class="line"></span><br><span class="line">-- 重启</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><strong>11) 在从服务器上,启动slave 进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- stop slave; 如果之前启动了slave进程，要先关闭</span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">-- 查看状态</span><br><span class="line">SHOW SLAVE STATUS;</span><br></pre></td></tr></table></figure>
<p>注意: 这两个参数的值,必须是 Yes,否则就要进行错误的排查.</p>
<p><a href="https://imgtu.com/i/4f4MgU"><img src="https://z3.ax1x.com/2021/09/28/4f4MgU.png" alt="4f4MgU.png"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 命令行下查看状态,如果上面两个参数错误就执行该语句，查看报错情况</span><br><span class="line">SHOW SLAVE STATUS \G;</span><br></pre></td></tr></table></figure>
<p><strong>12) 现在可以在我们的主服务器做一些更新的操作,然后在从服务器查看是否已经更新</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如在主库插入一条数据,观察从库是否同步</span><br><span class="line">INSERT INTO users VALUES(NULL,&#39;user4&#39;,23);</span><br></pre></td></tr></table></figure>
<h3 id="实现读写分离"><a href="#实现读写分离" class="headerlink" title="实现读写分离"></a>实现读写分离</h3><p>对于 MySQL来说，标准的读写分离是<strong>主从模式</strong>，一个写节点Master后面跟着多个读节点，读节点的数量取 决于系统的压力，通常是1-3个读节点的配置</p>
<p>在schema.xml文件中配置Mycat读写分离。使用前需要搭建MySQL主从架构，并实现主从复制， Mycat不负责数据同步问题。</p>
<p><a href="https://imgtu.com/i/4f44Kg"><img src="https://z3.ax1x.com/2021/09/28/4f44Kg.png" alt="4f44Kg.png" style="zoom:67%;" /></a></p>
<ul>
<li>server.xml</li>
</ul>
<p>修改用户可以访问的逻辑表为 test</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>schema标签<ul>
<li>逻辑库 name=”test” </li>
<li>逻辑表 name=”users” </li>
<li>读写分离 不设置分片规则 ruleRequired=false </li>
<li>分片节点 dataNode=”dn4”</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">ruleRequired</span>=<span class="string">&quot;false&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>dataNode标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读写分离 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;test&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>dataHost标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读写分离 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;M1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.11:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 从 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;S1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.200.12:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">password</span>=<span class="string">&quot;OddDog@666&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">weight</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>balance参数</strong>：</p>
<ul>
<li>0 ：所有读操作都发送到当前可用的writeHost </li>
<li>1 ：所有读操作都随机发送到readHost和stand by writeHost </li>
<li>2 ：所有读操作都随机发送到writeHost和readHost </li>
<li>3 ：所有读操作都随机发送到writeHost对应的readHost上，但是writeHost不负担读压力</li>
</ul>
<p><strong>writeType参数</strong>： </p>
<ul>
<li>0 ：所有写操作都发送到可用的writeHost </li>
<li>1 ：所有写操作都随机发送到readHost </li>
<li>2 ：所有写操作都随机发送到writeHost，readHost</li>
</ul>
<p><strong>重启MyCat</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;mycat restart</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<ol>
<li>插入一条数据, 观察否两个表都同时新增了,如果同时新增,证明插入的是主库的表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO users(NAME,age) VALUES(&#39;测试abc&#39;,26);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在从库插入一条数据, 然后进行查询, 查询的是从库中的数据,证明查询操作在从库进行.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users;</span><br></pre></td></tr></table></figure>
<p>本人在操作时出现的问题：</p>
<p>1）在配置文件中添加注释，启动MyCat会报错，但是我看它原本就有别的注释</p>
<p>2）MyCat中添加一条数据时，一定要这样写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO users(id,NAME,age) VALUES(0,&#39;测试abc&#39;,26);</span><br></pre></td></tr></table></figure>
<p>需要把字段完整地写出来，少一个或不写都不行，具体情况我也有点懵，如果出现这种错误经量去避免它就好了。。。</p>
<h1 id="ShardingJDBC"><a href="#ShardingJDBC" class="headerlink" title="ShardingJDBC"></a>ShardingJDBC</h1><p><strong>分库分表带来的问题</strong> </p>
<p>关系型数据库在单机单库的情况下,比较容易出现性能瓶颈问题,分库分表可以有效的解决这方面的问 题,但是同时也会产生一些 比较棘手的问题.</p>
<ul>
<li><p>事务一致性问题 </p>
<ul>
<li>当我们需要更新的内容同时分布在不同的库时, 不可避免的会产生跨库的事务问题. 原来在一个数据库操 作, 本地事务就可以进行控制, 分库之后 一个请求可能要访问多个数据库,如何保证事务的一致性,目前还 没有简单的解决方案. </li>
</ul>
</li>
<li><p>跨节点关联的问题 </p>
<ul>
<li>在分库之后, 原来在一个库中的一些表,被分散到多个库,并且这些数据库可能还不在一台服务器,无法关联 查询. 解决这种关联查询,需要我们在代码层面进行控制,将关联查询拆开执行,然后再将获取到的结果进行拼装. </li>
</ul>
</li>
<li><p>分页排序查询的问题 </p>
<ul>
<li>分库并行查询时,如果用到了分页 每个库返回的结果集本身是无序的, 只有将多个库中的数据先查出来,然 后再根据排序字段在内存中进行排序,如果查询结果过大也是十分消耗资源的. </li>
</ul>
</li>
<li><p>主键避重问题</p>
<ul>
<li>在分库分表的环境中,表中的数据存储在不同的数据库, 主键自增无法保证ID不重复, 需要单独设计全局主 键. </li>
</ul>
</li>
<li><p>公共表的问题 </p>
<ul>
<li>不同的数据库,都需要从公共表中获取数据. 可以在每一个库都创建这个公共表, 所有对公共表的更新操 作,都同时发送到所有分库执行. ShardingJDBC可以帮助我们解决这个问题.</li>
</ul>
</li>
</ul>
<h2 id="ShardingJDBC简介"><a href="#ShardingJDBC简介" class="headerlink" title="ShardingJDBC简介"></a>ShardingJDBC简介</h2><p><strong>ShardingSphere</strong>是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、 Sharding-Proxy和Sharding-Sidecar 这3款相互独立的产品组成,我们只关注 Sharding-JDBC 即可</p>
<p>官方地址：<a href="https://shardingsphere.apache.org/document/current/cn/overview/">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>
<p><strong>Sharding-JDBC</strong> 定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据 库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种 ORM框架的使用。 </p>
<ul>
<li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使 用JDBC。 </li>
<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, Druid等。 </li>
<li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li>
</ul>
<p> <strong>Sharding-JDBC主要功能</strong> </p>
<ul>
<li>数据分片</li>
<li>读写分离 </li>
</ul>
<p>通过Sharding-JDBC，应用可以透明的使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关 心数据源的数量以及数据如何分布。</p>
<p><strong>Sharding-JDBC与MyCat的区别</strong></p>
<ol>
<li><p>mycat是一个中间件的第三方应用，sharding-jdbc是一个jar包 </p>
</li>
<li><p>使用mycat时不需要修改代码，而使用sharding-jdbc时需要修改代码 </p>
</li>
<li><p>Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 的扩展，是以 jar 包的形式提供轻量级服务的。</p>
</li>
</ol>
<ul>
<li>Mycat(proxy中间件层)</li>
</ul>
<p><a href="https://imgtu.com/i/45sNbq"><img src="https://z3.ax1x.com/2021/09/29/45sNbq.png" alt="45sNbq.png" style="zoom: 80%;" /></a></p>
<ul>
<li>Sharding-jdbc(应用层)</li>
</ul>
<p><a href="https://imgtu.com/i/45saV0"><img src="https://z3.ax1x.com/2021/09/29/45saV0.png" alt="45saV0.png" style="zoom:67%;" /></a></p>
<h2 id="ShardingJDBC的基本使用"><a href="#ShardingJDBC的基本使用" class="headerlink" title="ShardingJDBC的基本使用"></a>ShardingJDBC的基本使用</h2><h3 id="搭建基础环境"><a href="#搭建基础环境" class="headerlink" title="搭建基础环境"></a>搭建基础环境</h3><p><strong>需求说明</strong> </p>
<p>创建数据库lg_order, 模拟将订单表进行水平拆分, 创建两张表pay_order_1 与 pay_order_2，这两 张表是订单表拆分后的表,我们通过Sharding-Jdbc向订单表插入数据，按照一定的分片规则，主键 为偶数的落入pay_order_1表 ，为奇数的落入pay_order_2表, 再通过Sharding-Jdbc 进行查询.</p>
<p><strong>创建数据库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE lg_order CHARACTER SET &#39;utf8&#39;;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS pay_order_1;</span><br><span class="line">CREATE TABLE pay_order_1 (</span><br><span class="line">    order_id BIGINT(20) PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    user_id INT(11) ,</span><br><span class="line">    product_name VARCHAR(128),</span><br><span class="line">    COUNT INT(11)</span><br><span class="line">);</span><br><span class="line">DROP TABLE IF EXISTS pay_order_2;</span><br><span class="line">CREATE TABLE pay_order_2 (</span><br><span class="line">    order_id BIGINT(20) PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    user_id INT(11) ,</span><br><span class="line">    product_name VARCHAR(128),</span><br><span class="line">    COUNT INT(11)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>创建SpringBoot项目引入maven依赖</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="分片规则配置-水平分表"><a href="#分片规则配置-水平分表" class="headerlink" title="分片规则配置(水平分表)"></a>分片规则配置(水平分表)</h3><p>使用sharding-jdbc 对数据库中水平拆分的表进行操作,通过sharding-jdbc对分库分表的规则进行配 置,配置内容包括：数据源、主键生成策略、分片策略等。</p>
<p><strong>application.properties</strong> </p>
<ul>
<li>基础配置</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span> = <span class="string">sharding-jdbc-simple</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span> = <span class="string">/sharding-jdbc</span></span><br><span class="line"><span class="meta">spring.http.encoding.enabled</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span> = <span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span> = <span class="string">true #</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打开SQL输出日志 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.props.sql.show &#x3D; true</span><br></pre></td></tr></table></figure>
<ul>
<li>数据源</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 水平分表</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span> = <span class="string">db1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.type</span> = <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.driver-class-name</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.url</span> = <span class="string">jdbc:mysql://localhost:3306/lg_order?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.password</span> = <span class="string">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置数据节点,查询时使用</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置数据节点,指定节点的信息</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.actual-data-nodes</span> = <span class="string">db1.pay_order_$-&gt;&#123;1..2&#125;</span></span><br></pre></td></tr></table></figure>
<p>表达式 db1.pay_order_$-&gt;{1..2} ，$ 会被 大括号中的 {1..2} 所替换 </p>
<p>会有两种选择: db1.pay_order_1 和 db1.pay_order_2</p>
<ul>
<li>配置分片算法</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定pay_order表的分片策略，分片策略包括分片键和分片算法</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.table-strategy.inline.sharding-column</span> = <span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.table-strategy.inline.algorithm-expression</span> = <span class="string">pay_order_$-&gt;&#123;order_id % 2 + 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>分表策略表达式: pay_order_$-&gt; {order_id % 2 + 1} </p>
<p>​        {order_id % 2 + 1} 结果是偶数 操作 pay_order_1表 </p>
<p>​        {order_id % 2 + 1} 结果是奇数 操作 pay_order_2表</p>
<ul>
<li>配置主键生成策略</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定pay_order表 (逻辑表)的主键生成策略为 SNOWFLAKE</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.key-generator.column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure>
<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>在启动类添加<code>@MapperScan</code>注解，指定mapper接口所在包的位置</p>
<p><strong>PayOrderMapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayOrderMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO pay_order (user_id,product_name,COUNT) VALUES(#&#123;user_id&#125;,#&#123;product_name&#125;,#&#123;count&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="meta">@Param(&quot;user_id&quot;)</span> Integer user_id,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="meta">@Param(&quot;product_name&quot;)</span> String product_name,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="meta">@Param(&quot;count&quot;)</span> Integer count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ids查询</span></span><br><span class="line">    <span class="meta">@Select(&#123;</span></span><br><span class="line"><span class="meta">        &quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;select * from pay_order where order_id in &quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;foreach collection=&#x27;ids&#x27; item=&#x27;id&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27; &gt;#&#123;id&#125;&lt;/foreach&gt;&quot; +</span></span><br><span class="line"><span class="meta">         &quot;&lt;/script&gt;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">List&lt;Map&gt; <span class="title">findByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PayOrderMapper payOrderMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  水平分表---添加，id是自动生成的，会根据其奇偶性判断去哪个表插入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertPayOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入10条数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        payOrderMapper.add(i, <span class="string">&quot;海尔电视&quot;</span> + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平分表--查询，会发送两条SQL语句，一条是去order_1查询下面两个id，另一条是去order_2查询下面两个id</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOrderByIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ids.add(<span class="number">649932127885852672L</span>); <span class="comment">//数据库的 order_1表</span></span><br><span class="line">    ids.add(<span class="number">649932127986515969L</span>); <span class="comment">//数据库的 order_2表</span></span><br><span class="line">    List&lt;Map&gt; mapList = payOrderMapper.findByIds(ids);</span><br><span class="line">    System.out.println(mapList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShardingJDBC执行流程"><a href="#ShardingJDBC执行流程" class="headerlink" title="ShardingJDBC执行流程"></a>ShardingJDBC执行流程</h3><p><a href="https://imgtu.com/i/4564jH"><img src="https://z3.ax1x.com/2021/09/29/4564jH.png" alt="4564jH.png" style="zoom:67%;" /></a></p>
<ol>
<li>SQL解析: 编写SQL查询的是逻辑表, 执行时 ShardingJDBC 要解析SQL ,解析的目的是为了找到需 要改写的位置. </li>
<li>SQL路由: SQL的路由是指 将对逻辑表的操作,映射到对应的数据节点的过程. ShardingJDBC会获取 分片键判断是否正确,正确 就执行分片策略(算法) 来找到真实的表. </li>
<li>SQL改写: 程序员面向的是逻辑表编写SQL, 并不能直接在真实的数据库中执行,SQL改写用于将逻辑 SQL改为在真实的数据库中可以正确执行的SQL. </li>
<li>SQL执行: 通过配置规则 pay_order_$-&gt;{order_id % 2 + 1} ,可以知道当 order_id 为偶数时 , 应该向 pay_order_1表中插入数据, 为奇数时向 pay_order_2表插入数据. </li>
<li>将所有真正执行sql的结果进行汇总合并，然后返回。</li>
</ol>
<h2 id="ShardingJDBC分库分表"><a href="#ShardingJDBC分库分表" class="headerlink" title="ShardingJDBC分库分表"></a>ShardingJDBC分库分表</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>刚刚上面的操作就是<strong>水平分表</strong>，把一张表的数据分配到同一个数据库的多张表中。</p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</p>
<p><a href="https://imgtu.com/i/45ckCT"><img src="https://z3.ax1x.com/2021/09/29/45ckCT.png" alt="45ckCT.png"></a></p>
<p>用上面个的sql语句，创建两个数据库(修改库名即可)，两张表。</p>
<h4 id="分片规则配置"><a href="#分片规则配置" class="headerlink" title="分片规则配置"></a>分片规则配置</h4><p><strong>配置两份数据源信息</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 水平分库，定义多个数据源</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span> = <span class="string">db1,db2</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.type</span> =<span class="string">com.alibaba.druid.pool.DruidDataSource   </span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.driver-class-name</span> =<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.url</span> =<span class="string">jdbc:mysql://localhost:3306/lg_order_1?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db1.password</span> = <span class="string">123456</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db2.type</span> =<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db2.driver-class-name</span> =<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db2.url</span> =<span class="string">jdbc:mysql://localhost:3306/lg_order_2?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db2.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db2.password</span> = <span class="string">123456</span></span><br></pre></td></tr></table></figure>
<p><strong>通过配置对数据库的分片策略,来指定数据库进行操作</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分库策略，以user_id为分片键，分片策略为user_id % 2 + 1，user_id为偶数操作db1数据源，否则操作db2。</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.database-strategy.inline.sharding-column</span>= <span class="string">user_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.database-strategy.inline.algorithm-expression</span>= <span class="string">db$-&gt;&#123;user_id % 2 + 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，这里是分库策略 <code>database-strategy</code>，水平分表中的是分表策略<code>table-strategy</code></p>
<p><strong>修改数据节点配置</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置数据节点,指定节点的信息</span></span><br><span class="line"><span class="comment">#spring.shardingsphere.sharding.tables.pay_order.actual-data-nodes = db1.pay_order_$-&gt;&#123;1..2&#125;</span></span><br><span class="line"><span class="comment"># 水平分库，需要定义两个库(上面是水平分表，数据库写死了)</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.pay_order.actual-data-nodes</span> = <span class="string">db$-&gt;&#123;1..2&#125;.pay_order_$-&gt;&#123;1..2&#125; </span></span><br></pre></td></tr></table></figure>
<p> Sharding-JDBC支持以下几种分片策略： （具体信息请查阅官方文档：<a href="https://shardingsphere.apache.org)/">https://shardingsphere.apache.org）</a></p>
<ul>
<li>standard：标准分片策略 </li>
<li>complex：符合分片策略 </li>
<li>inline：行表达式分片策略,使用Groovy的表达式. （上面使用的是该策略）</li>
<li>hint：Hint分片策略，对应HintShardingStrategy。 </li>
<li>none：不分片策略，对应NoneShardingStrategy。不分片的策略。</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>编写mapper接口，与测试代码(省略)。</p>
<p>水平分库是建立在水平分表基础上的，插入数据时：</p>
<ul>
<li><p>首先会根据分库策略找到对应的数据库 db$-&gt;{user_id % 2 + 1} </p>
</li>
<li><p>然后再根据分表策略 找到要插入数据的表 pay_order_$-&gt;{order_id % 2 + 1}</p>
</li>
</ul>
<p>查询时，会发送4条语句，db1两条，db2两条。</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上， 它的核心理念是专库专用. </p>
<p>所以这里配置垂直分库就像是在操作一个单一的数据库。</p>
<h4 id="创建数据库信息"><a href="#创建数据库信息" class="headerlink" title="创建数据库信息"></a>创建数据库信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE lg_user CHARACTER SET &#39;utf8&#39;;</span><br><span class="line">DROP TABLE IF EXISTS users;</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id BIGINT(20) PRIMARY KEY,</span><br><span class="line">    username VARCHAR(20) ,</span><br><span class="line">    phone VARCHAR(11),</span><br><span class="line">    STATUS VARCHAR(11)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h4><ul>
<li>数据源</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span> = <span class="string">db1,db2,db3,</span></span><br><span class="line"><span class="comment"># 垂直分库，就是一个单库的操作</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db3.type</span> =<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db3.driver-class-name</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db3.url</span> = <span class="string">jdbc:mysql://localhost:3306/lg_user?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db3.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.db3.password</span> = <span class="string">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数据节点与分片策略</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 垂直分库，配置数据节点</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.users.actual-data-nodes</span> = <span class="string">db$-&gt;&#123;3&#125;.users</span></span><br><span class="line"><span class="comment"># 分片策略，id直接指向自己</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.users.table-strategy.inline.sharding-column</span>= <span class="string">id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.users.table-strategy.inline.algorithm-expression</span>= <span class="string">users</span></span><br></pre></td></tr></table></figure>
<p>测试省略。</p>
<h2 id="操作公共表"><a href="#操作公共表" class="headerlink" title="操作公共表"></a>操作公共表</h2><p><strong>公共表</strong>  属于系统中数据量较小，变动少，而且属于高频联合查询的依赖表。参数表、数据字典表等属 于此类型。 可以将这类表在每个数据库都保存一份，所有更新操作都同时发送到所有分库执行。</p>
<p><a href="https://imgtu.com/i/45RNqJ"><img src="https://z3.ax1x.com/2021/09/29/45RNqJ.png" alt="45RNqJ.png" style="zoom: 80%;" /></a></p>
<p>1）创建数据库</p>
<p>在lg_order1 , lg_order2 , lg_user 数据库都创建 district表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 区域表</span><br><span class="line">CREATE TABLE district (</span><br><span class="line">    id BIGINT(20) PRIMARY KEY COMMENT &#39;区域ID&#39;,</span><br><span class="line">    district_name VARCHAR(100) COMMENT &#39;区域名称&#39;,</span><br><span class="line">    LEVEL INT COMMENT &#39;等级&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在Sharding-JDBC的配置文件中 指定公共表</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定district为公共表</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.broadcast-tables</span>=<span class="string">district</span></span><br><span class="line"><span class="comment"># 主键生成策略</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.district.key-generator.column</span>=<span class="string">id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.district.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写代码, 操作公共表</li>
</ol>
<p>编写mapper接口与测试类，经行如何操作，3个数据库中的表都执行一致的操作。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>Sharding-JDBC读写分离则是根据SQL语义的分析，将读操作和写操作分别路由至主库与从库。它提供透明化读写分离，让使用方尽量像使用一个数据库一样使用主从数据库集群。</p>
<p><a href="https://imgtu.com/i/45WdOg"><img src="https://z3.ax1x.com/2021/09/29/45WdOg.png" alt="45WdOg.png" style="zoom: 67%;" /></a></p>
<h3 id="MySQL主从同步"><a href="#MySQL主从同步" class="headerlink" title="MySQL主从同步"></a>MySQL主从同步</h3><p>实现Sharding-JDBC的读写分离，首先，要进行mysql的主从同步配置。在MyCat中已经搭建了一个主从同步数据库,这里继续使用。</p>
<ul>
<li>在主服务器中的 test数据库 创建商品表products</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE products (</span><br><span class="line">    pid BIGINT(32) PRIMARY KEY ,</span><br><span class="line">    pname VARCHAR(50) DEFAULT NULL,</span><br><span class="line">    price INT(11) DEFAULT NULL,</span><br><span class="line">    flag VARCHAR(2) DEFAULT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>主库新建表之后,从库会根据binlog日志,同步创建</li>
</ul>
<h3 id="sharding-jdbc实现读写分离"><a href="#sharding-jdbc实现读写分离" class="headerlink" title="sharding-jdbc实现读写分离"></a>sharding-jdbc实现读写分离</h3><p>1）配置数据源</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span> = <span class="string">db1,db2,db3,m1,s1</span></span><br><span class="line"><span class="comment"># 读写分离</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.type</span> =<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.driver-class-name</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.url</span> = <span class="string">jdbc:mysql://192.168.200.11/test?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.password</span> = <span class="string">OddDog@666</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.s1.type</span> =<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.s1.driver-class-name</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.s1.url</span> = <span class="string">jdbc:mysql://192.168.200.12/test?characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.s1.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.s1.password</span> = <span class="string">OddDog@666</span></span><br></pre></td></tr></table></figure>
<p>2）配置主库与从库的信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置m1与s1的关系，ms1 包含了 m1 和 s1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.master-slave-rules.ms1.master-data-source-name</span>=<span class="string">m1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.master-slave-rules.ms1.slave-data-source-names</span>=<span class="string">s1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li> 配置数据节点</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置数据节点  products为逻辑表</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.products.actual-data-nodes</span> = <span class="string">ms1.products</span></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>编写mapper接口与测试类。</p>
<p>插入数据时，发送SQL到m1 ,  m1数据库更新了数据，s1会同步数据；</p>
<p>查询数据时，发送SQL到s1.</p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>ShardingJDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-Seata</title>
    <url>/2021/10/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/</url>
    <content><![CDATA[<ul>
<li>我们的项目是微服务项目，多数据源，因此很多业务操作避免不了跨数据源操作，传统的事务是不能解决跨数据源的，因此我们需要寻求分布式事务的解决方案。</li>
<li>Seata 是一款阿里开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。 <a id="more"></a></li>
</ul>
<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ul>
<li>订单保存成功 &amp; 累计账户积分+10</li>
<li>账户微服务和订单微服务，都各自有独立的数据库</li>
</ul>
<h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><ul>
<li>父工程引入，子工程继承即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lagou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--pojo持久化使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- commons-lang3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加seata依赖：cloud集成的seata依赖，全局事务中使用的过滤器已经集成了，直接使用即可 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除低版本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这样引用seata本身的依赖也是可以的，但是要配置许多额外的程序，过滤器和注解 --&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">			 <span class="comment">&lt;!--&lt;groupId&gt;io.seata&lt;/groupId&gt;--&gt;</span></span><br><span class="line">			 <span class="comment">&lt;!--&lt;artifactId&gt;seata-all&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&lt;version&gt;1.3.0&lt;/version&gt;--&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="账户微服务"><a href="#账户微服务" class="headerlink" title="账户微服务"></a>账户微服务</h2><ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`test<span class="operator">-</span>account` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `test<span class="operator">-</span>account`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `taccount` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `taccount`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `taccount` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned zerofill <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;账户编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `score` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;积分&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `taccount` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `taccount`(`id`,`name`,`score`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">00000000001</span>,<span class="string">&#x27;吕布&#x27;</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">00000000002</span>,<span class="string">&#x27;赵云&#x27;</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">00000000003</span>,<span class="string">&#x27;典韦&#x27;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateAccountScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.updateAccountScore(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Taccount</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>service</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateAccountScore</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        Taccount account = accountDao.selectById(userid);</span><br><span class="line">        <span class="comment">// 在原来的积分之上，再增加10分</span></span><br><span class="line">        account.setScore(account.getScore()+score);</span><br><span class="line">        <span class="keyword">return</span> accountDao.updateById(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>yml  三个微服务都是一样的，这里只放一份</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-account</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.204.141:3306/test-account?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123123</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 注册到中心的客户端</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.lagou.testaccount.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAccountApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestAccountApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订单微服务"><a href="#订单微服务" class="headerlink" title="订单微服务"></a>订单微服务</h2><ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`test<span class="operator">-</span><span class="keyword">order</span>` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `test<span class="operator">-</span><span class="keyword">order</span>`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `torder` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `torder`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `torder` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `uid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账户编号&#x27;</span>,</span><br><span class="line">  `pid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Torder order = <span class="keyword">new</span> Torder();</span><br><span class="line">        order.setId(UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        order.setUid(<span class="number">1</span>);</span><br><span class="line">        order.setPid(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">return</span> orderService.saveOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Torder</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>service</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Torder order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderDao.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动类同上</li>
</ul>
<h2 id="业务入口"><a href="#业务入口" class="headerlink" title="业务入口"></a>业务入口</h2><ul>
<li>controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;front&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">frontController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;business&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">business</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  businessService.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>service</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessServiceImpl</span> <span class="keyword">implements</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRemoteService accountRemoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRemoteService orderRemoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">business</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountRemoteService.update();</span><br><span class="line">		<span class="comment">// int i = 10/0;</span></span><br><span class="line">        orderRemoteService.save();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>remote远程接口</p>
<p>@FeignClient(name = <b style='color:red'>“微服务名”</b> , path = <b style='color:red'>“一级路径”</b> )</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;test-account&quot;,path = &quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;test-order&quot;,path = &quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><span class="comment">// 排除 数据库自动注入（依赖中有mybatis，所以会自检）</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// feign的客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFrontApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestFrontApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>官网：<a href="http://seata.io/zh-cn/index.html">http://seata.io/zh-cn/index.html</a>  </p>
<ul>
<li>尽量不要选择最新的版本“不太稳定”，我们选择下载 <a href="https://github.com/seata/seata/releases/download/v1.2.0/seata-server-1.2.0.zip">1.2.0 (2020-04-20) binary</a></li>
</ul>
<p><a href="https://imgtu.com/i/5rXInx"><img src="https://z3.ax1x.com/2021/10/21/5rXInx.png" alt="5rXInx.png"></a></p>
<ul>
<li>seata-server-1.2.0.zip 上传到linux，并解压</li>
</ul>
<h1 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h1><ul>
<li><p>解压完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A opt]# unzip seata-server-1.2.0.zip</span><br><span class="line">[root@A opt]# cd seata&#x2F;conf</span><br></pre></td></tr></table></figure></li>
<li><p>主要配置两个文件：</p>
<ul>
<li>file.conf 配置数据库</li>
<li>registry.conf 配置注册中心</li>
</ul>
</li>
</ul>
<h2 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h2><ul>
<li>在mysql建一个seata库，下面的脚本代码，要在1.0之前的版本中<strong>db_store.sql</strong>获取，1.0之后取消了这个脚本文件，复制下面代码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`seata` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `seata`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `branch_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `branch_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `branch_table` (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_group_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `lock_key` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `branch_type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `client_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">  KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `branch_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `global_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `global_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `global_table` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_service_group` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `timeout` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `begin_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">  KEY `idx_gmt_modified_status` (`gmt_modified`,`status`),</span><br><span class="line">  KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `global_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `lock_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `lock_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock_table` (</span><br><span class="line">  `row_key` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` mediumtext,</span><br><span class="line">  `branch_id` mediumtext,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pk` <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`row_key`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `lock_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `undo_log` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `undo_log`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>


<ul>
<li>打开file.conf文件，修改两处</li>
</ul>
<p><a href="https://imgtu.com/i/5rjpHf"><img src="https://z3.ax1x.com/2021/10/21/5rjpHf.png" alt="5rjpHf.png"></a></p>
<h2 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h2><p><a href="https://imgtu.com/i/5rjeuq"><img src="https://z3.ax1x.com/2021/10/21/5rjeuq.png" alt="5rjeuq.png"></a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li>先启动eureka</li>
<li>再启动seata的服务端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@A ~]# cd &#x2F;opt&#x2F;seata&#x2F;bin&#x2F;</span><br><span class="line">[root@A bin]# .&#x2F;seata-server.sh -p 9099 -m db</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/5rjKET"><img src="https://z3.ax1x.com/2021/10/21/5rjKET.png" alt="5rjKET.png"></a></p>
<p>服务端启动成功</p>
<h1 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h1><p><b style='color:blue'>以下过程，每个参与事务的微服务都要配置一遍，3个conf，yml，启动类，数据库</b></p>
<h2 id="配置文件3个"><a href="#配置文件3个" class="headerlink" title="配置文件3个"></a>配置文件3个</h2><ul>
<li><p>全部存放在项目的resources资源目录中</p>
</li>
<li><p>其中file.conf和registry.conf去github示例项目中获取：</p>
<p><a href="https://github.com/seata/seata-samples/blob/master/springboot-dubbo-seata/samples-business">https://github.com/seata/seata-samples/blob/master/springboot-dubbo-seata/samples-business</a></p>
<p>如果github打不开，可以换地址</p>
<p><a href="https://hub.fastgit.org/seata/seata-samples/tree/master/springboot-dubbo-seata/samples-business">https://hub.fastgit.org/seata/seata-samples/tree/master/springboot-dubbo-seata/samples-business</a></p>
</li>
</ul>
<p>进入：<a href="https://hub.fastgit.org/seata/seata-samples/tree/master/springboot-dubbo-seata/samples-business/src/main/resources">https://hub.fastgit.org/seata/seata-samples/tree/master/springboot-dubbo-seata/samples-business/src/main/resources</a></p>
<p><strong>注意</strong> : 一下配置文件只需要修改中文注释的地方，其他不用动。</p>
<h3 id="file-conf-1"><a href="#file-conf-1" class="headerlink" title="file.conf"></a>file.conf</h3><p>vgroupMapping.<b style='color:blue'>自定义名称</b> = “<b style='color:red'>分布式seata applicationName</b>“<br><b style='color:red'>分布式seata applicationName</b>.grouplist = “192.168.204.141:9099”</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server = &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = true</span><br><span class="line">  # the client batch send request enable</span><br><span class="line">  enableClientBatchSendRequest = true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  threadFactory &#123;</span><br><span class="line">    bossThreadPrefix = &quot;NettyBoss&quot;</span><br><span class="line">    workerThreadPrefix = &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    serverExecutorThread-prefix = &quot;NettyServerBizHandler&quot;</span><br><span class="line">    shareBossWorker = false</span><br><span class="line">    clientSelectorThreadPrefix = &quot;NettyClientSelector&quot;</span><br><span class="line">    clientSelectorThreadSize = 1</span><br><span class="line">    clientWorkerThreadPrefix = &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    bossThreadSize = 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    workerThreadSize = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization = &quot;seata&quot;</span><br><span class="line">  compressor = &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  # 自定义的事务组由 seata服务端 管理</span><br><span class="line">  vgroupMapping.my_tx_group = &quot;seata-server&quot;</span><br><span class="line">  # 服务端的ip和端口</span><br><span class="line">  seata-server.grouplist = &quot;192.168.204.141:9099&quot;</span><br><span class="line">  #degrade, current not support</span><br><span class="line">  enableDegrade = false</span><br><span class="line">  #disable seata</span><br><span class="line">  disableGlobalTransaction = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  rm &#123;</span><br><span class="line">    asyncCommitBufferLimit = 10000</span><br><span class="line">    lock &#123;</span><br><span class="line">      retryInterval = 10</span><br><span class="line">      retryTimes = 30</span><br><span class="line">      retryPolicyBranchRollbackOnConflict = true</span><br><span class="line">    &#125;</span><br><span class="line">    reportRetryCount = 5</span><br><span class="line">    tableMetaCheckEnable = false</span><br><span class="line">    reportSuccessEnable = false</span><br><span class="line">  &#125;</span><br><span class="line">  tm &#123;</span><br><span class="line">    commitRetryCount = 5</span><br><span class="line">    rollbackRetryCount = 5</span><br><span class="line">  &#125;</span><br><span class="line">  undo &#123;</span><br><span class="line">    dataValidation = true</span><br><span class="line">    logSerialization = &quot;jackson&quot;</span><br><span class="line">    logTable = &quot;undo_log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  log &#123;</span><br><span class="line">    exceptionRate = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="registry-conf-1"><a href="#registry-conf-1" class="headerlink" title="registry.conf"></a>registry.conf</h3><ul>
<li>把type修改成eureka，然后填写自己eureka的地址</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;eureka&quot;  # 注册中心</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application = &quot;seata-server&quot;</span><br><span class="line">    serverAddr = &quot;localhost&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = &quot;http://localhost:7001/eureka&quot;   # 注册中心的地址</span><br><span class="line">    application = &quot;seata-server&quot;  # 服务端名称</span><br><span class="line">    weight = &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = &quot;localhost:6379&quot;</span><br><span class="line">    db = &quot;0&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">    timeout = &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:9603&quot;</span><br><span class="line">    region = &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter = &quot;DefaultDataCenter&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime = &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3、springCloudConfig</span><br><span class="line">  type = &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    appId = &quot;seata-server&quot;</span><br><span class="line">    apolloMeta = &quot;http://192.168.1.204:8801&quot;</span><br><span class="line">    namespace = &quot;application&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="seata-conf"><a href="#seata-conf" class="headerlink" title="seata.conf"></a>seata.conf</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">client &#123;</span><br><span class="line">    application.id = test-front   # 客户端项目的名字</span><br><span class="line">    transaction.service.group = my_tx_group   # 自定义的事务组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h2><ul>
<li>入口工程删除datasource相关即可</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-order</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.204.141:3306/test-order?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123123</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">my_tx_group</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><ul>
<li>业务工程：需要配置数据源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.testaccount.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> io.seata.spring.annotation.GlobalTransactionScanner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeataConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSource</span><span class="params">(DataSource druidDataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><b style='color:blue'>账户工程</b> 和 <b style='color:blue'>订单工程</b> 都要创建 <b style='color:red'>undo_log</b> 表，脚本和seata数据库中的一模一样</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<h2 id="加入注解"><a href="#加入注解" class="headerlink" title="加入注解"></a>加入注解</h2><ul>
<li>入口工程的业务方法加入注解：<b style='color:blue'>@GlobalTransactional</b></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessServiceImpl</span> <span class="keyword">implements</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRemoteService accountRemoteService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRemoteService orderRemoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GlobalTransactional</span> <span class="comment">// 全局事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">business</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountRemoteService.update();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        orderRemoteService.save();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动项目上是查看控制台:</p>
<p><a href="https://imgtu.com/i/5rvUQs"><img src="https://z3.ax1x.com/2021/10/21/5rvUQs.png" alt="5rvUQs.png"></a></p>
<p>over。。。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Seata</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存与垃圾回收</title>
    <url>/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p><strong>java虚拟机</strong>（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。<a id="more"></a></p>
<p><strong>JVM的位置</strong></p>
<p><a href="https://imgtu.com/i/IkL3uQ"><img src="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg" alt="IkL3uQ.jpg" style="zoom:50%;" /></a></p>
<p><strong>JVM架构模型</strong></p>
<p>java编译器输入的指令流基本上是一种基于栈的指令集架构，另一种指令集架构是则是基于寄存器的指令集架构。</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计与实现简单，使用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址方式分配</li>
<li>指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>指令集的架构完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令取完成一项操作</li>
<li>指令集以一地址指令、二地址指令和三地址指令为主</li>
</ul>
</li>
</ul>
<p><strong>举例</strong>  ：执行 2+3 操作</p>
<ul>
<li>基于栈的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_2  &#x2F;&#x2F;常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3  &#x2F;&#x2F;常量3入栈</span><br><span class="line">istore_2  </span><br><span class="line">iload_1	  </span><br><span class="line">iload_2</span><br><span class="line">iadd	  &#x2F;&#x2F;常量2、3出栈，执行相加</span><br><span class="line">istore_0  &#x2F;&#x2F;结果5入栈</span><br></pre></td></tr></table></figure>
<ul>
<li>基于寄存器的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax,2  &#x2F;&#x2F;将eax寄存器的值设为1</span><br><span class="line">add eax,3  &#x2F;&#x2F;使eax寄存器的值加3</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong> : 由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令。</p>
<p><strong>JVM总体流程</strong></p>
<p><a href="https://imgtu.com/i/Ikjg5n"><img src="https://z3.ax1x.com/2021/11/03/Ikjg5n.png" alt="Ikjg5n.png"  /></a></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><ul>
<li><p>类加载子系统<strong>只</strong>负责加载Class文件，class文件的文件开头有特定的文件标识。</p>
</li>
<li><p>加载的类信息存放于方法区中，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量与数字常量（这部分信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/IkjhvT"><img src="https://z3.ax1x.com/2021/11/03/IkjhvT.png" alt="IkjhvT.png"  /></a></p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><a href="https://imgtu.com/i/IkxN1P"><img src="https://z3.ax1x.com/2021/11/03/IkxN1P.jpg" alt="IkxN1P.jpg" style="zoom: 44%;" /></a></p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区中该类的各种数据的访问入口</li>
</ol>
<p><strong>加载 .class文件的方式</strong></p>
<ul>
<li>从本地系统直接加载（常用）</li>
<li>通过网络获取，如 Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，如 动态代理</li>
<li>有其他文件生成，如 JSP应用</li>
<li>从数据库中提取 .class文件</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
<h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><ul>
<li><p>验证（Verify）</p>
<ul>
<li>确保class文件的字节流包含信息的准确性，不危害虚拟机的自身安全</li>
<li>包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
<p><a href="https://imgtu.com/i/IUJjzT"><img src="https://z3.ax1x.com/2021/11/10/IUJjzT.png" alt="IUJjzT.png" style="zoom: 50%;" /></a></p>
</li>
<li><p>准备（Prepare）</p>
<ul>
<li>为类变量分配内存并且设置该类的默认初始值，即零值</li>
<li>这里不包括final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li>
</ul>
</li>
<li><p>解析（Resolve）</p>
<ul>
<li>将常量池的符号引用转换成直接引用，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>事实上，解析操作往往会伴随着初始化之后再执行</li>
</ul>
</li>
</ul>
<h3 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h3><p>初始化阶段就是执行类构造方法 &lt;clinit&gt;() 的过程</p>
<p><strong>clinit方法</strong> : 不需要定义，javac编译器自动收集类中所有 <strong>类变量的赋值动作</strong> 和 <strong>静态代码块中的语句</strong>  按顺序合并而来</p>
<p>若该类有父类，JVM会保证先执行父类中的 &lt;clinit&gt;() 方法</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器，引导类加载器（BootStrap ClassLoader）、自定义类加载器（User-Defined Classloader）</p>
<p>所有派生于抽象类ClassLoader的加载器都划分为自定义类加载器,在程序中常见的类加载器始终只有3个：</p>
<p><a href="https://imgtu.com/i/IAVsN6"><img src="https://z3.ax1x.com/2021/11/03/IAVsN6.md.png" alt="IAVsN6.md.png" style="zoom:80%;" /></a></p>
<p><strong>启动类加载器（BootStrap ClassLoader）</strong></p>
<ul>
<li>该类加载是由C/C++编写的，嵌套再JVM内部</li>
<li>它用来加载java的核心库，用于提供JVM自身需要的类</li>
<li>出于安全考虑，只加载包名为java、Javax、sun等开头的类</li>
<li>不继承java.lang.ClassLoader，没有父类加载器</li>
<li>加载扩展类加载器和系统类加载器，并指定为他们的父类加载器</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>从JDK的安装目录的jre/lib/ext 下加载类库，如果自定义插件jar文件放入该目录，也会加载。</li>
</ul>
<p><strong>系统类加载器（AppClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载的是程序中默认的类加载器，一般java应用中所有的类是由它来完成加载</li>
<li>通过 ClassLoader.getSystemClassLoader() 可获取到该类加载器</li>
</ul>
<p><strong>用户自定义类加载器</strong></p>
<p>在必要时，我们可以自定义类加载器，来定制类的加载方式，需继承抽象类ClassLoader，实现相关方法。</p>
<p>自定义类加载器作用：</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>放置源码泄露</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>JVM对class文件采用 <strong>按需加载</strong> 方式，加载某个类时采用<strong>双亲委派模式</strong> 。</p>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在父类加载器，则继续向上委托，最终到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类的加载任务，就返回成功，否则子类才会尝试自己去加载</li>
</ol>
<p><a href="https://imgtu.com/i/IAKq2V"><img src="https://z3.ax1x.com/2021/11/03/IAKq2V.png" alt="IAKq2V.png" style="zoom: 80%;" /></a></p>
<p><strong>作用</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，放置核心API被篡改<ul>
<li>如自定义java.lang.String类，而引导类加载器会先加载jdk自带的类，进而报错，这样就保证对java核心的源代码的保护，这也是<strong>沙箱安全机制</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong></p>
<p>在JVM中表示两个class对象是否为同一个类存在的两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader实例对象必须相同</li>
</ul>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证JVM的高效稳定运行。</p>
<p><a href="https://imgtu.com/i/IA8mC9"><img src="https://z3.ax1x.com/2021/11/03/IA8mC9.png" alt="IA8mC9.png" style="zoom: 67%;" /></a></p>
<p>线程独享：程序计算器、栈、本地栈</p>
<p>线程共享：堆、堆外内存（永久代或元空间、代码缓存）</p>
<h2 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h2><p>PC寄存器用来存储下一条指令的地址，交给执行引擎读取。</p>
<ul>
<li>它是一块很小的内存空间，是线程私有的，生命周期于线程声明周期一致。</li>
<li>任何时间一个线程只有一个方法在执行，PC计计数器会存储当前线程正在执行的java方法的JVM指令地址，如果正在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成</li>
</ul>
<p><strong>PC寄存器存储字节码指定地址作用</strong></p>
<p>CPU需要不停切换各个线程来执行程序，PC寄存器保存当前线程下执行的位置，JVM的字节码解释器需要通过PC寄存器的值来明确下一条执行什么样的字节码指令。</p>
<h2 id="虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stack）"></a>虚拟机栈（Java Virtual Machine Stack）</h2><p><strong>虚拟机栈出现的背景</strong>：由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令</p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内确保一个个的栈帧(Stack Frame),对应一次次的方法调用。</p>
<p><strong>生命周期</strong> ：和线程的生命周期一致</p>
<p><strong>作用</strong>：主管java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p><strong>JVM直接对Java栈的操作只有两个</strong></p>
<ul>
<li>每个方法执行，伴随着<b style='color:red'>进栈</b>（入栈、压栈）</li>
<li>执行结束后<b style='color:red'>出栈</b>操作</li>
</ul>
<p><strong>栈可能出现的异常</strong></p>
<ul>
<li>如果栈固定大小：每个虚拟机栈的容量在线程创建时就能确定下来，如果超过虚拟机栈允许的最大容量，就会抛出StackOverFlowError 异常。</li>
<li>如果栈允许动态扩展：在尝试扩展的时候无法申请到足够的内存，或在创建新的线程时没有足够的内存去创建虚拟机栈，就会抛出 OutOfMemoryError 异常。</li>
</ul>
<p><strong>设置栈内存大小</strong>： <b style='color:red'>-Xss</b>  设置线程的最大栈空间</p>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>每个线程都有直接的栈，栈中的数据都是以<b style="color:red">栈帧（Stack Frame）</b>的格式存在,每个栈帧对应一个方法。</p>
<p><strong>运行原理</strong></p>
<ul>
<li>在同一时间点上，只有一个活动栈帧（当前栈帧），执行引擎运行的所有字节码指令只对当前栈帧经行操作</li>
<li>在当前放法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前栈</li>
<li>不同线程中所包含的栈帧不允许存在相互应用的</li>
<li>方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，当前虚拟机栈会执行出栈操作，将当前栈帧丢弃</li>
<li>使用return指令正常的函数返回、抛出异常返回，都会导致栈帧被弹出</li>
</ul>
<p><a href="https://imgtu.com/i/IVzXXq"><img src="https://z3.ax1x.com/2021/11/04/IVzXXq.jpg" alt="IVzXXq.jpg" style="zoom:50%;" /></a></p>
<p><strong>栈帧的内部结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈 (Operand Stack)</li>
<li>动态链接 (Dynamic Linking)</li>
<li>方法返回地址 (Return Address)</li>
<li>一些附加信息，如对程序调试提供支持的信息</li>
</ul>
<p><a href="https://imgtu.com/i/IZS2UU"><img src="https://z3.ax1x.com/2021/11/04/IZS2UU.jpg" alt="IZS2UU.jpg" style="zoom: 44%;" /></a></p>
<h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><ul>
<li>定义为一个数字数组，用于存储方法参数和定义在方法体内的局部变量，这些数据的类型包括各种<b style="color:red">基本数据类型</b>、<b style="color:red">对象引用(reference)</b></li>
<li>局部变量表是建立在线程的栈上，是线程私有的数据，不存在数据安全问题</li>
<li>局部变量表的容量大小是在编译期间确定下来，并保存在Code属性的<b style="color:red">Maximum local variables</b>数据项中</li>
</ul>
<p><strong>Slot</strong></p>
<ul>
<li>局部变量表中最基本的存储单元是Slot（变量槽），从0开始</li>
<li>32位以内的各种基本数据类型占用一个Slot，64位的数据类型占用两个Slot<ul>
<li>byte、short、char、boolean 在存储前被都转化成 int ，占据一个Slot</li>
<li>long 、double 占据两个Slot</li>
</ul>
</li>
<li>方法被调用时，它的方法参数和方法体内定义的局部变量会<b style="color:red">按顺序被复制</b>到每一个Slot中，通过索引即可访问局部变量表中指定的值</li>
<li>如果当前方法是构造方法或非静态方法，会将 <b style="color:red">this</b> 放在index为0的Slot处</li>
</ul>
<p><strong>Slot的重复利用</strong></p>
<p>如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量很有可能会重复利用过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">	<span class="comment">// 该方法中的局部变量表大小为2: index[0]:this 、index[1]:b</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的b会复用a的槽位</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态变量与局部变量的对比</strong></p>
<ul>
<li>静态变量: 在<b style='color:red'>准备阶段</b>会赋予初始值，在<b style='color:red'>初始化</b>阶段，会赋予我们在代码中定义的值。</li>
<li>局部变量：不存在系统初始化过程，所以一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改代码是错误的，没有赋值，不能使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充</strong></p>
<p>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收。</p>
<h3 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h3><ul>
<li>操作数栈，用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</li>
<li>操作数栈是JVM执行引擎的工作区，其最大深度在编译器就定义好了，保存在Code属性的<b style='color:red'>max_stack</b></li>
<li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈与出栈<ul>
<li>如执行 复制、交换、求和等操作</li>
<li><a href="https://imgtu.com/i/IZAup8"><img src="https://z3.ax1x.com/2021/11/04/IZAup8.png" alt="IZAup8.png" style="zoom:50%;" /></a></li>
</ul>
</li>
<li>栈中的元素可以是任意的java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>如果被调用的方法带有返回值，其返回值将会压入操作数栈中，并根性PC寄存器中下一条需要执行的字节码指令</li>
</ul>
<p>补充：JVM的<b style='color:red'>解释引擎是基于栈的执行引擎</b>，其中的栈指的就是操作数栈</p>
<h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><p>动态链接（指向运行时常量池的方法引用）：每一个栈帧中内部都包含一个指向<b style='color:blue'>运行时常量池</b>中<b style='color:red'>该栈帧所属的方法引用</b>。</p>
<p>在java源文件被编译到字节码文件中时，所有的变量与方法引用都在为符号引用（Symbolic Reference）保存到class文件的常量池里。当调用其他方法时，就是通过常量池中指向的方法的符号引用来表示。所以<b style='color:red'>动态链接的作用就是为了将这些符号引用转换成调用方法的直接引用</b>。</p>
<p><a href="https://imgtu.com/i/IZel80"><img src="https://z3.ax1x.com/2021/11/04/IZel80.png" alt="IZel80.png" style="zoom: 80%;" /></a></p>
<h3 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址(Return Address)"></a>方法返回地址(Return Address)</h3><p>存放调用该方法时pc寄存器的值，用于方法的退出。</p>
<p>一个方法结束，有两种方式:</p>
<ul>
<li><p>正常完成出口</p>
<ul>
<li>执行引擎遇到任意一个返回字节码指令(return)时,会有返回值传递给上层的方法调用者。</li>
</ul>
</li>
<li><p>异常完成出口</p>
<ul>
<li>方法执行过程中遇到异常，并且该异常没有在经行处理，返回地址是要通过<b style='color:red'>异常表</b>来确定，并且没有返回值。</li>
</ul>
<p><a href="https://imgtu.com/i/IZKj7F"><img src="https://z3.ax1x.com/2021/11/04/IZKj7F.png" alt="IZKj7F.png"></a></p>
</li>
</ul>
<p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法中局部变量表、操作数栈，将返回值压入操作数栈中，设置PC寄存器值等，让调用者方法继续执行下去。</p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><strong>符号引用转换为方法的直接引用</strong></p>
<ul>
<li><p>静态链接</p>
<p>当字节码文件被装载到JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变，这种情况下方法的符号引用转换成直接引用的过程为静态链接。</p>
</li>
<li><p>动态链接</p>
<p>如果调用的方法在编译期间无法被确定下来，只能够在程序运行期间将调用方法的符号引用转换为直接引用，这种引用转换过程具备动态性，因此被称之为动态链接。</p>
</li>
</ul>
<p><strong>方法的绑定机制</strong>：绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅仅发生一次。</p>
<ul>
<li>早期绑定<ul>
<li>被调用的目标方法在编译器可知，且运行期间保持不变，因此可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>被调用的方法在编译期间无法被确定下来，只能够在运行期间根据实际的类型绑定相关的方法。</li>
</ul>
</li>
</ul>
<p><strong>虚方法与非虚方法</strong></p>
<p>非虚方法: 编译期间就确定了具体的调用版本，静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</p>
<p>其他的方法都称为虚方法</p>
<p><strong>方法调用指令</strong></p>
<ul>
<li>普通调用指令<ul>
<li><b style='color:blue'>invokestatic</b>：调用静态方法, 解析阶段可确定方法版本</li>
<li><b style='color:blue'>invokespecial</b>：调用&lt;init&gt;方法、私有方法、父类方法, 解析阶段可确定方法版本</li>
<li><b style='color:green'>invokevirtual</b>：调用所有的虚方法（包括final修饰的方法）</li>
<li><b style='color:green'>invokeinterface</b>：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固定在虚拟机内部，方法的调用执行不可人为的干预，而invokedynamic指令则支持用户确定方法版本。</p>
<p>invokedynamic是在java7中添加的，为了实现【动态类型语言】支持而做的改进。而java7中并没有提供直接生成invokedynamic指令的方法，直到java8的Lambda表达式的出现，才能够直接生成invokedynamic指令。</p>
<p><strong>动态类型语言和静态类型语言</strong></p>
<ul>
<li>两者的区别在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，满足后者就是动态类型语言</li>
<li>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</li>
</ul>
<p><strong>方法重写的本质</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的实际类型，记作 C</li>
<li>如果在类型 C 找到与常量中相对应的方法，则进行访问</li>
<li>如果没找到，按照继承的关系从下往上依次对 C 的各个父类经行访问</li>
<li>如果始终没找到合适的方法，则抛出 java.lang.AbstractMethodError异常，表示该方法是抽象方法，并且没有没实现。</li>
</ol>
<p>在访问方法时，需要进行访问权限校验，如果没通过，会抛出 java.lang.IllegalAccessError 异常</p>
<p><strong>虚方法表(virtual method table)</strong></p>
<ul>
<li><p>如果在每次动态分派的过程中都要重新在类的方法元数据搜索合适的目标，这样就会影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引的方式来代替查找。</p>
</li>
<li><p>每个类都有一个虚方法表，表中存放着各个虚方法的实际路口。</p>
</li>
<li><p>虚方法表在类的加载的链接阶段被创建并初始化。</p>
</li>
</ul>
<h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p><a href="https://imgtu.com/i/IeEAyD"><img src="https://z3.ax1x.com/2021/11/04/IeEAyD.jpg" alt="IeEAyD.jpg" style="zoom: 67%;" /></a></p>
<p><strong>本地方法</strong></p>
<p>一个Native Method就是一个Java调用非Java代码的接口。该方法的实现由非Java语言实现，比如C/C++。</p>
<p>本地接口的作用是融合不同的变成语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><strong>现状</strong> ：目前该方法使用的越来越少，除非是与硬件有关的应用。</p>
<p><strong>本地方法栈概述</strong></p>
<ul>
<li>Java的虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li>
<li>本地方法栈也是线程私有的。</li>
<li>允许被实现固定内存大小，或可动态扩展内存大小（与Java虚拟机栈基本相同）</li>
<li>当某个线程调用有关本地方法时，它就进入了一个全新的且不受虚拟机限制的环境，它与虚拟机有同样的权限。</li>
</ul>
<p><strong>补充</strong></p>
<p>不是所有的虚拟机都支持本地方法；在Hotspot JVM中，直接将本地方法和虚拟机栈合二为一。</p>
<h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p><strong>基本概述</strong></p>
<ul>
<li><p>一个JVM实例只存在一个堆内存，是java内存管理的核心区域。</p>
</li>
<li><p>堆可以处于物理不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
</li>
<li><p>几乎所有的对象实例都在这里分配内存，栈帧的局部变量表中仅仅保持对象的引用，该引用指向对象在堆中的位置。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，在垃圾收集的时候才可能会被移除，堆是GC执行垃圾回收的重点。</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/I3qt3T"><img src="https://z3.ax1x.com/2021/11/08/I3qt3T.png" alt="I3qt3T.png" style="zoom: 80%;" /></a></p>
<p><strong>内存细分</strong></p>
<ul>
<li>Java 7及之前：新生代+老年代+永久代(方法区)<ul>
<li>方法区在堆中</li>
</ul>
</li>
<li>Java8及之后：新生代+老年代+元空间(方法区)<ul>
<li>方法区使用本地内存</li>
</ul>
</li>
</ul>
<h3 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h3><p>堆的大小在JVM启动时就已经设定好了。可通过“-Xmx” 和 “-Xms” 来进行设置</p>
<ul>
<li>-Xms ：表示堆区的起始内存，等价于 -XX:InitialHeapSize，默认 物理电脑内存大小/64</li>
<li>-Xmx :  表示堆区的最大内存，等价于 -XX:MaxHeapSize,  默认 物理电脑内存大小/4</li>
</ul>
<p>一旦堆区的内存大小超过 ”-Xmx“ ,就会抛出 OutOfMemoryError 异常。</p>
<p>通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能。</p>
<h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>堆区可划分为年轻代(YoungGen) 和 老年代(OldGen) ，其中年轻代又可以划分为 Eden空间、Survivor0空间和Surviver1空间（有时也叫做from区、to区）</p>
<p><a href="https://imgtu.com/i/I3XENR"><img src="https://z3.ax1x.com/2021/11/08/I3XENR.jpg" alt="I3XENR.jpg" style="zoom: 50%;" /></a></p>
<p><strong>-XX:NewRation</strong>    </p>
<ul>
<li>配置新生代与老年代在堆中的占比</li>
<li>默认 -XX:NewRatio=2 ，新生代占1，老年代占2</li>
</ul>
<p><strong>-XX:SurvivorRatio</strong></p>
<ul>
<li>配置Eden空间和S0与S1空间占比</li>
<li>默认-XX:SurvivorRatio=8，Eden占8，Survivor0占1，Survivor1占1</li>
</ul>
<p><strong>-Xmn</strong></p>
<ul>
<li>设置新生代最大内存大小</li>
</ul>
<p>几乎所有的java对象都是在Eden区被new出来的，而java对象的销毁基本是在新生代进行的。</p>
<p>IBM公司的专门研究表明，新生代 80% 的对象都是”朝夕生死“的。</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>对象分配内存是一件非常严谨与复杂的任务，需要考虑内存如何分配、在哪里分配、内存碎片等问题。</p>
<p><strong>步骤</strong></p>
<ol>
<li>new的对象先放伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，GC将对伊甸园区进行垃圾回收(Minor GC) , 将伊甸园区中不再被其他对象所引用的对象进行销毁，将加载的对象放到伊甸园区</li>
<li>然后将伊甸园区的剩余对象移动到幸存者0区，幸存的对象会添加年龄 1</li>
<li>如果再次触发Minor GC，会对伊甸园区和幸存者0区一起GC，把幸存的对象放入幸存者1区，年龄 +1</li>
<li>如果再次Minor GC，会重新放回幸存者0区，接着再是幸存者1区，不断循环</li>
<li>如果对象的年龄为15，就会将该对象放入老年区<ul>
<li>可以设置参数  -XX:MaxTenuringThreshold=15  经行设置</li>
</ul>
</li>
<li>老年区相对清闲，当老年区内存不足时，会触发 Major GC，对老年区经行内存清理</li>
<li>如果老年区执行了 Major GC 后发现依然无法进行对象的保持，就会报 OOM 异常<ul>
<li>java.lang.OutOfmemoryError: Java heap space </li>
</ul>
</li>
</ol>
<p><strong>对不同年龄的对象分配原则</strong></p>
<ul>
<li>优先分配到Eden </li>
<li>大对象(超出Eden最大值)直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中的相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中设置的年龄</li>
</ul>
</li>
</ul>
<p><strong>分代思想</strong></p>
<p>经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象。</p>
<p>如果不分代程序也是可以运行的，所有的对象就在一块。分代的唯一理由就是优化GC性能。</p>
<h3 id="Garbage-Collection（GC）"><a href="#Garbage-Collection（GC）" class="headerlink" title="Garbage Collection（GC）"></a>Garbage Collection（GC）</h3><p>针对HotSpot VM的实现，GC按照区域又分为两大类型：</p>
<p><strong>部分搜集（Partial GC）</strong></p>
<ul>
<li>新生代收集（Minor GC / Young GC）: 只是新生代的垃圾收集</li>
<li>老年代收集（Mojor GC / Old Gc）: 只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC 会有该行为</li>
</ul>
</li>
<li>混合收集（Mixed GC）: 收集整个新生代与部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有该行为</li>
</ul>
</li>
</ul>
<p><strong>整堆收集（Full GC）</strong></p>
<ul>
<li>收集整个java堆和方法区的垃圾收集</li>
</ul>
<p>（提示：有关GC详情，在后面会讲解！）</p>
<h3 id="Thread-Local-Allocation-Buffer（TLAB）"><a href="#Thread-Local-Allocation-Buffer（TLAB）" class="headerlink" title="Thread Local Allocation Buffer（TLAB）"></a>Thread Local Allocation Buffer（TLAB）</h3><p><strong>问题</strong>：堆区是线程共享区域，任何线程都可以访问堆中的共享数据，而对象实例的创建很频繁，所以在并发环境下会不安全。为了避免操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>Eden区为每个线程分配了一个私有的缓存区域（TLAB），使用TLAB可以避免一系列非线程安全问题，同时还能提升内存分配的吞吐量，我们可以将这种分配方式称之为 <b style='color:red'>快速分配策略</b></p>
<p>OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><strong>分配过程</strong></p>
<ul>
<li>JVM将TLAB作为内存分配的首选</li>
<li>一旦对象在TLAB空间分配内存失败，JVM会尝试通过<b style='color:red'>加锁机制</b>确保数据操作的原则性，接着在Eden区分配内存</li>
<li>-XX:UseTLAB , 是否开启TLAB空间</li>
<li>-XX:TLABWasteTargetPercent , 设置TLAB所占用Eden空间的百分比大小，默认 1%</li>
</ul>
<p><a href="https://imgtu.com/i/I8kWMd"><img src="https://z3.ax1x.com/2021/11/08/I8kWMd.jpg" alt="I8kWMd.jpg" style="zoom: 50%;" /></a></p>
<h3 id="栈上分配对象"><a href="#栈上分配对象" class="headerlink" title="栈上分配对象"></a>栈上分配对象</h3><p>JVM中，对象是在java堆中分配内存是一个普遍常识。但是有一种特殊情况，那就是<b style='color:red'>如果经过逃逸分析(Escape Analysis) 后发现，该对象并没有逃逸出方法的话，那就有可能被优化成栈上分配。</b>这样就无需在堆上分配内存，也无需经行GC了，这也是最常见的堆外存储技术。</p>
<p><strong>逃逸分析</strong></p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>如果被外部方法所引用，则认为发生逃逸</li>
</ul>
<p>在JDK 6u23版本后，默认开启逃逸分析</p>
<ul>
<li>-XX:+DoEscapeAnalysis ,显示开启逃逸分析</li>
<li>-XX:+PrintEscapeAnalysis，查看逃逸分析的筛选结果</li>
<li>-server，启动Server模式，在该模式下才可以开启逃逸分析</li>
</ul>
<p><strong>同步省略</strong></p>
<p>JIT编译器可以借助逃逸分析来判断<b style='color:red'>同步块所使用的锁对象是否能够被一个线程访问而没有发布到其他线程。</b>如果没有，JIT编译器在编译这个同步块时会取消对这部分代码的同步。取消同步的过程就叫同步省略，也叫<b style='color:red'>锁消除</b></p>
<p>如以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        System.out.Println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对obj进行加锁，但obj不会被其他线程访问，所以在JIT编译阶段就会被优化掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="comment">// 取消了锁</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.Println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标量替换</strong></p>
<p><b style='color:red'>标量(Scalar) </b>指一个无法分解成更小的数据的数据。如 java中的基本数据类型</p>
<p><b style='color:red'>聚合量(Aggregate) </b> 可以分解的数据。如java中的对象，可以分成其他聚合量和标量</p>
<p>JIT阶段，如果通过逃逸分析，发现一个对象不会被外界访问，就会进行JIT优化，把该对象拆解成若干个其中包含的若干个成员变量来代替，该过程就是<b style='color:red'>标量替换 </b></p>
<p>-XX:+EliminateAllocations，开启标量替换（默认开启）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123; <span class="comment">// 构造方法省略</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(p.x);</span><br><span class="line">    System.out.println(p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，标量替换后，会变成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对象被替换成两个基本数据类型，这样可以不用创建对象，减少堆内存的占用。</p>
<p><strong>逃逸分析并不成熟</strong></p>
<ul>
<li>有关逃逸分析的论文在1999年就已经发表了，直到JDK1.6才有实现，并且到如今也并不是十分成熟</li>
<li>根本原因在于逃逸分析、标量替换、栈上分配、消除锁也是需要性能消耗的。如果逃逸分析后，所有的对象都逃逸了，那么逃逸分析的过程就白白浪费了。</li>
</ul>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><ul>
<li><p>方法区同java堆一样，是各个线程共享的内存区域。</p>
</li>
<li><p>在JVM启动时就会创建，实际的物理内存空间也是不连续的，可以固定大小或可扩展</p>
</li>
<li><p>方法区决定了系统可以保持多少个类，如果类太多，导致方法区溢出，会抛出异常:</p>
<ul>
<li>java.lang.OutOfmemoryError：Metaspace/PermGen space</li>
</ul>
</li>
</ul>
<p>jdk7及以前，习惯把方法区成为永久代。jdk8开始，使用元空间代替永久代，完全废弃了永久代的概念。</p>
<p>永久代和元空间的最大区别在于: 元空间不在虚拟机设置的内存中，而是使用本地内存。</p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><a href="https://imgtu.com/i/I8bZKe"><img src="https://z3.ax1x.com/2021/11/08/I8bZKe.png" alt="I8bZKe.png"></a></p>
<h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><p><strong>jdk7及以前</strong></p>
<ul>
<li>-XX:PermSize，设置永久代初始分配空间，默认 20.75M</li>
<li>-XX:MaxPermSize,设置永久最大可分配空间，32位机器默认64M，64位机器默认82M。</li>
</ul>
<p><strong>jdk8及以后</strong></p>
<ul>
<li>默认值依赖于平台，windows下，-XX:MetaspaceSize=21M，-XX:MaxMetaspaceSize=-1,表示没有限制</li>
<li>MetaspaceSize是元空间的初始大小，就是初始的高水位线，一旦触及这水位线，就会出发Full GC并卸载没有用的类，然后这个高水位线会被重置。新的高水位线的值取决于GC后释放了多少元空间。<ul>
<li>如果释放的空间不足，在不超过MaxMetaspaceSize时，会适当提高</li>
<li>如果释放空间过多，会适当降低该值</li>
</ul>
</li>
<li>初始的高水位线设置过低，就会多出发高水位线的调整，进而出发Full GC。所以建议将 MetaspaceSize 设置位一个相对较高的值。</li>
</ul>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等。</p>
<p><a href="https://imgtu.com/i/I8cIij"><img src="https://z3.ax1x.com/2021/11/08/I8cIij.jpg" alt="I8cIij.jpg"  /></a></p>
<p><strong>类型信息</strong></p>
<p>JVM必须存储类型(class、interface、enum、annotation)的以下信息:</p>
<ul>
<li>该类型的完整有效名</li>
<li>该类型的直接父类完整有效名（interface和Object没有父类）</li>
<li>该类型的修饰符</li>
<li>该类型的直接接口的一个有序列表</li>
</ul>
<p><strong>域(Field)信息</strong></p>
<ul>
<li><p>JVM必须存储类型的域(字段)相关信息: 域名称、域类型、域修饰符</p>
</li>
<li><p>域的声明顺序也会保存下来</p>
</li>
</ul>
<p><strong>方法信息</strong> </p>
<p>JVM必须保存所有方法的以下信息,同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称、方法的返回类型、方法参数的数量和类型、方法的修饰符、方法的字节码、异常表</li>
</ul>
<p><strong>运行时常量池(Runtime Constant Pool)</strong></p>
<ul>
<li>常量池表(Constant Pool Table) 是Class文件的一部分，<b style='color:red'>用于存放编译期生成的各种字面量与符号引用</b>，<b style='color:green'>这部分内容将在类加载后存放到方法区的运行时常量池中</b></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>此时不再是常量池中的符号引用了，这里换位真实地址，所以具备动态性</li>
</ul>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><p><strong>声明</strong>：只有Hotspot才有永久代的概念</p>
<p><strong>变化</strong></p>
<ul>
<li>jdk1.6及以前 : 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 : 有永久代，但已经逐步”去永久代“,字符串常量、静态变量移动到堆中</li>
<li>jdk1.8及以后 : 无永久代，类型保存在本地的元空间，但字符串常量池 、静态变量依旧在堆中</li>
</ul>
<p><strong>永久代为什么要被元空间所替换</strong></p>
<ol>
<li>永久代设置空间大小是很难确定的，如果动态加载的类过多，很容易抛出OOM异常。而元空间使用的是本地内存，受本地内存的限制。</li>
<li>对永久代进行调优的很困难的。</li>
</ol>
<p><strong>StringTalbe为什么要调整</strong></p>
<p>因为永久代的回收效率很低，在Full GC的时候才会触发。而Full GC是在老年代、永久代内存不足时才会触发。</p>
<p>导致StringTable的回收效率不高。放到堆里，能够及时回收内存。</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>《Java虚拟机规范》对方法区的约束时非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集，如JDK11时期的ZGC就不支持类卸载。</p>
<p>一般来所方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实时有必要的。</p>
<p><strong>方法区垃圾收集主要回收两部分内容:</strong></p>
<ul>
<li><p>常量池中废弃的常量（比较容易实现，与堆中的回收的对象类似）</p>
<ul>
<li>字面量</li>
<li>符号引用</li>
</ul>
</li>
<li><p>不再使用的类型</p>
<p>需要满足以下三个条件：</p>
<ul>
<li>该类的所有实例已被回收，包括其任何派生子类</li>
<li>该类的类加载器已被回收，该条件除非是经过精心设计的可替换类加载的场景，如OSGI、JSP的重复加载等，否则很难达成</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ul>
<p>满足上述的三个条件，也仅仅是”被允许“回收，而不是和对象一样，没有引用了就必然会回收。</p>
</li>
</ul>
<p>再大量使用反射、动态代理、GCLib等字节码框架的场景，通常需要JVM具备类卸载能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="StringTable相关概念"><a href="#StringTable相关概念" class="headerlink" title="StringTable相关概念"></a>StringTable相关概念</h3><p>字符串常量池(String Pool) ：存放字符串，且不会存储相同内容的字符串。</p>
<p>StringPool是一个固定大小的HashTable，如果放进String Pool的String 非常多，就会造成Hash冲突严重，从而导致链表很长，直接造成调用String.intern时性能下降。</p>
<p><b style='color:blue'>-XX:StringTableSize</b> 参数可设置StirngTable的长度</p>
<ul>
<li>jdk6中StringTable长度是固定的，长度为<b style='color:blue'>1009</b></li>
<li>jdk7中StringTable的长度默认值是<b style='color:blue'>60013</b>,可以手动修改，对设置没有要求</li>
<li>jdk8开始，设置StringTable的长度最小值是<b style='color:blue'>1009</b></li>
</ul>
<p><strong>将字符串放入字符串常量池</strong></p>
<ol>
<li>直接使用双引号声明出来的String ，如 <code>String s = &quot;怪狗狗&quot;;</code></li>
<li>使用Stirng 提供的 <code>intern()</code> 方法</li>
</ol>
<p><strong>字符串拼接</strong></p>
<ul>
<li><p>常量与常量的拼接结果在常量池。原理是编译期(前端编译)优化</p>
</li>
<li><p>如 <code>String s = &quot;a&quot;+&quot;b&quot;</code> 转换成字节码 <code>ldc #2 &lt;ab&gt;</code></p>
</li>
<li><p>只要其中有一个是变量，结果就在堆中。原理是StringBuilder</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;a&quot;;</span><br><span class="line">String s2 &#x3D; s1+&quot;b&quot;;</span><br><span class="line"># 上面字符串拼接代码翻译成相应的字节码指令如下:</span><br><span class="line">new 		   #5  创建串池中#5位置的对象，当前对象为StringBuilder，放入操作数栈中</span><br><span class="line">dup 		  	   将栈顶的stringBuilder对象复制一份，并入栈</span><br><span class="line">invokespecial  #6  调用栈顶对象在串池对应#6的方法，这里是&lt;init&gt;构造犯法,消费掉一个栈顶元素</span><br><span class="line">aload_1	 		   将局部变量表位置为1的值入栈，这里是&quot;a&quot;</span><br><span class="line">invokevirtual  #7  调用#7位置处的方法，StringBuilder.append()</span><br><span class="line">idc			   #3  将#3位置处的对象入栈，这里是&quot;b&quot;</span><br><span class="line">invokevirtual  #7  调用#7位置处的方法，StringBuilder.append()</span><br><span class="line">invokevirtual  #8  调用#7位置处的方法，StringBuilder.toString()</span><br><span class="line">astore 	       6   将结果放置局部变量表位置为6处</span><br></pre></td></tr></table></figure></li>
<li><p>*intern()的使用**</p>
</li>
<li><p>将字符串放入常量池，如果串池中有，则不会放入，返回已有的串池中的对象的地址；</p>
</li>
<li><p>如果串池中没有：</p>
<ul>
<li>jdk1.6中，把此<b style='color:blue'>对象复制一份</b>，放入串池，并返回串池中的对象地址</li>
<li>jdk1.7起，把此<b style='color:blue'>对象的引用地址复制一份</b>，放入串池，并返回串池中的引用地址</li>
</ul>
</li>
</ul>
<h2 id="对象详情"><a href="#对象详情" class="headerlink" title="对象详情"></a>对象详情</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><strong>创建对象的方式</strong></p>
<ul>
<li>new</li>
<li>Class的newInstance()</li>
<li>Constructor的newInstance(Xxx)</li>
<li>使用clone()</li>
<li>使用反序列化</li>
<li>第三方库Objenesis</li>
</ul>
<p><strong>创建对象的步骤</strong></p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化</li>
<li>为对象分配内存<ul>
<li>如果内存规整—–指针碰撞</li>
<li>如果内存不规整—–空闲列表分配（JVM需要维护一个列表来记录空闲的内存地址）</li>
</ul>
</li>
<li>处理并发安全问题<ul>
<li>每个线程预先分配一块TLAB</li>
<li>采用CAS配上失败重试保证更新的原子性</li>
</ul>
</li>
<li>初始化分配的空间<ul>
<li>所有属性设置默认值，保证对象实例字段不赋值时可以直接使用</li>
</ul>
</li>
<li>设置对象的对象头</li>
<li>执行init方法经行初始化</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象内部包括三部分：对象头、实例数据、对齐填充</p>
<p><strong>对象头(Header)</strong></p>
<ul>
<li>运行时数据(Mark Work)<ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程的ID</li>
<li>偏向时间戳</li>
<li>如果是数组，还需记录数组长度</li>
</ul>
</li>
<li>指针类型(Klass word)—–指向元数据InstanceKlass，确定该对象所属的类型</li>
</ul>
<p><strong>实例数据(Instance Data)</strong></p>
<ul>
<li>它是真正存储有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的字段）</li>
</ul>
<p><strong>对齐填充(Padding)</strong></p>
<ul>
<li>不是必须的，仅仅起到占位符的作用</li>
</ul>
<p><a href="https://imgtu.com/i/I8xQeO"><img src="https://z3.ax1x.com/2021/11/08/I8xQeO.jpg" alt="I8xQeO.jpg"></a></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM是通过栈帧上reference访问对象的，主要有两种方式:</p>
<p><strong>方式一：直接指针(HotSpot默认)</strong></p>
<p><a href="https://imgtu.com/i/IGSxWd"><img src="https://z3.ax1x.com/2021/11/08/IGSxWd.jpg" alt="IGSxWd.jpg" style="zoom:50%;" /></a></p>
<p><strong>方式二：句柄访问</strong></p>
<p><a href="https://imgtu.com/i/IGSTQ1"><img src="https://z3.ax1x.com/2021/11/08/IGSTQ1.jpg" alt="IGSTQ1.jpg" style="zoom: 50%;" /></a></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>直接内存是在java堆外的、直接指向系统申请的内存区间。</li>
<li>访问直接内存的速度会优于Java堆，出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
<li>由于直接内存在java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小。但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>直接内存大小可以通过MaxDirectMemorySize设置，默认与堆的最大值-Xmx参数一致</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>分配回收成本高</li>
<li>不是JVM内存的回收管理</li>
</ul>
<p><strong>非直接缓冲区</strong>： 读写文件，需要与磁盘交互，需要由用户态切换到内核态。如下图，使用IO需要两份内存存储重复数据，效率低。</p>
<p><a href="https://imgtu.com/i/IGZn4x"><img src="https://z3.ax1x.com/2021/11/08/IGZn4x.png" alt="IGZn4x.png"  /></a></p>
<p><strong>直接缓冲区</strong>：使用NIO时，操作系统划出直接的缓冲区可以被java代码直接访问，只有一份。NIO适合堆大文件的读写操作。</p>
<p><a href="https://imgtu.com/i/IGZg5q"><img src="https://z3.ax1x.com/2021/11/08/IGZg5q.md.png" alt="IGZg5q.md.png"  /></a></p>
<h1 id="执行引擎-Excution-Engine"><a href="#执行引擎-Excution-Engine" class="headerlink" title="执行引擎(Excution Engine)"></a>执行引擎(Excution Engine)</h1><p><a href="https://imgtu.com/i/IGyQKK"><img src="https://z3.ax1x.com/2021/11/08/IGyQKK.png" alt="IGyQKK.png"></a></p>
<p>执行引擎是JVM核心的组成部分之一</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，区别是： </p>
<ul>
<li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的</li>
<li><b style='color:red'>虚拟机的执行引擎是由软件自行实现的</b> , 因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</li>
</ul>
<p><strong>执行引擎的作用</strong></p>
<ul>
<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>执行引擎的任务就是<b style='color:red'>将字节码指令解释/编译为对应平台上的本地机器指令</b>, 让Java程序运行起来。换言之，JVM的执行引擎充当了将高级语言翻译成机器语言的译者。</li>
</ul>
<p><strong>工作过程</strong></p>
<ul>
<li>执行引擎执行的字节码指令完全依赖于PC寄存器，每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>方法在执行过程中，执行引擎可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指令定位到目标对象的类型信息。</li>
</ul>
<h2 id="Java代码编译和执行的过程"><a href="#Java代码编译和执行的过程" class="headerlink" title="Java代码编译和执行的过程"></a>Java代码编译和执行的过程</h2><p>大部份的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤:</p>
<p><a href="https://imgtu.com/i/IGokqA"><img src="https://z3.ax1x.com/2021/11/08/IGokqA.jpg" alt="IGokqA.jpg" style="zoom:50%;" /></a></p>
<p><strong>解释器(Interpreter)</strong></p>
<p>当Java虚拟机启动时会根据预定义的规范对<b style='color:red'>字节码采用逐行解释的方式执行</b>,将每条字节码文件中的内容“翻译”成对应平台的本地机器指令执行，启动快，但执行效率低。</p>
<p><strong>JIT编译器(Just In Time Compiler)</strong></p>
<p>虚拟机将源代码直接编译成本地机器平台相关的机器语言，需要一定的执行时间，但编译为本地代码后，执行效率高。</p>
<p><strong>Java是半编译半解释型语言</strong></p>
<p>JDK1.0时代，将Java语言定义为”解释执行”还是比较正确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码时，通常会将解释执行与编译执行二者结合起来</p>
<p><strong>执行引擎基本执行流程</strong></p>
<p><a href="https://imgtu.com/i/IGogJK"><img src="https://z3.ax1x.com/2021/11/08/IGogJK.jpg" alt="IGogJK.jpg"></a></p>
<p><strong>字节码</strong></p>
<ul>
<li>字节码是一种中间状态的二进制代码，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要是为了实现特定软件的运行与软件环境，与硬件环境无关。</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初中仅仅只是单纯的<b style='color:red'>为了满足Java程序实现跨平台特性</b>,  因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。<a href="https://imgtu.com/i/IG7uuQ"><img src="https://z3.ax1x.com/2021/11/08/IG7uuQ.jpg" alt="IG7uuQ.jpg" style="zoom: 50%;" /></a></p>
<p>在Java的发展历史里，一共由两套解释执行器，古老的<b style='color:red'>字节码解释器</b>、现在普遍使用的<b style='color:red'>模板解释器</b></p>
<ul>
<li><p>字节码解释器在执行时通过<b style='color:blue'>纯软件代码</b>模拟字节码的执行，效率非常地下</p>
</li>
<li><p>模板解释器将<b style='color:blue'>每一条字节码和一个模板函数相关联</b>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能</p>
<ul>
<li>在HotSpot VM中，解释器主要由Interpreter模板和Code模板构成<ul>
<li>Interpreter模板：实现了解释器的核心功能</li>
<li>Code模板: 用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>解释器在设计和实现上非常简单，出来Java语言外，如Python、Perl、Ruby等也是基于解释器执行的。如今，<b style='color:blue'>基于解释器执行已经被沦落为低效的代名词</b></p>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>现代虚拟机为了提高执行效率，会使用即时编译技术(JIL,Just In Time) 将方法编译成机器码后再执行。</p>
<p>HotSpot MV 采用解释器与即时编译器并存的架构 : </p>
<ul>
<li>当程序启动后,解释器可以马上发挥作用，<b style='color:blue'>省去许多不必要的编译时间</b>，立即执行</li>
<li>随着程序运行时间的推移，编译器逐渐发挥作用，根据热点探测功能，<b style='color:blue'>将有价值的字节码编译为本地机器指令</b>，以换取更高的程序执行效率。</li>
</ul>
<p><strong>热点代码</strong>：一个方法被调用多次方法，或者是一个方法体内部循环次数比较多的循环体。</p>
<p>JIT编译器会将<b style='color:blue'>热点代码</b>直接编译为对应平台的本地机器指令, 由于这种编译方式发生在方法的执行过程中，因此被称之为<b style='color:blue'>栈上替换</b>，或简称为<b style='color:blue'>OSR(On Stack Replacement)编译</b></p>
<p><strong>热点探测功能</strong> ： 判断热点代码</p>
<ul>
<li>目前HotSpot MV 所采用的热点探测方式是<b style='color:blue'>基于计数器的热点探测</b></li>
<li>HotSpot MV为每一个方法都建立2给不同类型的计数器<ul>
<li>方法调用计数器(Invocation Counter) : 统计方法的调用次数</li>
<li>回边计数器(Back Edge Counter): 统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<p><strong>方法调用计数器</strong></p>
<ul>
<li><p>默认阈值在Client模式下是1500次，在Server模式下是10000次，超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>可通过<b style='color:blue'>-XX:CompileThreshold</b>参数来设置</p>
</li>
<li><p>当一个方法被调用时，先检查该方法是否存在被JIT编译过的版本</p>
<ul>
<li>如果存在，则优先使用编译后的本地代码来执行。</li>
<li>如果不存在，将此方的调用计数器值+1，然后判断<b style='color:blue'>方法调用计数器与回边计数器值之和</b>是否超过方法调用计数器的阈值，如果超过阈值，就向即时编译器提交一个该方法的代码编译请求，最后解释执行</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/IGjtij"><img src="https://z3.ax1x.com/2021/11/08/IGjtij.jpg" alt="IGjtij.jpg" style="zoom: 40%;" /></a></p>
<ul>
<li>热度衰减</li>
</ul>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率。<b style='color:red'>一段时间之内方法调用的次数，当超过一定的时间限度</b>，如果方法调用次数仍然不足它提交给即时编译器，那这个方法的计数器就会被<b style='color:red'>减少一半</b>,这个过程称之为<b style='color:red'>方法调用计数器热度的衰减(Counter Decay)</b>,这段时间称之为<b style='color:red'>半衰周期(Counter Half Life Time)</b></p>
<p>进行热度衰减的动作是在虚拟机经行垃圾收集时顺便进行的。</p>
<p><b style='color:blue'>-XX:UseCounterDecay</b> 参数是关闭/开启热度衰减，默认开启。</p>
<p><b style='color:blue'>-XX:CounterHalfLifeTime</b> 参数设置半衰周期的时间，单位是秒。</p>
<p><strong>回边计数器</strong></p>
<p>统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称之为 “回边”(Back Edge)。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><a href="https://imgtu.com/i/IGvcB8"><img src="https://z3.ax1x.com/2021/11/08/IGvcB8.jpg" alt="IGvcB8.jpg" style="zoom:40%;" /></a></p>
<p><strong>HotSpot VM设置程序执行方式</strong></p>
<ul>
<li><b style='color:blue'>-Xint</b> : 完全采用解释器模式执行程序  </li>
<li><b style='color:blue'>-Xcomp </b>: 完全采用即时编译器模式执行程序，如果即时编译出现问题，解释器就会介入执行</li>
<li><b style='color:blue'>-Xmixed</b>: 采用解释器+即时编译器的混合模式共同执行程序  (默认方式)</li>
</ul>
<p><strong>HotSpot VM 中 JIT分类</strong></p>
<p>HotSpot VM内嵌两个JIT编译器，分别为Client Compiler 和 Server Compiler ，一般简称为C1编译器与C2编译器，可使用如下指令指定采用哪种编译器：</p>
<ul>
<li><b style='color:blue'>-clinet</b> : 指定JVM运行在Client模式下，使用C1编译器<ul>
<li>C1编译器对字节码进行<b style='color:red'>简单可靠的优化，耗时短</b>。以达到更快的编译速度。</li>
</ul>
</li>
<li><b style='color:blue'>-server</b>: 指定JVM运行在Server模式下，使用C2编译器<ul>
<li>C2编译器<b style='color:red'>耗时较长的优化，以及激进的优化</b>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<p><strong>C1和C2编译器不同的优化策略</strong></p>
<ul>
<li>C1编译器<ul>
<li>方法内联：将引用的函数代码编译到引用处，这样可以减少栈帧的生成，减少参数传递以及跳转的过程</li>
<li>去虚拟化：对唯一的实习类进行内联</li>
<li>冗余消除：在运行期间把不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2编译器  ： 优化主要是在全局层面，逃逸分析是优化的基础<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于为逃逸的对象分配到栈而不是堆</li>
<li>同步消除：清除同步操作，通常值synchronized</li>
</ul>
</li>
</ul>
<p><strong>分层编译(Tiered Compilation)策略</strong></p>
<ul>
<li>程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，经行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化</li>
<li>在Java7版本后，在-server 模式下会默认开启分层编译策略，有C1与C2相互协同来执行编译任务</li>
</ul>
<h1 id="垃圾回收-Garbage-Collectioin"><a href="#垃圾回收-Garbage-Collectioin" class="headerlink" title="垃圾回收(Garbage Collectioin)"></a>垃圾回收(Garbage Collectioin)</h1><p><strong>垃圾</strong> 是指在<b style='color:red'>运行程序中没有任何指针指向的对象</b>,这个对象就是需要被回收的垃圾</p>
<p>对于高级语言，不断地分配内存空间而不进行回收，内存迟早都会被消耗完。除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。</p>
<p><strong>早期的垃圾回收</strong></p>
<p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员使用new关键字进行内存申请，并使用delete释放该对象所占内存区域。这种方式可以灵活控制内存释放的时间，但是会带来<b style='color:blue'>频繁申请和释放内存的管理负担</b>，容易造成<b style='color:blue'>内存泄漏</b>.</p>
<p><strong>垃圾回收器的作用域</strong>：方法区和堆</p>
<p><strong>从回收次数上看</strong></p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不动Perm区</li>
</ul>
<h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>在GC执行垃圾回收之前，需要先区分处哪些是存活对象，哪些是死亡对象，只有被标记为已死亡的对象，才会被GC执行垃圾回收，释放掉器所占用的内存空间。</p>
<p>当一个对象已经不在别任何的存活对象继续引用时，就可以宣布为已经死亡。</p>
<p>判断对象存活一般有两种方式: <b style='color:red'>引用计数算法（Reference Counting）</b>  和  <b style='color:red'>可达性分析算法</b></p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>对每个对象<b style='color:blue'>保存一个整形的引用计数器属性</b>，用于记录对象被引用的情况</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要引用计数器的值为0 ，就表示对象A不可能在被使用，可进行回收。</li>
</ul>
<p><strong>优点</strong> ：实现简单，垃圾对象便于辨识；判断效率高，回收没有延迟性。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>单独字段存储计算器，增加了<b style='color:blue'>存储空间的开销</b></li>
<li>每次赋值都要更新计数器，伴随着加法和减法操作，增加了<b style='color:blue'>时间开销</b></li>
<li><b style='color:blue'>无法处理循环引用</b>的情况。这是一条致命的缺陷，导致Java垃圾回收器中没有使用这类算法。</li>
</ul>
<p>然而Python语言则支持引用计数器，那么Python是任何解决循环引用？</p>
<ol>
<li>手动解除：在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是python提供的标准库，旨在解决循环引用</li>
</ol>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法不仅实现简单和执行高效，更重要的是可以有效的<b style='color:blue'>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</b>，通常也叫做<b style='color:blue'>追踪性垃圾收集(Tracing Garbage Collection)</b></p>
<p><strong>基本思路</strong></p>
<ul>
<li>以<b style='color:blue'>根对象集合(GC Roots) </b>为起点，按照从上至下的方式<b style='color:blue'>搜索被根对象集合所连接的目标对象是否可达</b></li>
<li>可达性分析后，内存中存活的对象都会被GC Roots 直接或间接连接着，搜索所走过的路径称之为<b style='color:red'>引用链(Reference Chain)</b></li>
<li>如果目标没有别任何引用链相连，则是不可达的，可标记为垃圾对象</li>
</ul>
<p><strong>根对象集合(GC Roots)</strong>   是一组必须活跃的引用，包括以下几类元素:</p>
<ul>
<li>虚拟机栈中引用的对象，如方法中使用的参数、局部变量表</li>
<li>本地方法栈内JNI引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象，如StringTable里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>java虚拟机内部的引用，如基本数据类型对应的Class类型、异常对象、系统类加载器等</li>
</ul>
<p><strong>注意</strong>：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个保证一致性的快照中进行，否则无法保证其准确性。这也是导致GC进行时必须触发”Stop The World”的一个重要原因</p>
<h3 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><ul>
<li>对象终止机制允许开发人员提供<b style='color:blue'>对象被销毁之前定义处理逻辑</b>。</li>
<li>对象被回收前，总会先调用当前对象的<code>finalize()</code>方法，finalize()方法是Object类的方法，允许被重写。</li>
</ul>
<p>永远不要主动调用对象的 <code>finalize()</code> 方法,应该交给垃圾回收机制调用，理由如下:</p>
<ol>
<li>finalize() 可能导致对象复活</li>
<li>finalize() 方法的执行时间是没有保障的，它完全由GC线程决定。</li>
<li>一个糟糕的finalize() 会严重影响GC的性能</li>
</ol>
<p><strong>对象一般处于三种可能的在状态</strong></p>
<ul>
<li>可触及的：从根节点开始，可以达到这个对象</li>
<li>可复活的：对象的引用都被释放，但是对象有可能在finalize() 中复活</li>
<li>不可触及的：不可达且没有重写finalize() ,或对象的finalize() 被调用，并且没有被复活。</li>
</ul>
<p>只有不可触及的对象才会被回收，并且 <b style='color:blue'>finalize()只会被调用一次</b></p>
<h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>当成功区分出垃圾对象后，GC接下来的任务就是执行垃圾回收，释放无用的对象所占用的内存。</p>
<p>目前JVM比较常见的三种垃圾收集算法分别是 <b style='color:red'>标记—清除算法(Mark-Sweep)</b>、<b style='color:red'>复制算法(Copying)</b>、<b style='color:red'>标记—压缩算法(Mark-Compact)</b></p>
<h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>这是一种非常基础和常见的垃圾收集算法。</p>
<p><strong>执行过程</strong></p>
<p>当堆中有效内存被耗尽时，执行STW;<b style='color:blue'>阶段一:</b>标记阶段先标记哪些对象是可达的，<b style='color:blue'>阶段二 :</b>Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收</p>
<p><a href="https://imgtu.com/i/IYgxdf"><img src="https://z3.ax1x.com/2021/11/09/IYgxdf.jpg" alt="IYgxdf.jpg" style="zoom: 33%;" /></a></p>
<p><strong>注意: 怎么清除(回收)</strong></p>
<p>这里所谓的清除不是真的置空，而是把需要清理的对象地址保存在<strong>空闲列表</strong>中。下次有新对象需要加载时，分配相应的大小直接覆盖。</p>
<p><strong>缺点</strong></p>
<ul>
<li>效率不高</li>
<li>进行GC时，需要STW，导致用户体验差</li>
<li>清理了出来的内存是不连续的，容易产生内存碎片，并且需要唯一一个空闲列表</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，然后清除正在使用的内存卡中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><a href="https://imgtu.com/i/IYWCKs"><img src="https://z3.ax1x.com/2021/11/09/IYWCKs.jpg" alt="IYWCKs.jpg" style="zoom:33%;" /></a></p>
<p><strong>优点</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，允许高效</li>
<li>不会出现”碎片”问题</li>
<li>如果系统中的垃圾对象很多，需要复制的存活对象非常少</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要两倍的内存空间</li>
<li>存活对象要移动，所以相应的引用地址也需要改变</li>
</ul>
<p>在新生代，一次通常可以回收70%—90%的内存空间，所以用复制算法堪称完美。</p>
<h4 id="标记—压缩算法"><a href="#标记—压缩算法" class="headerlink" title="标记—压缩算法"></a>标记—压缩算法</h4><p><strong>背景</strong></p>
<p>复制算法的高性能时建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代则相反。因此<b style='color:red'>基于老年代垃圾回收的特性，需要使用其他的算法</b>。</p>
<p>标记-清除算法可以应用在老年代，但是该算法不仅效率低下，而且还会产生内存碎片，所以需要在此基础上进行改进。标记—压缩算法由此诞生</p>
<p><strong>执行过程</strong></p>
<ul>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象。</p>
</li>
<li><p>第二阶段将所有对象压缩到内存的一段，按顺序排放，之后，清理边界外所有的空间</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/ItW9X9"><img src="https://z3.ax1x.com/2021/11/09/ItW9X9.jpg" alt="ItW9X9.jpg" style="zoom:33%;" /></a></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行后再进行一次内存碎片整理。因此也可以把它称之为<b style='color:red'>标记—清除—压缩(Mark-Sweep-Compact)算法</b></p>
<p><strong>标记-清除与标记-压缩的区别</strong></p>
<ul>
<li>标记-清除算法是一种<b style='color:blue'>非移动式的回收算法</b>,标记-压缩算法是<b style='color:blue'>移动式的</b></li>
<li>标记的存活对象会被整理，按照内存地址依次排序，这样的话JVM<b style='color:blue'>只需要持有一个内存的起始地址即</b>可，这比维护一个空间列表要少了许多开销</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>消除了标记-清除算法中内存区域分散的缺点</li>
<li>消除了复制算法中，两倍内存的代价</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>效率低</li>
<li>移动对象的同时，如果对象被其他对象引用，还需要调整引用的地址</li>
<li>移动过程需要STW</li>
</ul>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述算法中，在GC过程中，应用软件将处于Stop The World的状态。如果GC时间过长，应用程序将被挂起很久，<b style='color:blue'>将严重影响用户体验或系统的稳定性</b>。为了解决该问题，增量收集(Incremental Collecting)算法诞生了</p>
<p><strong>基本思路</strong></p>
<p>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。</p>
<p><strong>缺点</strong></p>
<p>虽然能减少系统单次达到停顿时间，但是，因为线程切换和上下文切换的消耗，会使得垃圾回收的总体成本上升，<b style='color:blue'>造成系统吞吐量的下降</b></p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，堆空间越大，一次GC所需的时间就越长，STW时间也更长。为了更好的控制GC产生的停顿时间，<b style='color:blue'>将一块大的内存区域分割成多个小块</b>，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间,从而减少一次GC所产生的停顿。</p>
<p>每一个小区间都独立使用，该算法的好处是可以控制停顿的时间。</p>
<p><a href="https://imgtu.com/i/ItqlYd"><img src="https://z3.ax1x.com/2021/11/09/ItqlYd.png" alt="ItqlYd.png" style="zoom: 67%;" /></a></p>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>通过<code>System.gc()</code> 或 <code>Runtime.getRuntime.gc()</code>的调用，会<b style='color:blue'>显示触发Full GC</b>，对老年代和新生代进行回收。</p>
<p>再一般情况下，垃圾回收是自动进行的，无需手动触发，否则就太过于麻烦了。我们一般在测试代码中才调用System.gc() 方法</p>
<h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><p><strong>内存溢出</strong></p>
<p>没有空闲内存，并且垃圾收集器也无法提供更多内存时，会抛 OutOfMemoryError异常，表示内存溢出</p>
<p>java堆内存不够，原因有二:</p>
<ol>
<li>堆内存设置不够</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集</li>
</ol>
<p>在抛出OutOfMemoryError 之前，通常垃圾收集器都会被触发，其尽所能去清理空间。当然，不是在任何情况下垃圾收集器都会被触发，如出现一个超大对象，超过堆的最大值。</p>
<p><strong>内存泄漏</strong></p>
<p>内存泄漏指 当对象不会再被程序用到了，但是GC有不能回收他们的情况。</p>
<p>尽管内存泄漏不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中可用的内存会逐步蚕食，直至耗尽。</p>
<p>举例:</p>
<ol>
<li><p>单例模式</p>
<p>单例的生命周期和应用程序时一样长的，如果再单例程序中持有对外部对象的引用的话，这个外部对象时不能被回收的</p>
</li>
<li><p>一些提供close的资源未关闭</p>
<p>例如<b style='color:blue'>数据库连接池(dataSource.getConnection())</b>  , <b style='color:blue'>网络连接(socket)</b> ，<b style='color:blue'>io连接</b> 都必须手动close，否则时不能被回收的</p>
</li>
</ol>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p><strong>并发(Concurrent)</strong> ：多个事情在同一时间段内同时发生，在某一时间点只会处理一件事</p>
<p><strong>并行(Parallel)</strong> ：多个事情在同一时间点同时发生，只有在多CPU或多核的情况下才会发生</p>
<p>在垃圾收集器的上下文语境中:</p>
<ul>
<li>串行(Serial)：单线程执行，如果内存不够，暂停程序，执行GC，回收完，再启动程序的线程。</li>
<li>并行(Parallel)：多条垃圾收集线程并行工作，但用户线程仍处于等待状态</li>
</ul>
<p><a href="https://imgtu.com/i/IUp6sJ"><img src="https://z3.ax1x.com/2021/11/10/IUp6sJ.png" alt="IUp6sJ.png" style="zoom: 67%;" /></a></p>
<ul>
<li>并发（Conrurrent）：用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行），垃圾回收线程再执行时不会停顿用户的程序<ul>
<li>用户线程继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/IU91T1"><img src="https://z3.ax1x.com/2021/11/10/IU91T1.png" alt="IU91T1.png"></a></p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点(Safe Point)</strong></p>
<ul>
<li><p>再程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置被成为”安全点”。</p>
</li>
<li><p>Safe Point 的选择很重要，<b style='color:blue'>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</b>。所以会选择执行时间比较长的指令作为Safe Point ，如方法调用、循环跳转和异常跳转等。</p>
</li>
<li><p>在GC发生时，检查所有线程都跑到安全点的方式：</p>
<ul>
<li>抢先式中断(目前没有虚拟机采用)<ul>
<li>首先中断所有线程，如果还有线程不在安全点，就恢复该线程，让线程跑到安全点。</li>
</ul>
</li>
<li>主动式中断<ul>
<li>设置一个中断标志，各个线程运行到Safe Point时主动轮询这个标志，如果中断标志位真，就将自己进行中断挂起。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>安全区域(Safe Region)</strong></p>
<ul>
<li>当程序“不执行”的时候，如线程处于Sleep状态或Blocked状态，这时线程无法相应JVM的中断请求，”走“到安全点将自己中断挂起。这种情况下，就需要安全区域来解决。</li>
<li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，安全区域可以看做是安全点的扩展。</li>
</ul>
<p><strong>安全区域的实际执行</strong></p>
<ol>
<li>当线程运行到Safe Region时，首先标识已经进入到了Safe Region，如果在这段时间发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查GC是否已完成，如果完成则继续运行，否则线程必须等待直到收到可以离开Safe Region的信号为止</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在JDK1.2之后，java对引用的概念进行了扩展，将引用分为强、软、弱、虚4种，引用强度依次递减。除了强引用外，其他3种引用均可在java.lang.ref包中找到。</p>
<p><strong>强引用（Strong Reference）——不回收</strong></p>
<ul>
<li>默认的引用类型，系统99%以上都是强引用。直接给一个变量赋值操作，该变量就指向对象的一个强引用。</li>
<li>强引用如果是可触及的，垃圾收集器就永远不会收掉强引用的对象，所以强引用是造成java内存泄漏的主要原因之一</li>
<li>强引用可直接访问目标对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两个引用都是强引用</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2 = s;</span><br></pre></td></tr></table></figure>
<p><strong>软引用(Soft Reference)——内存不足即回收</strong></p>
<ul>
<li>软引用是用来描述一些还有用的，但非必要的对象。<b style='color:blue'>只被软引用关联着的对象，在系统要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收</b>，如果回收后还是没有足够的内存，才会抛出内存溢出异常。</li>
<li>软引用通常用来实现内存敏感的缓存。如：<b style='color:blue'>高速缓存</b>就用到软引用。如果有空闲内存，就暂时保留缓存，当内存不足时清理掉，这样就保证使用缓存的同时，不会耗尽内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line"><span class="comment">// 创建软引用，指向 obj 指向的对象地址</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>
<p><strong>弱引用(Weak Reference)——发现即回收</strong></p>
<ul>
<li>弱引用来描述那些非必须对象，<b style='color:blue'>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</b>。</li>
<li>由于垃圾收集器的线程优先级很低，因此弱引用也是可以存在比较长的时间，可以用来保存一些可有可无的缓存数据。</li>
<li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过该队列可以跟踪对象的回收情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line"><span class="comment">// 创建弱引用，指向 obj 指向的对象地址</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(obj); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>
<p><strong>虚引用(Phantom Reference)——对象回收跟踪</strong></p>
<ul>
<li>也称”幽灵引用“或”幻影引用“，如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的。随时都会被回收</li>
<li>它不能单独使用，也无法通过虚引用获取。当试图用虚引用的get()方法获取对象时，返回的是null</li>
<li>为一个对象设置虚引用关联的唯一目的在于<b style='color:blue'>跟踪垃圾回收过程</b>。如：在对象被回收时收到一个系统通知</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</li>
<li>虚引用必须和引用队列一起使用，创建虚引用时必须提供一个引用队列作为参数。当GC准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue(); <span class="comment">// 创建引用队列</span></span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj,queue); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>运行时数据区</tag>
        <tag>类加载子系统</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrent</title>
    <url>/2021/11/20/concurrent/</url>
    <content><![CDATA[<p>无论是并行还是并发，在用户看来都是“同时”运行的。实际上，一个CPU同一时刻只能执行一个任务。</p>
<ul>
<li>并发：指两个或多个事件在<strong>同一时段内</strong>发生，即单核CPU在固定时段内<strong>交替执行</strong>多个任务</li>
<li>并行：指两个或多个事件在<strong>同一时刻</strong>发生，即多核CPU<strong>同时执行</strong>多个任务。<a id="more"></a></li>
</ul>
<h1 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h1><p>哪些场景会导致线程上下文切换(Thread Context Switch)？</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 </li>
<li>有更高优先级的线程需要运行 </li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p><strong>Thread常见方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td>
</tr>
<tr>
<td>run()</td>
<td>新线程启动后会 调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td>等待线程运行结 束</td>
<td>一般用于线程之间的同步操作，一个线程需要获取另一个线程的执行结果</td>
</tr>
<tr>
<td>join(long)</td>
<td>等待线程运行结 束,最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td>获取线程长整型 的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>getName()</td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>setDaemon(true)</td>
<td>设置为守护线程</td>
<td>当进程中没有非守护线程时，即使守护线程没有执行完，进程也会结束(如 GC线程就是守护线程)</td>
</tr>
<tr>
<td>getState()</td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>isAlive()</td>
<td>线程是否存活</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td>打断线程</td>
<td></td>
</tr>
<tr>
<td>isInterrupted()</td>
<td>判断是否被打断</td>
<td>不会清除 打断标记</td>
</tr>
<tr>
<td>interrupted()</td>
<td>判断当前线程是 否被打断</td>
<td>static，会清除 打断标记（改为false）</td>
</tr>
<tr>
<td>currentThread()</td>
<td>获取当前正在执行的线程</td>
<td>static</td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>让当前执行的线 程休眠n毫秒</td>
<td>static</td>
</tr>
<tr>
<td>yield()</td>
<td>提示线程调度器 让出当前线程对 CPU的使用</td>
<td>static</td>
</tr>
</tbody></table>
<h2 id="Interrupt方法详解"><a href="#Interrupt方法详解" class="headerlink" title="Interrupt方法详解"></a>Interrupt方法详解</h2><p><strong>打断正常运行的线程</strong></p>
<p>一个线程正常执行，如果调用该线程的<code>interrupter()</code>方法，会添加打断标记(true)，调用<code>isInterrupted()</code>方法可返回true</p>
<p><strong>打断阻塞线程</strong></p>
<p>sleep、wait、join方法会使线程阻塞，如果再此时打断该线程，会抛出<code>InterruptedException</code>异常,并且会清空打断状态(false)</p>
<p><strong>打断park线程</strong></p>
<p>如果线程正在park阻塞中，打断该线程，添加打断标记(true)。该线程会处于RUNNABLE状态。</p>
<p>如果打断标记是true，则park会失效。（park&amp;unpark用法在下面会详细讲解）</p>
<h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>利用interrupt打断正在执行的线程，而不是使用stop()、suspend()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPTInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示该线程被打断，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (t.isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事---程序正在退出！&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在执行。。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 如果是在sleep时被打断，则要重新打断</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不推荐使用的方法"><a href="#不推荐使用的方法" class="headerlink" title="不推荐使用的方法"></a>不推荐使用的方法</h2><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume()</td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<h2 id="操作系统层面的五种状态"><a href="#操作系统层面的五种状态" class="headerlink" title="操作系统层面的五种状态"></a>操作系统层面的五种状态</h2><p><a href="https://imgtu.com/i/ILybvj"><img src="https://z3.ax1x.com/2021/11/20/ILybvj.png" alt="ILybvj.png" style="zoom: 67%;" /></a></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 </li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态 <ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li> 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 </li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们 </li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h2 id="java层面的六种状态"><a href="#java层面的六种状态" class="headerlink" title="java层面的六种状态"></a>java层面的六种状态</h2><p>根据源码Thread.State 枚举，分为六种状态</p>
<p><a href="https://imgtu.com/i/ILyLKs"><img src="https://z3.ax1x.com/2021/11/20/ILyLKs.png" alt="ILyLKs.png"></a></p>
<ul>
<li><p>【NEW】 线程刚被创建，但是还没有调用 start() 方法</p>
</li>
<li><p>【RUNNABLE】 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</p>
</li>
<li><p>【BLOCKED】， 【WAITING】 ， 【TIMED_WAITING】 都是 Java API 层面对【阻塞状态】的细分</p>
<ul>
<li>RUNNABLE -&gt; BLOCKED:   synchronized 获取锁失败，进入 EntryList 中阻塞</li>
<li>RUNNABLE -&gt; WAITING： 调用 wait() 、join() 、park() </li>
<li>RUNNABLE -&gt; TIMED_WAITING ：调用 wait(long n) 、join(long n) 、parkNanos(long n) 、sleep(long n)</li>
</ul>
</li>
<li><p>【TERMINATED】 当线程代码运行结束</p>
</li>
</ul>
<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><p><strong>临界区（Critical Section）</strong></p>
<p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p>
<p><strong>竞态条件 （Race Condition）</strong> </p>
<p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock </li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized 俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非静态方法上的synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态方法上的synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test.class) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象内部包括三部分：对象头、实例数据、对齐填充</p>
<p>其中对象头(Header)占64字节，而对象头包括两部分: 运行时数据(Mark Work)、指针类型(Klass word)</p>
<p>运行时数据占32个字节，结构为(最后两位表示锁的状态):</p>
<ul>
<li>32位虚拟机</li>
</ul>
<p><a href="https://imgtu.com/i/IOpI8f"><img src="https://z3.ax1x.com/2021/11/20/IOpI8f.png" alt="IOpI8f.png"></a></p>
<ul>
<li>64位虚拟机</li>
</ul>
<p><a href="https://imgtu.com/i/IOpHKg"><img src="https://z3.ax1x.com/2021/11/20/IOpHKg.png" alt="IOpHKg.png"></a></p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>偏行线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
<tr>
<td>指向锁定记录的指针</td>
<td>00</td>
<td>轻量级锁</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁）</td>
</tr>
<tr>
<td>空、不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
</tbody></table>
<h3 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a>Monitor原理</h3><p>Monitor 被翻译为监视器或管程，每个对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象的Mark Work 种就被设置指向Monitor 对象的指针。</p>
<p>Monitor结构：</p>
<p><a href="https://imgtu.com/i/IO9QqH"><img src="https://z3.ax1x.com/2021/11/20/IO9QqH.png" alt="IO9QqH.png"></a></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null </li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner </li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 经行阻塞BLOCKED </li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会讲解</li>
</ul>
<h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><h4 id="字节码角度"><a href="#字节码角度" class="headerlink" title="字节码角度"></a>字节码角度</h4><p>如果一段代码块加入了 synchronized 锁，其对应的字节码会添加两条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitorenter  &#x2F;&#x2F; 将锁对象 MarkWord 置为 Monitor 指针</span><br><span class="line">。。。。。</span><br><span class="line">monitorexit   &#x2F;&#x2F; 将锁对象 MarkWord 重置, 并唤醒 EntryList</span><br></pre></td></tr></table></figure>
<p>在异常表中也会有该代码块相对应的异常处理，表示如果在上锁过程中发生了错误，也会去执行释放锁的操作，不需要我们手动解锁。</p>
<p><strong>注意：</strong> 方法级别的 synchronized 不会在字节码指令中有所体现</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。轻量级锁对使用者是透明的，即语法仍然是 synchronized。</p>
<p>例子:  两个同步块，使用同一个对象锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当前线程<code>thread-0</code>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁对象的Mark Word</p>
</li>
<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/IOFVmD"><img src="https://z3.ax1x.com/2021/11/20/IOFVmD.png" alt="IOFVmD.png" style="zoom:67%;" /></a></p>
<ul>
<li>如果 cas 替换成功，Mark Word中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>
</ul>
<p><a href="https://imgtu.com/i/IOkl59"><img src="https://z3.ax1x.com/2021/11/20/IOkl59.png" alt="IOkl59.png" style="zoom:67%;" /></a></p>
<ul>
<li>如果 cas 失败，有两种情况<ol>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ol>
</li>
</ul>
<p><a href="https://imgtu.com/i/IOks2t"><img src="https://z3.ax1x.com/2021/11/20/IOks2t.png" alt="IOks2t.png" style="zoom:67%;" /></a></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li>
</ul>
<p><a href="https://imgtu.com/i/IOkTx0"><img src="https://z3.ax1x.com/2021/11/20/IOkTx0.png" alt="IOkTx0.png" style="zoom:67%;" /></a></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头<ul>
<li>成功，则解锁成功 </li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，<strong>将轻量级锁变为重量级锁</strong></p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><a href="https://imgtu.com/i/IOAtWn"><img src="https://z3.ax1x.com/2021/11/20/IOAtWn.png" alt="IOAtWn.png"></a></p>
<ul>
<li>Thread-1 加轻量级锁失败，进入锁膨胀流程 <ol>
<li>为 Object 对象申请 Monitor 锁，让Monitor的Owner指向拥有轻量级锁的线程，即Thread-0</li>
<li> 让 Object 指向重量级锁地址</li>
<li>THread-1 自己进入 Monitor 的 EntryList经行阻塞 BLOCKED</li>
</ol>
</li>
</ul>
<p><a href="https://imgtu.com/i/IOAO6P"><img src="https://z3.ax1x.com/2021/11/20/IOAO6P.png" alt="IOAO6P.png"></a></p>
<ul>
<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，不会立刻进入阻塞状态，而是自旋重试看看能不能获取到锁，如果在自旋时，持锁线程释放了锁，那么当前线程自旋成功。如果自旋多次还没获取锁，就会陷入阻塞状态。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 </p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><strong>偏向状态</strong></p>
<p>在对象头中，markword值为 0x05 即最后 3 位为 101，则表示偏向锁</p>
<p><img src="https://z3.ax1x.com/2021/11/20/IOpHKg.png" alt="IOpHKg.png"></p>
<p>一个对象创建时:</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 </li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay=0 来禁用延迟 </li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<p><strong>撤销偏向锁</strong></p>
<ul>
<li>调用对象 hashCode<ul>
<li>偏向锁的对象MarkWord中存储的时线程id，如果调用 hashCode 会导致偏向锁被 撤销<ul>
<li>轻量级锁会在锁记录中记录 hashCode </li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
</li>
</ul>
</li>
<li>其它线程使用锁对象<ul>
<li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li>
</ul>
</li>
<li>调用wait/notify</li>
</ul>
<p><strong>批量重偏向</strong></p>
<p>锁对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID </p>
<p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p>
<p><strong>批量撤销</strong></p>
<p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>如果加锁对象实在局部变量且没有逃逸出去，JIT编译器就会对字节码优化，同步消除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    synchroniezd(o)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p><strong>基本API</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>object.wait()</strong></td>
<td>让进入 object 监视器的线程到 waitSet 等待 ,无限制等待</td>
</tr>
<tr>
<td><strong>object.wait(long n)</strong></td>
<td>让进入 object 监视器的线程到 waitSet 等待 ,有时间限制</td>
</tr>
<tr>
<td><strong>object.notify()</strong></td>
<td>在 object 上正在 waitSet 等待的线程中挑一个唤醒</td>
</tr>
<tr>
<td><strong>object.notifyAll()</strong></td>
<td>让 object 上正在 waitSet 等待的线程全部唤醒</td>
</tr>
</tbody></table>
<p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p>
<h3 id="wait-amp-notify原理"><a href="#wait-amp-notify原理" class="headerlink" title="wait&amp;notify原理"></a>wait&amp;notify原理</h3><p><a href="https://imgtu.com/i/IXuAsA"><img src="https://z3.ax1x.com/2021/11/21/IXuAsA.png" alt="IXuAsA.png"></a></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
</ul>
<h3 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h3><p>创建 GuardedObject类，用在一个线程等待另一个线程的执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保护的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 不满足条件，等待 （while防止虚假唤醒）</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带超时版的get获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">long</span> passTime = <span class="number">0</span>;  <span class="comment">// 等待时间</span></span><br><span class="line">        <span class="comment">// 不满足条件，等待 （while防止虚假唤醒）</span></span><br><span class="line">        <span class="keyword">while</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 还需等待</span></span><br><span class="line">            <span class="keyword">long</span> waitTime = timeout - passTime;</span><br><span class="line">            <span class="comment">// 如果超时，就抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &gt;= waitTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;超时！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 带时效等待</span></span><br><span class="line">                lock.wait(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经等待的时间</span></span><br><span class="line">            passTime = System.currentTimeMillis() - begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>join原理</strong></p>
<p>join就是保护性暂停模式的体现，是调用者轮询检查线程 alive 状态</p>
<p>t1.join 等价于下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">        t1.wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h3><ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 </li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 </li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 </li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><a href="https://imgtu.com/i/IXlpmd"><img src="https://z3.ax1x.com/2021/11/21/IXlpmd.png" alt="IXlpmd.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 消息队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; queue;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 队列空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 队列空，等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T data = queue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒等待着的生产者</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 队列满，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 队列满，等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(data);</span><br><span class="line">            <span class="comment">// 唤醒等待着的消费者</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MessageQueue&lt;String&gt; queue = <span class="keyword">new</span> MessageQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 10个生产者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                queue.put(j + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个消费者</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String s = queue.get();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park&amp;Unpark"></a>Park&amp;Unpark</h2><p>它们是LockSupport类中的方法</p>
<table>
<thead>
<tr>
<th>基本使用</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>LockSupport.park()</td>
<td>暂停当前线程</td>
</tr>
<tr>
<td>LockSupport.unpark(Thread t)</td>
<td>恢复某个线程的运行</td>
</tr>
</tbody></table>
<ul>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex </p>
<p>_counter 为一个状态，取值 0 、1</p>
<p><strong>调用 park</strong></p>
<ul>
<li>如果_counter = 0<ul>
<li>获得 _mutex 互斥锁，</li>
<li>线程进入 _cond 条件变量阻塞 ，</li>
<li>设置 _counter = 0</li>
</ul>
</li>
<li>如果_counter = 1<ul>
<li>无需阻塞，继续运行</li>
<li>设置 _counter 为 0</li>
</ul>
</li>
</ul>
<p><strong>调用 unpark</strong></p>
<ul>
<li>如果线程正在 _cond阻塞<ul>
<li>设置 _counter 为 1，唤醒 _cond 条件变量中的 Thread-0</li>
<li>Thread_0 恢复运行</li>
<li>设置 _counter 为 0</li>
</ul>
</li>
<li>如果线程正常运行<ul>
<li>设置 _counter 为 1</li>
</ul>
</li>
</ul>
<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一个线程需要同时获取多把锁，这时就容易发生死锁, 如以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object A = <span class="keyword">new</span> Object();</span><br><span class="line">Object B = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="comment">// t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享的数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">0.2</span>);</span><br><span class="line">            count--;</span><br><span class="line">            Sysstem.out.println(<span class="string">&quot;count=&quot;</span>+ count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            sleep(<span class="number">0.2</span>);</span><br><span class="line">            count++;</span><br><span class="line">            Sysstem.out.println(<span class="string">&quot;count=&quot;</span>+ count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束, 一直处于阻塞状态</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized 它具备如下特点 </p>
<ul>
<li>可中断 </li>
<li>可以设置超时时间 </li>
<li>可以设置为公平锁 </li>
<li>支持多个条件变量</li>
</ul>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>ReentrantLock 和 synchronized，都支持可重入</p>
<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 </p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>调用<code>reentrantLock.lockInterruptibly()</code> 方法上锁，如果执行<code>interrupt</code>打断该线程，会抛出InterruptedException 异常</p>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>调用 <code>reentrantLock.tryLock()</code> 上锁，如果失败，会立刻返回false</p>
<p>调用 <code>reentrantLock.tryLock(long n,TimeUnit unit)</code> 上锁, 会在指定超时时间内返回加锁结果</p>
<p><strong>tryLock() 解决哲学家就餐问题</strong></p>
<ul>
<li>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 </li>
<li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 </li>
<li>如果筷子被身边的人拿着，自己就得等待</li>
</ul>
<p><a href="https://imgtu.com/i/IX6rdI"><img src="https://z3.ax1x.com/2021/11/21/IX6rdI.png" alt="IX6rdI.png" style="zoom:50%;" /></a></p>
<p>如果使用synchronized先对左筷子加锁，再对右筷子加锁，很快就会发生死锁。因为每个线程都抓着左手筷子不放，又获取不到右手筷子，一直处于阻塞状态。</p>
<p>使用 <code>reentrantLock.tryLock()</code> 获取锁，如果获取失败，就立马放弃本次操作，让其它线程获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筷子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哲学家类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Chopstick left; <span class="comment">// 左手筷子</span></span><br><span class="line">    <span class="keyword">private</span> Chopstick right; <span class="comment">// 右手筷子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123; <span class="comment">// 获取左筷子</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123; <span class="comment">// 获取右筷子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat(); <span class="comment">// 吃</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：eating。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就餐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">    <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">    <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">    <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">    <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 无参构造方法是不公平锁，可加一个boolean参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>)</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p><strong>不公平锁</strong>: 获得锁线程要释放锁时，这时刚好有新线程要来获取锁，直接争抢锁，新线程不会管 EntryList 中是否还有阻塞中的线程</p>
<p><strong>公平锁</strong>: 新线程会判断 EntryList  中是否还有阻塞线程，如果有，那么不会去抢锁，而是进入EntryList 中 阻塞 （具体细节在后面会介绍）</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized中也有条件变量，即wait &amp; notify ， 但是和容易虚假唤醒；</p>
<p>ReentrantLock  支持多个条件变量的 （await &amp; signal），可以指定某个条件进行唤醒。</p>
<p><strong>await&amp;signal要点</strong> （与wait&amp;notify原理相似）:</p>
<ul>
<li>await 前需要获得锁 </li>
<li>await 执行后，会释放锁，进入 conditionObject 等待 </li>
<li>await 的线程被唤醒（或打断、或超时）需重新竞争 lock 锁 </li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用reentrantLock改进之前synchronized的生产者消费者模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 消息队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; queue;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 队列满条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="comment">// 队列空条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 队列空，等待&quot;</span>);</span><br><span class="line">                    empty.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T data = queue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒等待着的生产者</span></span><br><span class="line">            full.signalAll();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 队列满，等待&quot;</span>);</span><br><span class="line">                    full.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(data);</span><br><span class="line">            <span class="comment">// 唤醒等待着的消费者</span></span><br><span class="line">            empty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><h4 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h4><p>两个线程，必须先输出 2，后输出1</p>
<ul>
<li>wait &amp;notify版本</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; 	  <span class="comment">// 标记2是否被输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>park&amp;unpark版本</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>线程 1 输出 a，线程 2 输出 b，线程 3 输出 c 。如果要求交替输出5次，即 abcabcabcabcabc</p>
<h5 id="wait-amp-notify版本"><a href="#wait-amp-notify版本" class="headerlink" title="wait&amp;notify版本"></a>wait&amp;notify版本</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环打印</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// 当前正在打印的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber; <span class="comment">// 循环打印次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str      打印的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currFlag 当前线程标记</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextFlag 下一个线程标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> currFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果不是自己，就等待</span></span><br><span class="line">                <span class="keyword">while</span> (flag != currFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印自己</span></span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="comment">// 更新当前可以打印标记</span></span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    WaitNotify wait = <span class="keyword">new</span> WaitNotify(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">4</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ReentrantLock条件变量版本"><a href="#ReentrantLock条件变量版本" class="headerlink" title="ReentrantLock条件变量版本"></a>ReentrantLock条件变量版本</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber; <span class="comment">// 循环打印次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str  打印的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curr 当前条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下一个条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition curr, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curr.await(); <span class="comment">//锁住当前条件</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str); <span class="comment">// 打印</span></span><br><span class="line">                next.signal();  <span class="comment">// 释放下一个条件</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AwaitSignal wait = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">    Condition a = wait.newCondition();</span><br><span class="line">    Condition b = wait.newCondition();</span><br><span class="line">    Condition c = wait.newCondition();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;a&quot;</span>, a, b)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;b&quot;</span>, b, c)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; wait.print(<span class="string">&quot;c&quot;</span>, c, d)).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始：&quot;</span>);</span><br><span class="line">    wait.lock(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">// 需要先手动释放第一个条件变量</span></span><br><span class="line">        a.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        wait.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="park-amp-unpark版本"><a href="#park-amp-unpark版本" class="headerlink" title="park&amp;unpark版本"></a>park&amp;unpark版本</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnPark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnPark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();  <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.print(str); <span class="comment">// 打印</span></span><br><span class="line">            LockSupport.unpark(next); <span class="comment">// 释放下一个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ParkUnPark parkUnPark = <span class="keyword">new</span> ParkUnPark(<span class="number">5</span>);</span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(() -&gt; &#123; parkUnPark.print(<span class="string">&quot;A&quot;</span>, t2); &#125;);</span><br><span class="line">    t2 = <span class="keyword">new</span> Thread(() -&gt; &#123; parkUnPark.print(<span class="string">&quot;B&quot;</span>, t3); &#125;);</span><br><span class="line">    t3 = <span class="keyword">new</span> Thread(() -&gt; &#123; parkUnPark.print(<span class="string">&quot;C&quot;</span>, t1); &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始。。&quot;</span>); </span><br><span class="line">    LockSupport.unpark(t1); <span class="comment">// 需要先手动释放第一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等</p>
<p>JMM 体现在下面几个方面:</p>
<ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受cpu缓存的影响</li>
<li>有序性：保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><p> 先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>产生原因</strong>:</p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><a href="https://imgtu.com/i/Ijnuyd"><img src="https://z3.ax1x.com/2021/11/21/Ijnuyd.png" alt="Ijnuyd.png" style="zoom: 67%;" /></a></p>
<ol start="2">
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率</li>
</ol>
<p><a href="https://imgtu.com/i/IjnQeI"><img src="https://z3.ax1x.com/2021/11/21/IjnQeI.png" alt="IjnQeI.png" style="zoom:77%;" /></a></p>
<ol start="3">
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值</li>
</ol>
<p><a href="https://imgtu.com/i/Ijnlwt"><img src="https://z3.ax1x.com/2021/11/21/Ijnlwt.png" alt="Ijnlwt.png" style="zoom:77%;" /></a></p>
<p><strong>解决方法</strong></p>
<p>使用 volatile（易变关键字）修饰 run</p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存</p>
<p>该例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可 见， 但是不能保证原子性。</p>
<h3 id="同步模式之Balking"><a href="#同步模式之Balking" class="headerlink" title="同步模式之Balking"></a>同步模式之Balking</h3><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否已有线程启动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> starting;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!starting) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!starting) &#123;</span><br><span class="line">                    starting = <span class="keyword">true</span>; <span class="comment">// 标记已启动监控线程</span></span><br><span class="line">                    <span class="comment">// 真正启动监控线程</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;启动监控线程。。。&quot;</span>);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            <span class="comment">//....</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;监控线程已启动&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;监控线程已启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序,如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i;</span><br><span class="line">static int j;</span><br><span class="line">&#x2F;&#x2F; 在某个线程内执行如下赋值操作</span><br><span class="line">i &#x3D; ...;</span><br><span class="line">j &#x3D; ...;</span><br></pre></td></tr></table></figure>
<p>至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响，所以代码真正执行时，也可能是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j &#x3D; ...;</span><br><span class="line">i &#x3D; ...;</span><br></pre></td></tr></table></figure>
<p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。</p>
<p><strong>解决方法</strong></p>
<p>volatile 修饰的变量，可以禁用指令重排</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p><strong>cpu缓存结构</strong></p>
<p>如果缓存中有数据，就会先去缓存读取。</p>
<p><a href="https://imgtu.com/i/IjfwuT"><img src="https://z3.ax1x.com/2021/11/21/IjfwuT.png" alt="IjfwuT.png" style="zoom: 67%;" /></a></p>
<table>
<thead>
<tr>
<th>从 cpu到</th>
<th>大约需要的时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1 cycle</td>
</tr>
<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>
<tr>
<td>L2</td>
<td>10~20 cycle</td>
</tr>
<tr>
<td>L3</td>
<td>40~45 cycle</td>
</tr>
<tr>
<td>内存</td>
<td>120~240 cycle</td>
</tr>
</tbody></table>
<p><strong>内存屏障 Memory Barrier (Memory Fence)</strong></p>
<ul>
<li>可见性 <ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 </li>
<li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据 </li>
</ul>
</li>
<li>有序性 <ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 </li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p>
<ul>
<li>对 volatile 变量的 <strong>写指令后会加入写屏障</strong> </li>
<li>对 volatile 变量的 <strong>读指令前会加入读屏障</strong></li>
</ul>
<h3 id="volatile保证可见性和有序性"><a href="#volatile保证可见性和有序性" class="headerlink" title="volatile保证可见性和有序性"></a>volatile保证可见性和有序性</h3><p><strong>写指令后加入写屏障</strong></p>
<ul>
<li>而写屏障回保证在该屏障之前的，对共享变量的改动，都同步到主存当中（可见性）</li>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 （有序性）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读指令前会加入读屏障</strong></p>
<ul>
<li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据 （可见性）</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前（有序性）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123; <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h3><p>以著名的 double-checked locking 单例模式为例,我们一般都是这样设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 私有化构造方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当多个线程首次访问需要加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检查</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;  <span class="comment">// 返回实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在多线程环境下还是有问题的。</p>
<p>将 创建单例对象 <code>INSTANCE = new Singleton();</code> 代码翻译成字节码为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17: new #3   			&#x2F;&#x2F; 创建对象到堆中，并入操作数栈中</span><br><span class="line">20: dup					&#x2F;&#x2F; 复制一份引用到操作数栈中</span><br><span class="line">21: invokespecial #4 	&#x2F;&#x2F; 调用对象的构造方法，经行初始化，消耗栈顶一个元素</span><br><span class="line">24: putstatic #2 		&#x2F;&#x2F; 再消耗一个栈顶元素，赋值给静态字段 INSTANCE</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM也许会优化为 ：先执行 24，再执行21。</li>
<li>如果t1线程执行了24指令，t2线程刚好进来了，判断 INSTANCE不为null，就直接获取了 INSTANCE</li>
<li>而此时t1还没执行 21行指令，说明 t2获取的INSTANCE 是一个未初 始化完毕的单例</li>
</ul>
<p><strong>解决</strong></p>
<p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<h3 id="单例模式饿汉式的另一种实现"><a href="#单例模式饿汉式的另一种实现" class="headerlink" title="单例模式饿汉式的另一种实现"></a>单例模式饿汉式的另一种实现</h3><p>采用内部类的方式：当类被使用到时，才会被类加载器所加载，并创建单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//  单例对象为内部类的一个静态成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">// 从内部类中获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结。</p>
<ol>
<li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li>
<li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li>
<li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）</li>
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
</ol>
<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>以下这段代码，在多线程不加锁的情况下，也可以正常执行，因为共享变量是一个原子整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 count - 10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = count.get();  <span class="comment">// 拿到旧值</span></span><br><span class="line">        <span class="keyword">int</span> next = prev - <span class="number">10</span>;	 <span class="comment">// 计算出新值</span></span><br><span class="line">        <span class="comment">// 如果成功就退出</span></span><br><span class="line">        <span class="keyword">if</span> (count.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的关键是 <strong>compareAndSet</strong>，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<p><strong>为什么无锁效率高</strong></p>
<ol>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇；而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换，反而会影响效率。</li>
</ol>
<p><strong>CAS与synchronized</strong></p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，继续重试</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。</li>
</ul>
<p>所以结合CAS和volatile可以实现无锁并发，适用与线程数少，多核CPU的场景下。</p>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C 并发包提供了  AtomicInteger 、AtomicBoolean、AtomicLong 原子类</p>
<p>以AtomicInteger为例：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>get()</td>
<td>直接获取</td>
</tr>
<tr>
<td>set(int value)</td>
<td>直接修改</td>
</tr>
<tr>
<td>getAndIncrement()</td>
<td>获取并自增</td>
</tr>
<tr>
<td>incrementAndSet()</td>
<td>自增并获取</td>
</tr>
<tr>
<td>decrementAndGet()</td>
<td>自减并获取</td>
</tr>
<tr>
<td>getAndDecrement()</td>
<td>获取并自减</td>
</tr>
<tr>
<td>getAndAdd(int i)</td>
<td>获取并加值</td>
</tr>
<tr>
<td>addAndGet(int i)</td>
<td>加值并获取</td>
</tr>
<tr>
<td>getAndUpdate(p-&gt;p+2)</td>
<td>获取并修改，传递一个lambda</td>
</tr>
<tr>
<td>updateAndGet(p-&gt;p+2)</td>
<td>修改并获取，传递一个lambda</td>
</tr>
<tr>
<td>compareAndSet(int oldValue,int newValue)</td>
<td>如果旧值一致就修改，并返回true，否则false</td>
</tr>
</tbody></table>
<p><strong>使用AtomicInteger创建一个cas锁（不要用于实践）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CasLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0表示没上锁，1表示已经上锁</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 获取锁，如果获取失败，会一直重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果上锁成功，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原则引用"><a href="#原则引用" class="headerlink" title="原则引用"></a>原则引用</h2><p>三种原子引用：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>如果一个对象，我们需要保证它的原子性，可以通过创建原子引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建原子引用，包装一个String类型</span></span><br><span class="line"><span class="keyword">private</span> AtomicReference&lt;String&gt; val = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原子引用中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String prev = val.get();</span><br><span class="line">        String next = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        <span class="comment">// 如果成功就退出</span></span><br><span class="line">        <span class="keyword">if</span> (val.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p><strong>ABA问题</strong></p>
<p>上面的例子中，调用<code>compareAndSet(prev, next)</code>方法，只是判断<strong>旧值如果相等就修改</strong>，如果在执行该操作之前，有一个线程把 A 修改成B，又有一个线程把B修改成A ，<code>compareAndSet(prev, next)</code>操作依旧会成功。</p>
<p>如果要有其它线程【动过了】共享变量，不管最终旧值是否相等，都应该cas失败，这时比较值是不够的，还需要加上一个版本号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：值  参数二：版本号</span></span><br><span class="line"><span class="keyword">private</span> AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String val = reference.getReference(); <span class="comment">// 旧值</span></span><br><span class="line">        <span class="keyword">int</span> stamp = reference.getStamp();      <span class="comment">// 版本号</span></span><br><span class="line">        <span class="comment">// 需要传递旧新版本号</span></span><br><span class="line">        <span class="keyword">if</span> (reference.compareAndSet(val, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference给原子引用加上版本号，我们可以知道变量在中途被更改了几次。</p>
<p>但有时我们并不关心变量更改了几次，只单纯的关心<strong>是否更改过</strong>，可以使用AtomicMarkableReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用boolean类型标记是否修改过</span></span><br><span class="line">AtomicMarkableReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="string">&quot;A&quot;</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="原则数组"><a href="#原则数组" class="headerlink" title="原则数组"></a>原则数组</h2><ul>
<li>AtomicIntegerArray : 整数型</li>
<li>AtomicLongArray ： 长整数型</li>
<li>AtomicReferenceArray：引用型</li>
</ul>
<p>需求：创建一个长度为10的数组，创建10个线程，每个线程循环给数组添加1000次,输出最后结果</p>
<ul>
<li>如果使用正常的数组，需要加锁才能实现，如果使用原子数组则不需要加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子数组</span></span><br><span class="line">    AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 启动10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程给数组每个位置处添加100</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// i%10 位置处自增</span></span><br><span class="line">                array.incrementAndGet(i % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 睡眠一下，等待结果</span></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length(); i++) &#123;</span><br><span class="line">        System.out.print(array.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000	1000	1000	1000	1000	1000	1000	1000	1000	1000</span><br></pre></td></tr></table></figure>
<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater   引用型</li>
<li>AtomicIntegerFieldUpdater      整数型</li>
<li>AtomicLongFieldUpdater       长整数型</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，<b style="color:red">只能配合 volatile 修饰的字段使用</b>，否则会出现 异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Must be volatile type</span><br></pre></td></tr></table></figure>
<p>以 AtomicIntegerFieldUpdater为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建字段更新器</span></span><br><span class="line">        AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(Test.class,<span class="string">&quot;val&quot;</span>);</span><br><span class="line">       	<span class="comment">// 创建对象</span></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(updater.compareAndSet(test, <span class="number">0</span>, <span class="number">20</span>)); <span class="comment">// 失败</span></span><br><span class="line">        System.out.println(updater.compareAndSet(test, <span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>AtomicInteger与AtomicLong都有自增的方法，且都是原子操作，但是经行累加是效率不行。</p>
<p>如果只是进行累加操作，可以使用<strong>原子累加器 LongAdder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LongAdder adder = <span class="keyword">new</span> LongAdder(); <span class="comment">// 创建原子累加器</span></span><br><span class="line">adder.increment(); <span class="comment">// 累加</span></span><br><span class="line">System.out.println(adder.longValue()); <span class="comment">// 获取并输出结果</span></span><br></pre></td></tr></table></figure>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p>
<h3 id="获取Unsafe对象"><a href="#获取Unsafe对象" class="headerlink" title="获取Unsafe对象"></a>获取Unsafe对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unsafe对象获取器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>); <span class="comment">// 运行访问</span></span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>); <span class="comment">// 获取,因为是静态成员，所以传递一个null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Unsafe中的CAS操作"><a href="#使用Unsafe中的CAS操作" class="headerlink" title="使用Unsafe中的CAS操作"></a>使用Unsafe中的CAS操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Unsafe unsafe = UnsafeAccessor.getUnsafe(); <span class="comment">// 获取unsafe对象</span></span><br><span class="line">    <span class="comment">// 获取Student的属性</span></span><br><span class="line">    Field name = Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    Field age = Student.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(name);</span><br><span class="line">    <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(age);</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">&quot;怪狗狗&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用cas修改属性 , 修改成功返回true</span></span><br><span class="line">    unsafe.compareAndSwapObject(student, nameOffset, <span class="string">&quot;怪狗狗&quot;</span>, <span class="string">&quot;oddDog&quot;</span>);</span><br><span class="line">    unsafe.compareAndSwapInt(student, ageOffset, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;oddDog&#39;, age&#x3D;2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义一个原子整数"><a href="#自定义一个原子整数" class="headerlink" title="自定义一个原子整数"></a>自定义一个原子整数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> dataOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 MyAtomicInteger 对象中的偏移量，用于 Unsafe 直接访问该属性</span></span><br><span class="line">            dataOffset = unsafe.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  添加值--原子操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = data; <span class="comment">// 获取旧值</span></span><br><span class="line">            <span class="comment">// cas修改值，如果成功，返回</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, dataOffset, old, old + value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>问题</strong></p>
<p>日期格式转换类<code>SimpleDateFormat</code>在多线程环境下格式转换是线程不安全的，有很大的几率会出现 java.lang.NumberFormatException 异常</p>
<p><strong>解决一：同步锁</strong></p>
<p>线程调用 SimpleDateFormat 日期转换时，上锁，转换完后解锁</p>
<p>这样虽然能解决问题，但是会带来性能上的损失</p>
<p><strong>解决二：不可变</strong></p>
<p>如果一个对象不能修改其内部属性，那它就算是线程安全的，因为不存在并发。</p>
<p>java8 提供了新的日期格式转换类<code>DateTimeFormatter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">LocalDate date = dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>
<h2 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h2><p>就拿<code>String </code>来说，它就是一个不可变类，其内部所有属性都是 <code>fianl</code> 修饰的</p>
<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改 </li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<p><strong>保护性拷贝 （defensive copy）</strong></p>
<p>在使用 String中的 substring 等方法，会返回一个新的结果。其内部并没有对 byte[] 修改，而是创建了一个新的 byte[] ，并返回。</p>
<p><strong>无状态</strong> </p>
<p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的 </p>
<p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>
<h2 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式(Flyweight Pattern)"></a>享元模式(Flyweight Pattern)</h2><p>也叫蝇量模式:   运用共享技术有效地支持大量细粒度的对象</p>
<h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><p><strong>1.String常量池</strong></p>
<p><strong>2.包装类</strong></p>
<p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 <strong>-128~127</strong> 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象：</p>
<ul>
<li><p>Byte, Short, Long 缓存的范围都是 -128~127 </p>
</li>
<li><p>Character 缓存的范围是 0~127 </p>
</li>
<li><p>Integer的默认范围是 -128~127 ( 最大值可以通过调整虚拟机参数 <code> -Djava.lang.Integer.IntegerCache.high</code> 来改变)</p>
</li>
<li><p>Boolean 缓存了 TRUE 和 FALSE</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Long.valueOf() 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">extends</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockConnection</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 连接池状态， 0表示空闲，1表示正在使用中</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[capacity];</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[capacity]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果发现空闲连接</span></span><br><span class="line">                <span class="keyword">if</span> (status.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果获取成功,就返回该连接</span></span><br><span class="line">                    <span class="keyword">if</span> (status.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环了一遍，还没获取连接，就阻塞</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == con) &#123;</span><br><span class="line">                status.set(i, <span class="number">0</span>); <span class="comment">// 修改为空闲状态</span></span><br><span class="line">                <span class="comment">// 唤醒阻塞线程</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>需要实现一个任务队列类和一个线程池类，线程池放不下的任务就交给任务队列中，当线程池空闲时，从任务队列中获取任务。</p>
<p><a href="https://imgtu.com/i/oFUwnS"><img src="https://z3.ax1x.com/2021/11/25/oFUwnS.png" alt="oFUwnS.png"></a></p>
<ol>
<li>自定义拒绝策略接口（lambda）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义任务队列</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 队列满条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullCondition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 队列空条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列空，空条件阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队列头弹出一个任务</span></span><br><span class="line">            T task = queue.removeFirst();</span><br><span class="line">            fullCondition.signal(); <span class="comment">// 唤醒一个满条件等待的线程</span></span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 时间格式转换成纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 队列空，阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果超时，就返回空</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 超时等待,awaitNanos返回的是还需等待多少时间</span></span><br><span class="line">                    nanos = emptyCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队列头弹出一个任务</span></span><br><span class="line">            T task = queue.removeFirst();</span><br><span class="line">            fullCondition.signal(); <span class="comment">// 唤醒一个满条件等待的线程</span></span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满，满条件阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务添加到队列尾中</span></span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signal();<span class="comment">// 唤醒一个空条件等待的线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 时间格式转换成纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 队列满，满条件阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果超时，返回 false</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullCondition.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务添加到队列尾中</span></span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyCondition.signal();<span class="comment">// 唤醒一个空条件等待的线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次尝试将任务放入阻塞队列,如果失败，就使用policy中的策略来解决</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; policy, T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="comment">// 使用policy中的策略来解决</span></span><br><span class="line">                <span class="keyword">if</span> (policy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    policy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.addLast(task); <span class="comment">// 队列不满，直接放入队列</span></span><br><span class="line">                emptyCondition.signal();<span class="comment">// 唤醒一个空条件等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自定义线程池</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Work&gt; works = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; queue;</span><br><span class="line">    <span class="comment">// 超时时间, Work线程从队列中获取任务的等待时间,如果超过该时间,线程会自动消销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">// 时间格式</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit;</span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; policy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">int</span> queueCapacity, <span class="keyword">long</span> timeout, TimeUnit unit, RejectPolicy&lt;Runnable&gt; policy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.unit = unit;</span><br><span class="line">        <span class="keyword">this</span>.policy = policy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果线程数量小于容量，就创建新的Work线程去执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (works.size() &lt; coreSize) &#123;</span><br><span class="line">                Work work = <span class="keyword">new</span> Work(task);</span><br><span class="line">                works.add(work); <span class="comment">// 加入集合中</span></span><br><span class="line">                work.start();<span class="comment">// 执行任务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务放入队列中阻塞（使用拒绝策略方式）</span></span><br><span class="line">                queue.tryPut(policy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义线程类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="comment">// while (task != null || (task = queue.take()) != null) &#123; // 死等，如果长时间没获取到任务，就一直阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = queue.take(timeout, unit)) != <span class="keyword">null</span>) &#123; <span class="comment">// 获取任务超时等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出循环表示，该work线程长时间没获取到任务，以致超时，线程会自动消销毁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                works.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>测试 (可自行添加打印信息与sleep测试)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                         (queue, task) -&gt; &#123;</span><br><span class="line">                             <span class="comment">// 1) 死等</span></span><br><span class="line">                             <span class="comment">// queue.take();</span></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                             queue.take(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                             <span class="comment">// 啥也不做</span></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                             <span class="comment">//  throw new RuntimeException(&quot;超时！&quot;);</span></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                             <span class="comment">// task.run();</span></span><br><span class="line">                         &#125;</span><br><span class="line">     );</span><br><span class="line">    <span class="comment">// 添加10个任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        pool.executor(() -&gt; &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><a href="https://imgtu.com/i/oF48E9"><img src="https://z3.ax1x.com/2021/11/25/oF48E9.png" alt="oF48E9.png" style="zoom:67%;" /></a></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高 3位</th>
<th>接收新任务</th>
<th>处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,      // 核心线程数目</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,	 // 最大线程数目</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,	 // 急救线程的生存时间</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,		 // 时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,	   // 线程工厂-- 可以为线程创建时起个好名字</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler   // 拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>工作方式</strong></p>
<ul>
<li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务</p>
</li>
<li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程</p>
</li>
<li><p>如果队列选择了有界队列，当任务超过了队列大小时，会创建 ( maximumPoolSize - corePoolSize) 数目的急救线程来救急</p>
</li>
<li><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略 handler。</p>
</li>
<li><p>当高峰过去后，救急线程如果一段时间没有任务做，释放该线程，这个时间由 keepAliveTime 和 unit 来控制。</p>
</li>
</ul>
<p><strong>jdk提供了4种拒绝策略的实现</strong></p>
<p><a href="https://imgtu.com/i/oFohDO"><img src="https://z3.ax1x.com/2021/11/25/oFohDO.png" alt="oFohDO.png"></a></p>
<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略。</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h3 id="Executor工具类"><a href="#Executor工具类" class="headerlink" title="Executor工具类"></a>Executor工具类</h3><p>根据ThreadPoolExecutor类的构造方法，Executor工具类提供了众多工厂方法来创建 各种用途的线程池。</p>
<p><strong>newFixedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：没有急救线程（核心线程数 == 最大线程数），且阻塞队列是无界的</li>
<li>适用于任务量已知，相对耗时的任务</li>
</ul>
<p><strong>newCachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点: <ul>
<li>全部都是急救线程（60s后回收），且可以无限创建</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）</li>
</ul>
</li>
<li> 适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
<p><strong>newSingleThreadExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：核心线程只有一个，且没有急救线程，其他任务会放入无界队列中排队。</li>
<li>该线程池与自己创建一个线程的区别:<ul>
<li>自己创建的一个线程如果执行失败会终止，而线程池还会创建一个线程，保证池的正常工作</li>
<li>该线程池初始化时为1，以后还可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池是否处于 RUNNING 状态</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p><strong>任务调度线程池</strong>，只有一个实现类，即 ScheduledThreadPoolExecutor。</p>
<p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能 ,但是Timer是单线程的，前一个任务的延迟会影响到之后的任务。而『任务调度线程池』是多线程的，每个任务都是独立的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    pool.schedule(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务&quot;</span> + j + <span class="string">&quot;，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他方法的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3秒后，每隔一秒执行一次</span></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Thread.sleep(2000); // 加了该代码就是每隔2秒执行一次(时间被撑大了)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;任务&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">pool.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Thread.sleep(2000); // 加了该代码就是每隔3秒执行一次(任务完成后再开始计时)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;任务&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p><strong>定时任务</strong></p>
<p>需求：让每周四 18:00:00 定时执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 获取本周四时间</span></span><br><span class="line">    LocalDateTime time = now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果已经过了本周周四，就获取下一周的周四</span></span><br><span class="line">    <span class="keyword">if</span> (now.compareTo(time) &gt;= <span class="number">0</span>)  time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算出时间差，即延时执行时间</span></span><br><span class="line">    <span class="keyword">long</span> init = Duration.between(now, time).toMillis();</span><br><span class="line">    <span class="comment">// 间隔时间，(一周的毫秒值)</span></span><br><span class="line">    <span class="keyword">long</span> oneWeek = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建任务调度线程池，并执行定时任务</span></span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务..&quot;</span>);</span><br><span class="line">    &#125;,init,oneWeek,TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><ul>
<li><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 </p>
</li>
<li><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解，把每个小任务交给不同的线程来完成</p>
</li>
<li><p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
</li>
<li><p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</p>
</li>
</ul>
<p>需求： 计算1~n 之间的整数之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Fork/Join线程池</span></span><br><span class="line">    ForkJoinPool forkJoin = <span class="keyword">new</span> ForkJoinPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    Integer res = forkJoin.invoke(<span class="keyword">new</span> addTask(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;结果：&quot;</span>+res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fork/Join任务类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">addTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">addTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 拆分成两个任务</span></span><br><span class="line">        addTask task1 = <span class="keyword">new</span> addTask(begin, mid);</span><br><span class="line">        addTask task2 = <span class="keyword">new</span> addTask(mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 调用两个线程去执行</span></span><br><span class="line">        task1.fork();</span><br><span class="line">        task2.fork();</span><br><span class="line">        <span class="comment">// 获取结果并返回</span></span><br><span class="line">        <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 </p>
<p><strong>特点</strong>： </p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 <ul>
<li>getState - 获取 state 状态 </li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 </li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p><strong>子类主要实现这样一些方法</strong>（默认抛出 UnsupportedOperationException） </p>
<ul>
<li>tryAcquire   获取锁</li>
<li>tryRelease   释放锁</li>
<li>tryAcquireShared  获取共享锁</li>
<li>tryReleaseShared  释放共享锁</li>
<li>isHeldExclusively  是否被其他线程获取到锁</li>
</ul>
<h3 id="自定义不可重入锁"><a href="#自定义不可重入锁" class="headerlink" title="自定义不可重入锁"></a>自定义不可重入锁</h3><p><strong>自定义同步器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义AQS同步器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 原子修改 state 状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义锁</strong></p>
<p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">	<span class="comment">// 尝试获取，不成功，进入阻塞队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试获取，不成功，进入阻塞队列，可打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只尝试一次，不成功直接返回false,不进入阻塞队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试获取，不成功进入阻塞队列，有超时时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 释放</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS的设计思想"><a href="#AQS的设计思想" class="headerlink" title="AQS的设计思想"></a>AQS的设计思想</h3><p><strong>AQS 要实现的功能目标</strong> </p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li>
<li>获取锁超时机制</li>
<li>通过打断取消机制 </li>
<li>独占机制及共享机制 </li>
<li>条件不满足时的等待机制</li>
</ul>
<p><strong>state设计</strong></p>
<ul>
<li>state 使用 volatile 配合 cas 保证其修改时的原子性 </li>
<li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li>
</ul>
<p><strong>阻塞恢复的设计</strong></p>
<ul>
<li>使用park&amp;unpark实现希纳是从的暂停与恢复</li>
<li>park&amp;unpark是针对线程的，而不是同步器，所以控制粒度更为精细</li>
<li>park线程还可以通过interrupt来打断</li>
</ul>
<p><strong>队列的设计</strong></p>
<ul>
<li>使用 FIFO 先入先出队列，并不支持优先级队列</li>
<li>并借鉴了 CLH 队列，它是一种单向无锁队列</li>
</ul>
<p><strong>CLH的入队与出队</strong></p>
<p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态</p>
<ul>
<li>入队伪代码，只需要考虑tail赋值的原子性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 原来的 tail</span></span><br><span class="line">    Node prev = tail;</span><br><span class="line">    <span class="comment">// 用 cas 在原来 tail 的基础上改为 node</span></span><br><span class="line">&#125; <span class="keyword">while</span>(tail.compareAndSet(prev, node))</span><br></pre></td></tr></table></figure>
<ul>
<li>出队伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prev 是上一个节点</span></span><br><span class="line"><span class="keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置头节点</span></span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure>
<p><strong>CLH的优点</strong></p>
<ul>
<li>无锁，使用自旋</li>
<li>快速，无阻塞</li>
</ul>
<p>AQS在一些方面改进了CLH</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 队列中还没有元素 tail 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 head 从 null -&gt; dummy</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 的 prev 设置为原来的 tail</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 将 tail 从原来的 tail 设置为 node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 原来 tail 的 next 设置为 node</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主要用到 AQS 的并发工具类</strong></p>
<p><a href="https://imgtu.com/i/oZz0AJ"><img src="https://z3.ax1x.com/2021/11/27/oZz0AJ.png" alt="oZz0AJ.png"></a></p>
<h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p><a href="https://imgtu.com/i/oeSmCR"><img src="https://z3.ax1x.com/2021/11/27/oeSmCR.png" alt="oeSmCR.png"></a></p>
<h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h4><p>没有竞争时</p>
<p><a href="https://imgtu.com/i/oeE92Q"><img src="https://z3.ax1x.com/2021/11/27/oeE92Q.png" alt="oeE92Q.png" style="zoom: 67%;" /></a></p>
<p>第一个竞争 Thread-1 出现时:</p>
<ol>
<li>Thread-1尝试CAS将state由0-&gt;1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
</ol>
<p><a href="https://imgtu.com/i/oeEiKs"><img src="https://z3.ax1x.com/2021/11/27/oeEiKs.png" alt="oeEiKs.png" style="zoom: 67%;" /></a></p>
<ol start="3">
<li>进入AddWaiter逻辑，构造Node队列<ul>
<li>图中黄色三角表示该 Node 的 waitStatus（0） 状态，默认状态</li>
<li>Node的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><a href="https://imgtu.com/i/oeEFrn"><img src="https://z3.ax1x.com/2021/11/27/oeEFrn.md.png" alt="oeEFrn.md.png" style="zoom: 80%;" /></a></p>
<ol start="4">
<li><p>将AddWaiter构造的Node返回，并执行 acquireQueued逻辑</p>
<ul>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁<ul>
<li>如果获取锁成功，将当前Node设置为Head，结束循环，返回中断标记 interrupt</li>
<li>如果获取失败，进入shouldParkAfterFailedAcquire逻辑</li>
</ul>
</li>
</ul>
</li>
<li><p>shouldParkAfterFailedAcquire表示，是否应当阻塞当前线程</p>
<ul>
<li>第一次进来，发现前一个节点不是 -1 状态（阻塞状态），会将前一个节点设置为-1，并返回false，再进行一次  acquireQueued  循环</li>
</ul>
<p><a href="https://imgtu.com/i/oeEkbq"><img src="https://z3.ax1x.com/2021/11/27/oeEkbq.png" alt="oeEkbq.png"></a></p>
<ul>
<li>如果acquireQueued  循环还是没获取倒锁，之后再次进来这里，发现前一个节点是 -1 状态，那当前线程也应当阻塞，返回true，并进入 parkAndCheckInterrupt逻辑，park阻塞当前线程（灰色表示）</li>
</ul>
</li>
</ol>
<p><a href="https://imgtu.com/i/oeEVaV"><img src="https://z3.ax1x.com/2021/11/27/oeEVaV.png" alt="oeEVaV.png"></a></p>
<p>再次有多个线程如果竞争失败，也会变成阻塞状态</p>
<p><a href="https://imgtu.com/i/oeEmPU"><img src="https://z3.ax1x.com/2021/11/27/oeEmPU.png" alt="oeEmPU.png"></a></p>
<h4 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// Node.SIGNAL为-1</span></span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);  <span class="comment">// 线程就是阻塞在此时</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();  <span class="comment">// 如果被打断，就会返回打断的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> ：是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定</p>
<h4 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h4><p>Thread-0释放锁，执行 release</p>
<ol>
<li><p>先进入tryRelease流程，进行解锁</p>
<ul>
<li>因为可重入锁，只会让 state -1 ，如果state-1 后还不为0，表示解锁失败，返回false</li>
<li>如果(state-1)==0 ，表示解锁成功，设置 exclusiveOwnerThread 为 null，返回true</li>
</ul>
</li>
<li><p>如果当前队列不为null，并且Head的状态为 -1，进入 unparkSuccessor 流程，找到离Head最近的一个Node, unpark恢复其运行, 如图中的 Thread-1 实例</p>
<p><a href="https://imgtu.com/i/oeGMb8"><img src="https://z3.ax1x.com/2021/11/27/oeGMb8.png" alt="oeGMb8.png"></a></p>
</li>
</ol>
<p>Thread-1 线程恢复了运行，就会回到 acquireQueued的流程中，继续执行循环</p>
<ul>
<li><p>如果Thread-1加锁成功</p>
<ul>
<li>ExclusiveOwnerThread = Thread-1, state = 1</li>
<li>当前Node成为Head，原先的Head成为null，从而被垃圾回收</li>
</ul>
<p><a href="https://imgtu.com/i/oeJhyq"><img src="https://z3.ax1x.com/2021/11/27/oeJhyq.md.png" alt="oeJhyq.md.png"></a></p>
</li>
<li><p>这时如果Thread-4线程来竞争（非公平的体现）,  Thread-1 获取所失败</p>
<ul>
<li>ExclusiveOwnerThread = Thread-1, state = 1</li>
<li>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入如 park阻塞</li>
</ul>
<p><a href="https://imgtu.com/i/oeJImV"><img src="https://z3.ax1x.com/2021/11/27/oeJImV.png" alt="oeJImV.png" style="zoom: 80%;" /></a></p>
</li>
</ul>
<h4 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unpark唤醒该线程</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>上面加锁源码中  <code>nonfairTryAcquire</code> 和 解锁中 <code>tryRelease</code> 体现了可重入原理</p>
<h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式</strong></p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);  <span class="comment">// 线程就是阻塞在此时</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();  <span class="comment">// 如果被打断，就会返回打断的状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 </span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>; <span class="comment">// 标记被打断</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可打断模式</strong></p>
<p>如果线程被打断，直接抛出 InterruptException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 不是直接去获取锁，而是先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            (</span><br><span class="line">            <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">            s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<p><strong>await流程</strong></p>
<p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p>
<p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><a href="https://imgtu.com/i/oehkOx"><img src="https://z3.ax1x.com/2021/11/27/oehkOx.png" alt="oehkOx.png"  /></a></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><a href="https://imgtu.com/i/oehEm6"><img src="https://z3.ax1x.com/2021/11/27/oehEm6.png" alt="oehEm6.png"></a></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><a href="https://imgtu.com/i/oehZTO"><img src="https://z3.ax1x.com/2021/11/27/oehZTO.png" alt="oehZTO.png"></a></p>
<p>park阻塞Thread-0</p>
<p><a href="https://imgtu.com/i/oehnte"><img src="https://z3.ax1x.com/2021/11/27/oehnte.png" alt="oehnte.png"></a></p>
<p><strong>signal流程</strong></p>
<p>假设 Thread-1 要来唤醒 Thread-0</p>
<p>进入 ConditionObject 的 doSignal 流程，取出等待队列中第一个 Node，即 Thread-0</p>
<p><a href="https://imgtu.com/i/oe4r2d"><img src="https://z3.ax1x.com/2021/11/27/oe4r2d.png" alt="oe4r2d.png" style="zoom:67%;" /></a></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p>
<p><a href="https://imgtu.com/i/oe4fIS"><img src="https://z3.ax1x.com/2021/11/27/oe4fIS.png" alt="oe4fIS.png" style="zoom: 80%;" /></a></p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用 读写锁 让 <code>读-读</code> 可以并发，提高性能。 </p>
<p>如下面代码，使用读锁保护类的 read() 方法，写锁保护类的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="comment">// 读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r.lock();  <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        w.lock();  <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试上面代码，可得知： <code>读-读</code>可并发， <code>读-写</code>、<code>写-写</code>相互阻塞</p>
<p><strong>其他要点</strong></p>
<ul>
<li>读锁不支持条件变量 </li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类是JDK8加入的，为了进一步优化读写性能，他的特点是使用读锁、写锁时都必须配合【戳】使用</p>
<ul>
<li>加解读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>
<ul>
<li>加解写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>乐观读</p>
<p>StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次<code>戳校验</code>如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123; <span class="comment">// 验证失败</span></span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：利用StampedLock，读锁保护类的 read() 方法，写锁保护类的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="keyword">private</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 乐观锁</span></span><br><span class="line">        <span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line">        <span class="comment">// 如果校验成功，直接返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验失败，锁升级--读锁</span></span><br><span class="line">        stamp = lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);  <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.writeLock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试上面代码，可以看到，<code>读-读</code>实际没有加锁</p>
<p><strong>其他要点</strong></p>
<ul>
<li>StampedLock 不支持条件变量 </li>
<li>StampedLock 不支持可重入</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限</p>
<p>semaphore构造方法传递的参数，其内部就是设置 state = 3</p>
<ul>
<li>来一个线程 : state-1，当state = 0时，表示没空位，其他线程再次进来就会进入队列阻塞</li>
<li>释放一个线程 : state+1，就会唤醒队列中的阻塞线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 semaphore对象，最多只能有3个线程同时访问共享资源</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release(); <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure>
<p><strong>应用</strong></p>
<p>使用 semaphore 实现简单连接池，对比『享元模式』下用wait&amp;notify的实现，性能和可读性显然更好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接池 -- semaphore模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 连接池状态， 0表示空闲，1表示正在使用中</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="comment">// 信号量，用来限制线程访问最大数量</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[capacity];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[capacity]);</span><br><span class="line">        <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;capacity;i++)&#123; <span class="comment">// 初始化线程池</span></span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();<span class="comment">// 获取许可，如果超过线程数量最大限制，就会再此处阻塞</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果原子性修改状态成功，就返回当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> connections[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 一般不会走到这一步</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == con) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。 </p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<p><strong>基本使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数为2</span></span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">latch.countDown(); <span class="comment">// 计数-1</span></span><br><span class="line">latch.await(); <span class="comment">// 阻塞状态，只有等计数为0时，才会唤醒</span></span><br></pre></td></tr></table></figure>
<p><strong>应用：模拟游戏加载画面</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">// 创建10个线程进行加载</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 从1加到100</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= <span class="number">100</span>; n++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">100</span>)); <span class="comment">// 随机休眠</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                str[j] = n + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown(); <span class="comment">// 加载完毕计数-1</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个线程进行打印</span></span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(str));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    printThread.start();</span><br><span class="line">    <span class="comment">// 主线程等待所有的加载线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        printThread.interrupt(); <span class="comment">// 打断打印线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n游戏开始！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p> 循环栅栏，用来进行线程协作，等待线程满足某个计数。</p>
<p>构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"><span class="comment">// 如果第一二个线程调用 `cb.await()`, 才会向下执行，否则阻塞</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时又将计数变成0，第三四个线程调用`cb.await()`才会继续执行 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h2><p><a href="https://imgtu.com/i/ouVWRK"><img src="https://z3.ax1x.com/2021/11/28/ouVWRK.png" alt="ouVWRK.png"></a></p>
<p>线程安全集合类可以分为三大类： </p>
<ol>
<li><p>遗留的线程安全集合如 Hashtable ， Vector </p>
</li>
<li><p>使用 Collections 装饰的线程安全集合，如： </p>
<ul>
<li>Collections.synchronizedCollection </li>
<li>Collections.synchronizedList </li>
<li>Collections.synchronizedMap </li>
<li>Collections.synchronizedSet </li>
<li>Collections.synchronizedNavigableMap </li>
<li>Collections.synchronizedNavigableSet </li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet </li>
</ul>
</li>
<li><p>java.util.concurrent.* （JUC）</p>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 </li>
<li>CopyOnWrite 之类容器修改开销相对较重 , 利用复制的方式</li>
<li>Concurrent 类型的容器<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>
<li>弱一致性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>在所有的并发容器中，BlockingQueue是最常⻅的⼀种。BlockingQueue是⼀个带阻塞功能的队列，当⼊队列 时，若队列已满，则阻塞调⽤者；当出队列时，若队列为空，则阻塞调⽤者。</p>
<p>在Concurrent包中，BlockingQueue是⼀个接⼝，有许多个不同的实现类，如图所示：</p>
<p><a href="https://imgtu.com/i/ousHJA"><img src="https://z3.ax1x.com/2021/11/28/ousHJA.png" alt="ousHJA.png"></a></p>
<p><strong>该接口的定义如下</strong>：</p>
<p>与 Queue接⼝是兼容的，同时在其基础上增加了阻塞功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是⼀个⽤数组实现的环形队列，在构造⽅法中，会要求传⼊数组的容量。</p>
<p><strong>核心数据结构</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">// 队列中元素个数</span></span><br><span class="line">    <span class="keyword">int</span> count;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核⼼为1个锁外加两个条件</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入队操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  <span class="comment">// 获取锁对象</span></span><br><span class="line">    lock.lockInterruptibly();  <span class="comment">// 可中断的lock</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满，阻塞非满条件（生产者）</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);  <span class="comment">// 元素入队列</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items; <span class="comment">// 获得数组对象</span></span><br><span class="line">    items[putIndex] = e;  <span class="comment">// e 元素加入数组中</span></span><br><span class="line">    <span class="comment">// 更新putIndex，如果到达了数组顶部，就更新 putIndex = 0（因为环形队列）</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>; </span><br><span class="line">    count++; <span class="comment">// 元素个数+1</span></span><br><span class="line">    notEmpty.signal();  <span class="comment">// 通知非空条件（消费者）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出队操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  <span class="comment">// 获取锁对象</span></span><br><span class="line">    lock.lockInterruptibly();  <span class="comment">// 可中断的lock</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)  <span class="comment">// 如果队列空，阻塞非空条件（消费者）</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();  <span class="comment">// 队列中取出元素</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;  <span class="comment">// 获得数组对象</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  	</span><br><span class="line">    E e = (E) items[takeIndex];   <span class="comment">// 从数组中取出一个元素</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;  <span class="comment">// 清空该位置，便于垃圾回收</span></span><br><span class="line">    <span class="comment">// 更新takeIndex,如果到达了数组顶部，就更新 putIndex = 0（因为环形队列）</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>; </span><br><span class="line">    count--; <span class="comment">// 元素个数-1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); <span class="comment">// 通知非满条件（生产者）</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LikedBlockingQueue"><a href="#LikedBlockingQueue" class="headerlink" title="LikedBlockingQueue"></a>LikedBlockingQueue</h3><p>LinkedBlockingQueue是⼀种基于单向链表的阻塞队列。因为队头和队尾是2个指针分开操作的，所以⽤了2把锁 + 2个条件，同时有1个AtomicInteger的原⼦变量记录count数。</p>
<p>在其构造⽅法中，也可以指定队列的总容量。如果不指定，默认为Integer.MAX_VALUE。</p>
<p><strong>核心数据结构：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 原⼦变量，队列中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 单向链表的头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 单向链表的尾部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两把锁，两个条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFUll = putLock.newCondition();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入队操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);		<span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;  <span class="comment">// 获取put锁</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;  <span class="comment">// 获取元素个数</span></span><br><span class="line">    putLock.lockInterruptibly();  <span class="comment">// 可中断的Lock</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;  <span class="comment">// 队列满，阻塞</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);  <span class="comment">// （二）入队</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)  <span class="comment">// 队列中至少还有一个位置，通知一个put线程</span></span><br><span class="line">            notFull.signal();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();   <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)	 		<span class="comment">// 元素入队前是空队列，通知一个take线程</span></span><br><span class="line">        signalNotEmpty(); <span class="comment">//(三)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （二）入队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    last = last.next = node;   <span class="comment">// 添加至队列尾，并将last指向新入队的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （三）唤醒一个take线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>出队操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;  <span class="comment">// 获取元素个数</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock; <span class="comment">// 获取take锁</span></span><br><span class="line">    takeLock.lockInterruptibly();  <span class="comment">// 可中断 Lock</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 队列空，阻塞</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();  	<span class="comment">// （二）一个元素出队</span></span><br><span class="line">        c = count.getAndDecrement(); </span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)			<span class="comment">// 队列至少还有一个元素，通知一个take线程</span></span><br><span class="line">            notEmpty.signal(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity) 	<span class="comment">// 元素出对前，队列容量满，通知一个put线程</span></span><br><span class="line">        signalNotFull(); <span class="comment">//（三）</span></span><br><span class="line">    <span class="keyword">return</span> x;	<span class="comment">// 返回的出队元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (二)出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (三)唤醒一个put线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedBlockingQueue和ArrayBlockingQueue的差异</strong>： </p>
<ol>
<li>LinkedBlockingQueue⽤2把锁，分别控制队头、队尾的操作，<code>put(...)</code>和<code>take()</code>之间并不互斥,可以同时进行。但对于count变量，双⽅都需要操作，所以必须是原⼦类 型。 </li>
<li>因为各⾃拿了⼀把锁，所以当需要调⽤对⽅的condition的signal时，还必须再加上对⽅的锁，就是 signalNotEmpty()和signalNotFull()⽅法。</li>
<li>不仅put会通知 take，take 也会通知 put。当put 发现⾮满的时候，也会通知其他 put线程；当take发现 ⾮空的时候，也会通知其他take线程。</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>队列通常是先进先出的，⽽PriorityQueue是按照元素的优先级从⼩到⼤出队列的。正因为如此， PriorityQueue中的2个元素之间需要可以⽐较⼤⼩，并实现Comparable接⼝。</p>
<p>其构造⽅法，如果不指定初始大小，内部会设定⼀个默认值11，当元素个数超过这个⼤⼩之后，会⾃动扩容，所以没有非满条件。</p>
<p><strong>内部核心数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ⽤数组实现的⼆插⼩根堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 数组大小</span></span><br><span class="line">	<span class="comment">// 比较器，如果构造器传递过来，就通过对象自身做比较</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 1个锁+⼀个条件，没有⾮满条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue即延迟队列，也就是⼀个按延迟时间从⼩到⼤出队的PriorityQueue。所谓延迟时间，就是“未来 将要执⾏的时间”减去“当前时间”。为此，放⼊DelayQueue中的元素，必须实现Delayed接⼝。</p>
<p><strong>Delayed接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果getDelay的返回值⼩于或等于0，则说明该元素到期，需要从队列中拿出来执⾏。 </li>
<li>该接⼝⾸先继承了 Comparable 接⼝，所以要实现该接⼝，必须实现 Comparable 接⼝。具体来说，就 是基于getDelay()的返回值⽐较两个元素的⼤⼩。</li>
</ul>
<p><strong>内部核心数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ⼀把锁和⼀个⾮空条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    <span class="comment">// 优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take() 获取元素，如果堆顶元素的延迟还没到：</p>
<ul>
<li>没有其他take线程在等待堆顶元素，当前take线程会处于有时限的阻塞状态，直到堆顶元素的延迟到期；</li>
<li>如果有其他take线程正在等待堆顶元素，当前take线程会处于永久的阻塞状态。 （具体细节请看源码，不难）</li>
</ul>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是⼀种特殊的BlockingQueue，它本身没有容量。</p>
<p>先调put(…)，线程会阻塞；直到另外⼀ 个线程调⽤了take()，两个线程才同时解锁，反之亦然 。对于多个线程⽽⾔，例如3个线程，调⽤3次put(…)，3个线 程都会阻塞；直到另外的线程调⽤3次take()，6个线程才同时解锁，反之亦然。</p>
<p><strong>有参构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平与非公平模式，无参构造方式是非公平模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>put/take</code> 都调⽤了<code>transfer(...)</code>抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一（e）： take调用时，e为null，表示取元素；put调用时，e不为null，表示放元素</span></span><br><span class="line"><span class="comment">// 参数二、参数三是设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>TransferQueue类</code>（公平）和<code>TransferStack类</code>（非公平）分别实现了 <code>transfer()</code> 接⼝</p>
<ul>
<li>TransferQueue 内部使用的是队列，先进先出，如果3个线程执行<code>put(..)</code> , 这3 个线程处于阻塞状态，这时如果一个线程执行<code>take()</code> ,它会选择第一个调用 <code>put()</code>的线程，即公平。</li>
<li>TransferStack 内部使用的是栈，后进先出，如果3个线程执行<code>put(..)</code> , 这3 个线程处于阻塞状态，这时如果一个线程执行<code>take()</code> ,它会选择最后一个调用 <code>put()</code>的线程，即非公平。</li>
</ul>
<h2 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h2><p>BlockingDeque（Blocking Double end Queue）定义了⼀个阻塞的双端队列接⼝，该接⼝继承了BlockingQueue接⼝，同时增加了对应的双端队列操作接⼝。其接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 头部放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;	<span class="comment">// 尾部放</span></span><br><span class="line">    <span class="function">E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;	<span class="comment">// 头部取</span></span><br><span class="line">    <span class="function">E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;	<span class="comment">// 尾部取</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接⼝只有⼀个实现，就是 <strong>LinkedBlockingDeque</strong>，其核⼼数据结构是⼀个双向链表，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双向链表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 队列头</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;	 <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count; <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line">    <span class="comment">// ⼀把锁+两个条件</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.netCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的实现原理，和 LinkedBlockingQueue 基本⼀样，只是LinkedBlockingQueue是单向链表，⽽ LinkedBlockingDeque是双向链表。</p>
<p>（具体细节请看源码，easy）</p>
<h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><p>CopyOnWrite指在“写”的时候，不是直接“写”源数据，⽽是把数据拷⻉⼀份进⾏修改，再通过悲观锁或者乐观 锁的⽅式写回。 </p>
<p>那为什么不直接修改，⽽是要拷⻉⼀份修改呢？  这是为了在“读”的时候不加锁。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>和ArrayList⼀样，CopyOnWriteArrayList 的核⼼数据结构也是⼀个数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,</span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList 的 “读” 方法中，如 getArray()、get(int index)、isEmpty()等，都没有加锁，那是因为 在 “写” 方法中是利用复制的思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 尾部添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 同步锁对象</span></span><br><span class="line">            Object[] es = getArray(); <span class="comment">// 获得数组对象</span></span><br><span class="line">            <span class="keyword">int</span> len = es.length; <span class="comment">// 获取数组长度</span></span><br><span class="line">            es = Arrays.copyOf(es, len + <span class="number">1</span>); <span class="comment">// 拷贝，并且长度+1</span></span><br><span class="line">            es[len] = e;	<span class="comment">// 数组尾部放入元素</span></span><br><span class="line">            setArray(es);	<span class="comment">// 把新数组赋值给⽼数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标处添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 同步锁对象</span></span><br><span class="line">            Object[] es = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = es.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBounds(index, len));</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                newElements = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index); <span class="comment">// CopyOnWrite，写的时候，先拷⻉⼀份之前的数组。</span></span><br><span class="line">                System.arraycopy(es, index, newElements, index + <span class="number">1</span>, numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements); <span class="comment">// 把新数组赋值给⽼数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他“写”⽅法，和add() 类似，此处不再详述。</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>CopyOnWriteArraySet 就是⽤ Array 实现的⼀个 Set，保证所有元素都不重复。其内部是封装的⼀个 CopyOnWriteArrayList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新封装的CopyOnWriteArrayList</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 不重复的加进去,添加前会先判断是否有同样的数据，如果有，就直接返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.addIfAbsent(e); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 </p>
<ul>
<li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 </li>
<li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争 </li>
<li>只是 ConcurrentLinkedQueue 使用了 cas 来实现，又类似于ASQ内部的阻塞队列</li>
</ul>
<p>它是⼀个单向链表，其内部结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head; <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail; <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头尾节点默认为 null</span></span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(Objects.requireNonNull(e));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对tail的next指针执行CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (NEXT.compareAndSet(p, <span class="keyword">null</span>, newNode)) &#123; </span><br><span class="line">                <span class="comment">// 每加入两次节点，才会移动tail指针</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) </span><br><span class="line">                    TAIL.weakCompareAndSet(<span class="keyword">this</span>, t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 已经到达队列尾部</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 后移p指针</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程1要⼊队item2节点：</p>
<ul>
<li>step1:p=tail,q=p.next=NULL. </li>
<li>step2：对p的next执⾏CAS操作，追加item2，成功之后，p=tail。所以上⾯的casTail⽅法不会执⾏，直接返 回。此时tail指针没有变化。</li>
</ul>
<p><a href="https://imgtu.com/i/oMUuWV"><img src="https://z3.ax1x.com/2021/11/29/oMUuWV.png" alt="oMUuWV.png"></a></p>
<p>假设线程2要⼊队item3节点：</p>
<ul>
<li>step3:p=tail,q=p.next. </li>
<li>step4：q！=NULL，因此不会⼊队新节点。p，q都后移1位。</li>
<li>step5：q=NULL，对p的next执⾏CAS操作，⼊队item3节点。 </li>
<li>step6：p！=t，满⾜条件，执⾏上⾯的casTail操作，tail后移2个位置，到达队列尾部</li>
</ul>
<p><a href="https://imgtu.com/i/oMUtF1"><img src="https://z3.ax1x.com/2021/11/29/oMUtF1.png" alt="oMUtF1.png"></a></p>
<p>出队列的代码和⼊队列类似，也有p、q两个指针，并且每取出两个节点，head节点才会后移。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>该容器类似于HashMap，支持并发场景下的使用</p>
<p><strong>重要属性和内部类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 节点，整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 超过一定数量后，node（节点）会变成treebin（红黑树）</span></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<p>在该方法中，只是计算了sizeCtl的值，而没有创建table，可见哈希表是懒惰初始化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：初始化大小；</span></span><br><span class="line"><span class="comment">// 参数二：加载因子</span></span><br><span class="line"><span class="comment">// 参数三: 并发级别，表示同时可以多少条线程访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// 初始容量不能小于并发级别</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ...</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算处key的哈希值，其中 spread() 能确保返回结果为正数</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 哈希表不为null &amp;&amp; 长度大于0 &amp;&amp; 链表中的第一个节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123; <span class="comment">//((n - 1) &amp; h) 是取模运算</span></span><br><span class="line">       	<span class="comment">// 如果头节点就是要查找的 key</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头节点hash为负数，表示该链表在扩容，或者是红黑树，调用find方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 正常遍历链表，比较equals,直到找到 key节点为止</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>put流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数三：是否不允许修改。true--如果key不存在，添加，如果存在，不做操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许有空的 key 或 value</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算处key的哈希值，其中 spread() 能确保返回结果为正数</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自旋插入结点，直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="comment">// 分支1：首次插入键值对时，需要初始化table —— 懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// (二)</span></span><br><span class="line">        <span class="comment">// 分支2：头节点为空，使用cas创建头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分支3：如果头节点的hash值为 MOVED(-1)，表示是ForwardingNode结点，说明此时table正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) </span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// 帮忙扩容，扩容完后, 进入下一轮循环</span></span><br><span class="line">        <span class="comment">// 该分支不懂啥意思。。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="comment">// 分支4：正式添加节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 链表头加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 在次确定链表头有没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表操作</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到相同的 kye </span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 更新value</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 已经是最后的节点了，尾部新增 Node</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加完节点的后续操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) <span class="comment">// 将修改的节点旧值返回</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (二) 初始化哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 自旋等待，直到初始化完毕</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// 没有修改sizeCtl成功的线程，会一直在此处自旋等待</span></span><br><span class="line">        <span class="comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次判断是否哈希表是否被初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建 table 操作</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc; <span class="comment">// 恢复 sizeCtl的值，表示初始化完毕</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>over。。。</p>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>并发编程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB</title>
    <url>/2022/01/19/mongoDB/</url>
    <content><![CDATA[<p>MongoDB是一个介于<code>关系数据库</code>和<code>非关系数据库</code>之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。<strong>他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型</strong>。<a id="more"></a></p>
<p><strong>应用场景</strong></p>
<ul>
<li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、 积分等直接以内嵌文档的形式存储，方便查询、更新 </li>
<li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过 程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次 查询就能将订单所有的变更读取出来。 </li>
<li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表 的朋友圈信息，通过地理位置索引实现附近的人、地点等功能 </li>
<li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息， 以及设备汇报的日志信息，并对这些信息进行多维度的分析 </li>
<li>视频直播，使用 MongoDB 存储用户信息、礼物信息等</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li> 弱一致性（最终一致），更能保证用户的访问速度</li>
<li>文档结构的存储方式，能够更便捷的获 取数据</li>
<li>内置GridFS，支持大容量的存储<ul>
<li>GridFS是一个出色的分布式文件系统，可以支持海量的数据存 储。 </li>
<li>内置了GridFS了MongoDB，能够满足对大数据集的快速范围查 询。</li>
</ul>
</li>
<li>内置Sharding</li>
<li>第三方支持丰富</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>事务支持不友好</li>
<li>占用空间过大<ul>
<li>空间的预分配：为避免形成过多的硬盘碎片，mongodb 每次空间不足时都会申请生成一大块的硬盘空间，而且申请 的量从64M、128M、256M那 样的指数递增，直到2G为单 个文件的最大体积。</li>
<li>删除记录不释放空间：这很容易理解，为避免记录删除 后的数据的大规模挪动，原记录空间不删除，只标记“已删 除”即可，以后还可以重复利用。</li>
<li>可以定期运行 <code>db.repairDatabase()</code>来整理记录，但这个 过程会比较缓慢</li>
</ul>
</li>
</ul>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><p>官网： <a href="http://www.mongodb.org/">www.mongodb.org</a>   , 这里下载的是 <code>mongodb-linux-x86_64-rhel70-4.2.18.tgz</code></p>
<ul>
<li>将压缩包上传到 linux 下的 /opt 目录，并解压</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-4.2.18.tgz</span><br></pre></td></tr></table></figure>
<ul>
<li>进入 mongoDB 目录中，创建配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim mongo.conf</span><br><span class="line">## 文件内容如下</span><br><span class="line">dbpath&#x3D;&#x2F;data&#x2F;mongo&#x2F;     # 数据库目录，默认&#x2F;data&#x2F;db</span><br><span class="line">port&#x3D;27017				# 监听的端口，默认27017</span><br><span class="line">bind_ip&#x3D;0.0.0.0			# 监听IP地址，默认全部可以访问</span><br><span class="line">fork&#x3D;true				# 是否已后台启动的方式登入</span><br><span class="line">logpath&#x3D;&#x2F;data&#x2F;mongo&#x2F;MongoDB.log	 # 日志路径</span><br><span class="line">logappend&#x3D;true			# 是否追加日志</span><br><span class="line">auth&#x3D;false				# 是否开启用户密码登入</span><br></pre></td></tr></table></figure>
<ul>
<li>创建数据库目录  <code>dbpath=/data/mongo/</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;mongo&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>启动，指定配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;mongod -f mongo.conf</span><br></pre></td></tr></table></figure>
<p><strong>进入mongo，可指定ip与端口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;mongo (--host&#x3D;主机IP --prot&#x3D;端口)</span><br></pre></td></tr></table></figure>
<p>(这里使用的GUI工具是 NoSQLBooster，可取官网自行下载)</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul>
<li>查看数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs;</span><br></pre></td></tr></table></figure>
<ul>
<li>切换数据库 (如果没有则新增，新数据库要插入了一个文档后才显示)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.dropDatabase();</span><br></pre></td></tr></table></figure>
<ul>
<li>创建集合 (相当于表)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;集合名&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>查看集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br><span class="line">show collections;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.集合名.drop();</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入一条数据，dept集合如果没有会自动创建（数据为json格式）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.dept.insert(</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="attr">&quot;did&quot;</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">&quot;dname&quot;</span>:<span class="string">&quot;开发部&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;loc&quot;</span>:<span class="string">&quot;A区1座&quot;</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var dataVar = &#123;</span><br><span class="line">     &quot;did&quot;:2,</span><br><span class="line">     &quot;dname&quot;:&quot;市场部&quot;,</span><br><span class="line">     &quot;loc&quot;:&quot;深圳&quot;,</span><br><span class="line">     &quot;count&quot;:20</span><br><span class="line">&#125;</span><br><span class="line">db.dept.insert(dataVar);</span><br></pre></td></tr></table></figure>
<p>插入多条数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">for(var i = 1; i&lt;100;i++)&#123;</span><br><span class="line"> db.dept.insert(&#123;&quot;did&quot;:i,&quot;dname&quot;:&quot;测试&quot;+i+&quot;部&quot;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MondoDB中的每一条数据都有 <code>_id</code>字段，该字段是由 <strong>时间戳+机器码+进程的pid+计数器</strong> 组成的,绝对不会重复</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>remove( ) 有两个可选项 </p>
<ul>
<li>满足条件的删除 </li>
<li>是否只删除一条，默认 false</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.dept.remove(&#123;</span><br><span class="line">     &quot;_id&quot; : ObjectId(&quot;6114d0d2430f6b4dcc876c41&quot;)</span><br><span class="line">&#125;,true);</span><br></pre></td></tr></table></figure>
<p>删除名称中含有 “测试”的数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.dept.remove(&#123;</span><br><span class="line">	&quot;dname&quot;: /测试/</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>清空集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.dept.remove(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>对于Mongo而言,最好的办法不是修 改,而是删掉,重新添加.</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>update(更新条件, 新对象数据, upsert , multi)</p>
<ul>
<li>upsert  : 数据没有时是否执行新增操作</li>
<li>multi : 是否匹配多个结果</li>
</ul>
<p>根据id执行简单的修改 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var newData=&#123;</span><br><span class="line">     &quot;id&quot;:1,</span><br><span class="line">     &quot;name&quot;:&quot;吕布&quot;,</span><br><span class="line">     &quot;age&quot;:29	</span><br><span class="line">&#125;</span><br><span class="line">db.dept.update(&#123;</span><br><span class="line"> 	&quot;_id&quot;: ObjectId(&quot;6114df1d430f6b4dcc876c42&quot;),</span><br><span class="line">&#125;, newData);</span><br></pre></td></tr></table></figure>
<h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><p>初始化一条数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.student.insert(&#123;</span><br><span class="line">    &quot;name&quot;:&quot;王二麻子&quot;,</span><br><span class="line">    &quot;age&quot;:88,</span><br><span class="line">    &quot;score&quot;:99</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$inc</font> : 针对数字字段,增加某个数字字段的值</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改王二麻子的age+2，score-10</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;王二麻子&quot;&#125;,&#123;</span><br><span class="line">	&quot;$inc&quot;:&#123;&quot;age&quot;:2,&quot;score&quot;:-10&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$set</font> : 重新设定内容</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改王二麻子的名称</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;王二麻子&quot;&#125;,&#123;</span><br><span class="line">	&quot;$set&quot;:&#123;&quot;name&quot;:&quot;张三&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$unset</font>：删除某个字段</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;score&quot;字段</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$unset&quot;:&#123;&quot;score&quot;:1&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$push</font>：给字段追加内容（数组操作）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给subject字段添加一门科目</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$push&quot;:&#123;&quot;subject&quot;:&quot;语文&quot;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$pushAll</font>：追加数组，在高版本该修改其已淘汰，可使用 $push+$each</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加多门科目</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$push&quot;:&#123;&quot;subject&quot;:&#123;</span><br><span class="line">		&quot;$each&quot;:[&quot;语文&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;数学&quot;]</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$addToSet</font>：追加内容到数组，如果存在就不新增</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一门科目，如果已存在就不添加</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$addToSet&quot;:&#123;&quot;subject&quot;:&quot;物理&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$pop</font>: 删除数组中的内容</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第一门科目</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$pop&quot;:&#123;&quot;subject&quot;:-1&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 删除最后一门科目</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$pop&quot;:&#123;&quot;subject&quot;:1&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$pull </font>:  删除数组中指定的内容, 不存在则没变化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除语文课</span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$pull&quot;:&#123;&quot;subject&quot;:&quot;语文&quot;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$pullAll</font>: 删除数组中多个内容</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除多门课</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$pullAll&quot;:&#123;&quot;subject&quot;:[&quot;物理&quot;,&quot;数学&quot;]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red">$rename</font>: 字段重命名</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将&quot;subject&quot;重命名为&quot;学科&quot;</span></span><br><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;</span><br><span class="line">	&quot;$rename&quot;:&#123;&quot;subject&quot;:&quot;学科&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>普通查询 <strong>db.集合名.find({查询条件})</strong> </p>
<p>投影查询 <strong>db.集合名.find( {查询条件} , {控制字段的显示})</strong></p>
<p>查询一条 <strong>db.集合名.findOne()</strong></p>
<p>0不显示  , 1显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询did为1,并只显示dname与address字段(要么全为1或全为0)</span><br><span class="line">db.dept.find(</span><br><span class="line">   &#123;&quot;did&quot;:1&#125;,</span><br><span class="line">   &#123;&quot;dname&quot;:1,&quot;address&quot;:1&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><table>
<thead>
<tr>
<th>操作</th>
<th>条件</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>{key:{“<strong>$eq</strong>“:value}}  或   {key:value}</td>
</tr>
<tr>
<td>大于</td>
<td>{key:{“<strong>$gt</strong>“:value}}</td>
</tr>
<tr>
<td>小于</td>
<td>{key:{“<strong>$lt</strong>“:value}}</td>
</tr>
<tr>
<td>大于等于</td>
<td>{key:{“<strong>$gte</strong>“:value}}</td>
</tr>
<tr>
<td>小于等于</td>
<td>{key:{“<strong>$lte</strong>“:value}}</td>
</tr>
<tr>
<td>不等于</td>
<td>{key:{“<strong>$ne</strong>“:value}}</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询18岁以上的同学</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 查询18岁以上的女同学(与关系)</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;,</span><br><span class="line">	&quot;sex&quot;:&quot;女&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>与 <strong>$and</strong></p>
<p>或  <strong>$or</strong></p>
<p>非  <strong>$not/$nor</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询年龄在18-20之间的同学(与关系)</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;age&quot;:&#123;</span><br><span class="line">		&quot;$gt&quot;:18,</span><br><span class="line">		&quot;$lt&quot;:20</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 18岁以上,或者性别是女的同学(或关系)</span><br><span class="line">db.stuent.find(&#123;</span><br><span class="line">	&quot;$or&quot;:[</span><br><span class="line">		&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;,</span><br><span class="line">		&#123;&quot;sex&quot;:&quot;女&quot;&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 22岁以下,性别是男的同学(使用&quot;$nor&quot;取反操作)</span><br><span class="line">db.stuent.find(&#123;</span><br><span class="line">	&quot;$nor&quot;:[</span><br><span class="line">		&#123;&quot;age&quot;:&#123;&quot;$gte&quot;:22&#125;&#125;,</span><br><span class="line">		&#123;&quot;sex&quot;:&quot;女&quot;&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h3><p>求余数   <strong>{key:{“$mod”:[x,y]}}</strong>  , 表示获取满足  key% x == y 的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取年龄为奇数的同学</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;age&quot;:&#123;&quot;$mod&quot;:[2,1]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><strong>$in</strong> 在范围内</p>
<p><strong>$nin</strong>  不在范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询 张三,李四,王五</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><p>初始化一些数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;辉-A&quot;,&quot;address&quot;:&quot;中关村1&quot;,&quot;subject&quot;:[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;]&#125;);</span><br><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;辉-B&quot;,&quot;address&quot;:&quot;中关村2&quot;,&quot;subject&quot;:[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;]&#125;);</span><br><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;辉-C&quot;,&quot;address&quot;:&quot;中关村3&quot;,&quot;subject&quot;:[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;]&#125;);</span><br><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;辉-D&quot;,&quot;address&quot;:&quot;中关村4&quot;,&quot;subject&quot;:[&quot;物理&quot;,&quot;化学&quot;]&#125;);</span><br><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;辉-E&quot;,&quot;address&quot;:&quot;中关村5&quot;,&quot;subject&quot;:[&quot;语文&quot;,&quot;数学&quot;,&quot;化学&quot;]&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>$all</strong>   并查询数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询同时有 语文 和 数学 课程的同学</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;subject&quot; : &#123;</span><br><span class="line">        &quot;$all&quot; : [&quot;语文&quot;,&quot;数学&quot;]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>key.index</strong> 查询数组中指定下标内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询第一门课为数学的学生</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;subject.0&quot; : &quot;数学&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>$size</strong>  数组长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询只有两门课的学生</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;subject&quot; : &#123;</span><br><span class="line">    	&quot;$size&quot;:2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>$slice</strong>  投影查询,只返回数组中指定的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询年龄为19,只返回前两门课</span><br><span class="line">db.student.find(</span><br><span class="line">	&#123;&quot;age&quot;:19&#125;,</span><br><span class="line">	&#123;&quot;subject&quot;:&#123;</span><br><span class="line">		&quot;$slice&quot;:2</span><br><span class="line">	&#125;&#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; 返回后两节课</span><br><span class="line">&quot;$slice&quot;:-2</span><br><span class="line">&#x2F;&#x2F; 返回从索引1开始,获取两节课</span><br><span class="line">&quot;$slice&quot;:[1,2]</span><br></pre></td></tr></table></figure>
<h3 id="嵌套集合"><a href="#嵌套集合" class="headerlink" title="嵌套集合"></a>嵌套集合</h3><p>初始化数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.student.insert(&#123;</span><br><span class="line">    &quot;name&quot;:&quot;辉&quot;,</span><br><span class="line">    &quot;age&quot;:21,</span><br><span class="line">    &quot;pets&quot;:[</span><br><span class="line">       &#123;</span><br><span class="line">            &quot;name&quot;:&quot;旺财&quot;,</span><br><span class="line">            &quot;age&quot;:3,</span><br><span class="line">            &quot;brand&quot;:&quot;狗&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">            &quot;name&quot;:&quot;tom&quot;,</span><br><span class="line">            &quot;age&quot;:4,</span><br><span class="line">            &quot;brand&quot;:&quot;猫&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>
<p><strong>$elemMatch</strong> 遍历数组中的每一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询20以上并养猫的人</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">	&quot;age&quot;:&#123;&quot;$gt&quot;:20&#125;,</span><br><span class="line">	&quot;pets&quot;:&#123;</span><br><span class="line">		&quot;$elemMatch&quot;:&#123;</span><br><span class="line">			&quot;brand&quot;:&quot;猫&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="字段是否存在"><a href="#字段是否存在" class="headerlink" title="字段是否存在"></a>字段是否存在</h3><p><strong>$exists</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询有宠物的人</span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;pets&quot;:&#123;</span><br><span class="line">        &quot;$exists&quot; : true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>想模糊查询,必须使用正则</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询名字包含辉的同学</span></span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;name&quot; : &#123;</span><br><span class="line">        &quot;$regex&quot; : /辉/</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上面写法中$regex可省略</span></span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;name&quot; : /辉/</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 查询姓名中包含a的,可加i,忽略大小写</span></span><br><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;name&quot; : /a/i</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上模糊查询对数组也生效</p>
<h3 id="分页与排序"><a href="#分页与排序" class="headerlink" title="分页与排序"></a>分页与排序</h3><p><strong>skip(n)</strong>  跳过多少行 <code>(pageNum-1)*pageSize</code></p>
<p><strong>limit(n)</strong>  获取多少行数据</p>
<p><strong>sort({})</strong>   排序,1为升序,-1为降序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取第一页数据,每页显示10条数据,却年龄升序</span><br><span class="line">db.student.find().skip(0).limit(10).sort(&#123;</span><br><span class="line">	&quot;age&quot;:1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="条件过滤where"><a href="#条件过滤where" class="headerlink" title="条件过滤where"></a>条件过滤where</h3><ul>
<li>查询年龄40岁以上的学生</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.student.find(&#123;</span><br><span class="line">    &quot;$where&quot;:&quot;this.age &gt; 40&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>   将MongoDB中的BSON数据转成了Javascript 语法结构循环验证</p>
<p>不方便使用数据库的索引机制.并不推荐使用,只需知道有这种查询方式即可</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标就是让数据一行行的执行，类似与java中的foreach循环</p>
<p>使用 find() 函数可返回游标，然后使用游标的两个函数 <code>hasNext()</code> 、<code>next()</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var you = db.student.find();</span><br><span class="line">while(you.hasNext())&#123;</span><br><span class="line">    print(you.next().name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引能够加快搜索性能,索引分两种: 自动创建的 和 手动创建的</p>
<p><strong>查看集合中索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.student.getIndexes();</span><br></pre></td></tr></table></figure>
<p>_id_  为自动创建的索引</p>
<p><a href="https://imgtu.com/i/7ygDyt"><img src="https://s4.ax1x.com/2022/01/20/7ygDyt.png" alt="7ygDyt.png"></a></p>
<p><strong>创建索引</strong></p>
<p><code>db.集合名.ensureIndex()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为age创建一个降序索引</span><br><span class="line">db.student.ensureIndex(&#123;</span><br><span class="line">	&quot;age&quot;:-1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>删除索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除刚刚创建的索引</span><br><span class="line">db.student.dropIndex(&#123;</span><br><span class="line">	&quot;age&quot;:-1</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 删除全部索引,默认索引不能删除</span><br><span class="line">db.student.dropIndexes();</span><br></pre></td></tr></table></figure>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>用在有一个字段,让该字段的内容不能重复</p>
<ul>
<li>给name字段加上唯一索引,如果添加重复的值,会报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.student.ensureIndex(</span><br><span class="line">	&#123;&quot;name&quot;,1&#125;,</span><br><span class="line">	&#123;&quot;unique&quot;:true&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>程序会出现若干秒之后，信息删除,这个间隔时间大多数情况下并不准确</p>
<p>删除过程是由后台程序每60s跑一次，而且删除也需要一些 时间，存在误差</p>
<ul>
<li>添加一个10s的过期索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.phones.ensureIndex(</span><br><span class="line">	&#123;&quot;time&quot;,1&#125;,</span><br><span class="line">	&#123;&quot;expireAfterSeconds&quot;:10&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>添加数据</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.phones.insert(&#123;&quot;num&quot;:110,&quot;time&quot;: ISODate(&quot;2020-01-01T22:55:13.369Z&quot;)&#125;);</span><br></pre></td></tr></table></figure>
<p>过期索引中最好的时间类型是<strong>ISODate</strong>（0时区的时间），0 时区到Date会有一定的换算程序，所以用Date删除的时间偏差更大</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>模糊查询只能根据某个字段进行查询,而全文查询能查询整个集合.</p>
<ul>
<li>初始化一些数据</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.news.insert(&#123;&quot;title&quot;:&quot;NoSQL&quot;,&quot;context&quot;:&quot;MongoDB&quot;&#125;);</span><br><span class="line">db.news.insert(&#123;&quot;title&quot;:&quot;js java&quot;,&quot;context&quot;:&quot;前端技术&quot;&#125;);</span><br><span class="line">db.news.insert(&#123;&quot;title&quot;:&quot;编程语言&quot;,&quot;context&quot;:&quot;java&quot;&#125;);</span><br><span class="line">db.news.insert(&#123;&quot;title&quot;:&quot;java&quot;,&quot;context&quot;:&quot;好语言&quot;&#125;);</span><br><span class="line">db.news.insert(&#123;&quot;title&quot;:&quot;java&quot;,&quot;context&quot;:&quot;java&quot;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>设置全文索引</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.news.ensureIndex(&#123;</span><br><span class="line">   &quot;title&quot;:&quot;text&quot;,</span><br><span class="line">   &quot;context&quot;:&quot;text&quot;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 可给所有字段添加全文索引</span></span><br><span class="line">db.news.ensureIndex(&#123;</span><br><span class="line">    &quot;$**&quot;:&quot;text&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>全文搜索</strong></p>
<p>使用 <code>$text</code> 与 <code>$search</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.news.find(&#123;</span><br><span class="line">	&quot;$text&quot;:&#123;</span><br><span class="line">		&quot;$search&quot;:&quot;java&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>查询多个关键字(或关系)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$search&quot;:&quot;关键字1 关键字2&quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询多个关键字(且关系)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$search&quot;:&quot; \&quot;关键字1\&quot; \&quot;关键字2\&quot; &quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询多个关键字(差关系)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$search&quot;:&quot;关键字1 -关键字2&quot;&#125;  &#x2F;&#x2F; 存在关键字1且不存在关键字2</span><br></pre></td></tr></table></figure>
<h2 id="地理信息索引"><a href="#地理信息索引" class="headerlink" title="地理信息索引"></a>地理信息索引</h2><p>2DSphere(球面索引) :  摇一摇，大众点评，美团都是基于2D索引的，保存的信息都是坐标，坐标都是经纬度.</p>
<ul>
<li>初始化一些数据</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[10,10]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[11,11]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[13,12]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[50,14]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[66,66]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[110,119]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[93,24]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[99,54]&#125;);</span><br><span class="line">db.shops.insert(&#123;&#x27;loc&#x27;:[77,7]&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建2D索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.shops.ensureIndex(&#123;</span><br><span class="line">	&quot;loc&quot;:&quot;2d&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>坐标查询</strong></p>
<ul>
<li>$near : 查询距离某个点距离最近的坐标点;</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询[11,11]坐标点附件的点,可设置查询范围</span></span><br><span class="line">db.shops.find(&#123;</span><br><span class="line">	&quot;loc&quot;:&#123;</span><br><span class="line">		&quot;$near&quot;:[11,11],</span><br><span class="line">		&quot;$maxDistance&quot;:5</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>$geoWithin : 查询某个形状内的坐标点;<ul>
<li>矩形范围 $box</li>
<li>圆形范围 $center</li>
<li>多边形范围 $polygon</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩形范围</span></span><br><span class="line">db.shops.find(&#123;</span><br><span class="line">	&quot;loc&quot;:&#123;</span><br><span class="line">		&quot;$genWithin&quot;:&#123;</span><br><span class="line">			&quot;$box&quot;:[[9,9],[11,11]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆形范围</span></span><br><span class="line">db.shops.find(&#123;</span><br><span class="line">	&quot;loc&quot;:&#123;</span><br><span class="line">		&quot;$genWithin&quot;:&#123;</span><br><span class="line">			&quot;$center&quot;:[[9,9],3] 			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多边形范围, 如下是三角形</span></span><br><span class="line">db.shops.find(&#123;</span><br><span class="line">	&quot;loc&quot;:&#123;</span><br><span class="line">		&quot;$genWithin&quot;:&#123;</span><br><span class="line">			&quot;$polygon&quot;:[[1,2],[2,5],[5,3]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="索引的限制"><a href="#索引的限制" class="headerlink" title="索引的限制"></a>索引的限制</h2><ol>
<li>如果MongoDB的索引项超过索引限制，即1024 bytes，将不会 创建该索引（创建失败），并且插入数据和更新数据会报错 </li>
<li>一个collections最多能够有64个索引</li>
<li>针对复合索引,包含的索引属性不能够超过31个属性 </li>
<li>查询不能够同时使用文本索引和地理空间索引(Queries cannot use both text and Geospatial Indexes) </li>
<li>包含2d 属性的索引，只能够针对地理空间属性</li>
</ol>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>所谓的”聚合”,也就是”分组统计”</p>
<h2 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h2><ul>
<li>获取集合中的数据量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.student.count();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取查询后的数据量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.student.count(&#123;&quot;name&quot;:/辉/&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="消除重复数据"><a href="#消除重复数据" class="headerlink" title="消除重复数据"></a>消除重复数据</h2><p>没有直接的函数支持.所以我们只能用,最原始的runCommand()</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有student,消除重复的name</span></span><br><span class="line">db.runCOmmand(&#123;</span><br><span class="line">	&quot;distinct&quot;:&quot;student&quot;,</span><br><span class="line">	&quot;key&quot;:&quot;name&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="聚合框架"><a href="#聚合框架" class="headerlink" title="聚合框架"></a>聚合框架</h2><p>MongoDB中的MapReduce写起来的很复杂 , 所以在 Mongo2.x之后,提供了聚合框架.</p>
<p>函数 : <strong>aggregate()</strong></p>
<ul>
<li>初始化数据</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:19,&quot;job&quot;:&quot;程序猿&quot;,&quot;salary&quot;:5000&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:18,&quot;job&quot;:&quot;美工&quot;,&quot;salary&quot;:6000&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;王五&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:21,&quot;job&quot;:&quot;测试&quot;,&quot;salary&quot;:7000&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;赵六&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:21,&quot;job&quot;:&quot;程序猿&quot;,&quot;salary&quot;:5500&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;孙七&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:22,&quot;job&quot;:&quot;测试&quot;,&quot;salary&quot;:8000&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;田八&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:22,&quot;job&quot;:&quot;程序猿&quot;,&quot;salary&quot;:3000&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;钱九&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:23,&quot;job&quot;:&quot;美工&quot;,&quot;salary&quot;:4500&#125;);</span><br><span class="line">db.emps.insert(&#123;&quot;name&quot;:&quot;周十&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:17,&quot;job&quot;:&quot;程序猿&quot;,&quot;salary&quot;:9000&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h3><p>获取每个职位的人数,总工资,平均工资,最高工资,最低工资</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$group&quot;:&#123;</span><br><span class="line">		&quot;_id&quot;:&quot;$job&quot;,  // 根据&quot;job&quot;字段分组</span><br><span class="line">        &quot;count&quot;:&#123;	   // 人数,使用 $sum,每次+1</span><br><span class="line">            &quot;$sum&quot;:1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;salary_sum&quot;:&#123; //总工资,每个职位在工资相加</span><br><span class="line">            &quot;$sum&quot;:&quot;$salary&quot; </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;salary_avg&quot;:&#123;</span><br><span class="line">            &quot;$avg&quot;:&quot;$salary&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;salary_max&quot;:&#123;</span><br><span class="line">            &quot;$max&quot;:&quot;$salary&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;salary_min&quot;:&#123;</span><br><span class="line">            &quot;$min&quot;:&quot;$salary&quot;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>获取每个职位中员工的姓名,使用 “$push” (如果要消除重复name,可使用”$addToSet”)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$group&quot;:&#123;</span><br><span class="line">		&quot;_id&quot;:&quot;$job&quot;,</span><br><span class="line">		&quot;names&quot;:&#123;</span><br><span class="line">			&quot;$push&quot;:&quot;$name&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h3><ul>
<li>数据列的显示规则,投影查询</li>
</ul>
<p>1|true 显示</p>
<p>0|false 不显示</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询emps表,不显示_id,显示name</span></span><br><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$project&quot;:&#123;</span><br><span class="line">		&quot;_id&quot;:0,</span><br><span class="line">		&quot;name&quot;:1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>起别名</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$project&quot;:&#123;</span><br><span class="line">		&quot;_id&quot;:0,</span><br><span class="line">		&quot;姓名&quot;:&quot;$name&quot;,</span><br><span class="line">		&quot;职位&quot;:&quot;$job&quot;,</span><br><span class="line">		&quot;薪资&quot;:&quot;$salary&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>支持四则运算<ul>
<li>加 $add  </li>
<li>减 $subtract </li>
<li>乘 $multiply</li>
<li>除 $divide </li>
<li>求模 $mod</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求年薪</span></span><br><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$project&quot;:&#123;</span><br><span class="line">		&quot;_id&quot;:0,</span><br><span class="line">		&quot;姓名&quot;:&quot;$name&quot;,</span><br><span class="line">		&quot;年薪&quot;:&#123;</span><br><span class="line">			&quot;$multiply&quot;:[&quot;$salary&quot;,12]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>聚合管道运算符中文文档：<a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-abs.html">https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-abs.html</a></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="$sort"></a>$sort</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄升序,如果相等,则工资降序</span></span><br><span class="line">db.emps.aggregate(&#123;</span><br><span class="line">	&quot;$sort&quot;:&#123;</span><br><span class="line">		&quot;age&quot;:1,</span><br><span class="line">		&quot;salary&quot;:-1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跨3行数据,再取5个</span></span><br><span class="line">db.emps.aggregate(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;$project&quot;</span>:&#123;</span><br><span class="line">			<span class="attr">&quot;_id&quot;</span>:<span class="number">0</span>,</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>:<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;$skip&quot;</span>:<span class="number">3</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;$limit&quot;</span>:<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>$skip一定要在$limit前面</p>
<h3 id="out"><a href="#out" class="headerlink" title="$out"></a>$out</h3><p>将投影结果,输出到一个集合中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.emps.aggregate(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;$project&quot;</span>:&#123;</span><br><span class="line">			<span class="attr">&quot;_id&quot;</span>:<span class="number">0</span>,</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>:<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;$out&quot;</span>:<span class="string">&quot;emps_2&quot;</span>  <span class="comment">// 将结果保存到&quot;emps_2&quot;中</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="固定集合"><a href="#固定集合" class="headerlink" title="固定集合"></a>固定集合</h2><p>规定集合大小，如果保存内容超过了集合的长度，那么会采用 <strong>LRU</strong>的算法，将最早的数据移除，来保存新的数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;depts&quot;,&#123;</span><br><span class="line">    &quot;capped&quot;:true,  // true:固定集合</span><br><span class="line">    &quot;size&quot;:1024, // 集合空间容量 1024字节</span><br><span class="line">    &quot;max&quot;:5 // 最多有5条记录</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="java操作"><a href="#java操作" class="headerlink" title="java操作"></a>java操作</h1><p>这里介绍spring提供对MongoDB操作的工具类的使用</p>
<h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="spring-xml"><a href="#spring-xml" class="headerlink" title="spring.xml"></a>spring.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">&lt;beans</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:mongo=&quot;http://www.springframework.org/schema/data/mongo&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">                           http://www.springframework.org/schema/beans</span><br><span class="line">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/context</span><br><span class="line">                           http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                           http://www.springframework.org/schema/data/mongo</span><br><span class="line">                           http://www.springframework.org/schema/data/mongo/spring-mongo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">mongo:db-factory</span> <span class="attr">id</span>=<span class="string">&quot;mongoDbFactory&quot;</span> <span class="attr">client-uri</span>=<span class="string">&quot;mongodb://212.129.221.154:27017/test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mongoTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.mongodb.core.MongoTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mongoDbFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mongoDbFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实体类-操作emps集合"><a href="#实体类-操作emps集合" class="headerlink" title="实体类(操作emps集合)"></a>实体类(操作emps集合)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.entity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document(collection = &quot;emps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String _id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> age;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="comment">// getter setter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MongoTemplate常用方法"><a href="#MongoTemplate常用方法" class="headerlink" title="MongoTemplate常用方法"></a>MongoTemplate常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongoTemplate.findAll(Student.class) &#x2F;&#x2F; 查询Student文档的全部数据</span><br><span class="line">mongoTemplate.findById(&lt;id&gt;, Student.class) &#x2F;&#x2F; 查询Student文档id为id的数据</span><br><span class="line">mongoTemplate.find(query, Student.class) &#x2F;&#x2F; 根据query内的查询条件查询</span><br><span class="line">mongoTemplate.upsert(query, update, Student.class) &#x2F;&#x2F; 修改</span><br><span class="line">mongoTemplate.remove(query, Student.class) &#x2F;&#x2F; 删除</span><br><span class="line">mongoTemplate.insert(student) &#x2F;&#x2F; 新增</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Query对象</p>
<ul>
<li>封装所有条件对象,可通过构造方法传条件<code>new Query(Criteria)</code>或<code>query.addCriteria(criteria)</code></li>
</ul>
</li>
<li><p>Criteria对象</p>
<ul>
<li>用来构建条件,可直接<code>new Criteria()</code>,也可使用 <code>Criteria.where(&quot;key&quot;)</code> 创建</li>
<li>精准条件: criteria.and(“key”).is(“条件”)</li>
<li>模糊条件: criteria.and(“key”).regex(“条件”)</li>
<li>大于: criteria.and(“key”).gt(“条件”)</li>
<li>小于: criteria.and(“key”).lt(“条件”)</li>
</ul>
</li>
</ul>
<h2 id="接口及实现类"><a href="#接口及实现类" class="headerlink" title="接口及实现类"></a>接口及实现类</h2><ul>
<li>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmpService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Emp emp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Emp emp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Emp <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Long <span class="title">findCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊查询</span></span><br><span class="line">    <span class="function">List&lt;Emp&gt; <span class="title">findList</span><span class="params">(Integer pageNum, Integer pageSize, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;empService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpServiceImpl</span> <span class="keyword">implements</span> <span class="title">EmpService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        mongoTemplate.insert(emp);</span><br><span class="line">        System.out.println(<span class="string">&quot;增加成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(id));</span><br><span class="line">        DeleteResult remove = mongoTemplate.remove(query, Emp.class);</span><br><span class="line">        <span class="keyword">if</span> (remove.getDeletedCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(emp.get_id()));</span><br><span class="line"></span><br><span class="line">        Update update = <span class="keyword">new</span> Update();</span><br><span class="line">        update.set(<span class="string">&quot;name&quot;</span>, emp.getName());</span><br><span class="line">        update.set(<span class="string">&quot;sex&quot;</span>, emp.getSex());</span><br><span class="line">        update.set(<span class="string">&quot;age&quot;</span>, emp.getAge());</span><br><span class="line">        update.set(<span class="string">&quot;job&quot;</span>, emp.getJob());</span><br><span class="line">        update.set(<span class="string">&quot;salary&quot;</span>, emp.getSalary());</span><br><span class="line"></span><br><span class="line">        UpdateResult upsert = mongoTemplate.upsert(query, update, Emp.class);</span><br><span class="line">        <span class="keyword">if</span> (upsert.getModifiedCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Emp emp = mongoTemplate.findById(id, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">findCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        <span class="keyword">long</span> count = mongoTemplate.count(query, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊+分页查询</span></span><br><span class="line">    <span class="comment">// 模糊查询以【^】开始,以【$】结束,【.*】相当于Mysql中的%</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">findList</span><span class="params">(Integer pageNum, Integer pageSize, String name)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        <span class="comment">// 不为空就模糊查询</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            String regex = <span class="string">&quot;^.*&quot;</span> + name + <span class="string">&quot;.*$&quot;</span>;</span><br><span class="line">            <span class="comment">// 构建正则对象, Pattern.CASE_INSENSITIVE表示忽略大小写</span></span><br><span class="line">            Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">            query.addCriteria(Criteria.where(<span class="string">&quot;name&quot;</span>).regex(pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分页</span></span><br><span class="line">        List&lt;Emp&gt; emps = mongoTemplate.find(query.skip((pageNum - <span class="number">1</span>) * pageSize).limit(pageSize), Emp.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        EmpService empService = context.getBean(<span class="string">&quot;empService&quot;</span>, EmpService.class);</span><br><span class="line">        <span class="comment">// 增</span></span><br><span class="line"><span class="comment">//        empService.insert(new Emp(&quot;2&quot;,&quot;2&quot;,2,&quot;2&quot;,2));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删</span></span><br><span class="line"><span class="comment">//        empService.delete(&quot;61e26329a13ff02ed43c5b4f&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改</span></span><br><span class="line"><span class="comment">//        empService.update(new Emp(&quot;61e26506a13ff02ac8e05955&quot;,&quot;怪狗狗&quot;,&quot;男&quot;,22,&quot;man&quot;,2000));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据id查询</span></span><br><span class="line"><span class="comment">//        Emp byId = empService.findById(&quot;61e26506a13ff02ac8e05955&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(byId);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询数量</span></span><br><span class="line"><span class="comment">//        Long count = empService.findCount();</span></span><br><span class="line"><span class="comment">//        System.out.println(count);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊查询</span></span><br><span class="line">        List&lt;Emp&gt; list = empService.findList(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;怪&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>noSQL</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2022/02/24/SpringSecurity/</url>
    <content><![CDATA[<p>​    <strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。<a id="more"></a></p>
<p>​    一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>
<p>​     一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>
<p>​        <strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p>​        <strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<p>​    而认证和授权也是SpringSecurity作为安全框架的核心功能。</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>​    我们先要搭建一个简单的SpringBoot工程</p>
<p>① 设置父工程 添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>② 创建启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SecurityApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>③ 创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>引入springSecurity依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。</p>
<p>​    必须登陆之后才能对接口进行访问。</p>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p><strong>登陆校验流程</strong></p>
<p><a href="https://imgtu.com/i/biU2cQ"><img src="https://s4.ax1x.com/2022/02/24/biU2cQ.png" alt="biU2cQ.png"></a></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>
<p><a href="https://imgtu.com/i/biUfns"><img src="https://s4.ax1x.com/2022/02/24/biUfns.png" alt="biUfns.png"></a></p>
<p>​    图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<p>​    我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>
<p><a href="https://imgtu.com/i/biUThT"><img src="https://s4.ax1x.com/2022/02/24/biUThT.png" alt="biUThT.png"></a></p>
<h3 id="认证流程详解"><a href="#认证流程详解" class="headerlink" title="认证流程详解"></a>认证流程详解</h3><p><a href="https://imgtu.com/i/biaEDA"><img src="https://s4.ax1x.com/2022/02/24/biaEDA.png" alt="biaEDA.png"></a></p>
<p>核心类:</p>
<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p>AuthenticationManager接口：定义了认证Authentication的方法 </p>
<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><strong>登录</strong></p>
<p>​    ①自定义登录接口  </p>
<p>​                调用ProviderManager的<code>Authentication()</code>方法进行认证 如果认证通过生成jwt</p>
<p>​                把用户信息存入redis中</p>
<p>​    ②自定义UserDetailsService 实现类</p>
<p>​                在这个实现类中去查询数据库</p>
<p><strong>校验</strong>：</p>
<p>​    ①定义Jwt认证过滤器</p>
<p>​                获取token</p>
<p>​                解析token获取其中的userid</p>
<p>​                从redis中获取用户信息</p>
<p>​                存入SecurityContextHolder</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="添加Redis相关配置"><a href="#添加Redis相关配置" class="headerlink" title="添加Redis相关配置"></a>添加Redis相关配置</h3><h4 id="fastJson序列化"><a href="#fastJson序列化" class="headerlink" title="fastJson序列化"></a>fastJson序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.TypeFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis使用FastJson序列化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonRedisSerializer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = <span class="keyword">new</span> String(bytes, DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JavaType <span class="title">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="redis配置类"><a href="#redis配置类" class="headerlink" title="redis配置类"></a>redis配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        FastJsonRedisSerializer serializer = <span class="keyword">new</span> FastJsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="redis工具类"><a href="#redis工具类" class="headerlink" title="redis工具类"></a>redis工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 时间颗粒度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value, <span class="keyword">final</span> Integer timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getCacheObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operation.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除单个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 多个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">deleteObject</span><span class="params">(<span class="keyword">final</span> Collection collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存List数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 待缓存的List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">long</span> <span class="title">setCacheList</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> List&lt;T&gt; dataList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="keyword">null</span> ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的list对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getCacheList</span><span class="params">(<span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSet 缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存数据的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">BoundSetOperations&lt;String, T&gt; <span class="title">setCacheSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Set&lt;T&gt; dataSet)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);</span><br><span class="line">        Iterator&lt;T&gt; it = dataSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            setOperation.add(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setOperation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">getCacheSet</span><span class="params">(<span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setCacheMap</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Map&lt;String, T&gt; dataMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getCacheMap</span><span class="params">(<span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往Hash中存入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey, <span class="keyword">final</span> T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash中的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> opsForHash.get(key, hKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash中的数据</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hkey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashOperations hashOperations = redisTemplate.opsForHash();</span><br><span class="line">        hashOperations.delete(key, hkey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多个Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKeys Hash键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getMultiCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Collection&lt;Object&gt; hKeys)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, hKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 字符串前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">(<span class="keyword">final</span> String pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效期为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long JWT_TTL = <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000  一个小时</span></span><br><span class="line">    <span class="comment">//设置秘钥明文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY = <span class="string">&quot;sangeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUUID</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String token = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createJWT</span><span class="params">(String subject)</span> </span>&#123;</span><br><span class="line">        JwtBuilder builder = getJwtBuilder(subject, <span class="keyword">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> </span>&#123;</span><br><span class="line">        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> </span>&#123;</span><br><span class="line">        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;</span><br><span class="line">        SecretKey secretKey = generalKey();</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis==<span class="keyword">null</span>)&#123;</span><br><span class="line">            ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> expMillis = nowMillis + ttlMillis;</span><br><span class="line">        Date expDate = <span class="keyword">new</span> Date(expMillis);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setId(uuid)              <span class="comment">//唯一的ID</span></span><br><span class="line">                .setSubject(subject)   <span class="comment">// 主题  可以是JSON数据</span></span><br><span class="line">                .setIssuer(<span class="string">&quot;sg&quot;</span>)     <span class="comment">// 签发者</span></span><br><span class="line">                .setIssuedAt(now)      <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span></span><br><span class="line">                .setExpiration(expDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> </span>&#123;</span><br><span class="line">        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;</span>;</span><br><span class="line">        Claims claims = parseJWT(token);</span><br><span class="line">        System.out.println(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">generalKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey secretKey = generalKey();</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应类"><a href="#响应类" class="headerlink" title="响应类"></a>响应类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示信息，如果有错误时，前端可以获取该字段进行提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的结果数据，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer code, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer code, String msg, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表(User)实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">40356785423868312L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 昵称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 账号状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮箱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 手机号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String phonenumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户性别（0男，1女，2未知）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 头像</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户类型（0管理员，1普通用户）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建人的用户id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除标志（0代表未删除，1代表已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;sys_user&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;user_name&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,</span><br><span class="line">  &#96;nick_name&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,</span><br><span class="line">  &#96;password&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,</span><br><span class="line">  &#96;status&#96; CHAR(1) DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,</span><br><span class="line">  &#96;email&#96; VARCHAR(64) DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">  &#96;phonenumber&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;手机号&#39;,</span><br><span class="line">  &#96;sex&#96; CHAR(1) DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,</span><br><span class="line">  &#96;avatar&#96; VARCHAR(128) DEFAULT NULL COMMENT &#39;头像&#39;,</span><br><span class="line">  &#96;user_type&#96; CHAR(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,</span><br><span class="line">  &#96;create_by&#96; BIGINT(20) DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,</span><br><span class="line">  &#96;create_time&#96; DATETIME DEFAULT NULL COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_by&#96; BIGINT(20) DEFAULT NULL COMMENT &#39;更新人&#39;,</span><br><span class="line">  &#96;update_time&#96; DATETIME DEFAULT NULL COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;del_flag&#96; INT(11) DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;用户表&#39;</span><br></pre></td></tr></table></figure>


<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>​    application.properties</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">212.129</span><span class="number">.221</span><span class="number">.154</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>​        定义Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        配置Mapper扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hui.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSecurityApplication</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从数据库加载用户信息"><a href="#从数据库加载用户信息" class="headerlink" title="从数据库加载用户信息"></a>从数据库加载用户信息</h3><p><strong>UserDetailsService</strong>中的方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetails</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用户信息</span></span><br><span class="line">    <span class="keyword">private</span> User user; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 获取权限信息 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取密码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取用户名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写UserDetailsService接口，从数据库加载用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">// 认证,根据用户名查询数据库</span></span><br><span class="line">        QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        qw.eq(<span class="string">&quot;user_name&quot;</span>, userName);</span><br><span class="line">        User user = userMapper.selectOne(qw);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 授权</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyUserDetails(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如</p>
<p><a href="https://imgtu.com/i/biamUP"><img src="https://s4.ax1x.com/2022/02/24/biamUP.png" alt="biamUP.png"></a></p>
<p>这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。</p>
<h3 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h3><p>​    实际项目中我们不会把密码明文存储在数据库中。</p>
<p>​    默认使用的<strong>PasswordEncoder</strong>要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p>
<p>​    我们一般使用SpringSecurity为我们提供的<strong>BCryptPasswordEncoder</strong>。</p>
<p>​    我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p>
<p>​    我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="登陆接口"><a href="#登陆接口" class="headerlink" title="登陆接口"></a>登陆接口</h3><p>​    自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p>
<p>​    在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把<strong>AuthenticationManager</strong>注入容器。</p>
<p>​    认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。</p>
<p><strong>springSecurity配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginServcie loginServcie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>service接口与实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">    <span class="function">ResponseResult <span class="title">login</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title">LoginServcie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用AuthenticationManager的authenticate方法经行认证</span></span><br><span class="line">        UsernamePasswordAuthenticationToken t = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());</span><br><span class="line">        Authentication authenticate = authenticationManager.authenticate(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证失败,提示</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authenticate)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;登入失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证成功,获取userid生产JWT,并返回出去</span></span><br><span class="line">        MyUserDetails myUserDetails = (MyUserDetails) authenticate.getPrincipal();</span><br><span class="line">        String id = myUserDetails.getUser().getId().toString();</span><br><span class="line">        String jwt = JwtUtil.createJWT(id);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;jwt&quot;</span>, jwt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将用户信息保存到redis中,key为&quot;userid:1&quot;形式</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;userid:&quot;</span> + id, myUserDetails);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult(<span class="number">200</span>, <span class="string">&quot;登入成功!&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义认证过滤器"><a href="#定义认证过滤器" class="headerlink" title="定义认证过滤器"></a>定义认证过滤器</h3><p>​    我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。</p>
<p>​    使用userid去redis中获取对应的LoginUser对象。</p>
<p>​    然后封装Authentication对象存入SecurityContextHolder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 请求头中获取jwt</span></span><br><span class="line">        String jwt = httpServletRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(jwt)) &#123;</span><br><span class="line">            <span class="comment">// 没有jwt,就直接放行,并返回 --- 后面的过滤器会将其拦截</span></span><br><span class="line">            filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析jwt,获取userid</span></span><br><span class="line">        String userid = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = JwtUtil.parseJWT(jwt);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;jwt非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过userid从redis中读取loginUserDetails</span></span><br><span class="line">        MyUserDetails myUserDetails = redisCache.getCacheObject(<span class="string">&quot;userid:&quot;</span> + userid);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(myUserDetails)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户未认证!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将用户信息存入 securityContextHolder</span></span><br><span class="line">        <span class="comment">// TODO 将权限信息放入t中</span></span><br><span class="line">        UsernamePasswordAuthenticationToken t = </span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordAuthenticationToken(myUserDetails, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将JwtAuthenticationTokenFilter过滤器添加到springSecurity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Security中的configure()方法下添加该代码</span></span><br><span class="line"><span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
<h3 id="退出登陆"><a href="#退出登陆" class="headerlink" title="退出登陆"></a>退出登陆</h3><p>​    只需要定义一个退出接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可</p>
<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/loginOut&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseResult <span class="title">loginOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loginService.loginOut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意 SecurityContextHolder 对象是每个请求独享的</span></span><br><span class="line"><span class="comment">// 在调用该方法之前,一定会经过JwtAuthenticationTokenFilter过滤器,并且认证通过,所以SecurityContextHolder中是有用户信息的,因为是同一个请求</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseResult <span class="title">loginOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SecurityContextHolder中获取userid</span></span><br><span class="line">    UsernamePasswordAuthenticationToken t = (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    MyUserDetails myUserDetails = (MyUserDetails) t.getPrincipal();</span><br><span class="line">    Long userid = myUserDetails.getUser().getId();</span><br><span class="line">    <span class="comment">//清空redis缓存</span></span><br><span class="line">    redisCache.deleteObject(<span class="string">&quot;userid:&quot;</span> + userid);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult(<span class="number">200</span>, <span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p><strong>授权基本流程</strong></p>
<p>​    在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从<strong>SecurityContextHolder</strong>获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>​    所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>
<p>​    然后设置我们的资源所需要的权限即可。</p>
<h2 id="使用注解设置访问权限"><a href="#使用注解设置访问权限" class="headerlink" title="使用注解设置访问权限"></a>使用注解设置访问权限</h2><p>​    SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式</p>
<ol>
<li>需要在SecurityConfig中开启相关配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后就可以使用对应的注解  @PreAuthorize</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">   <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;)</span> <span class="comment">// 需要test权限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装权限信息"><a href="#封装权限信息" class="headerlink" title="封装权限信息"></a>封装权限信息</h2><p>​    UserDetailsServiceImpl中查询出用户后还要获取对应的权限信息，并且封装到UserDetails中返回。</p>
<p>​    所以这里要修改MyUserDetail类,让其能封装权限信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetails</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions; <span class="comment">// 权限信息</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUserDetails</span><span class="params">(User user, List&lt;String&gt; permissions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">        <span class="keyword">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储SpringSecurity所需要的权限信息的集合(提高效率)  </span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span>  <span class="comment">// 不参与序列化</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line"><span class="comment">//        List&lt;GrantedAuthority&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (String p : permissions) &#123;</span></span><br><span class="line"><span class="comment">//            res.add(new SimpleGrantedAuthority(p));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return res;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authorities == <span class="keyword">null</span>) &#123;</span><br><span class="line">            authorities = permissions.stream().map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 其他代码不动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改-UserDetailsServiceImpl"><a href="#修改-UserDetailsServiceImpl" class="headerlink" title="修改 UserDetailsServiceImpl"></a>修改 UserDetailsServiceImpl</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">       	<span class="comment">// 认证,根据用户名查询数据库</span></span><br><span class="line">        QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        qw.eq(<span class="string">&quot;user_name&quot;</span>, userName);</span><br><span class="line">        User user = userMapper.selectOne(qw);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 授权(暂时写死)</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;test,admin&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyUserDetails(user,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改-JwtAuthenticationTokenFilter-过滤器"><a href="#修改-JwtAuthenticationTokenFilter-过滤器" class="headerlink" title="修改 JwtAuthenticationTokenFilter 过滤器"></a>修改 JwtAuthenticationTokenFilter 过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将用户信息存入 securityContextHolder , 并添加权限信息</span></span><br><span class="line">UsernamePasswordAuthenticationToken t = </span><br><span class="line">    <span class="keyword">new</span> UsernamePasswordAuthenticationToken(myUserDetails, <span class="keyword">null</span>, myUserDetails.getAuthorities());</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(t);</span><br></pre></td></tr></table></figure>
<h2 id="从数据库查询权限信息"><a href="#从数据库查询权限信息" class="headerlink" title="从数据库查询权限信息"></a>从数据库查询权限信息</h2><p><strong>RBAC权限模型</strong></p>
<p>​    RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p>
<p><a href="https://imgtu.com/i/biaQgg"><img src="https://s4.ax1x.com/2022/02/24/biaQgg.png" alt="biaQgg.png"></a></p>
<h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>sql脚本</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`sg_security` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line"></span><br><span class="line">USE `sg_security`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `menu_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;菜单名&#x27;</span>,</span><br><span class="line">  `path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路由地址&#x27;</span>,</span><br><span class="line">  `component` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;组件路径&#x27;</span>,</span><br><span class="line">  `visible` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0显示 1隐藏）&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `perms` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `icon` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;#&#x27;</span> COMMENT <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除（0未删除 1已删除）&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_key` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色权限字符串&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;del_flag&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`,`menu_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账号状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phonenumber` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户性别（0男，1女，2未知）&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_type` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人的用户id&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志（0代表未删除，1代表已删除）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user_role` (</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`,`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<p><strong>根据用户id获取权限信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	DISTINCT m.&#96;perms&#96;</span><br><span class="line">FROM</span><br><span class="line">	sys_user_role ur</span><br><span class="line">	LEFT JOIN &#96;sys_role&#96; r ON ur.&#96;role_id&#96; &#x3D; r.&#96;id&#96;</span><br><span class="line">	LEFT JOIN &#96;sys_role_menu&#96; rm ON ur.&#96;role_id&#96; &#x3D; rm.&#96;role_id&#96;</span><br><span class="line">	LEFT JOIN &#96;sys_menu&#96; m ON m.&#96;id&#96; &#x3D; rm.&#96;menu_id&#96;</span><br><span class="line">WHERE</span><br><span class="line">	user_id &#x3D; 2</span><br><span class="line">	AND r.&#96;status&#96; &#x3D; 0</span><br><span class="line">	AND m.&#96;status&#96; &#x3D; 0</span><br></pre></td></tr></table></figure>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value=&quot;sys_menu&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">54979041104113736L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 路由地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 组件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String component;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0显示 1隐藏）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String visible;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 权限标识</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String perms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单图标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否删除（0未删除 1已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 备注</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>mapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MenuMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">selectPermsByUserId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hui.mapper.MenuMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPermsByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            DISTINCT m.`perms`</span><br><span class="line">        FROM</span><br><span class="line">            sys_user_role ur</span><br><span class="line">            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">        WHERE</span><br><span class="line">            user_id = #&#123;userid&#125;</span><br><span class="line">            AND r.`status` = 0</span><br><span class="line">            AND m.`status` = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>在application.yml中配置mapperXML文件的位置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/*.xml</span> </span><br></pre></td></tr></table></figure>
<p>​    <strong>修改UserDetailsServiceImpl,从数据库中获取权限信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 认证,根据用户名查询数据库</span></span><br><span class="line">    QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    qw.eq(<span class="string">&quot;user_name&quot;</span>, userName);</span><br><span class="line">    User user = userMapper.selectOne(qw);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">    <span class="comment">//  授权</span></span><br><span class="line">    List&lt;String&gt; permissions = menuMapper.selectPermsByUserId(user.getId());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyUserDetails(user, permissions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义失败处理"><a href="#自定义失败处理" class="headerlink" title="自定义失败处理"></a>自定义失败处理</h1><p>​    我们希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>
<p>在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被<strong>ExceptionTranslationFilter</strong>捕获到。</p>
<ul>
<li><font color='red'>认证</font>过程中: 出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</li>
<li><font color='red'>授权</font>过程中: 出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</li>
</ul>
<p>所以我们需要自定义AuthenticationEntryPoint和AccessDeniedHandler实习类, 然后配置给SpringSecurity</p>
<p><strong>添加WebUtils工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUtils</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 渲染对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 待渲染的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderString</span><span class="params">(HttpServletResponse response, String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AuthenticationEntryPoint实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        ResponseResult result = <span class="keyword">new</span> ResponseResult(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;认证失败请重新登录&quot;</span>);</span><br><span class="line">        String json = JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AccessDeniedHandler实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        ResponseResult result = <span class="keyword">new</span> ResponseResult(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">        String json = JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置给SpringSecurity</strong></p>
<p>​    先注入对应的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br></pre></td></tr></table></figure>
<p>​    然后我们可以使用HttpSecurity对象的方法去配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">    <span class="comment">// 添加认证失败处理器</span></span><br><span class="line">    .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">    <span class="comment">// 添加授权失败处理器</span></span><br><span class="line">    .accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>​    浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p>
<p>​    前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>
<p>①先对SpringBoot配置，运行跨域请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②开启SpringSecurity的跨域访问</p>
<p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SecurityConfig的configure()添加以下代码</span></span><br><span class="line"><span class="comment">//允许跨域</span></span><br><span class="line">http.cors();</span><br></pre></td></tr></table></figure>
<h1 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h1><h2 id="权限校验方法"><a href="#权限校验方法" class="headerlink" title="权限校验方法"></a>权限校验方法</h2><p>​    我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：<strong>hasAnyAuthority，hasRole，hasAnyRole</strong>等。</p>
<p>​    hasAuthority方法实际是执行到了<strong>SecurityExpressionRoot</strong>的hasAuthority() , 其内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>
<ul>
<li>hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h2><p>​    我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAuthority</span><span class="params">(String authority)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取用户所有权限</span></span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        MyUserDetails userDetails = (MyUserDetails) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; list = userDetails.getPermissions();</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">return</span> list.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​     在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;test&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h2><p>​    我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">        	<span class="comment">// testCors接口需要 &quot;system:dept:list&quot; 权限</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/testCors&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list&quot;</span>)</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="各种处理器"><a href="#各种处理器" class="headerlink" title="各种处理器"></a>各种处理器</h1><h2 id="认证成功处理器"><a href="#认证成功处理器" class="headerlink" title="认证成功处理器"></a>认证成功处理器</h2><p>​    实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。</p>
<p>​    我们也可以自己去自定义成功处理器进行成功后的相应处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SGSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加认证成功处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 认证成功处理器</span></span><br><span class="line">        http.formLogin().successHandler(successHandler);</span><br><span class="line">		<span class="comment">// 所有接口需要认证</span></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="认证失败处理器"><a href="#认证失败处理器" class="headerlink" title="认证失败处理器"></a>认证失败处理器</h2><p>​    实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。</p>
<p>​    我们也可以自己去自定义失败处理器进行失败后的相应处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SGFailureHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证失败了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加认证失败处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="登出成功处理器"><a href="#登出成功处理器" class="headerlink" title="登出成功处理器"></a>登出成功处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SGLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title">LogoutSuccessHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandler logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.logout()</span><br><span class="line">                <span class="comment">//配置注销成功处理器</span></span><br><span class="line">                .logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结: </p>
<ul>
<li>上面的各种处理器用得少,因为前面的案例使用<strong>自定义jwt过滤器</strong>进行认证, 没有用到 UsernamePasswordAuthenticationFilter 过滤器</li>
<li>如果使用的是UsernamePasswordAuthenticationFilter 过滤器,可以在 认证成功过滤器中添加 一些逻辑,例如:<ul>
<li>生产jwt</li>
<li>将数据保存到redis</li>
</ul>
</li>
</ul>
<p>over..</p>
]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>springboot</tag>
        <tag>springSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>EasyExcel</title>
    <url>/2022/03/03/EasyExcel/</url>
    <content><![CDATA[<p><strong>EasyExcel</strong>是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。<br>github地址:<a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a>  . </p>
<p>EasyExcel重写了POI对07版Excel的解析，可以把内存消耗从100M左右降低到10M以内，并且再大的Excel不会出现内存溢出，03版仍依赖POI的SAX模式。并在上层做了模型转换的封装，让使用者更加简单方便<a id="more"></a></p>
<p><strong>特点</strong></p>
<ol>
<li>在数据模型层面进行了封装，使用简单</li>
<li>重写了07版本的Excel的解析代码，降低内存消耗，能有效避免OOM</li>
<li>只能操作Excel</li>
<li>不能读取图片</li>
</ol>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><strong>创建maven项目,并导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- EasyExcel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok 优雅编程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  学生出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 学生性别</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最简单的读"><a href="#最简单的读" class="headerlink" title="最简单的读"></a>最简单的读</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Read</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String path  =<span class="string">&quot;C:\\Users\\oddDog\\Desktop\\EasyExcel\\杭州黑马在线202003班学员信息表.xlsx&quot;</span>;</span><br><span class="line">        <span class="comment">// 工作簿对象</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	pathName  		文件路径；</span></span><br><span class="line"><span class="comment">        	head			每行数据对应的实体；Student.class</span></span><br><span class="line"><span class="comment">        	readListener	读监听器，每读一样就会调用一次该监听器的invoke方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ExcelReaderBuilder read = EasyExcel.read(path, Student.class, <span class="keyword">new</span> MyReadListener());</span><br><span class="line">        <span class="comment">// 获取第一个sheet,可传integer与string类型参数</span></span><br><span class="line">        ExcelReaderSheetBuilder sheet = read.sheet();</span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        sheet.doRead();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义Excel的监听器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 每读取一行调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Student student, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部读取完毕后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最简单的写"><a href="#最简单的写" class="headerlink" title="最简单的写"></a>最简单的写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Write</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作簿对象</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String pathName 写入文件的路径</span></span><br><span class="line"><span class="comment">            Class head      写入文件的对象类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExcelWriterBuilder write = EasyExcel.write(<span class="string">&quot;hui.xlsx&quot;</span>, Student.class);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        write.sheet().doWrite(initData());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化10条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Student(<span class="string">&quot;hui&quot;</span> + i, <span class="keyword">new</span> Date(), <span class="string">&quot;男&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入数据的顺序是实体类中字段从上到下的顺序. 表头是属性名.可使用 <code>@ExcelProperty</code>注解来定义</p>
<h1 id="常用的API及注解"><a href="#常用的API及注解" class="headerlink" title="常用的API及注解"></a>常用的API及注解</h1><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><ul>
<li><strong>EasyExcel</strong> 入口类，用于构建开始各种操作；</li>
<li><strong>ExcelReaderBuilder</strong> 构建出一个ReadWorkbook对象，即一个工作簿对象，对应的是一个Excel文件；</li>
<li><strong>ExcelWriterBuilder</strong> 构建出一个WriteWorkbook对象，即一个工作簿对象，对应的是一个Excel文件；</li>
<li><strong>ExcelReaderSheetBuilder</strong> 构建出一个ReadSheet对象，即一个工作表的对象，对应的Excel中的每个sheet，一个工作簿可以有多个工作表；</li>
<li><strong>ExcelWriterSheetBuilder</strong> 构建出一WriteSheet对象，即一个工作表的对象，对应的Excel中的每个sheet，一个工作簿可以有多个工作表；</li>
<li><strong>ReadListener</strong> 在每一行读取完毕后都会调用ReadListener来处理数据，我们可以把调用service的代码可以写在其<code>invoke</code>方法内部；</li>
<li><strong>WriteHandler</strong> 在每一个操作包括创建单元格、创建表格等都会调用WriteHandler来处理数据，对使用者透明不可见；</li>
<li><strong>所有配置都是继承的</strong> Workbook的配置会被Sheet继承。所以在用EasyExcel设置参数的时候，在EasyExcel…sheet()方法之前作用域是整个sheet，之后针对单个sheet。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="ExcelProperty"><a href="#ExcelProperty" class="headerlink" title="@ExcelProperty"></a>@ExcelProperty</h3><p><strong>可选属性：</strong></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th align="left">含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td align="left">对应Excel表中的列数</td>
<td>默认-1，建议指定时从0开始</td>
</tr>
<tr>
<td>value</td>
<td align="left">对应Excel表中的列头</td>
<td></td>
</tr>
<tr>
<td>converter</td>
<td align="left">成员变量转换器</td>
<td>自定义转换器需要实Converter接口</td>
</tr>
</tbody></table>
<p><strong>使用效果</strong>：index属性可以指定当前字段对应excel中的哪一列，可以根据列名value去匹配，也可以不写。</p>
<p>如果不使用@ExcelProperty注解，成员变量从上到下的顺序，对应表格中从左到右的顺序；</p>
<p>( 如果要设置复杂的头，可以为value指定多个值 )</p>
<p><strong>使用建议：</strong>要么全部用index，要么全部用value匹配，尽量不要混着用</p>
<p><strong>例如</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;编号&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;学生姓名&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;学生性别&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;学生出生日期&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure>
<h3 id="ExcelIgnore"><a href="#ExcelIgnore" class="headerlink" title="@ExcelIgnore"></a>@ExcelIgnore</h3><p>标注在成员变量上，默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</p>
<h3 id="DateTimeFormat"><a href="#DateTimeFormat" class="headerlink" title="@DateTimeFormat"></a>@DateTimeFormat</h3><p>标注在成员变量上，日期转换，代码中String类型的成员变量去接收excel中日期格式的数据会调用这个注解。里面的value参照<code>java.text.SimpleDateForma</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;java</span><br></pre></td></tr></table></figure>
<h3 id="NumberFormat"><a href="#NumberFormat" class="headerlink" title="@NumberFormat"></a>@NumberFormat</h3><p>标注在成员变量上，数字转换，代码中用String类型的成员变量去接收excel数字格式的数据会调用这个注解。里面的value参照<code>java.text.DecimalFormat</code></p>
<h3 id="ExcelIgnoreUnannotated"><a href="#ExcelIgnoreUnannotated" class="headerlink" title="@ExcelIgnoreUnannotated"></a>@ExcelIgnoreUnannotated</h3><p>标注在类上。不标注该注解时，默认类中所有成员变量都会参与读写，无论是否在成员变量上加了<code>@ExcelProperty</code> 的注解。</p>
<p>标注该注解后，类中的成员变量如果没有标注<code>@ExcelProperty</code> 注解将不会参与读写.(用的少)</p>
<h3 id="ContentRowHeight"><a href="#ContentRowHeight" class="headerlink" title="@ContentRowHeight()"></a>@ContentRowHeight()</h3><p>标注在类上或属性上，指定内容行高</p>
<h3 id="HeadRowHeight"><a href="#HeadRowHeight" class="headerlink" title="@HeadRowHeight()"></a>@HeadRowHeight()</h3><p>标注在类上或属性上，指定列头行高</p>
<h3 id="ColumnWidth"><a href="#ColumnWidth" class="headerlink" title="@ColumnWidth()"></a>@ColumnWidth()</h3><p>标注在类上或属性上，指定列宽</p>
<h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><p>基于SpringMVC的文件上传和下载</p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringMVC（Spring） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hui.demo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MVC文件上传多部件解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生性别&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生出生日期&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他配置省略</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><strong>回调监听器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>	<span class="comment">// 作者要求每次读取都要使用新的Listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentReadListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_SAVE_NUM = <span class="number">5</span>;</span><br><span class="line">   	<span class="keyword">private</span> ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每读5行保存一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Student data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="keyword">if</span> (++count % BATCH_SAVE_NUM == <span class="number">0</span>) &#123;</span><br><span class="line">            studentService.save(students); <span class="comment">// 调用service层进行保存</span></span><br><span class="line">            students.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部读完之后，会调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUploadAndDownload</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * 1. 编写excel中每一行对应的实体类</span></span><br><span class="line"><span class="comment">     * 2. 由于默认异步读取excel，所以需要逐行读取的回调监听器</span></span><br><span class="line"><span class="comment">     * 3. 开始读取Excel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentReadListener studentReadListener;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;upload&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExcelReaderBuilder workBook = EasyExcel.read(file.getInputStream(), Student.class, studentReadListener);</span><br><span class="line">        workBook.sheet().doRead();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUploadAndDownload</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     * 1. 编写实体类并创建对象以便写入表格</span></span><br><span class="line"><span class="comment">     * 2. 设置响应参数：文件的ContentType和文件名，同时设置编码避免乱码</span></span><br><span class="line"><span class="comment">     * 3. 直接写，内部会调用finish方法自动关闭OutputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;download&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置相应参数等配置</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        String fileName = URLEncoder.encode(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 防止中文乱码 </span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename*=UTF-8&#x27;&#x27;&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        ExcelWriterBuilder workBook = EasyExcel.write(response.getOutputStream(), Student.class);</span><br><span class="line">        ExcelWriterSheetBuilder sheet = workBook.sheet();</span><br><span class="line">        sheet.doWrite(initData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>EasyExcel支持调整行高、列宽、背景色、字体大小等内容，但是控制方式与使用原生POI无异，比较繁琐，不建议使用。</p>
<p>但是可以使用模板填充的方式，向预设样式的表格中直接写入数据，写入数据的时候会保持原有样式。</p>
<h2 id="一组数据填充"><a href="#一组数据填充" class="headerlink" title="一组数据填充"></a>一组数据填充</h2><p>​    Excel表格中用{} 来表示包裹要填充的变量，如果单元格文本中本来就有<code>&#123;</code>、<code>&#125;</code>左右大括号，需要在括号前面使用斜杠转义<code>\&#123;</code>、<code>\&#125;</code>。</p>
<p>​    填充数据可使用实体类与map集合,不过变量名称要一致</p>
<p><strong>准备模板</strong></p>
<p><a href="https://imgtu.com/i/bJyG1H"><img src="https://s4.ax1x.com/2022/03/03/bJyG1H.png" alt="bJyG1H.png"></a></p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载模板</span></span><br><span class="line">    InputStream templateFile = </span><br><span class="line">        FillData.class.getClassLoader().getResourceAsStream(<span class="string">&quot;fill_data_template1.xlsx&quot;</span>);</span><br><span class="line">    <span class="comment">// 生成工作簿对象,并指定模板</span></span><br><span class="line">    ExcelWriterBuilder workBookWriter = EasyExcel.write(<span class="string">&quot;单组数据填充.xlsx&quot;</span>).withTemplate(templateFile);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ********* 使用实体类填充 ********</span></span><br><span class="line">    FillData fillData = <span class="keyword">new</span> FillData(<span class="string">&quot;hui&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 获取工作表并填充</span></span><br><span class="line">    workBookWriter.sheet().doFill(fillData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ********* 使用Map数据填充 ********</span></span><br><span class="line">    <span class="comment">// HashMap&lt;String, String&gt; mapFillData = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// mapFillData.put(&quot;name&quot;, &quot;hui&quot;);</span></span><br><span class="line">    <span class="comment">// mapFillData.put(&quot;age&quot;, &quot;11&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个工作表填充并自动关闭流</span></span><br><span class="line">    <span class="comment">// workBookWriter.sheet().doFill(mapFillData);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多组数据填充"><a href="#多组数据填充" class="headerlink" title="多组数据填充"></a>多组数据填充</h2><p><strong>模板</strong></p>
<p><a href="https://imgtu.com/i/bJcrOs"><img src="https://s4.ax1x.com/2022/03/03/bJcrOs.png" alt="bJcrOs.png"></a></p>
<p><strong>填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载模板</span></span><br><span class="line">    InputStream templateFile = FillData.class.getClassLoader().getResourceAsStream(</span><br><span class="line">            <span class="string">&quot;fill_data_template2.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成工作簿对象,并指定模板</span></span><br><span class="line">    ExcelWriterBuilder workBookWriter = EasyExcel.write(<span class="string">&quot;多组数据填充.xlsx&quot;</span>).withTemplate(templateFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个工作表填充并自动关闭流</span></span><br><span class="line">    workBookWriter.sheet().doFill(initData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合填充"><a href="#组合填充" class="headerlink" title="组合填充"></a>组合填充</h2><p>即有多组数据填充，又有单一数据填充，为了避免两者数据出现冲突覆盖的情况，在多组填充时需要通过<code>FillConfig</code>对象设置换行。</p>
<p>如果单一数据在多组数据上面,则不需要设置换行</p>
<p><strong>模板</strong></p>
<p><a href="https://imgtu.com/i/bJguBn"><img src="https://s4.ax1x.com/2022/03/03/bJguBn.png" alt="bJguBn.png"></a></p>
<p><strong>填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模板</span></span><br><span class="line">    InputStream templateFile = FillData.class.getClassLoader().getResourceAsStream(</span><br><span class="line">            <span class="string">&quot;fill_data_template3.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成工作簿对象,并指定模板</span></span><br><span class="line">    <span class="comment">// 这里调用了build()方法,生成的是ExcelWriter对象,需要我们手动关闭</span></span><br><span class="line">    ExcelWriter excelWriter = EasyExcel.write(<span class="string">&quot;组合数据填充.xlsx&quot;</span>).withTemplate(templateFile).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成工作表对象</span></span><br><span class="line">     <span class="comment">// 这里调用了build()方法,生成的是WriteSheet对象</span></span><br><span class="line">    WriteSheet writeSheet = EasyExcel.writerSheet().build();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 组合填充时，因为多组填充的数据量不确定，需要在多组填充完之后另起一行</span></span><br><span class="line">    FillConfig fillConfig = FillConfig.builder().forceNewRow(<span class="keyword">true</span>).build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充多组数据并换行</span></span><br><span class="line">    List&lt;FillData&gt; fillDatas = initData();</span><br><span class="line">    excelWriter.fill(fillDatas, fillConfig, writeSheet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充单组数据</span></span><br><span class="line">    HashMap&lt;String, String&gt; otherData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    otherData.put(<span class="string">&quot;date&quot;</span>, <span class="string">&quot;2020-03-14&quot;</span>);</span><br><span class="line">    otherData.put(<span class="string">&quot;total&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">    excelWriter.fill(otherData, writeSheet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="水平填充"><a href="#水平填充" class="headerlink" title="水平填充"></a>水平填充</h2><p>水平填充和多组填充模板一样，不一样的地方在于，填充时需要通过<code>FillConfig</code>对象设置水平填充</p>
<p><strong>模板</strong></p>
<p><a href="https://imgtu.com/i/bJ2cGT"><img src="https://s4.ax1x.com/2022/03/03/bJ2cGT.png" alt="bJ2cGT.png"></a></p>
<p><strong>填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模板</span></span><br><span class="line">    InputStream templateFile = FillData.class.getClassLoader().getResourceAsStream(</span><br><span class="line">            <span class="string">&quot;fill_data_template4.xlsx&quot;</span>);</span><br><span class="line">    <span class="comment">// 生成工作簿对象</span></span><br><span class="line">    ExcelWriter excelWriter = EasyExcel.write(<span class="string">&quot;水平数据填充.xlsx&quot;</span>).withTemplate(templateFile).build();</span><br><span class="line">    <span class="comment">// 生成工作表对象</span></span><br><span class="line">    WriteSheet writeSheet = EasyExcel.writerSheet().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合填充时，因为多组填充的数据量不确定，需要在多组填充完之后另起一行</span></span><br><span class="line">    FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();</span><br><span class="line">    <span class="comment">// 填充多组数据</span></span><br><span class="line">    List&lt;FillData&gt; fillDatas = initData();</span><br><span class="line">    excelWriter.fill(fillDatas, fillConfig, writeSheet);</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>EasyExcel 采用的是一行一行写入的方式，不能实现删除和移动行，也不支持备注写入。多组数据写入的时候，如果需要新增行，只能在最后一行增加，不能在中间位置添加.</p>
<p>over…</p>
]]></content>
      <categories>
        <category>java工具</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2022/04/06/netty/</url>
    <content><![CDATA[<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p><strong>Netty 的地位</strong></p>
<p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！<a id="more"></a></p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p><strong>创建maven工程,加入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>
</li>
<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/qxRxJA"><img src="https://s1.ax1x.com/2022/04/07/qxRxJA.png" alt="qxRxJA.png"></a></p>
<ul>
<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>
</li>
<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p>
</li>
<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>
</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>
</li>
<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>
<p><a href="https://imgtu.com/i/qxWqlq"><img src="https://s1.ax1x.com/2022/04/07/qxWqlq.png" alt="qxWqlq.png"></a></p>
</li>
<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，指定要连接的服务器和端口</p>
</li>
<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法同步等待 connect 建立连接完毕</p>
</li>
<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>
</li>
<li><p>7 处，写入消息并清空缓冲区</p>
</li>
<li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p>
</li>
</ul>
<p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>
<p><strong>理解</strong></p>
<blockquote>
<p>一开始需要树立正确的观念</p>
<ul>
<li>把 channel 理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 Inbound 和 Outbound 两类</li>
</ul>
</li>
<li>把 eventLoop 理解为处理数据的工人<ul>
<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><strong>事件循环对象</strong></p>
<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong></p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line">DefaultEventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next()); <span class="comment">// io.netty.channel.DefaultEventLoop@60f82f98</span></span><br><span class="line">System.out.println(group.next()); <span class="comment">// io.netty.channel.DefaultEventLoop@35f983a6</span></span><br><span class="line">System.out.println(group.next()); <span class="comment">// io.netty.channel.DefaultEventLoop@60f82f98</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// io.netty.channel.DefaultEventLoop@60f82f98</span></span><br><span class="line"><span class="comment">// io.netty.channel.DefaultEventLoop@35f983a6</span></span><br></pre></td></tr></table></figure>
<p><strong>优雅关闭</strong></p>
<p> <code>EventLoopGroup.shutdownGracefully()</code> 方法能实现优雅关闭。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h3 id="NioEventLoop-处理-io-事件"><a href="#NioEventLoop-处理-io-事件" class="headerlink" title="NioEventLoop 处理 io 事件"></a>NioEventLoop 处理 io 事件</h3><p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    <span class="comment">// eventLoop细分,boss(处理accept)  worker</span></span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// ByteBuf转换成String</span></span><br><span class="line">            nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">            <span class="comment">// 处理器1</span></span><br><span class="line">            nioSocketChannel.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   log.debug(msg); <span class="comment">// 日志输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<p>启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>))</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel();</span><br><span class="line"></span><br><span class="line">channel.writeAndFlush(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">channel.writeAndFlush(<span class="string">&quot;zhangsan&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>服务端输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu </span><br></pre></td></tr></table></figure>
<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>
<p><strong>事件交给别的EventLoopGroup线程处理</strong></p>
<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个非 nio 工人</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    <span class="comment">// eventLoop细分,boss  worker</span></span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// ByteBuf转换成String</span></span><br><span class="line">            nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">            <span class="comment">// 处理器1</span></span><br><span class="line">            nioSocketChannel.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(msg); <span class="comment">// 日志输出</span></span><br><span class="line">                    <span class="comment">// 提交给下一个handler处理</span></span><br><span class="line">                    channelHandlerContext.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 处理器2,添加了一个EventLoopGroup,事件交给别的线程处理</span></span><br><span class="line">            nioSocketChannel.pipeline().addLast(group, <span class="string">&quot;handler2&quot;</span>, <span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(msg); <span class="comment">// 日志输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>客户端代码不变，同样启动三次</p>
<p>可以发现，处理器1由nio 工人处理,  处理器2 由非 nio 工人处理 . 无论是nio工人还是非nio工人都是轮流处理 channel，且工人与 channel 之间进行了绑定.</p>
<h3 id="handler-执行中如何换线程"><a href="#handler-执行中如何换线程" class="headerlink" title="handler 执行中如何换线程"></a>handler 执行中如何换线程</h3><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>
</ul>
<h3 id="NioEventLoop-处理普通任务"><a href="#NioEventLoop-处理普通任务" class="headerlink" title="NioEventLoop 处理普通任务"></a>NioEventLoop 处理普通任务</h3><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup nioWorkers = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用来执行耗时较长的任务</p>
</blockquote>
<h3 id="NioEventLoop-处理定时任务"><a href="#NioEventLoop-处理定时任务" class="headerlink" title="NioEventLoop 处理定时任务"></a>NioEventLoop 处理定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup nioWorkers = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 0秒后执行任务,1秒的频率</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用来执行定时任务</p>
</blockquote>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>channel 的主要作用</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>将之前的客户端代码拆开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 返回 ChannelFuture 对象,可调用channel()来获取channel对象</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>
<p><strong>同步等待连接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 连接未建立，打印 `[id: 0x2e1884dd]`</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 同步等待连接建立完成</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 连接建立，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`</span></span><br></pre></td></tr></table></figure>
<p><strong>异步等待连接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 连接未建立，打印 `[id: 0x749124ba]`</span></span><br><span class="line"><span class="comment">// 异步,给nio线程传递一个回调,连接成功后调用</span></span><br><span class="line">channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel c = channelFuture.channel();</span><br><span class="line">        System.out.println(c); <span class="comment">// 连接建立，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h3><p>客户端连接后开启一条线程,用户可循环输入内容, 如果输入’q’,就关闭连接 , channel.close(), 但是该方法是异步的.</p>
<p>这时需要 CloseFuture 来做善后工作,如关闭eventLoopGroup对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        channel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同步等待连接</span></span><br><span class="line">        Channel channel = channelFuture.sync().channel();</span><br><span class="line">        <span class="comment">// 开启一个线程,客户端循环输入内容</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String next = scanner.next();</span><br><span class="line">                <span class="comment">// 关闭</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(next)) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取closeFuture对象</span></span><br><span class="line">         ChannelFuture closeFuture对象 = channel.closeFuture();</span><br><span class="line">        <span class="comment">// 1.同步</span></span><br><span class="line">        closeFuture.sync(); <span class="comment">// 阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程:关闭后的操作&quot;</span>);</span><br><span class="line">        group.shutdownGracefully();  <span class="comment">// 优雅关闭 NioEventLoopGroup 中的线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.异步,给nio线程传递一个回调,关闭channel时调用</span></span><br><span class="line"><span class="comment">//        closeFuture.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;其他线程:关闭后的操作&quot;);</span></span><br><span class="line"><span class="comment">//                group.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future&amp;Promise"></a>Future&amp;Promise</h2><p>在异步处理时，经常用到这两个接口</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<p><strong>同步处理任务成功</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop executors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise(executors);</span><br><span class="line"></span><br><span class="line">executors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    promise.setSuccess(<span class="string">&quot;hhh&quot;</span>); <span class="comment">// 两秒后设置成功结果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 还没有结果</span></span><br><span class="line">System.out.println(promise.getNow());</span><br><span class="line"><span class="comment">// 同步获取</span></span><br><span class="line">System.out.println(promise.get());</span><br></pre></td></tr></table></figure>
<p><strong>异步处理任务成功</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop executors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise(executors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加回调,异步接收结果</span></span><br><span class="line">promise.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> String&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 用的是executors中的线程处理结果</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        System.out.println(future.getNow()); <span class="comment">// 获取值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    promise.setSuccess(<span class="string">&quot;hhh&quot;</span>); <span class="comment">// 两秒后设置成功结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>同步处理任务失败</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop executors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise(executors);</span><br><span class="line"></span><br><span class="line">executors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    promise.setFailure(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;error&quot;</span>)); <span class="comment">// 两秒后设置失败结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 抛出异常,使用sync() 也会出现异常</span></span><br><span class="line"><span class="comment">//System.out.println(promise.get()); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 等待结果, 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class="line">promise.await(); </span><br><span class="line"><span class="comment">// 自行判断结果,进行处理</span></span><br><span class="line">String res =  promise.isSuccess()?promise.getNow():promise.cause().toString();</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure>
<p><strong>异步处理任务失败</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop executors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise(executors);</span><br><span class="line"></span><br><span class="line">promise.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> String&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 不抛异常,自行判断</span></span><br><span class="line">        System.out.println(future.isSuccess() ? future.getNow() : future.cause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    promise.setFailure(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;error&quot;</span>)); <span class="comment">// 两秒后设置失败结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler&amp;Pipeline"></a>Handler&amp;Pipeline</h2><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 <code>ChannelInboundHandlerAdapter</code> 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 <code>ChannelOutboundHandlerAdapter</code> 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1  数据传递下一个处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2  数据传递下一个处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3  写出数据,从尾部触发出战处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4  写出数据,触发上一个出站处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5  写出数据,触发上一个出站处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6  写出数据,触发上一个出站处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>服务器端打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>
<p><a href="https://imgtu.com/i/LplTcq"><img src="https://s1.ax1x.com/2022/04/08/LplTcq.png" alt="LplTcq.png"></a></p>
<ul>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
</li>
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
</li>
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
</li>
<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>
</ul>
</li>
</ul>
<h2 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h2><p>ButeBuf是对字节数据的封装</p>
<p><strong>输出工具</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</span></span><br><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也可使用ChannelHandler中的 channelHandlerContext 分配</span></span><br><span class="line">ByteBuf buffer =  ctx.alloc().buffer();</span><br></pre></td></tr></table></figure>
<p><strong>ByteBuf 由四部分组成</strong></p>
<p><a href="https://imgtu.com/i/LpJQzj"><img src="https://s1.ax1x.com/2022/04/08/LpJQzj.png" alt="LpJQzj.png"></a></p>
<p>最开始读写指针都在 0 位置</p>
<h3 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h3><p>创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h3 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h3><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>ByteBuf.write…() 方法,写入各种数据.</p>
<ul>
<li>这些方法的返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>写入一个数据时，容量不够了（初始容量是 10），这时会引发扩容</p>
<p><strong>扩容规则</strong></p>
<ul>
<li>如果写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<p>如何需要重复读取:</p>
<p>可以在 read 前先做个标记 mark , 这时要重复读取的话，重置到标记位置 reset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex(); <span class="comment">// 标记</span></span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br><span class="line">buffer.resetReaderIndex(); <span class="comment">// 重置</span></span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>
<h3 id="retain-amp-release"><a href="#retain-amp-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h3><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p><strong>谁来负责 release 呢</strong></p>
<p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>:</p>
<ul>
<li>入站 ByteBuf 处理原则<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li>出站 ByteBuf 处理原则<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release(无需我们处理)</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<p><strong>TailContext 释放未处理消息逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();  <span class="comment">// 计数-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p><a href="https://imgtu.com/i/LpJLtS"><img src="https://s1.ax1x.com/2022/04/08/LpJLtS.png" alt="LpJLtS.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 写入数据</span></span><br><span class="line"><span class="comment">// 切片,无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片</span></span><br><span class="line">ByteBuf slice = origin.slice();</span><br></pre></td></tr></table></figure>
<p>原始 ByteBuf 发生读(read)操作, slice 不受影响，因为它有独立的读写指针</p>
<p>slice 的内容发生了更改(set), 原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><strong>duplicate</strong></p>
<p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<p><a href="https://imgtu.com/i/LpYv4O"><img src="https://s1.ax1x.com/2022/04/08/LpYv4O.png" alt="LpYv4O.png"></a></p>
<p><strong>copy</strong></p>
<p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h3 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h3><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个ByteBuf</span></span><br><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2</p>
<ul>
<li>方法1 ,直接内存复制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf3 = ByteBufAllocator.DEFAULT.buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2,使用 CompositeByteBuf 组合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="keyword">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>
<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<p><strong>ByteBuf 优势</strong></p>
<ul>
<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<h1 id="双向通信案例"><a href="#双向通信案例" class="headerlink" title="双向通信案例"></a>双向通信案例</h1><p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 入站处理器</span></span><br><span class="line">            sc.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 获取并输出客户端消息</span></span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                    <span class="comment">// 响应相同的结果</span></span><br><span class="line">                    ByteBuf response = ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buf);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    buf.release(); <span class="comment">// 释放内存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            sc.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">            sc.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg; <span class="comment">// 获取内容</span></span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                    buf.release(); <span class="comment">// 释放内存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync().channel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一条线程,用户循环输入内容</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入内容:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出回调,异步</span></span><br><span class="line">channel.closeFuture().addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h1><h2 id="粘包半包现象"><a href="#粘包半包现象" class="headerlink" title="粘包半包现象"></a>粘包半包现象</h2><p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap</span><br><span class="line">                .group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        sc.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">// 输出结果</span></span><br><span class="line">                                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                log(buf);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭服务端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">        <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">            .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">            .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">            .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">            .append(NEWLINE);</span><br><span class="line">        appendPrettyHexDump(buf, buffer);</span><br><span class="line">        System.out.println(buf.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="comment">// 建立连接后,发送10次消息</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                        ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                                        buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">                                        ctx.writeAndFlush(buf);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">                                    ctx.close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭客户端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务端与客户端,可以看到服务器一次就接收了 160 个字节，而非分 10 次接收,出现了粘包现象.</p>
<p><strong>修改其服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 固定其接收缓冲区,会造成半包问题</span></span><br><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>修改客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个消息,大小为160字节</span></span><br><span class="line">ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);  </span><br></pre></td></tr></table></figure>
<p>可以看到服务器接收的消息被分为两次，第一次 20 字节，第二次 140 字节,出现半包现象.</p>
<p><strong>注意</strong></p>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
<h3 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h3><p>客户端发送消息后,立刻断开连接 (以解决粘包为例)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortLinkClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送10次消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="comment">// 建立连接后,发送消息,断开连接</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                                ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                                buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buf);</span><br><span class="line">                                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">                                ctx.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭客户端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>
<h3 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h3><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>
<p>客户端代码, 发送数据如果没超过8字节,就用 ‘_’ 填充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="comment">// 建立连接后,发送10条消息,其长度固定</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                                <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                                ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                    String str = getString(c, random.nextInt(<span class="number">8</span>) + <span class="number">1</span>);</span><br><span class="line">                                    buf.writeBytes(str.getBytes());</span><br><span class="line">                                    ctx.writeAndFlush(buf);</span><br><span class="line">                                    c++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">                                ctx.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭客户端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长度为8的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; length) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h3 id="固定分隔符"><a href="#固定分隔符" class="headerlink" title="固定分隔符"></a>固定分隔符</h3><p>服务端加入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认以 \n 或 \r\n 作为分隔符，如果超出指定长度(1024)仍未出现分隔符，则抛出异常</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<p>客户端在每条消息之后，加入 \n 分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBaseClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="comment">// 建立连接后,发送10条消息,数据结尾添加分隔符</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                                <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                                ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                    String str = getString(c, random.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                    buf.writeBytes(str.getBytes());</span><br><span class="line">                                    ctx.writeAndFlush(buf);</span><br><span class="line">                                    c++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">                                ctx.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭客户端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串,其后添加分隔符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h3 id="预设长度"><a href="#预设长度" class="headerlink" title="预设长度"></a>预设长度</h3><p>服务端加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预设长度帧解码器: 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">sc.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthFieldBaseClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="comment">// 建立连接后,发送2条数据</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                                ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line"></span><br><span class="line">                                send(buf, <span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">                                send(buf, <span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                                ctx.writeAndFlush(buf);</span><br><span class="line">                                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">                                ctx.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭客户端时的同步等待</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ByteBuf buf, String content)</span> </span>&#123;</span><br><span class="line">        buf.writeInt(content.length());   <span class="comment">// 写入长度</span></span><br><span class="line">        buf.writeBytes(content.getBytes()); <span class="comment">// 写入内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="协议设计与分析"><a href="#协议设计与分析" class="headerlink" title="协议设计与分析"></a>协议设计与分析</h1><p>TCP/IP 中消息传输基于流的方式，没有边界。协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<h2 id="http协议举例"><a href="#http协议举例" class="headerlink" title="http协议举例"></a>http协议举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 添加 http协议 编解码器</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, HttpRequest httpRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(httpRequest.getUri());</span><br><span class="line">                                <span class="comment">// 创建一个response</span></span><br><span class="line">                                DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(httpRequest.getProtocolVersion(), HttpResponseStatus.OK);</span><br><span class="line">                                <span class="comment">// 写入响应内容</span></span><br><span class="line">                                <span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line">                                response.content().writeBytes(bytes);</span><br><span class="line">                                <span class="comment">// 写入内容长度</span></span><br><span class="line">                                response.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, bytes.length);</span><br><span class="line">                                <span class="comment">// 将response写出去</span></span><br><span class="line">                                channelHandlerContext.writeAndFlush(response);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8888</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p><strong>基本要素</strong></p>
<ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组(序列化)</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="comment">// 获取正文</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        <span class="comment">// 输出内容</span></span><br><span class="line">        System.out.println(magicNum + <span class="string">&quot;,&quot;</span> + version + <span class="string">&quot;,&quot;</span> + serializerType + <span class="string">&quot;,&quot;</span> + messageType + <span class="string">&quot;,&quot;</span> + sequenceId + <span class="string">&quot;,&quot;</span> + length);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="comment">// 将message传递到给后面的处理器</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">    <span class="comment">// 添加预设长度帧解码器,解决粘包半包</span></span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> MessageCodec()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 测试 encode</span></span><br><span class="line">LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;odd-dog&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">channel.writeOutbound(message); <span class="comment">// 出站</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 测试 decode</span></span><br><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>, message, buf);</span><br><span class="line">log(buf);  <span class="comment">// 打印encode后的结果</span></span><br><span class="line"><span class="comment">// 模拟半包问题</span></span><br><span class="line">ByteBuf s1 = buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">ByteBuf s2 = buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain();  <span class="comment">// 引用计算+1 (  writeInbound()方法会自动调用 s1.release()  )</span></span><br><span class="line"><span class="comment">// 两次入站</span></span><br><span class="line">channel.writeInbound(s1);</span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>
<h3 id="shareable"><a href="#shareable" class="headerlink" title="@shareable"></a>@shareable</h3><p>加了@shareable注解的处理器类,可以被多个channelHandler共享</p>
<p><strong>什么时候能加@shareable</strong></p>
<ul>
<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>
<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>
<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>
</ul>
<p><strong>修改自定义编解码器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="comment">// 将message传递给后面的处理器</span></span><br><span class="line">        list.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="comment">// 将message传递给后面的处理器</span></span><br><span class="line">        list.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="聊天室案例"><a href="#聊天室案例" class="headerlink" title="聊天室案例"></a>聊天室案例</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>这里都是通过内存的实现类管理连接状态,具体业务代码我们无需太关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(Channel channel, String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(Channel channel, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天组会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">joinMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeGroup</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getMembers</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Channel&gt; <span class="title">getMembersChannel</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h2><p><strong>登入处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String username = msg.getUsername();</span><br><span class="line">        String password = msg.getPassword();</span><br><span class="line">        <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span>(login) &#123;</span><br><span class="line">            <span class="comment">// 绑定</span></span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>封装预设长度编解码器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLengthFieldBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">LengthFieldBasedFrameDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLengthFieldBasedFrameDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLengthFieldBasedFrameDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">int</span> lengthFieldOffset, <span class="keyword">int</span> lengthFieldLength, <span class="keyword">int</span> lengthAdjustment, <span class="keyword">int</span> initialBytesToStrip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// group</span></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// message编解码器</span></span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="comment">// 登入消息处理器</span></span><br><span class="line">        LoginRequestMessageHandler loginRequestMessageHandler = <span class="keyword">new</span> LoginRequestMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 预设长度帧解码器</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    <span class="comment">// 自定义编码解码器</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    <span class="comment">// 客户端登入</span></span><br><span class="line">                    sc.pipeline().addLast(loginRequestMessageHandler);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">		<span class="comment">// message编解码器</span></span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">       	<span class="comment">// 用来等待登入结果</span></span><br><span class="line">        CountDownLatch WAIT_FOR_LOGIN = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 用户登入标识</span></span><br><span class="line">        AtomicBoolean LOGIN = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                LoginResponseMessage response = (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="keyword">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                String username = scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                String password = scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(username, password);</span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作...&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    WAIT_FOR_LOGIN.await(); <span class="comment">// 等待登入结果</span></span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send [username] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gmembers [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gjoin [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gquit [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    String command = scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>: <span class="comment">// 单聊</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> ChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>: <span class="comment">// 群聊</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>: <span class="comment">// 创建群</span></span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateRequestMessage(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>: <span class="comment">// 获取群聊成员</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersRequestMessage(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>: <span class="comment">// 加入群</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>: <span class="comment">// 退出群</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>: <span class="comment">// 退出客户端</span></span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h2><p>单聊处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ChatRequestMessage chatRequestMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对方channel</span></span><br><span class="line">        Channel channel = SessionFactory.getSession().getChannel(chatRequestMessage.getTo());</span><br><span class="line">        <span class="comment">// 在线</span></span><br><span class="line">        <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在线</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端添加单聊处理器</p>
<h2 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h2><p>创建群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupCreateRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 群管理器</span></span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        Group group = groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 发生成功消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">            <span class="comment">// 发送拉群消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">false</span>, groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取所有群内成员的channel</span></span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line">		<span class="comment">// 遍历,发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupJoinRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupJoinRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群加入成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupQuitRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupQuitRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupMembersRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupMembersRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembers(msg.getGroupName());</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersResponseMessage(members));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端添加群聊处理器</p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuitHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel()); <span class="comment">// 解除绑定</span></span><br><span class="line">        System.out.println(ctx.channel()+<span class="string">&quot;正常退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常退出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel()); <span class="comment">// 解除绑定</span></span><br><span class="line">        System.out.println(ctx.channel()+<span class="string">&quot;异常退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端添加退出处理器</p>
<h2 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h2><p><strong>连接假死</strong></p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p><strong>后果</strong></p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p><strong>服务端解决</strong></p>
<p>每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲检查  (读  写  读+写) , 10s 内没有读事件,会触发一个IdleState.READER_IDLE事件</span></span><br><span class="line">sc.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">sc.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">// 处理特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 长时间未读,断开连接</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            System.out.println(ctx + <span class="string">&quot;长时间未发送数据,即将断开连接!&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>客户端定时心跳</strong></p>
<p>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲检查(读  写  读+写) 5 s 内没有写事件,会触发一个IdleState.WRITE_IDLE事件</span></span><br><span class="line">sc.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">sc.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 长时间未写,发送心跳</span></span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            System.out.println(ctx.channel() + <span class="string">&quot;发送心跳&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> PingMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="扩展序列化算法"><a href="#扩展序列化算法" class="headerlink" title="扩展序列化算法"></a>扩展序列化算法</h2><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">byte</span>[] body = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(body));</span><br><span class="line">Message message = (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(out).writeObject(message);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure>
<p>为了支持更多序列化算法，<strong>抽象一个 Serializer 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInputStream in = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">                Object object = in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加配置类和配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">// 获取配置文件</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// 获取序列化算法方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.<span class="function">Algorithm <span class="title">getSerializerAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java; <span class="comment">// 默认java序列化方式</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">serializer.algorithm=Json</span><br></pre></td></tr></table></figure>
<p><strong>修改编解码器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 4字节魔数</span></span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1字节版本号</span></span><br><span class="line">        buf.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1字节序列化算法 0:jdk序列化  1:json格式</span></span><br><span class="line">        buf.writeByte(Config.getSerializerAlgorithm().ordinal()); <span class="comment">// 从配置文件中获取</span></span><br><span class="line">        <span class="comment">// 4. 1字节指令类型</span></span><br><span class="line">        buf.writeByte(message.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4字节请求序号</span></span><br><span class="line">        buf.writeInt(message.getSequenceId());</span><br><span class="line">        <span class="comment">// 1字节填充,无意义</span></span><br><span class="line">        buf.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 将消息转换成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(message);</span><br><span class="line">        <span class="comment">// 6. 4字节长度</span></span><br><span class="line">        buf.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 7. 消息正文</span></span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = buf.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = buf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializable = buf.readByte(); <span class="comment">//序列化算法 0:jdk序列化  1:json格式</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = buf.readByte(); <span class="comment">// 消息类型</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = buf.readInt();</span><br><span class="line">        buf.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = buf.readInt();</span><br><span class="line">        <span class="comment">// 获取正文</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        buf.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="comment">// 将byte数组转换成 message 类型</span></span><br><span class="line">        Serializer.Algorithm serializer = Serializer.Algorithm.values()[serializable];  <span class="comment">// 获取序列化算法类型</span></span><br><span class="line">        Class&lt;? extends Message&gt; aClass = Message.getMessageClass(messageType); <span class="comment">// 获取消息类型</span></span><br><span class="line">        Message message = serializer.deserialize(aClass, bytes); <span class="comment">// 反序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出内容</span></span><br><span class="line">        System.out.println(magicNum + <span class="string">&quot;,&quot;</span> + version + <span class="string">&quot;,&quot;</span> + serializable + <span class="string">&quot;,&quot;</span> + messageType + <span class="string">&quot;,&quot;</span> + sequenceId + <span class="string">&quot;,&quot;</span> + length);</span><br><span class="line">        System.out.println(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将message传递给后面的处理器</span></span><br><span class="line">        list.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决Gson中class类型序列化失败</strong></p>
<ul>
<li>转换类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义json序列化时 class类型的转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCodec</span> <span class="keyword">implements</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Class</span>&lt;?&gt;&gt;, <span class="title">JsonDeserializer</span>&lt;<span class="title">Class</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 反序列化,将字符串转换成class对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) <span class="keyword">throws</span> JsonParseException &#123;</span><br><span class="line">        String json = jsonElement.getAsString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化,直接将class类型转换成 全限定类名的字符串</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonElement <span class="title">serialize</span><span class="params">(Class&lt;?&gt; aClass, Type type, JsonSerializationContext jsonSerializationContext)</span> </span>&#123;</span><br><span class="line">        String className = aClass.getName();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonPrimitive(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改json序列化算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Json &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().registerTypeAdapter(Class.class, <span class="keyword">new</span> ClassCodec()).create();</span><br><span class="line">        String json = <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(json, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().registerTypeAdapter(Class.class, <span class="keyword">new</span> ClassCodec()).create();</span><br><span class="line">        String json = gson.toJson(object);</span><br><span class="line">        <span class="keyword">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>serverBootstrap.option(ChannelOption<T> childOption, T value)</td>
<td>服务端设置参数</td>
</tr>
<tr>
<td>serverBootstrap.childOption(ChannelOption<T> childOption, T value)</td>
<td>服务端设置连接客户端channel参数</td>
</tr>
<tr>
<td>bootstrap.option(ChannelOption<T> childOption, T value)</td>
<td>客户端设置参数</td>
</tr>
</tbody></table>
<p><strong>CONNECT_TIMEOUT_MILLIS</strong></p>
<ul>
<li>属于 SocketChannal 参数</li>
<li>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li>
<li>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootStrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>其源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了超时时间,添加定时任务</span></span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                ConnectTimeoutException cause =</span><br><span class="line">                    <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress); <span class="comment">// 断点2</span></span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SO_BACKLOG</strong></p>
<ul>
<li>属于 ServerSocketChannal 参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>
<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列(半连接)</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue(全连接)</li>
</ol>
<p>其中</p>
<ul>
<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
</li>
<li><p>sync queue - 半连接队列</p>
<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li><p>accept queue - 全连接队列</p>
<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<p>netty 中</p>
<p>可以通过  option(ChannelOption.SO_BACKLOG,  value) 来设置大小</p>
<p>可以通过下面源码查看默认大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title">DefaultChannelConfig</span></span></span><br><span class="line"><span class="class">                                              <span class="keyword">implements</span> <span class="title">ServerSocketChannelConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> backlog = NetUtil.SOMAXCONN;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<p><strong>TCP_NODELAY</strong></p>
<ul>
<li>属于 SocketChannal 参数</li>
<li>默认false, 表示开启 nagle算法</li>
</ul>
<p><strong>SO_SNDBUF &amp; SO_RCVBUF</strong></p>
<p>设置发送与接收缓冲区大小</p>
<p><strong>ALLOCATOR</strong></p>
<ul>
<li>属于 SocketChannal 参数</li>
<li>用来分配 ByteBuf， ctx.alloc()</li>
</ul>
<p>通过io.netty.channel.ChannelConfig的实现类io.netty.channel.DefaultChannelConfig中allocator属性,一步步跟踪进去,找到赋值语句,</p>
<p>可以发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.netty.allocator.type  设置&quot;unpooled&quot; 或 &quot;pooled&quot;类型的ByteBuf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.netty.noPreferDirect  设置是否采用直接内存</span><br></pre></td></tr></table></figure>
<p><strong>RCVBUF_ALLOCATOR</strong></p>
<ul>
<li>属于 SocketChannal 参数</li>
<li>控制 netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<h1 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h1><p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>RPC请求消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestMessage</span><span class="params">(<span class="keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="keyword">this</span>.parameterValue = parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RPC响应消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>service工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServicesFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">// 类似与spring中的IOC容器</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class="line">            <span class="comment">// 将配置文件中,接口与实现类的对应,存放在map中</span></span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;Service&quot;</span>)) &#123;</span><br><span class="line">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class="line">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class="line">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口对应相关实现类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关配置 application.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer.algorithm&#x3D;Json</span><br><span class="line">## 类似与spring配置</span><br><span class="line">com.hui.app.server.service.HelloService&#x3D;com.hui.app.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure>
<h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p><strong>基本架子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="comment">// rpc 请求消息处理器</span></span><br><span class="line">        RpcRequestMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcRequestMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    sc.pipeline().addLast(<span class="keyword">new</span> MyLengthFieldBasedFrameDecoder());</span><br><span class="line">                    sc.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    sc.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8888</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>处理RPC请求handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, RpcRequestMessage message)</span> </span>&#123;</span><br><span class="line">        RpcResponseMessage response = <span class="keyword">new</span> RpcResponseMessage();</span><br><span class="line">        response.setSequenceId(message.getSequenceId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据全限定类名找到对应的实现类</span></span><br><span class="line">            HelloService helloService = (HelloService) ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">            <span class="comment">// 找到对应方法</span></span><br><span class="line">            Method method = helloService.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">            <span class="comment">// 方法调用</span></span><br><span class="line">            Object invoke = method.invoke(helloService, message.getParameterValue());</span><br><span class="line"></span><br><span class="line">            response.setReturnValue(invoke); <span class="comment">// 成功结果</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            response.setExceptionValue(e); <span class="comment">// 异常结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果响应回去</span></span><br><span class="line">        channelHandlerContext.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试,如何解析一个RpcRequestMessage消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcRequestMessage message = <span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;com.hui.app.server.service.HelloService&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">            String.class,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;怪狗狗&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 根据全限定类名找到对应的实现类</span></span><br><span class="line">        HelloService helloService = (HelloService) ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">        <span class="comment">// 找到对应方法</span></span><br><span class="line">        Method method = helloService.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">        <span class="comment">// 方法调用</span></span><br><span class="line">        Object invoke = method.invoke(helloService, message.getParameterValue());</span><br><span class="line">        System.out.println(invoke);<span class="comment">// 打印消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="comment">// rpc 响应消息处理器</span></span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    sc.pipeline().addLast(<span class="keyword">new</span> MyLengthFieldBasedFrameDecoder());</span><br><span class="line">                    sc.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    sc.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)).sync().channel();</span><br><span class="line">            <span class="comment">// 发送RPC消息</span></span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="string">&quot;com.hui.app.server.service.HelloService&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">                String.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;怪狗狗&quot;</span>&#125;</span><br><span class="line">            ));</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>处理RPC响应handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg); <span class="comment">// 简单输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个简单的RPC调用就设计好了</p>
<ul>
<li>但是如果每次发送消息都发送RpcRequestMessage类型,调用方就会很麻烦;</li>
<li>并且结果存放在RpcResponseMessageHandler中,不能直接获取</li>
</ul>
<p>所以客户端代码需要优化.</p>
<h2 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h2><p><strong>自增代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger id = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcChannelManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxyService</span><span class="params">(Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = service.getClassLoader();</span><br><span class="line">        Class[] classes = <span class="keyword">new</span> Class[]&#123;service&#125;;</span><br><span class="line">        </span><br><span class="line">        Object o = Proxy.newProxyInstance(classLoader, classes, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 创建rpc请求消息</span></span><br><span class="line">                <span class="keyword">int</span> sequenceId = SequenceIdGenerator.nextId();  <span class="comment">// 序列号,自增</span></span><br><span class="line">                RpcRequestMessage message = <span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                        sequenceId,</span><br><span class="line">                        service.getName(),</span><br><span class="line">                        method.getName(),</span><br><span class="line">                        method.getReturnType(),</span><br><span class="line">                        method.getParameterTypes(),</span><br><span class="line">                        args</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                getChannel().writeAndFlush(message);</span><br><span class="line">                <span class="comment">// 创建promise对象,                                   指定 promise 对象异步接收结果线程</span></span><br><span class="line">                DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(channel.eventLoop());</span><br><span class="line">                RpcResponseMessageHandler.PROMISES.put(sequenceId, promise); <span class="comment">// 放入RPC响应handler中</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这种写法就是使用异步接收结果</span></span><br><span class="line"><span class="comment">//                promise.addListener(future -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                      // 接收结果</span></span><br><span class="line"><span class="comment">//                &#125;);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待结果,该方法是同步,还是使用主线程接收结果</span></span><br><span class="line">                promise.await();</span><br><span class="line">                <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">                    <span class="comment">// 成功,返回结果</span></span><br><span class="line">                    <span class="keyword">return</span> promise.getNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 失败,抛出</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(promise.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取channel,单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    initChannel();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="comment">// rpc 响应消息处理器</span></span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    sc.pipeline().addLast(<span class="keyword">new</span> MyLengthFieldBasedFrameDecoder());</span><br><span class="line">                    sc.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    sc.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            channel = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>)).sync().channel();</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    group.shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>处理RPC响应handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 sequenceId 获取promise</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, RpcResponseMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 找到对应的 promise,并移除</span></span><br><span class="line">        Promise&lt;Object&gt; promise = PROMISES.remove(message.getSequenceId());</span><br><span class="line">        <span class="comment">// 将结果写入promise</span></span><br><span class="line">        Exception exceptionValue = message.getExceptionValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceptionValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功返回</span></span><br><span class="line">            promise.setSuccess(message.getReturnValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">            promise.setFailure(exceptionValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取代理类</span></span><br><span class="line">    HelloService proxyService = RpcChannelManager.getProxyService(HelloService.class);</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    String res1 = proxyService.sayHello(<span class="string">&quot;怪狗狗&quot;</span>);</span><br><span class="line">    System.out.println(res1);</span><br><span class="line">    String res2 = proxyService.sayHello(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    System.out.println(res2);</span><br><span class="line">    String res3 = proxyService.sayHello(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">    System.out.println(res3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>网络框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
