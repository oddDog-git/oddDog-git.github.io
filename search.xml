<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇</title>
    <url>/2021/02/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="你知道ma"><a href="#你知道ma" class="headerlink" title="你知道ma"></a>你知道ma</h1><a id="more"></a>

<h2 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h2><p><a href="https://www.baidu.com/">百度</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组与稀疏数组</title>
    <url>/2021/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组与稀疏数组之间的转变说明（图）"><a href="#二维数组与稀疏数组之间的转变说明（图）" class="headerlink" title="二维数组与稀疏数组之间的转变说明（图）"></a>二维数组与稀疏数组之间的转变说明（图）</h1><a id="more"></a>

<p>​    <a href="https://imgtu.com/i/6EUbLD"><img src="https://s3.ax1x.com/2021/03/03/6EUbLD.png" alt="6EUbLD.png"></a></p>
<p><a href="https://imgtu.com/i/6EdVBD"><img src="https://s3.ax1x.com/2021/03/03/6EdVBD.png" alt="6EdVBD.png"></a></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="二维数组转变成稀疏数组"><a href="#二维数组转变成稀疏数组" class="headerlink" title="二维数组转变成稀疏数组"></a>二维数组转变成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 二维数组</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arrayToSparse(<span class="keyword">int</span> array[][]) &#123;</span><br><span class="line">        <span class="comment">//获取二维数组中值的个数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//稀疏数组的第一行的值分别为 二维数组总行数  二维数组总列数  二维数组中值的个数</span></span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line">        sparse[<span class="number">0</span>][<span class="number">2</span>] = num;</span><br><span class="line">        <span class="comment">//将二维数组中的值填充到稀疏数组中  二维数组行 二维数组列 二维数组值</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sparse[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparse[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparse[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="稀疏数组转变从二维数组"><a href="#稀疏数组转变从二维数组" class="headerlink" title="稀疏数组转变从二维数组"></a>稀疏数组转变从二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 稀疏数组</span></span><br><span class="line"><span class="comment"> * return : 二维数组</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span> sparse[][]) &#123;</span><br><span class="line">        <span class="comment">//根据稀疏数组的第一行数据创建一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[sparse[<span class="number">0</span>][<span class="number">0</span>]][sparse[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//将稀疏数组中的值填充到二维数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparse.length;i++)&#123;</span><br><span class="line">            array[sparse[i][<span class="number">0</span>]][sparse[i][<span class="number">1</span>]]=sparse[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="将稀疏数组与本地文件之间在互相转换"><a href="#将稀疏数组与本地文件之间在互相转换" class="headerlink" title="将稀疏数组与本地文件之间在互相转换"></a>将稀疏数组与本地文件之间在互相转换</h1><p> 保存二维数组 ：二维数组 -&gt; 稀疏数组 -&gt; 本地文件</p>
<p> 获取二维数组 :  本地文件 -&gt; 稀疏数组 -&gt; 二维数组</p>
<p>二维数组与稀疏数组之间的转换上面已经写明了，这里主要讲稀疏数组与本地文件的转换，需要用到 java 中的IO操作</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="稀疏数组保存至本地文件"><a href="#稀疏数组保存至本地文件" class="headerlink" title="稀疏数组保存至本地文件"></a>稀疏数组保存至本地文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args1: 稀疏数组  args2: 需要保存文件的地址</span></span><br><span class="line"><span class="comment"> * return : 是否保存成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arraySave</span><span class="params">(<span class="keyword">int</span> sparse[][], String fileName)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter writer = <span class="keyword">new</span> FileWriter(file);<span class="comment">//文件输入流</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparse) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                    writer.write(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="将本地文件转换成稀疏数组"><a href="#将本地文件转换成稀疏数组" class="headerlink" title="将本地文件转换成稀疏数组"></a>将本地文件转换成稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * args: 需要读取的文件地址</span></span><br><span class="line"><span class="comment"> * return : 稀疏数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getArray(String fileName) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先获取文件的行数</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//根据文件的行数创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparse=<span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//再次读取文件，将文件的内容填充到稀疏数组中</span></span><br><span class="line">        reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));<span class="comment">//输出流</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//获取文件中的每一行数据</span></span><br><span class="line">            String[] temp = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">                sparse[count][i]=Integer.parseInt(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> sparse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>稀疏数组</tag>
        <tag>io流</tag>
      </tags>
  </entry>
  <entry>
    <title>数组队列与环形队列</title>
    <url>/2021/03/04/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E4%B8%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p> 队列是一个有序列表，可以用数组或是链表来实现。 </p>
<a id="more"></a>

<p> 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 </p>
<p> 示意图：(使用数组模拟队列示意图)</p>
<p><a href="https://imgtu.com/i/6ZdR8s"><img src="https://s3.ax1x.com/2021/03/04/6ZdR8s.png" alt="6ZdR8s.png"></a></p>
<h1 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h1><p>1.队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队 列的最大容量。</p>
<p>2.因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</p>
<p>3.头指针front 指向队列头元素的前一个位置，默认为-1</p>
<p>4.尾指针rear指向队列尾元素， 默认为-1</p>
<p>5.向队列中添加数据时：</p>
<p>​    1). 将尾指针往后移：rear+1</p>
<p>​    2).若尾指针 rear == maxSize - 1  ，表示队列已满，不能再存放数据了</p>
<p>6.向队列弹出一个数据时:</p>
<p>​    1). 将头指针往后移： front+1</p>
<p>​    2).将下标为 front+1 返回即可</p>
<p>​    3).头指针等于尾指针 ，即 front==rear ,则表示该队列为空，不能弹出数据了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//前部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//后部</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">this</span>.maxSize=max;</span><br><span class="line">            <span class="keyword">this</span>.rear=-<span class="number">1</span>;<span class="comment">// 指向队列尾部，默认-1</span></span><br><span class="line">            <span class="keyword">this</span>.front=-<span class="number">1</span>;<span class="comment">// 指向队列头部的前一个位置，默认-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.rear==<span class="keyword">this</span>.front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            <span class="keyword">this</span>.arr[rear]=data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.front++;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front+<span class="number">1</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;arr[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.arr[front+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析并优化"><a href="#问题分析并优化" class="headerlink" title="问题分析并优化"></a>问题分析并优化</h3><ol>
<li><p>目前数组使用一次就不能用， 没有达到复用的效果 </p>
</li>
<li><p>将这个数组使用算法，改进成一个环形的队列 （取模：%）</p>
</li>
</ol>
<h1 id="环形数组模拟队列"><a href="#环形数组模拟队列" class="headerlink" title="环形数组模拟队列"></a>环形数组模拟队列</h1><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><p>1)对头指针front含义做一个调整：front指向队列的第一个元素，初始值为 0</p>
<p>2)对尾指针rear含义做一个调整：rear指向队列最后一个元素的下一个位置，初始值为 0  ，因为希望空出一个位置作为约定</p>
<p>3)队列满表示为 ：(rear+1)%maxSize==front </p>
<p>4)队列空表示为：rear==front</p>
<p>5)队列中有效的值的个数表示为: (rear+maxSize-front)%maxSize </p>
<p>6)front++   与  rear++   统一写成  (front+1)%maxSize  与  (rear+1)%maxSize  ,因为这是个环形队列，如果front或rear超过数组最大下标则需要从下标0开始添加数据</p>
<p>7)根据原来的队列代码进行修改，就可以得到一个环形队列</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">        <span class="comment">//指向队列头部 默认为0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">        <span class="comment">//指向队列尾部的后一个位置 默认为0  因为这是一个环形队列，需要预留一个位置作为约定</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存放数据的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">            arr=<span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            maxSize=max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="comment">//尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear==front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFull())&#123; <span class="comment">//判断队列是否满</span></span><br><span class="line">                System.out.println(<span class="string">&quot;队列满了，不能添加数据!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为 rear 指向队列尾元素的下一个位置，直接添加，再进行 rear++操作</span></span><br><span class="line">            arr[rear]=data;</span><br><span class="line">            <span class="comment">// 本来这里是 rear++ ，但是这是个环形队列，如果rear超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将队列头元素先保存下来,最后需要返回</span></span><br><span class="line">            <span class="keyword">int</span> result=arr[front];</span><br><span class="line">            <span class="comment">//本来这里是 front++ ，但是这是个环形队列，如果front超过数组最大下标则需要从下标0开始添加数据</span></span><br><span class="line">            front=front+<span class="number">1</span>%maxSize;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列所有内容</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;队列内容为:\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=front;i&lt;front+size();i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;arr[&quot;</span>+i%maxSize+<span class="string">&quot;]=&quot;</span>+arr[i%maxSize]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前队列中的有效个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示队列头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[front]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试数组队列</span></span><br><span class="line">    	<span class="comment">//Queue queue = new Queue(3);</span></span><br><span class="line">    	<span class="comment">//测试环形数组队列</span></span><br><span class="line">       CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);<span class="comment">//因为需要预留一个位置作为约定, 所以该队列中只能存放3个数据，如需存放4个数据，该算法即可</span></span><br><span class="line">    	</span><br><span class="line">       Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;\na : 添加数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;p : 弹出一个数据&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;s : 显示队列&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;h : 显示头&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;e : 退出&quot;</span>);</span><br><span class="line">           String key = scanner.next();</span><br><span class="line">           <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                   System.out.println(<span class="string">&quot;请输入值:&quot;</span>);</span><br><span class="line">                   <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">                   queue.add(i);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;p&quot;</span>:</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> pop = queue.pop();</span><br><span class="line">                       System.out.println(<span class="string">&quot;弹出值为:&quot;</span>+pop);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       System.out.println(e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                   queue.showQueue();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;h&quot;</span>:</span><br><span class="line">                   queue.showHead();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       scanner.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题</title>
    <url>/2021/03/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>单向环形链表应用场景：</p>
<p> Josephu(约瑟夫、约瑟夫环) 问题 ：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。</p>
<a id="more"></a> 

<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<h3 id="约瑟夫问题-创建环形链表的思路"><a href="#约瑟夫问题-创建环形链表的思路" class="headerlink" title="约瑟夫问题-创建环形链表的思路:"></a>约瑟夫问题-创建环形链表的思路:</h3><p>1.创建一个节点时，让first节点等于它，并且first.setNext(first)，一个节点也形成环形</p>
<p>2.后面创建新节点时，就把节点加入到环形链表最后，即链表原来最后的节点指向新节点，新节点指向first，又可变成一个环形</p>
<h3 id="约瑟夫问题-小孩出圈的思路分析"><a href="#约瑟夫问题-小孩出圈的思路分析" class="headerlink" title="约瑟夫问题-小孩出圈的思路分析:"></a>约瑟夫问题-小孩出圈的思路分析:</h3><p>用户需要穿入3个数据(startNo:从 startNo 个节点开始数， count:  数 num 下， size: 圈中一共有多少个节点)</p>
<p>1.创建一个辅助指针 helper ，事先指向链表的最后一个节点，即first的前面，因为是单向链表，只能通过遍历来完成，直到 helper.getNext()=first</p>
<p>2.报数之前，先让first与helper移动 startNo -1 次，因为是从startNo开始报数的</p>
<p>3.循环遍历数时，每次报数让 first与helper移动 count-1 次(自己也要报一次数)，这是将first指向的节点出圈</p>
<p>4.出圈为 ： first=first.next      helpser.next=first</p>
<p>5.直到first==helper，循环才可结束，这时链表中只有一个节点，first与helper同时指向它</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码:"></a>实现代码:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环形单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boy first; <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 根据传入的数据创建size个节点的环形单链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoys</span><span class="params">(Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建失败:请传入不小于1的数！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针，指向新添加的节点，即最后的一个节点</span></span><br><span class="line">        boy currBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">            boy boy = <span class="keyword">new</span> boy(i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//第一个节点</span></span><br><span class="line">                first=boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                currBoy=first;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currBoy.setNext(boy); <span class="comment">//原来最后的节点指向新节点</span></span><br><span class="line">                boy.setNext(first);  <span class="comment">//新节点指向first</span></span><br><span class="line">                currBoy=boy;		</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历环形单链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        boy currBoy=first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(currBoy.getId()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currBoy.getNext()==first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currBoy=currBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出圈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从 startNo 个节点开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  数 num 下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 圈中一共有多少个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Integer startNo,Integer count,Integer size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first ==<span class="keyword">null</span> || startNo&lt;<span class="number">1</span> || startNo&gt;size || count&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据有问题，请重试！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个helper指针，指向first之前的位置</span></span><br><span class="line">        boy helper=first;</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext()!=first) &#123;</span><br><span class="line">          helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将helper与first移动到 startNo 位置 ，移动 startNo-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startNo-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备就绪，开始出圈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper==first)&#123; <span class="comment">//表示只有一个数据了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count-<span class="number">1</span>;i++)&#123; <span class="comment">//移动count-1次</span></span><br><span class="line">                first=first.getNext();</span><br><span class="line">                helper=helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(first.getId()+<span class="string">&quot;--》&quot;</span>);</span><br><span class="line">            <span class="comment">//将当前first指向的节点出圈</span></span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后保留的数据:&quot;</span>+first.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">boy</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表与双向链表</title>
    <url>/2021/03/06/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>​     链表是以节点的方式来存储,是链式存储 ， 每个节点包含 data 域， next 域：指向下一个节点.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定,这里主要介绍带头节点的链表</p>
<a id="more"></a>

<h1 id="使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"><a href="#使用带-head-头的单向链表实现-–完成水浒英雄排行榜管理完成对英雄人物的增删改查操作" class="headerlink" title="使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作"></a>使用带 head 头的单向链表实现 –完成水浒英雄排行榜管理完成对英雄人物的增删改查操作</h1><ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部 </p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6uwseI"><img src="https://s3.ax1x.com/2021/03/06/6uwseI.png" alt="6uwseI.png"></a></p>
<ol start="3">
<li>修改节点功能, 思路:</li>
</ol>
<p>​                (1) 通过遍历,先找到该节点,直接修改数据即可</p>
<p>​                (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p>
<ol start="4">
<li>删除节点 ，思路分析的示意图</li>
</ol>
<p><a href="https://imgtu.com/i/6uwgFf"><img src="https://s3.ax1x.com/2021/03/06/6uwgFf.png" alt="6uwgFf.png"></a></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer no;  <span class="comment">//序号</span></span><br><span class="line">    String name;    <span class="comment">//名称</span></span><br><span class="line">    String nickName;    <span class="comment">//昵称</span></span><br><span class="line">    Node next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer no, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&#x27;&quot;</span> + no + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加  找到最后一个节点，将新节点添加到链表的尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照序号进行添加  根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//标记新节点序号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;node.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==node.no)&#123; <span class="comment">//该序号已存在，则无法插入</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该节点序号已存在，添加数据失败！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next=temp.next;</span><br><span class="line">            temp.next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表所有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;<span class="comment">//循环遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改  根据序号进行修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要修改的节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.no==node.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=node.name;</span><br><span class="line">            temp.nickName= node.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功:&quot;</span>+temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+node.no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除 根据序号进行删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span></span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标记是否存在该序号</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到需要删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功序号为‘&quot;</span>+no+<span class="string">&quot;’节点&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到序号为&#x27;&quot;</span>+no+<span class="string">&quot;&#x27;的节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="一些单项链表常见面试题"><a href="#一些单项链表常见面试题" class="headerlink" title="一些单项链表常见面试题"></a>一些单项链表常见面试题</h3><ol>
<li>求单链表中有效节点的个数,代码演示(easy):</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;<span class="comment">//循环遍历</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>查找单链表中的倒数第 k 个结点</p>
<p>代码演示:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 列表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 倒数第 index 个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第index个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLastIndexNode</span><span class="params">(Node head,Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遍历，获取该链表有效节点</span></span><br><span class="line">        Integer size=getLength(head);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span> || index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历，遍历 (size-index)次</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(size-index);i++)&#123;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-快慢指针法"><a href="#方法二-快慢指针法" class="headerlink" title="方法二:快慢指针法"></a>方法二:快慢指针法</h5><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h6><p>1.快指针从头开始走，慢指针从头的前一个地方开始走</p>
<p>2.快指针先走，走n次，然后快指针与慢指针一起走</p>
<p>3.直到快指针走到尾部，这时慢指针指向的下一个节点就是要删除的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//快慢指针法</span></span><br><span class="line">       ListNode temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> temp.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>单链表的反转 采用头插法</li>
</ol>
<p>思路分析：1.先创建一个头节点，暂时存放反转节点   Node reverseHead=new Node(0,””,””);</p>
<p>​                   2.循环遍历原来的链表，每遍历一遍，就把当前的节点转移到临时头节点  reverseHead的最前面</p>
<p>​                            curr.next=reverseHead.next;      reverseHead.next=curr;</p>
<p>​                   3.遍历完毕后原来的头节点后的节点全部反转到临时头节点 reverseHead后面，直接将原来头节点指向临时头节点之后的节点即可           head.next=reverseHead.next</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//当链表为空或只有一个节点，无需反转</span></span><br><span class="line">       <span class="keyword">if</span>(head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//暂时存放反转节点的节点头</span></span><br><span class="line">       Node reverseHead=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       Node curr=head.next;<span class="comment">//需要转移到到reverseList头部的节点</span></span><br><span class="line">       Node next=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           next=curr.next;</span><br><span class="line">           <span class="comment">//开始转移</span></span><br><span class="line">           curr.next=reverseHead.next;</span><br><span class="line">           reverseHead.next=curr;</span><br><span class="line">           curr=next;</span><br><span class="line">       &#125;</span><br><span class="line">       head.next=reverseHead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>从尾到头打印单链表 【要求方式 1：反向遍历 。 方式 2：Stack 栈】</li>
</ol>
<p>方法一:先反转链表，再遍历打印 （这样改变了链表原来的结构，不推荐，即使再次反转过来也很浪费时间）<br>方法二:将链表的数据全部放入栈中，再遍历栈取出数据，这样不会改变链表原来的结构（这里暂时使用java中的stack，不手写栈了）</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环遍历将链表的数据放入栈中</span></span><br><span class="line">        Node curr=head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历打印栈的数据</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
</ol>
<p>思路分析: </p>
<p>1.如果两个链表全部空则返回空；如果list1为空，返回list2；如果list2为空，返回list1</p>
<p>2.新建一个链表list用来存放合并list1与list2合并后的数据</p>
<p>3.同时遍历list1与list2，每一次比较list1当前节点与list2当前节点，谁更小就转移到list最后 (转移节点可参考问题三:链表的反转)</p>
<p>4.如果list1为空了，则把list2中的数据全部转移到list最后；如果list2空了，则把list1中的数据全部转移到list最后</p>
<p>注意: 可添加一个新的指针来标识list中新插入的节点位置</p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的单链表，合并之后的链表依然有序 ,如果链表中的有两个序号相同，默认先取 list1 中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">merge</span><span class="params">(SingleLinkedList list1,SingleLinkedList list2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span> &amp;&amp; list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2.getHead().next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        SingleLinkedList list = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//记录当前插入的节点</span></span><br><span class="line">        Node newNode=list.getHead();</span><br><span class="line">        <span class="comment">//标志list1暂时需要转移的节点</span></span><br><span class="line">        Node curr1=list1.getHead().next;</span><br><span class="line">        <span class="comment">//记录curr1的下一个节点</span></span><br><span class="line">        Node next1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//标志list2暂时需要转移的节点</span></span><br><span class="line">        Node curr2=list2.getHead().next;</span><br><span class="line">        <span class="comment">//记录list2的下一个节点</span></span><br><span class="line">        Node next2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr1==<span class="keyword">null</span>)&#123;<span class="comment">//list1合并完毕,可将curr2中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr2==<span class="keyword">null</span>)&#123;<span class="comment">//list2合并完毕，可将curr1中的剩余数据全部添加到list尾部</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next1=curr1.next;</span><br><span class="line">            next2=curr2.next;</span><br><span class="line">            <span class="keyword">if</span>(curr1.no&lt;=curr2.no)&#123; <span class="comment">//添加curr1</span></span><br><span class="line">                newNode.next=curr1;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr1=next1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//添加curr2</span></span><br><span class="line">                newNode.next=curr2;</span><br><span class="line">                newNode=newNode.next;</span><br><span class="line">                curr2=next2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用带-head-头的双向链表实现-–水浒英雄排行榜"><a href="#使用带-head-头的双向链表实现-–水浒英雄排行榜" class="headerlink" title="使用带 head 头的双向链表实现 –水浒英雄排行榜"></a>使用带 head 头的双向链表实现 –水浒英雄排行榜</h1><p>管理单向链表的缺点分析:</p>
<p>​                 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p>
<p>​                 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，前面我们单链表删除 时节点，总是找到待删除节点的前一个节点.</p>
<p>双向链表的遍历与修改与单链表一样，添加与删除方法略有不同</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点需要新增一个值</span></span><br><span class="line">DoubleNode pre; <span class="comment">//指向前一个结点</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 添加再链表最后位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">        DoubleNode temp = head;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行添加</span></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        newNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序进行添加 根据从小到大序号进行插入，找到节点序号大于新节点序号的前一个节点，将新节点插入到前一个节点之后。注意：如果该序号已存在，则无法插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(DoubleNode newNode)</span> </span>&#123;</span><br><span class="line">            DoubleNode temp=head;</span><br><span class="line">            <span class="comment">//标记新节点是否存在</span></span><br><span class="line">            <span class="keyword">boolean</span> exist=<span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//标记新节点是否插入到最后</span></span><br><span class="line">            <span class="keyword">boolean</span> last=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;<span class="comment">//表示新节点序号最大，需要插入到最后</span></span><br><span class="line">                    last=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no&gt; newNode.no)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no== newNode.no)&#123;<span class="comment">//表示新节点序号已存在</span></span><br><span class="line">                    exist=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入失败:该节点序号‘&quot;</span>+newNode.no+<span class="string">&quot;’已存在！！！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(last)&#123; <span class="comment">//插入到最后</span></span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//表示后一个节点</span></span><br><span class="line">                    DoubleNode rear = temp.next;</span><br><span class="line">                    temp.next=newNode;</span><br><span class="line">                    newNode.next=rear;</span><br><span class="line">                    rear.pre=newNode;</span><br><span class="line">                    newNode.pre=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 无需像单链表一样找到要删除的前一个节点，直接找到需要删除的节点，就可执行自我删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找序号为no的节点</span></span><br><span class="line">        DoubleNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;<span class="comment">//找到该节点,进行自我删除</span></span><br><span class="line">                temp.pre.next = temp.next;<span class="comment">//让temp前一个节点指向temp的后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next!=<span class="keyword">null</span>) &#123; <span class="comment">//如果temp的后一个节点为空，则会有空控制在异常</span></span><br><span class="line">                    temp.next.pre = temp.pre;<span class="comment">//让temp的后一个节点指向temp的前一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败:没找到序号为‘&quot;</span> + no + <span class="string">&quot;’的节点&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/03/06/%E6%A0%88/</url>
    <content><![CDATA[<p> 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除</p>
<a id="more"></a>

<h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><ol>
<li><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。</p>
</li>
<li><p>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。</p>
</li>
<li><p>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</p>
</li>
<li><p>二叉树的遍历。</p>
</li>
<li><p>图形的深度优先(depth 一 first)搜索法。</p>
</li>
</ol>
<h3 id="用数组模拟栈的使用"><a href="#用数组模拟栈的使用" class="headerlink" title="用数组模拟栈的使用"></a>用数组模拟栈的使用</h3><p>思路 : </p>
<p>1.定义一个top表示栈顶,初始值为-1</p>
<p>2.入栈操作: top++;   stack[top]=data;</p>
<p>3.出栈操作: int val=stack[top];    top–;    return val;</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">int</span> [] stack; <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// 栈顶，默认-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize=maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        <span class="keyword">this</span>.top=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败:栈满~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历显示栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;stack[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+stack[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表模拟栈的使用-采用有头单项链表"><a href="#用链表模拟栈的使用-采用有头单项链表" class="headerlink" title="用链表模拟栈的使用,采用有头单项链表"></a>用链表模拟栈的使用,采用有头单项链表</h3><p>思路:</p>
<p>1.压栈：放入链表的第一个位置     newNode.next=head.next;      head.next=newNode;</p>
<p>2.弹栈：取链表的第一个节点      Node oldFirst = head.next;    head.next=head.next.next;   return oldFirst.data;</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈 采用头差法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        newNode.next=head.next;</span><br><span class="line">        head.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈 头取法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;弹栈失败:栈空~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        head.next=head.next.next;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历栈失败:栈空~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>over…</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器</title>
    <url>/2021/03/07/%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<p>栈实现一个中缀表达式计算器和一个后缀表达式计算器</p>
<a id="more"></a>

<h3 id="中缀表达式计算器"><a href="#中缀表达式计算器" class="headerlink" title="中缀表达式计算器"></a>中缀表达式计算器</h3><h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------再栈中补充以下代码,方便后续操作-------------------------------------	</span></span><br><span class="line"><span class="comment">//瞄一眼栈顶的数据，不是弹栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回运算符的优先级，越大优先级越高  假设只有 加减乘除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&#x27;*&#x27;</span> || oper==<span class="string">&#x27;/&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper==<span class="string">&#x27;+&#x27;</span> || oper==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他无效字符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span> || val==<span class="string">&#x27;-&#x27;</span> || val==<span class="string">&#x27;*&#x27;</span> || val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num2+num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num2*num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(num1==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式实现思路分析"><a href="#中缀表达式实现思路分析" class="headerlink" title="中缀表达式实现思路分析:"></a>中缀表达式实现思路分析:</h4><p>1.创建两个栈，一个用来存放数字numStack，一个用来存放运算符operStack</p>
<p>2.用一个指针index遍历需要计算的表达式，初始值为0</p>
<p>3.遍历如果发现是index指向的是数字就直接存入数栈</p>
<p>4.如果是运算符则需要一下判断:如果符号栈为空或当前运算符的优先级大于栈顶运算符的优先级，则可以直接将当前运算符入栈；</p>
<p>如果当前运算符优先级小于或等于栈顶运算符优先级，则需将符号栈栈顶的运算符弹出，将数栈的前两位数值弹出，进行运算，将结果放入数栈中，当前运算符放入符号栈</p>
<p>5.遍历完毕后继续遍历两个栈中剩下的数据，取出数栈的两个值，符号栈一个符号继续进行运算，将结果放入数栈，直到符号栈空</p>
<p>6.此时数栈只有一个数值，该值就是运算结果</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题:"></a>存在问题:</h5><p>上面思路只能解决一位数的计算，如果要多位数，则需一下改进:</p>
<ol>
<li>创建一个字符串chs，用来拼接多位数</li>
<li>数值压入数栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是就不能入栈，继续扫描，直到下一位是运算符才能入栈</li>
</ol>
<h5 id="实现计算器代码"><a href="#实现计算器代码" class="headerlink" title="实现计算器代码"></a>实现计算器代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算该表达式</span></span><br><span class="line">        String expression = <span class="string">&quot;7*2*2-5+16-5+3-4&quot;</span>; <span class="comment">//33</span></span><br><span class="line">        <span class="comment">//String expression=&quot;10+12*2-10&quot;;</span></span><br><span class="line">        <span class="comment">//用于存放 数字的栈</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于存放运算符的栈</span></span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(expression.length());</span><br><span class="line">        <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">//第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">//第二个数字</span></span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;<span class="comment">//运算符</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//运算结果</span></span><br><span class="line">        <span class="keyword">char</span> ch;<span class="comment">//将每次扫描得到 char 保存到 ch</span></span><br><span class="line">        String chs=<span class="string">&quot;&quot;</span>;<span class="comment">//用来拼接多位数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//一个一个字符扫描</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是表达式</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//是表达式</span></span><br><span class="line">                <span class="comment">//判断 operStack 是否空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123; <span class="comment">//不空,不能直接将表达式压栈，需要判断</span></span><br><span class="line">                    <span class="comment">//如果当前表达式优先级小于或等于栈顶的表达式的优先级，则需要将栈顶的表达式取出，还需取出数值栈中的前两个数字，进行运算</span></span><br><span class="line">                    <span class="comment">//运算完毕将结果压入数值栈中，将当前表达式压入表达式栈中</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peekTop()))&#123;</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        <span class="comment">//进行运算</span></span><br><span class="line">                        result = operStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//空，直接将表达式压栈即可</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是表达式,即数字,将数字直接压入数值栈中(注:当前ch是字符,如果ch=&#x27;1&#x27;,转换成数字等于49,如果ch=&#x27;2&#x27;,转换成数字等于50,之间相差48)</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);</span></span><br><span class="line">                <span class="comment">//上面写法只能处理一位数的运算，如果需要多位数的运算，需要改进</span></span><br><span class="line">                <span class="comment">//思路:数值压入数值栈时需要判断当前数值后一个是不是运算符，如果是则可以直接入栈，如果不是则不能入栈，继续扫描，直到下一位是运算符才能入栈</span></span><br><span class="line">                chs += ch;<span class="comment">//拼接多位数</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;<span class="comment">//如果已经是最后一位数，可以直接入数栈</span></span><br><span class="line">                    numStack.push(Integer.parseInt(chs));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123; <span class="comment">//下一位是运算符，可以直接入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(chs));</span><br><span class="line">                        <span class="comment">//入栈后需清空chs</span></span><br><span class="line">                        chs=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环遍历</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描完毕,将栈中剩余的值计算掉,计算完毕后运算符栈中没有数据,但是数值栈中还有一个值，就是结果</span></span><br><span class="line">        <span class="keyword">while</span>(!operStack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            <span class="comment">//进行运算</span></span><br><span class="line">            result = operStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;运算结果为:&quot;</span>+numStack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>中缀表达式不利于计算机的计算，所以这里再实现一个后缀表达式计算器</p>
<h3 id="后缀表达式计算器"><a href="#后缀表达式计算器" class="headerlink" title="后缀表达式计算器"></a>后缀表达式计算器</h3><p>因为这里主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算</p>
<p>步骤: 中缀表达式 ==&gt; 中缀表达式list ==&gt; 后缀表达式list ==》 计算后缀表达式list ==》 结果</p>
<h4 id="将中缀表达式中的每一个值放入list集合中（方便后续计算）"><a href="#将中缀表达式中的每一个值放入list集合中（方便后续计算）" class="headerlink" title="将中缀表达式中的每一个值放入list集合中（方便后续计算）"></a>将中缀表达式中的每一个值放入list集合中（方便后续计算）</h4><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个指针index，用来遍历表达式；创建一个list集合，用来存放数据</p>
<p>2.循环遍历如果当前值不是数字，直接放入list集合中    (ch = s.charAt(index)) &lt; 48 || (ch = s.charAt(index)) &gt; 57  （字符0-9的十进制ASCII码为48-57）</p>
<p>3.如果当前值是数字，则需要考虑多位数 </p>
<p>4.遍历结束，直接将list集合返回即可</p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将中缀表达式放入到list中   13+8*6+2*5-(2+1) ==&gt; list[13,+,8,*,6,+,2,*,5,-,(,2,+,1,)]</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixExpressionBeList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//扫描指针</span></span><br><span class="line">       <span class="keyword">char</span> ch;<span class="comment">//表示每一个字符</span></span><br><span class="line">       String chs = <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> ((ch = s.charAt(index)) &lt; <span class="number">48</span> || (ch = s.charAt(index)) &gt; <span class="number">57</span>) &#123; <span class="comment">//表示不是数字，直接放入list中即可</span></span><br><span class="line">               list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//是数字,则需要考虑多位数</span></span><br><span class="line">               chs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; (ch = s.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = s.charAt(index)) &lt;= <span class="number">57</span>) &#123; <span class="comment">//属于0-9</span></span><br><span class="line">                   chs += ch;</span><br><span class="line">                   index++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//循环结束表示当前 s.charAt(index) 不是一个数字，chs中是个单位数或多位数</span></span><br><span class="line">               list.add(chs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (index &lt; s.length());<span class="comment">//表示扫描完毕</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将中缀表达式转换成后缀表达式（重难点）"><a href="#将中缀表达式转换成后缀表达式（重难点）" class="headerlink" title="将中缀表达式转换成后缀表达式（重难点）"></a>将中缀表达式转换成后缀表达式（重难点）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2</p>
<p>2.遍历中缀表达式</p>
<p>3.遇到数字时，将其压 s2</p>
<p>4.遇到运算符时，需要进行以下判断：</p>
<p>​            （1）.如果是左括号”(“,直接将此运算符入栈</p>
<p>​            （2）.如果是右括号”)”,则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，并将左括号弹出，此时这一对括号丢弃</p>
<p>​            （3）.如果 s1 为空，直接将此运算符入栈            </p>
<p>​            （4）.如果当前运算符优先级 &gt; 栈顶运算符优先级，也将运算符压入 s1；</p>
<p>​            （5）.如果当前运算符优先级 &lt;= 栈顶运算符优先级,将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(3)(4)进行比较；</p>
<p>5.遍历结束，将s1剩余的运算符依次弹出并压入到s2中，直到s1为空</p>
<p>6.此时s2中保存的数据就是转换后的后缀表达式的逆序</p>
<p>注:因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list集合代替s2,最后直接返回即可</p>
<h5 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式list转化成后缀表达式list(难点)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">       Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//存放运算符的栈</span></span><br><span class="line">       <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;&gt;();//存放数字以及结果的栈</span></span><br><span class="line">       <span class="comment">//因为s2只有压栈没有弹栈操作，而却存放的结果还需要逆序后才能得到最终结果，很麻烦，所以这里用list代替s2,最后直接返回即可</span></span><br><span class="line">       List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//遍历中缀表达式list</span></span><br><span class="line">       <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">           <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//数字直接存放到s2</span></span><br><span class="line">               s2.add(item);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123; <span class="comment">//item为符号，需要判断</span></span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;(&quot;</span>.equals(item))&#123; <span class="comment">//item为左括号，直接放入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;)&quot;</span>.equals(item))&#123; <span class="comment">//item为右括号，需要将符号栈中的符号转入到s2集合中，直到找到左括号为止，并将左括号弹出，这样就能消除一对括号</span></span><br><span class="line">                   <span class="keyword">while</span>(!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示s1栈顶是一个左括号，将它弹出即可，右括号也无需保存</span></span><br><span class="line">                   s1.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前运算符优先级小于符号栈栈顶优先级，需要将栈顶符号转入list中，再重新判断，否则可直接入符号栈，</span></span><br><span class="line">                   <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item)) &#123;</span><br><span class="line">                       s2.add(s1.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，表示当前运算符高于栈顶运算符，或符号栈为空，将当前符号直接入符号栈</span></span><br><span class="line">                   s1.push(item);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，还需将符号栈剩余的符号全部依次转入list集合中</span></span><br><span class="line">       <span class="keyword">while</span>(s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           s2.add(s1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="将后缀表达式进行计算（比中缀表达式计算简单的多）"><a href="#将后缀表达式进行计算（比中缀表达式计算简单的多）" class="headerlink" title="将后缀表达式进行计算（比中缀表达式计算简单的多）"></a>将后缀表达式进行计算（比中缀表达式计算简单的多）</h4><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.创建一个栈用来存放数值</p>
<p>2.遍历 list 集合，如果是数值则放入栈中，如果是运算符则从栈中弹出两个数进行运算，将结果压入栈中</p>
<p>3.遍历结束后栈中只有一个值，该值就是运算结果</p>
<h5 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//正则表达式判断是否为数字</span></span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不是数字</span></span><br><span class="line">                num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">switch</span> (s) &#123;  <span class="comment">//进行运算</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = num2 + num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = num2 - num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = num2 * num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (num1 == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:被除数不能为0!!!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = num2 / num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;计算失败:运算符错误!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果放回栈中</span></span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中只有一个数据，就是运算结果，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>计算器</tag>
        <tag>中缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2021/03/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八皇后问题介绍 ：</p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的</p>
<a id="more"></a>

<p>国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。</p>
<h4 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h4><ol>
<li><p>第一个皇后先放第一行第一列</p>
</li>
<li><p>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 </p>
</li>
<li><p>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 </p>
</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解， 全部得到. </p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
<li><p>示意图:</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6lgytg"><img src="https://s3.ax1x.com/2021/03/08/6lgytg.png" alt="6lgytg.png"></a></p>
<p>说明：</p>
<p> 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. （注:下标是从0开始）</p>
<p>map[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 map 下标 表示第几行，即第几个皇后，map[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘 ，一维数组</span></span><br><span class="line">    <span class="comment">//说明:下标表示第几个皇后，也就是第几行，对应的值表示每个皇后所在的列,  例如: map=[0,4,7,5,2,6,1,3]</span></span><br><span class="line">    <span class="comment">//    比如上面的数组表示:第一个皇后在第一行第一列；第二个皇后在第二行第五列，第三个皇后在第三行第八列,第四个皇后在第四行第六列。。。。。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//总共解法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count2=<span class="number">0</span>;<span class="comment">//总共检查了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queen8 queen = <span class="keyword">new</span> Queen8();</span><br><span class="line">        <span class="comment">//从第一个皇后开始</span></span><br><span class="line">        queen.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有’&quot;</span>+queen.count+<span class="string">&quot;‘解法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共检查了’&quot;</span>+queen.count2+<span class="string">&quot;‘次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摆放皇后,从第n个皇后开始摆放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">8</span>)&#123;<span class="comment">//该摆放第9个皇后了，表示第八个皇后已摆放好</span></span><br><span class="line">            print();<span class="comment">//打印结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始放，直到第8列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放皇后 n 到 i 上</span></span><br><span class="line">            map[n]=i;</span><br><span class="line">            <span class="comment">//检查n皇后是否摆放正确</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;<span class="comment">//如果正确，递归，开始摆放下一个皇后</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查当前第n个皇后是否摆放正确</span></span><br><span class="line">    <span class="comment">//从n皇后之前的所有皇后进行遍历检查</span></span><br><span class="line">    <span class="comment">// map[i]==map[n] 表示在同一列</span></span><br><span class="line">    <span class="comment">// Math.abs(n-i)==Math.abs(map[n]-map[i] 表示在同一斜线--- 如果在同一斜线这两个坐标显示为一个等腰三角形，而等腰三角形两边相等，注意要取绝对值再判断~~自行体会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//摆放错误</span></span><br><span class="line">            <span class="keyword">if</span>(map[i]==map[n] || Math.abs(n-i)==Math.abs(map[n]-map[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++)&#123;</span><br><span class="line">            System.out.print(map[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>八皇后</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫回溯</title>
    <url>/2021/03/08/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p>运用递归方法给小球找一条路能让小球到出口</p>
<a id="more"></a>

<p>思路:全在代码里，自行体会</p>
<p><a href="https://imgtu.com/i/6l6JHO"><img src="https://s3.ax1x.com/2021/03/08/6l6JHO.png" alt="6l6JHO.png"></a></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试给地图找路&quot;</span>);</span><br><span class="line">        <span class="comment">//创建地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = MiGong.createMap();</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//给地图找条路,从(1,1)开始出发</span></span><br><span class="line">        <span class="keyword">boolean</span> isOk = MiGong.setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(isOk?<span class="string">&quot;正确通过&quot;</span>:<span class="string">&quot;此路不通&quot;</span>);</span><br><span class="line">        MiGong.showMap(map);<span class="comment">//打印</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用递归方式给地图找路</span></span><br><span class="line">    <span class="comment">// 约定:1.  0表示还没走的路；1表示墙；2表示通路可以走；3表示该路走过，但走不通</span></span><br><span class="line">    <span class="comment">//     2.   在走迷宫时定义一条策略(方法):下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">    <span class="comment">//     3.   地图入口为 (i,j) ，出口为 (6,5)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;<span class="comment">//出口走过，表示走通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            map[i][j]=<span class="number">2</span>; <span class="comment">//先默认该路可走</span></span><br><span class="line">            <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//表示该路走不通</span></span><br><span class="line">                map[i][j]=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果map[i][j]= 1、2、3 都不继续玩下走</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建小地图   地图为8行7列大小，1表示墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] createMap()&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置个障碍</span></span><br><span class="line"><span class="comment">//        map[1][2]=1;</span></span><br><span class="line"><span class="comment">//        map[2][2]=1;</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span> <span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/03/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<p>排序的分类:  内部排序，指将需要处理的所有数据都加载到内部存储器(内存)中进行排序 ；外部排序法， 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。</p>
<p> 常见的排序算法分类(见右图):</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/68rGTS"><img src="https://s3.ax1x.com/2021/03/09/68rGTS.png" alt="68rGTS.png"></a></p>
<h2 id="冒泡排序（bubble-sorting）"><a href="#冒泡排序（bubble-sorting）" class="headerlink" title="冒泡排序（bubble sorting）"></a>冒泡排序（bubble sorting）</h2><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<p>优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果哪一趟排序没有交换，就代表数组已经有序了，直接退出即可</span></span><br><span class="line">        <span class="keyword">boolean</span> isExchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//用于交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//总共进行 length-1 次排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//将当前数据与下一位数据比较</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isExchange = <span class="keyword">true</span>; <span class="comment">//标记交换了</span></span><br><span class="line">                    <span class="comment">//进行交换</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            <span class="comment">//小小优化</span></span><br><span class="line">            <span class="keyword">if</span> (isExchange) &#123;</span><br><span class="line">                isExchange = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//没有交换，数组已经有序了，直接退出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="选择排序（select-sorting）"><a href="#选择排序（select-sorting）" class="headerlink" title="选择排序（select sorting）"></a>选择排序（select sorting）</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/68s139"><img src="https://s3.ax1x.com/2021/03/09/68s139.png" alt="68s139.png"></a></p>
<p>1.一共排序 （数组大小-1）次</p>
<p>2.每一轮排序，又是一个循环，循环规则:</p>
<p>​    2.1 先假定当前这个数是最小值，并记录下标</p>
<p>​    2.2 然后与后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到该最小数的下标</p>
<p>​    2.3 遍历结束就可以得到最小数以及下标</p>
<p>​    2.4 交换，将最小数放入循环刚开始的位置</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//存放最小值，默认最小值为 arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="comment">//存放最小值下标，默认最小值下标为 i</span></span><br><span class="line">            <span class="keyword">int</span> minIndex=i;</span><br><span class="line">            <span class="comment">//每一次与后一位数比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="comment">//如果min大于后面的数，则在min中放后一位数，minIndex也放后一位数的下标</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;</span><br><span class="line">                    minIndex=j;   <span class="comment">//更换最小值下标</span></span><br><span class="line">                    min=arr[j];   <span class="comment">//更换最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，min存放的值为最小值，minIndex是最小值下标，进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;  <span class="comment">//优化: minIndex==i表示最小值下标没更换，即 arr[i] 已经是最小值，没必要交换</span></span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入排序（insert-sorting）"><a href="#插入排序（insert-sorting）" class="headerlink" title="插入排序（insert sorting）"></a>插入排序（insert sorting）</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本思想：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><a href="https://imgtu.com/i/68yla8"><img src="https://s3.ax1x.com/2021/03/09/68yla8.png" alt="68yla8.png"></a></p>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;<span class="comment">//总共排序 length-1 次</span></span><br><span class="line">        <span class="keyword">int</span> insertVal=<span class="number">0</span>;  <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">        <span class="keyword">int</span> insertBeforeIndex=<span class="number">0</span>; <span class="comment">//记录当前正在排序的值的前一个下标</span></span><br><span class="line">        <span class="comment">//将数组分成两份，一份为已排好序，默认一个数，一份为没排序，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertVal=arr[i];</span><br><span class="line">            insertBeforeIndex=i-<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//如果insertBeforeIndex指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">            <span class="keyword">while</span>(insertBeforeIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertBeforeIndex])&#123;</span><br><span class="line">                <span class="comment">//将前一个值后移一位</span></span><br><span class="line">                arr[insertBeforeIndex+<span class="number">1</span>]=arr[insertBeforeIndex];</span><br><span class="line">                insertBeforeIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束，insertBeforeIndex+1 表示当前正在排序的值该插入的位置</span></span><br><span class="line">            arr[insertBeforeIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+i+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h2><p>简单插入排序存在的问题 </p>
<p>我们看简单的插入排序可能存在的问题. 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), </p>
<p>这样的过程是： </p>
<p>{2,3,4,5,6,6}  ==》 {2,3,4,5,5,6}  ==》  {2,3,4,4,5,6}   ==》 {2,3,3,4,5,6}  ==》  {2,2,3,4,5,6}  ==》  {1,2,3,4,5,6} </p>
<p>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p>希尔排序法的示意图:</p>
<p><a href="https://imgtu.com/i/686Xc9"><img src="https://s3.ax1x.com/2021/03/09/686Xc9.png" alt="686Xc9.png"></a></p>
<p><a href="https://imgtu.com/i/68cS76"><img src="https://s3.ax1x.com/2021/03/09/68cS76.png" alt="68cS76.png"></a></p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用交换法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 : 交换法     （不是说升级版吗？怎么感觉不太行。。。尴尬了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;<span class="comment">//存放临时变量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123; <span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123; <span class="comment">// 如果当前值大于当前值下标加步长的值，则交换位置</span></span><br><span class="line">                        temp=arr[j+gap];</span><br><span class="line">                        arr[j+gap]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot;+(++count)+&quot;趟排序&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><p>希尔排序时， 对有序序列在插入时采用移动法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种排序:移动法（真正的希尔排序，利用插入法原则，每一轮排序调整大小时不需要直接交换，而是向后移位，直到最后的位置才交换）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellPlus</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计排序次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123; <span class="comment">//步长 每次/2</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;<span class="comment">//从当前步长开始遍历，每次加一</span></span><br><span class="line">               <span class="keyword">int</span> j=i; <span class="comment">//记录当前正在排序的值需要插入的位置 ，每次循环减步长gap</span></span><br><span class="line">               <span class="keyword">int</span> temp=arr[j]; <span class="comment">//保存当前正在排序的值</span></span><br><span class="line">               <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="keyword">while</span>((j-gap)&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-gap])&#123; <span class="comment">//如果(j-gap)指向的下标小于0 或 当前正在排序的值不小于前一位值(前一个步长位的值)，就结束循环</span></span><br><span class="line">                       <span class="comment">//前面的值向后移一位(步长位)</span></span><br><span class="line">                       arr[j]=arr[j-gap];</span><br><span class="line">                       <span class="comment">//j指向的下标向前移一位(步长位)</span></span><br><span class="line">                       j-=gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，j所指向的下标就是当前排序的值需要插入的地方</span></span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//不走if语句说明当前值不小于前一位的值(前一个步长位的值)，没必要继续走下去，否则，还需循环判断下面的值是否还小于</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+(++count)+<span class="string">&quot;趟排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（quick-sort）"><a href="#快速排序（quick-sort）" class="headerlink" title="快速排序（quick sort）"></a>快速排序（quick sort）</h3><p>是对冒泡排序的一种改进。</p>
<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.把数组中的一个数当作基准书,一般会把数组中最左边的数当作基准数</p>
<p>2.从两边开始检索，如果是最左边的数是基准数就从右边开始检索，否则从左边开始检索，</p>
<p>从右边开始检索，如果找到比基准数小的数时，停下，再从右边开始检索，如果找到比基准数大的数时，也停下，交换左右两边指向的数，然后继续检索。。</p>
<p>3.当左右两边指针相遇，就停止检索，交换基准数和当前的位置</p>
<p>4.递归上面代码 继续排序数组左边的元素</p>
<p>5.递归上面代码 继续排序数组右边的元素</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6YAm60"><img src="https://s3.ax1x.com/2021/03/10/6YAm60.png" alt="6YAm60.png"></a></p>
<h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123; <span class="comment">//出口  排序到最后面只有一个值时，就会执行该语句</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> temp=<span class="number">0</span>;  <span class="comment">//存放交换时的临时变量</span></span><br><span class="line">       <span class="keyword">int</span> base=arr[left]; <span class="comment">//基数，默认选每一组数的第一个元素</span></span><br><span class="line">       <span class="keyword">int</span> l=left;  <span class="comment">//左指针，从数组头开始</span></span><br><span class="line">       <span class="keyword">int</span> r=right; <span class="comment">//右指针，从数组尾开始</span></span><br><span class="line">       <span class="comment">//左右指针开始移动进行排序，因为 基数是最左边的元素，所以从右边开始索引，否则从左边开始索引</span></span><br><span class="line">       <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">           <span class="comment">//如果右指针的数据小于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span>(arr[r] &gt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               r--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果左指针的数据大于基数 或 左指针大于右指针 ，则停止移动</span></span><br><span class="line">           <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; r&gt;l)&#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两边指针都停止，交换两边指针所指向的值</span></span><br><span class="line">           temp=arr[r];</span><br><span class="line">           arr[r]=arr[l];</span><br><span class="line">           arr[l]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// l==i 时, 退出循环,说明当前指向的位置是基数该放的位置，将当前值与计算交换即可</span></span><br><span class="line">       arr[left]=arr[l];</span><br><span class="line">       arr[l]=base;</span><br><span class="line">       <span class="comment">//继续排序数组左边的元素</span></span><br><span class="line">       quick(arr,left,l-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//继续排序数组右边的元素</span></span><br><span class="line">       quick(arr,r+<span class="number">1</span>,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p>
<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><p>分简单，重点是治(合)</p>
<p>总体思路图:</p>
<p><a href="https://imgtu.com/i/6YA5NQ"><img src="https://s3.ax1x.com/2021/03/10/6YA5NQ.png" alt="6YA5NQ.png"></a></p>
<p>合并相邻有序子序列: </p>
<p>治阶段，我们需要将两个已经有序的子序列合并成一个有序序列</p>
<p>1.创建一个temp数组保存临时排序数据</p>
<p>2.相邻有序子序列都从左到右开始遍历，并进行比较，那个小就 先加入到temp临时数组中</p>
<p>3.当其中一组子序列遍历完毕，就可将另一组子序列全部放入temp中</p>
<p>4.此时temp中存放的数据就是这两个有序子序列中的所有值，并且排好序，只需将temp中的值全部导入到相邻序列中</p>
<p><a href="https://imgtu.com/i/6YEMvt"><img src="https://s3.ax1x.com/2021/03/10/6YEMvt.png" alt="6YEMvt.png"></a></p>
<h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分与和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//先从左开始分</span></span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//再从右开始分</span></span><br><span class="line">            mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//进行合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   最左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid    中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  最右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp   暂时存放排序数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一.将数组左右两边的数依次比较，哪个小就把哪个放入临时数组temp中，直到有一组数据遍历完毕</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;  <span class="comment">// 记录临时数组存放位置的指针</span></span><br><span class="line">        <span class="keyword">int</span> l=left;  <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right)&#123;     <span class="comment">//循环结束就表示有一组数据全部填充完毕</span></span><br><span class="line">            <span class="comment">//进行比较判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l]&lt;=arr[r])&#123;   <span class="comment">//将左边的数据填充到 temp中，并 l++; t++;</span></span><br><span class="line">                temp[t]=arr[l];</span><br><span class="line">                l++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t]=arr[r];  <span class="comment">//将右边的数据填充到 temp中，并 r++; t++;</span></span><br><span class="line">                r++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二.将另一组没有遍历完的数据依次放入临时数组中</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到 temp</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123;</span><br><span class="line">            temp[t]=arr[l];</span><br><span class="line">            t++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[r];</span><br><span class="line">            t++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三.将临时数组中的数据导入到arr数组中 ,arr数组中的位置是 left~~right</span></span><br><span class="line">        <span class="keyword">int</span>  j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            arr[i]=temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 </p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 </p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展 </p>
</li>
<li><p>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。</p>
</li>
</ol>
<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>2.这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
<p><a href="https://imgtu.com/i/6YeBrt"><img src="https://s3.ax1x.com/2021/03/10/6YeBrt.png" alt="6YeBrt.png"></a></p>
<p><a href="https://imgtu.com/i/6YeDqP"><img src="https://s3.ax1x.com/2021/03/10/6YeDqP.png" alt="6YeDqP.png"></a></p>
<p><a href="https://imgtu.com/i/6YesVf"><img src="https://s3.ax1x.com/2021/03/10/6YesVf.png" alt="6YesVf.png"></a></p>
<h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先获取数组中最高位的个数,才能判断排序几轮</span></span><br><span class="line">       <span class="comment">//存放该数组中最大的数，默认第一个数最大</span></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(max&lt;arr[i])&#123;</span><br><span class="line">               max=arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxSize=(max+<span class="string">&quot;&quot;</span>).length();<span class="comment">//获取位数</span></span><br><span class="line">       <span class="comment">//创建一个二维数组，二维数组包含10个一维数组，每个一位数组表示一个桶，一维数组存放的数据就是arr存放的需要排序的数据</span></span><br><span class="line">       <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">       <span class="comment">//创建一个一维数组，表示每个桶里有多少个数据，便于后面将数据放回到arr中</span></span><br><span class="line">       <span class="keyword">int</span>[] bucketCount=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,n=<span class="number">1</span>;j&lt;=maxSize;j++,n*=<span class="number">10</span>)&#123; <span class="comment">//共排序maxSize轮,当前第j轮</span></span><br><span class="line">           <span class="comment">//开始排序,将数据放入桶中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">               <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">               <span class="keyword">int</span> digit = arr[i]/n % <span class="number">10</span>;  <span class="comment">//如果n=1，获取个位；n=10，获取十位；n=100，获取百位。。。。判断当前数该放在哪个桶</span></span><br><span class="line">               bucket[digit][bucketCount[digit]]=arr[i];<span class="comment">//放入第digit个桶中第bucketCount[digit]个位置</span></span><br><span class="line">               bucketCount[digit]++;<span class="comment">//该桶中的数量加一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将10个桶中结果依次放回到arr中</span></span><br><span class="line">           <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//指向放入arr中数据的位置</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bucketCount[i]!=<span class="number">0</span>)&#123;<span class="comment">//如果桶中没数据，则跳过该桶</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;bucketCount[i];m++)&#123;<span class="comment">//根据该桶显示的数据循环获取数据，放入arr中</span></span><br><span class="line">                       arr[index++]=bucket[i][m];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//循环结束，当前桶 i 中的数据全部放回至arr中，需要当前桶需将bucketCount[i]中的数据改为0，表示桶i中没有了数据，为了下一轮的排序</span></span><br><span class="line">                   bucketCount[i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，全部桶中的数据全部放回到arr中</span></span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+j+<span class="string">&quot;轮排序&quot;</span>);</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 基数排序的说明:</p>
<ol>
<li><p>基数排序是对传统桶排序的扩展，速度很快. </p>
</li>
<li><p>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError（内存溢出异常） 。</p>
</li>
<li><p>基数排序时稳定的。</p>
</li>
<li><p>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。 </p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。 </p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 </p>
</li>
<li><p>大顶堆举例说明</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6B9M1H"><img src="https://s3.ax1x.com/2021/03/14/6B9M1H.png" alt="6B9M1H.png"></a></p>
<ol start="5">
<li>小顶堆举例说明</li>
</ol>
<p><a href="https://imgtu.com/i/6B93nI"><img src="https://s3.ax1x.com/2021/03/14/6B93nI.png" alt="6B93nI.png"></a></p>
<ol start="6">
<li>一般升序采用大顶堆，降序采用小顶堆</li>
</ol>
<h4 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h4><p>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，这里是大顶堆，此时，整个序列的最大值就是堆顶的根节点</p>
<p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; </p>
<ol start="3">
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次大值,如此反复执行，便能得到一个有序 序列了</li>
</ol>
<p>​        可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p>提示:最后一个非叶子节点:(arr.length/2-1) , 左子树:(n<em>2+1) , 右子树:(n</em>2+2) , 父节点:(n+1)/2</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//堆排序，从小到大</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//将数组变成大顶堆</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           adjust(arr,i,arr.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//循环遍历，将最大值依次放到数组最后</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="comment">//将根节点（最大值）与最后一个节点的数据交换位置</span></span><br><span class="line">           <span class="keyword">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">           arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">           <span class="comment">//再调整位置</span></span><br><span class="line">           adjust(arr,<span class="number">0</span>,i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;	</span><br><span class="line"><span class="comment">//------------------------------核心代码-------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr 要排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i   将当前树的 i 节点与左右子树比较，将大的排在前面</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length 排序的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//调整当前数组i位置的值，将该值要大于子树的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="comment">//保存当前值</span></span><br><span class="line">       <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">       <span class="comment">//如果存在子节点，循环遍历左子树</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=(i*<span class="number">2</span>+<span class="number">1</span>);k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果存在右子树，且大于左子树，将大的子树提出来</span></span><br><span class="line">           <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k+<span class="number">1</span>]&gt;arr[k])&#123;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断 k 指向的子树是否大于当前节点,如果大则将子节点放入到当前节点位置</span></span><br><span class="line">           <span class="keyword">if</span>(arr[k]&gt;temp)&#123;</span><br><span class="line">               arr[i]=arr[k];</span><br><span class="line">               i=k;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，最大值已经放入到当前树的根节点处</span></span><br><span class="line">       <span class="comment">//如果当前值被替换了，需将 temp 值放到调整后的位置</span></span><br><span class="line">       <span class="keyword">if</span>(temp!=arr[i])&#123;</span><br><span class="line">           arr[i]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h3><p><a href="https://imgtu.com/i/6Ymrl9"><img src="https://s3.ax1x.com/2021/03/10/6Ymrl9.png" alt="6Ymrl9.png"></a></p>
<h4 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h4><ol>
<li><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</p>
</li>
<li><p>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； </p>
</li>
<li><p>内排序：所有排序操作都在内存中完成；</p>
</li>
<li><p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
</li>
<li><p>时间复杂度： 一个算法执行所耗费的时间。</p>
</li>
<li><p>空间复杂度：运行完一个程序所需内存的大小。</p>
</li>
<li><p>n: 数据规模 </p>
</li>
<li><p>k: “桶”的个数 </p>
</li>
<li><p>In-place: 不占用额外内存</p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ol>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/03/11/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 java 中，我们常用的查找有四种:  顺序(线性)查找 ；二分查找/折半查找 ； 插值查找 ； 斐波那契查找</p>
<a id="more"></a>

<h3 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h3><p>就是通过遍历数组，每次判断，如果当前值等于要查找的值，就返回下标即可，相当的easy啦，这里就不演示了</p>
<h3 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找/折半查找"></a>二分查找/折半查找</h3><p>只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>1.获取该数组中间下标 midIndex=(left+right)/2</p>
<p>2.如果查找的值是否小于中间值mid，则向左继续递归查找</p>
<p>3.如果查找的值是否大于中间值mid，则向右继续递归查找</p>
<p>3.如果等于，则将中间下标返回即可</p>
<p>4.如果遍历完毕还没找到需要查找的值，即 left&gt;right，就反回-1 </p>
<p>问题:上面方法只能找到一个值,如需找到所有该值的下标，需要改进步骤 3 </p>
<p>优化 ： 如果等于，不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只查找一个匹配的下标，并返回该下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchOne</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接返回-1即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchOne(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">            <span class="keyword">return</span> midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找所有匹配的值，将下标放入集合中，并返回该集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">searchList</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(left+right)/<span class="number">2</span>;<span class="comment">//获取中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid=arr[midIndex]; <span class="comment">//获取中间的值</span></span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">if</span>(data&lt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值小于中间值，则向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值大于中间值，则向右递归查找</span></span><br><span class="line">            <span class="keyword">return</span> searchList(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//改进</span></span><br><span class="line">            <span class="comment">//如果需要查找的值等于中间值，即找到</span></span><br><span class="line">            <span class="comment">//但是不能立马返回，还需向左右两边分别遍历，把相同的值放入集合中，并一起返回</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//向左遍历，将左边一样的值放入list</span></span><br><span class="line">            <span class="keyword">int</span> temp=midIndex-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;<span class="number">0</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将中间值放入list</span></span><br><span class="line">            list.add(midIndex);</span><br><span class="line">            <span class="comment">//向右遍历，将右边一样的值放入list</span></span><br><span class="line">            temp=midIndex+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=mid)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码（非递归形式查找）"><a href="#补充代码（非递归形式查找）" class="headerlink" title="补充代码（非递归形式查找）"></a>补充代码（非递归形式查找）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归形式查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchPlus</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">           mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="comment">//向左查找</span></span><br><span class="line">           <span class="keyword">if</span>(target&lt;arr[mid])&#123;</span><br><span class="line">               right=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;arr[mid])&#123;</span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h3><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>将折半查找中的求 mid 索引的公式进行改进 , low 表示左边索引 left, high 表示右边索引 right. key 就是我们需要查找的值</p>
<p>如图：</p>
<p><a href="https://imgtu.com/i/6Nl0pV"><img src="https://s3.ax1x.com/2021/03/11/6Nl0pV.png" alt="6Nl0pV.png"></a></p>
<p>二分查找时，中间值下标  midIndex = (left+right)/2 = left+(right-left)*(1/2)</p>
<p>插值查找将上面的 1/2 做了改进，变成 (data-arr[left])/(arr[right]-arr[left])，让midIndex自适应</p>
<p>midIndex  = left+(right-left)*(data-arr[left])/(arr[right]-arr[left])    通过当前查找的值在最大值与最小值之间的比例来获得中间值</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><p>1.退出条件还需添加  data&lt;arr[left] 与  data&gt;arr[right]，查找的数不小于最小值，不大于最大值，这两个条件不仅是为了优化，还必须存在 （如果查找的数是个特别大或小的数，会造成下标越界异常）</p>
<p>2.插值查找适合在大量数据，且数据分布均匀的条件下使用，如果数据分布相当不均匀，不如用二分查找</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值查找，只查一个值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;插值查找~~&quot;</span>);</span><br><span class="line">       <span class="comment">//出口，左下标大于右下标说明，遍历完该数组还没找到，直接空数组即可</span></span><br><span class="line">       <span class="comment">// data&lt;arr[left] 与 data&gt;arr[right] 查找的数不小于最小值，不大于最大值，这两个条件不仅时为了优化，必须存在 （如果查找的数是个相当大或小的数，会造成下标越界异常）</span></span><br><span class="line">       <span class="keyword">if</span>(left&gt;right || data&lt;arr[left] || data&gt;arr[right])&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//中间值下标，自适应，(该算法的核心)</span></span><br><span class="line">       <span class="keyword">int</span> midIndex=left+(right-left)*(data-arr[left])/(arr[right]-arr[left]);</span><br><span class="line">       <span class="keyword">int</span> mid=arr[midIndex];</span><br><span class="line">       <span class="keyword">if</span>(data&lt;mid)&#123;<span class="comment">//查找值小于中间值，继续向左递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,left,midIndex-<span class="number">1</span>,data);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;mid)&#123;<span class="comment">//查找值大于中间值，继续向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> search(arr,midIndex+<span class="number">1</span>,right,data);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果需要查找的值等于中间值，即找到，返回中间值的下标即可</span></span><br><span class="line">           <span class="keyword">return</span> midIndex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契（黄金分割法）查找算法"><a href="#斐波那契（黄金分割法）查找算法" class="headerlink" title="斐波那契（黄金分割法）查找算法"></a>斐波那契（黄金分割法）查找算法</h3><ol>
<li><p>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神 奇的数字，会带来意向不大的效果。</p>
</li>
<li><p>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ，当前数等于两个数相加，并且斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
</li>
</ol>
<p>本人一直不知道该算法有何意义，真的是玄学算法，好玩倒是真的</p>
<p>一样只能查找有序的数组，这里就当数组是从小到大是顺序</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p>
<p><a href="https://imgtu.com/i/6N1UDe"><img src="https://s3.ax1x.com/2021/03/11/6N1UDe.png" alt="6N1UDe.png"></a></p>
<h6 id="对-F-k-1-1-的理解"><a href="#对-F-k-1-1-的理解" class="headerlink" title="对 F(k-1)-1 的理解"></a>对 F(k-1)-1 的理解</h6><p>1.由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段,再加上mid这个位置，即如上图所示。从而中间位置为 mid=low+F[k-1]-1</p>
<p>2.类似的，每一子段也可以用相同的方式分割</p>
<p>3.但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使 得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。</p>
<p> while(n&gt;fib[k]-1) {</p>
<p>​        k++;</p>
<p>}</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认斐波那契数组大小为20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize=<span class="number">20</span>;</span><br><span class="line">   <span class="comment">//创建一个斐波那契数组  &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55 , 89  ...... &#125;</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">       <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">       fib[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxSize;i++)&#123;</span><br><span class="line">           fib[i]=fib[i-<span class="number">1</span>]+fib[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fib;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//斐波那契算法，不用递归  mid=low+fib[k-1]-1</span></span><br><span class="line">   <span class="comment">// fib[k] = fib[k-1] + fib[k-2]</span></span><br><span class="line">   <span class="comment">// fib[k]-1 = (fib[k-1]-1) +(fib[k-2]-1) + 1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> low=<span class="number">0</span>;  <span class="comment">//最低点</span></span><br><span class="line">       <span class="keyword">int</span> high=arr.length-<span class="number">1</span>;  <span class="comment">//最高点</span></span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//斐波那契中k的值</span></span><br><span class="line">       <span class="keyword">int</span> mid=<span class="number">0</span>; <span class="comment">//中间值</span></span><br><span class="line">       <span class="keyword">int</span>[] fib = fib(); <span class="comment">//获取斐波那契数组</span></span><br><span class="line">       <span class="comment">//通过最大下标，获取k, fib[k]-1 要大于或等于 high</span></span><br><span class="line">       <span class="keyword">while</span> (high&gt;fib[k]-<span class="number">1</span>) &#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束，获取到k值，这时arr的长度可能小于fib的长度，这时需要复制通过数组temp</span></span><br><span class="line">       <span class="keyword">int</span>[] temp= Arrays.copyOf(arr,fib[k]);</span><br><span class="line">       <span class="comment">//默认后面填充的值是0，需将0全部变成最后一个数</span></span><br><span class="line">       <span class="comment">//&#123;1,8, 10, 89, 1000, 1234, 0, 0, 0&#125; ==》 &#123;1,8, 10, 89, 1000, 1234, 1234, 1234, 1234&#125;</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=high+<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">           temp[i]=arr[high];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始循环，获取data下标</span></span><br><span class="line">       <span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">           mid=low+fib[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">           System.out.println(mid);</span><br><span class="line">           <span class="keyword">if</span>(data&lt;temp[mid])&#123;<span class="comment">//小于，向左继续查找</span></span><br><span class="line">               high=mid-<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//fib[k]=fib[k-1]+fib[k-2]</span></span><br><span class="line">               <span class="comment">//在前一部分的值中继续查找，前一部分也就是 fib[k-1]</span></span><br><span class="line">               k-=<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;temp[mid])&#123;<span class="comment">//大于，向右继续查找</span></span><br><span class="line">               low=mid+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//在后一部分的值中继续查找,后一部分也就是 fib[k-2]</span></span><br><span class="line">               k-=<span class="number">2</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//等于 ，</span></span><br><span class="line">               <span class="keyword">if</span>(mid&lt;=high)&#123;</span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> high;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/03/13/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/6waRI0"><img src="https://s3.ax1x.com/2021/03/13/6waRI0.png" alt="6waRI0.png"></a></p>
<p>哈希表中存放 链表数组，每一条链表都存放了雇员信息，如图</p>
<p><a href="https://imgtu.com/i/6w05z8"><img src="https://s3.ax1x.com/2021/03/13/6w05z8.png" alt="6w05z8.png"></a></p>
<h4 id="代码实现（暂时不包含相应的方法）"><a href="#代码实现（暂时不包含相应的方法）" class="headerlink" title="代码实现（暂时不包含相应的方法）"></a>代码实现（暂时不包含相应的方法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span> </span>&#123;</span><br><span class="line">    <span class="comment">//哈希表中的链表条数,默认8条（注:后期不能修改）</span></span><br><span class="line">    <span class="keyword">private</span> Integer size = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">private</span> LinkUser[] hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义链表条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hash</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        hash = <span class="keyword">new</span> LinkUser[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> LinkUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数，根据用户id判断该用户应该在哪一条链表中(这里根据链表条数进行取模计算)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个节点，默认为空</span></span><br><span class="line">    User head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一个用户（节点）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    User next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码实现-实现添加，遍历，查找，删除"><a href="#代码实现-实现添加，遍历，查找，删除" class="headerlink" title="代码实现(实现添加，遍历，查找，删除)"></a>代码实现(实现添加，遍历，查找，删除)</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].add(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据用户id判断该用户应该在哪一条链表中</span></span><br><span class="line">       <span class="keyword">int</span> i = hashFun(user.id);</span><br><span class="line">       <span class="keyword">return</span> hash[i].addByOrder(user);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line">	<span class="comment">//添加(添加到尾部,不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不为空，找到最后一个节点，添加到最后</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,temp为最后一个节点</span></span><br><span class="line">       temp.next = user;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//按从小到大顺序添加(不重复id)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addByOrder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果该链表为空，则直接添加到头部</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果等于头节点，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(head.id==user.id)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果新节点小于头节点，直接换头节点</span></span><br><span class="line">       <span class="keyword">if</span>(user.id&lt;head.id)&#123;</span><br><span class="line">           user.next=head;</span><br><span class="line">           head=user;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果上面条件都不满足，找到需要添加位置的前一个节点</span></span><br><span class="line">       User temp = head;</span><br><span class="line">       <span class="comment">//标记temp节点是否是最后一个节点</span></span><br><span class="line">       <span class="keyword">boolean</span> isLast=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next.id == user.id) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;该用户id已存在&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(user.id&lt;temp.next.id)&#123;</span><br><span class="line">               isLast=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面循环结束，要么找到了需要插入的位置，要么遍历到了最后</span></span><br><span class="line">       <span class="keyword">if</span>(isLast)&#123;</span><br><span class="line">           temp.next = user;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           user.next=temp.next;</span><br><span class="line">           temp.next=user;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//遍历哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;链表&quot;</span> + i + <span class="string">&quot;为\t&quot;</span>);</span><br><span class="line">            hash[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该链表为空！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot; ==&gt; id=&quot;</span> + temp.id + <span class="string">&quot;,name=&quot;</span> + temp.name);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        User user = hash[i].find(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123; <span class="comment">//存在</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------这里是哈希表中的代码(Hash)-----------------------------------------</span></span><br><span class="line"> <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hashFun(id);</span><br><span class="line">        <span class="keyword">return</span> hash[i].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------这里是链表中的代码(LinkUser)--------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.id==id)&#123;<span class="comment">//如果该用户是头节点，直接自我删除即可</span></span><br><span class="line">            head=head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//指向当前要删除的节点的前一个节点</span></span><br><span class="line">        User temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:该用户不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h5 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h5><h6 id="1-数组存储方式的分析"><a href="#1-数组存储方式的分析" class="headerlink" title="1) 数组存储方式的分析"></a>1) 数组存储方式的分析</h6><a id="more"></a>

<p> 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</p>
<h6 id="2-链式存储方式的分析"><a href="#2-链式存储方式的分析" class="headerlink" title="2) 链式存储方式的分析"></a>2) 链式存储方式的分析</h6><p> 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<h6 id="3-树存储方式的分析"><a href="#3-树存储方式的分析" class="headerlink" title="3) 树存储方式的分析"></a>3) 树存储方式的分析</h6><p> 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度</p>
<p>数示意图:</p>
<p><a href="https://imgtu.com/i/6wsnyT"><img src="https://s3.ax1x.com/2021/03/13/6wsnyT.png" alt="6wsnyT.png"></a></p>
<p>树的常用术语(结合示意图理解): </p>
<ol>
<li><p>节点</p>
</li>
<li><p>根节点</p>
</li>
<li><p>父节点</p>
</li>
<li><p>子节点 </p>
</li>
<li><p>叶子节点 (没有子节点的节点) </p>
</li>
<li><p>节点的权(节点值)</p>
</li>
<li><p>路径(从 root 节点找到该节点的路线)</p>
</li>
<li><p>层 </p>
</li>
<li><p>子树 </p>
</li>
<li><p>树的高度(最大层数) </p>
</li>
<li><p>森林 :多颗子树构成森林</p>
</li>
</ol>
<h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><ol>
<li><p>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 </p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6wsw0e"><img src="https://s3.ax1x.com/2021/03/13/6wsw0e.png" alt="6wsw0e.png"></a></p>
<ol start="4">
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树</li>
</ol>
<p><a href="https://imgtu.com/i/6wsrtA"><img src="https://s3.ax1x.com/2021/03/13/6wsrtA.png" alt="6wsrtA.png"></a></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>使用前序，中序和后序对下面的二叉树进行遍历</p>
<ol>
<li><p>前序遍历: 先输出父节点，再递归遍历左子树，最后递归遍历右子树 </p>
</li>
<li><p>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</p>
</li>
<li><p>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 </p>
</li>
</ol>
<p>小结: 看输出父节点的顺序，就确定是前序，中序还是后序</p>
<h5 id="实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加"><a href="#实现代码-这里没有实现在树中添加数据，请手动创建数，再根据set方法添加" class="headerlink" title="实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)"></a>实现代码(这里没有实现在树中添加数据，请手动创建数，再根据set方法添加)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历  父节点==》左节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历  左节点==》父节点==》右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历  左节点==》右节点==》父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-查找指定节点"><a href="#二叉树-查找指定节点" class="headerlink" title="二叉树-查找指定节点"></a>二叉树-查找指定节点</h4><p>使用前序查找，中序查找和后序查找</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><h6 id="前序查找"><a href="#前序查找" class="headerlink" title="前序查找"></a>前序查找</h6><p>1.先判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>2.如果不等，则判断当前节点左子树是否为空，如果不为空,则向左子树递归前序查找</p>
<p>3.如果左子树找到节点，直接返回，否则判断当前节点右子树是否为空，如果不空，则继续向右子树递归前序查找</p>
<h6 id="中序查找"><a href="#中序查找" class="headerlink" title="中序查找"></a>中序查找</h6><p>1.判断当前节点左子树是否为空，如果不为空,则向左子树递归中序查找</p>
<p>2.如果左子树找到节点，直接返回，否则判断当前节点的no是否等于要查找的no，如果是，则直接返回当前节点</p>
<p>3.如果不是，则向右子树中序递归查找，找到就返回，没有就返回null</p>
<h6 id="后序查找"><a href="#后序查找" class="headerlink" title="后序查找"></a>后序查找</h6><p>1.先左，再右，后当前节点。。。。。与上面基本一样的套路</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//前序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是前序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//先判断当前节点,如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//没找到就向左子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//左子树没找到，就向右子树继续递归前序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是中序查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">//如果左子树没找到，就判单当前节点，如果是，直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当前节点没找到，就向右子树递归调用中序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不管找到没找到，直接返回即可</span></span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序查找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       HeroNode resNode=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先向左子树递归后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果当左子树没找到，就向右子树递归调用后序查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           resNode=<span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果找到，就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>  resNode;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是后续查找~~~&quot;</span>);</span><br><span class="line">       <span class="comment">// 如果左子树没找到，就判断当前节点，如果是就返回当前</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果都没找到，就返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-删除节点（不考虑是否有子树，统一删除）"><a href="#二叉树-删除节点（不考虑是否有子树，统一删除）" class="headerlink" title="二叉树-删除节点（不考虑是否有子树，统一删除）"></a>二叉树-删除节点（不考虑是否有子树，统一删除）</h4><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先考虑:</p>
<p>改树是否为空树；根节点是否是要删除的节点；</p>
<p>然后进行以下步骤:</p>
<p>1.因为二叉树是单项的，所以我们需要判断当前节点的子树是否要删除的节点</p>
<p>2.如果当前节点的左子树不为空，并且左子树就是要删除节点，就将 this.left=null; 并返回（结束递归删除）</p>
<p>3.如果当前节点的右子树不为空，并且右子树就是要删除节点，就将 this.right=null; 并返回（结束递归删除）</p>
<p>4.如果第2步与第3步没有删除节点，则需要向左子树递归删除节点</p>
<p>5.如果第4步也没有删除节点，则需要向右子树递归删除</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------这是在树(Tree)中的代码---------------------------------</span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;删除失败:该数为空！！！&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果要删除的节点是根节点，直接自我删除即可</span></span><br><span class="line">           <span class="keyword">if</span>(root.getNo()==no)&#123;</span><br><span class="line">               root=<span class="keyword">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果不是，就调用树节点的方法</span></span><br><span class="line">               root.deleteNode(no);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//----------------这是在树节点(HeroNode)中的代码--------------------------------- </span></span><br><span class="line"><span class="comment">//删除指定节点 （不考虑是否有子树，统一删除）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先判断删除的节点是不是左子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//再判断删除的节点是不是右子树,如果是直接删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no==no)&#123;</span><br><span class="line">           <span class="keyword">this</span>.right=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不是左右子树,则先向左子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">this</span>.left.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果左子树递归没找都，就再向右子树递归删除</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.right.deleteNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>数</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/2021/03/14/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>先看一个问题， 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. （ n+1=7 个空指针 )</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<a id="more"></a>

<p>问题分析: </p>
<ol>
<li><p>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } </p>
</li>
<li><p>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</p>
</li>
<li><p>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? </p>
</li>
<li><p>解决方案-线索二叉树</p>
</li>
</ol>
<h4 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h4><ol>
<li><p>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） </p>
</li>
<li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 </p>
</li>
<li><p>一个结点的前一个结点，称为前驱结点</p>
</li>
<li><p>一个结点的后一个结点，称为后继结点</p>
</li>
</ol>
<h4 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h4><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><a href="https://imgtu.com/i/6ydklt"><img src="https://s3.ax1x.com/2021/03/16/6ydklt.png" alt="6ydklt.png"></a></p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h5><p>中序遍历的结果：{8, 3, 10, 1, 14, 6}，如图</p>
<p><a href="https://imgtu.com/i/6ywk4J"><img src="https://s3.ax1x.com/2021/03/16/6ywk4J.png" alt="6ywk4J.png"></a></p>
<p>节点8，10。。没有左右子树，安装中序遍历结果，8的前驱节点为null，后继节点为3；10的前驱节点为3，后继节点为1。。。</p>
<p>1.我们可以定义一个前驱节点pre，默认为null</p>
<p>2.线索化左节点时，判断当前节点node是否有左子树，如果没有则让当前节点的左指针指向pre</p>
<p>3.线索化右节点时，判断前驱节点pre是否为null，是否有右子树，如果不为null，并且没有右子树，则让pre的右指针指向当前节点</p>
<p>4.每次线索化后，都让pre后移，即 pre=node</p>
<h6 id="说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况"><a href="#说明-当线索化二叉树后，Node-节点的-属性-left-和-right-，有如下情况" class="headerlink" title="说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:"></a>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</h6><ol>
<li><p>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. </p>
</li>
<li><p>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//用来表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> Node pre=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先向左递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化左指针</span></span><br><span class="line">        <span class="comment">//如果左子树为空，则将左指针指向前驱节点,并改变左指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化右指针</span></span><br><span class="line">        <span class="comment">//如果当前前驱节点不为空，且前驱节点没有右子树，则让他右指针指向它的后继节点（即当前节点），并改变右指针类型</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">        pre=node;</span><br><span class="line">        <span class="comment">//最高向右递归中序线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            infixThreaded(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法</span></span><br><span class="line">        infixThreaded(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//左节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="comment">//右节点，默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line">    <span class="comment">// 表示左指针指向的类型是什么，0表示左子树，1表示前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示右指针指向的类型是什么，0表示右子树，1表示后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历中序线索化二叉树"><a href="#遍历中序线索化二叉树" class="headerlink" title="遍历中序线索化二叉树"></a>遍历中序线索化二叉树</h4><p>对前面的中序线索化的二叉树， 进行遍历 </p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历 线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次 序应当和中序遍历保持一致。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       root.infixList();<span class="comment">//从根节点开始</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的(核心)==========================</span></span><br><span class="line"><span class="comment">//中序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前节点，从根节点开始</span></span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//先找到最左边的节点，也就是第一个有前驱的节点，注:即使前驱节点为空，leftType 也等于 1</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到第一个,直接打印</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//如果有后继节点，也直接打印</span></span><br><span class="line">           <span class="keyword">while</span>(temp.getRightType()==<span class="number">1</span>)&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//最后将它变成右子树</span></span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//--------------创建线索化二叉树--------------------</span></span><br><span class="line">       Node root=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">       Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">       Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">       Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">       Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">       root.setLeft(node1);</span><br><span class="line">       root.setRight(node2);</span><br><span class="line">       node1.setLeft(node3);</span><br><span class="line">       node1.setRight(node4);</span><br><span class="line">       node2.setLeft(node5);</span><br><span class="line">       <span class="comment">//这里手动创建</span></span><br><span class="line">       ThreadedBinaryTree tree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">       tree.setRoot(root);</span><br><span class="line">       <span class="comment">//-------------------中序线索化 和 遍历  测试------------------</span></span><br><span class="line">       <span class="comment">//中序线索化</span></span><br><span class="line">       <span class="comment">//中序遍历后是 :  3, 1, 4, 0, 5, 2</span></span><br><span class="line">       <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">       <span class="comment">//但是在线索化后，节点3的前驱为null,后继为1; 节点4的前驱为1，后继为0; 节点5的前驱为0，后继为2</span></span><br><span class="line">       tree.infixThreaded();</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">       System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">     	<span class="comment">//中序线索化后遍历</span></span><br><span class="line">       System.out.println(<span class="string">&quot;中序线索化后的遍历:&quot;</span>);  <span class="comment">// 3, 1, 4, 0, 5, 2</span></span><br><span class="line">       tree.infixList();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>根据上面的思路，接下来我将实现前序线索化二叉树及遍历 与 后续线索化二叉树及遍历</p>
<p>注: 向左子树递归与向右子树递归还需加一个条件node.getLeftType()==0与node.getRightType()==0</p>
<p>不加会出现死循环，可自己画个图看看叶节点的前驱与后继是指向哪里</p>
<h4 id="前序线索化二叉树及其遍历"><a href="#前序线索化二叉树及其遍历" class="headerlink" title="前序线索化二叉树及其遍历"></a>前序线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span> )&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每执行一次，让前驱指针后移一步</span></span><br><span class="line">       pre=node;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           preThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">           preThreaded(node.getRight());</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       preThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.preList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//前序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node temp=<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">while</span> (temp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//直接打印当前</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//先向左遍历</span></span><br><span class="line">           <span class="keyword">while</span> (temp.getLeftType()==<span class="number">0</span>)&#123;</span><br><span class="line">               temp=temp.getLeft();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示向左遍历完毕,继续获取的后继节点</span></span><br><span class="line">           <span class="keyword">if</span> (temp.getRightType()==<span class="number">1</span> )&#123;</span><br><span class="line">               temp=temp.getRight();</span><br><span class="line">               System.out.println(temp);</span><br><span class="line">           &#125;</span><br><span class="line">           temp=temp.getRight();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line">      <span class="comment">//前序遍历 : 0, 1, 3, 4, 2, 5</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为1，后继节点为4; 节点4的前驱为3，后继为2; 节点5的前驱为2，后继为null</span></span><br><span class="line">      tree.preThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.preList();</span><br></pre></td></tr></table></figure>
<h4 id="后续线索化二叉树及其遍历"><a href="#后续线索化二叉树及其遍历" class="headerlink" title="后续线索化二叉树及其遍历"></a>后续线索化二叉树及其遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===============这段代码是二叉树ThreadedBinaryTree中的======================</span></span><br><span class="line"> <span class="comment">//后序线索化二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="comment">//向左递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//向右递归</span></span><br><span class="line">       <span class="keyword">if</span> (node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           postThreaded(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化左指针</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.setLeft(pre);</span><br><span class="line">           node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线索化右指针</span></span><br><span class="line">       <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span>)&#123;</span><br><span class="line">           pre.setRight(node);</span><br><span class="line">           pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//前驱指针向后移</span></span><br><span class="line">       pre=node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreaded</span><span class="params">()</span></span>&#123;<span class="comment">//重构上面的线索化方法，方便调用</span></span><br><span class="line">       postThreaded(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后序线索化后的的遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//从根节点开始</span></span><br><span class="line">       root.postList();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//===============这段代码是树节点Node中的==========================</span></span><br><span class="line"><span class="comment">//这里本人写不出来，字节用递归的笨方法。。。。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node.getLeftType()==<span class="number">0</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getLeft());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(node.getRightType()==<span class="number">0</span> &amp;&amp; node.getRight()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postList(node.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(node);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//后序线索化后的的遍历，重构上面遍历方法，方便调用</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       postList(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建树上面中序线索化二叉树测试代码有</span></span><br><span class="line"><span class="comment">//前序遍历 : 3, 4, 1, 5, 2, 0</span></span><br><span class="line">      <span class="comment">//在原来的树中节点 3，4，5 的左右子树为空</span></span><br><span class="line">      <span class="comment">//但是在线索化后，节点3的前驱为null，后继节点为4; 节点4的前驱为3，后继为1; 节点5的前驱为1，后继为2</span></span><br><span class="line">      tree.postThreaded();</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的前驱为:&quot;</span>+node3.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点3的后继为:&quot;</span>+node3.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的前驱为:&quot;</span>+node4.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点4的后继为:&quot;</span>+node4.getRight());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的前驱为:&quot;</span>+node5.getLeft());</span><br><span class="line">      System.out.println(<span class="string">&quot;节点5的后继为:&quot;</span>+node5.getRight());</span><br><span class="line">      <span class="comment">//前序线索化后遍历</span></span><br><span class="line">      System.out.println(<span class="string">&quot;前序线索化后的遍历:&quot;</span>);</span><br><span class="line">      tree.postList();</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼编码</title>
    <url>/2021/03/15/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="赫夫曼树基本介绍"><a href="#赫夫曼树基本介绍" class="headerlink" title="赫夫曼树基本介绍"></a>赫夫曼树基本介绍</h2><ol>
<li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 </li>
</ol>
<a id="more"></a>

<ol start="2">
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h5 id="赫夫曼树几个重要概念和举例说明"><a href="#赫夫曼树几个重要概念和举例说明" class="headerlink" title="赫夫曼树几个重要概念和举例说明"></a>赫夫曼树几个重要概念和举例说明</h5><ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 </p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结 点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 </p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 </p>
</li>
<li><p>WPL 最小的就是赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rMxqx"><img src="https://s3.ax1x.com/2021/03/15/6rMxqx.png" alt="6rMxqx.png"></a></p>
<h3 id="构成赫夫曼树："><a href="#构成赫夫曼树：" class="headerlink" title="构成赫夫曼树："></a>构成赫夫曼树：</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>将每一个数据变成一个节点，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树 </p>
</li>
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将该数字变成一颗霍夫曼树</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HufNode tree = createHuffmanTree(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;霍夫曼树为:&quot;</span>);</span><br><span class="line">        tree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入一个数组，将数组变成一颗赫夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HufNode <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组的每一个元素都组成一个节点，然后放入到list集合中</span></span><br><span class="line">        List&lt;HufNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HufNode(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历，直到list中只有一个值</span></span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先排好序</span></span><br><span class="line">        	Collections.sort(list);</span><br><span class="line">            <span class="comment">// 取出前两个节点(即最小值与次小值)，组成一颗新树</span></span><br><span class="line">            HufNode leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            HufNode rightNode = list.get(<span class="number">1</span>);</span><br><span class="line">            HufNode newNode = <span class="keyword">new</span> HufNode(leftNode.value+ rightNode.value,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//将之前的两个节点删除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新树放入到list集合中，再次排序</span></span><br><span class="line">            list.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时list中只有一个节点，该节点就是一颗完整的赫夫曼树，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HufNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HufNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    HufNode left;</span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    HufNode right;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HufNode o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value-o.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HufNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value, HufNode left, HufNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HufNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼编码基本介绍"><a href="#赫夫曼编码基本介绍" class="headerlink" title="赫夫曼编码基本介绍"></a>赫夫曼编码基本介绍</h2><ol>
<li><p>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 </p>
</li>
<li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 </p>
</li>
<li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 </p>
</li>
<li><p>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</p>
</li>
</ol>
<h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><h5 id="通信领域中信息的处理方式-1-定长编码"><a href="#通信领域中信息的处理方式-1-定长编码" class="headerlink" title="通信领域中信息的处理方式 1-定长编码"></a>通信领域中信息的处理方式 1-定长编码</h5><p><a href="https://imgtu.com/i/6rlKn1"><img src="https://s3.ax1x.com/2021/03/15/6rlKn1.png" alt="6rlKn1.png"></a></p>
<h5 id="通信领域中信息的处理方式-2-变长编码"><a href="#通信领域中信息的处理方式-2-变长编码" class="headerlink" title="通信领域中信息的处理方式 2-变长编码"></a>通信领域中信息的处理方式 2-变长编码</h5><p><a href="https://imgtu.com/i/6rlQ76"><img src="https://s3.ax1x.com/2021/03/15/6rlQ76.png" alt="6rlQ76.png"></a></p>
<h5 id="通信领域中信息的处理方式-3-赫夫曼编码"><a href="#通信领域中信息的处理方式-3-赫夫曼编码" class="headerlink" title="通信领域中信息的处理方式 3-赫夫曼编码"></a>通信领域中信息的处理方式 3-赫夫曼编码</h5><h5 id="传输的-字符串"><a href="#传输的-字符串" class="headerlink" title="传输的 字符串"></a>传输的 字符串</h5><ol>
<li><p>i like like like java do you like a java </p>
</li>
<li><p>d:1  y:1  u:1  j:2  v:2  o:2  l:4  k:4  e:4  i:5  a:5  &lt;空格&gt;:9 // 各个字符对应出现的次数 </p>
</li>
<li><p>按照上面字符出现的次数构建一颗赫夫曼树, 字符出现的次数作为权值  </p>
</li>
</ol>
<h5 id="构成赫夫曼树的步骤"><a href="#构成赫夫曼树的步骤" class="headerlink" title="构成赫夫曼树的步骤"></a>构成赫夫曼树的步骤</h5><p>1)将每一个数据变成一个节点 , 将上面的字符变成节点的值，字符出现的次数变成节点的权重，将节点从小到大进行排序 ， 每个节点可以看成是一颗最简单的二叉树</p>
<ol start="2">
<li><p>取出根节点权值最小的两颗二叉树 </p>
</li>
<li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
</li>
<li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序</p>
<p>不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6rltcd"><img src="https://s3.ax1x.com/2021/03/15/6rltcd.png" alt="6rltcd.png"></a></p>
<ol start="4">
<li><p>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ，</p>
<p>编码 如下: o: 1000   u: 10010   d: 100110   y: 100111   i: 101   a : 110   k: 1110   e: 1111   j: 0000   v: 0001   l: 001  &lt;空格&gt;: 01 </p>
</li>
<li><p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注 意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110 </p>
</li>
</ol>
<p>通过赫夫曼编码处理 长度为 133 </p>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h6><p> 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% , 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 ,赫夫曼编码是无损处理方案</p>
<h4 id="压缩代码实现"><a href="#压缩代码实现" class="headerlink" title="压缩代码实现"></a>压缩代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================简单封装了下边的所有方法,方便调用 =========================</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   压缩后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(String s)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodeList(s);    <span class="comment">//根据数据获取节点，并放入list集合中</span></span><br><span class="line">        Node tree = createHuffmanTree(nodes); <span class="comment">// 根据所有的节点获取霍夫曼树</span></span><br><span class="line">        Map&lt;Byte, String&gt; table = createHuffmanTable(tree); <span class="comment">// 根据霍夫曼树或取霍夫曼编码表</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = huffmanZip(table, s); <span class="comment">//根据编码表将数据压缩，并返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//===========将字符串中的每一个字符及其出现的频率保存到 List&lt;Node&gt; 集合中=============</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodeList</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="comment">//转换成字符数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">//遍历该字符数组,将数据放入map集合中，key为字符，value为当前字符出现频率</span></span><br><span class="line">        Map&lt;Byte,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = map.get(b);</span><br><span class="line">            <span class="comment">//如果不存在，就直接存入</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(b,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//存在就频率+1</span></span><br><span class="line">                map.put(b,count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历map,将map中的数据全部转换成 Node ，并保存到list中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================创建根据List&lt;Node&gt;集合创建赫夫曼树==================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出最小与次小的两个节点，组成新树，并加入到list中</span></span><br><span class="line">            Node leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode=list.get(<span class="number">1</span>);</span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight, leftNode, rightNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">            <span class="comment">//删除之前的两个最小值</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面循环结束，list中只有一个node节点，该节点就是一颗完整的 赫夫曼树</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//==================根据霍夫曼树，创建霍夫曼编码表==================</span></span><br><span class="line">	<span class="comment">//霍夫曼编码表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanTable=<span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">    <span class="comment">//用来拼接编码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node   节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code   编码, 0表示左子树，1表示右子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用来拼接编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="comment">//如果不是叶节点，则递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node.data==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123; <span class="comment">//向左递归,0表示</span></span><br><span class="line">                createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;<span class="comment">//向右递归,1表示</span></span><br><span class="line">                createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是叶节点，就直接将编码保存到huffmanTable中</span></span><br><span class="line">            huffmanTable.put(node.data,stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//为了简便调用，重构上面方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">createHuffmanTable</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            createHuffmanTable(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//===========根据霍夫曼编码表将字符串进行压缩，得到压缩后的byte数组=============</span></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanTable  霍夫曼编码表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text          需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              压缩完后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(Map&lt;Byte,String&gt; huffmanTable, String text)&#123;</span><br><span class="line">        <span class="comment">//将文本变成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes();</span><br><span class="line">        <span class="comment">// 用来保存字节数组根据编码表转换后的内容</span></span><br><span class="line">        <span class="comment">// 如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">        StringBuilder codes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历字节数组，根据编码表将值替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            codes.append(huffmanTable.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，此时codes保存了译码后的内容，还需将codes内容8位为一体，转变成字节放入压缩后的字节数组zip中</span></span><br><span class="line">        <span class="comment">//根据codes判断zip数组大小，也可以这样写: len=(builder.length()+7)/8</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(codes.length()%<span class="number">8</span>==<span class="number">0</span>)&#123; <span class="comment">//刚好除8没有余数</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果有余数，长度+1即可</span></span><br><span class="line">            len=codes.length()/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放压缩后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] zip=<span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//标记zip的下标</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历builder，每次获取8位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;codes.length();i+=<span class="number">8</span>)&#123;</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span>&gt;=codes.length())&#123;</span><br><span class="line">                <span class="comment">//如果超过长度，字节截取到最后即可</span></span><br><span class="line">                data=codes.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                data=codes.substring(i,i+<span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为builder是字符串类型，需要先转换成二进制类型，再变成字节类型</span></span><br><span class="line">            zip[index]=(<span class="keyword">byte</span>)Integer.parseInt(data,<span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 字符</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">// 权重（字符出现的频率）</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight-o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">byte</span> data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据解压-使用赫夫曼编码解码"><a href="#数据解压-使用赫夫曼编码解码" class="headerlink" title="数据解压(使用赫夫曼编码解码)"></a>数据解压(使用赫夫曼编码解码)</h3><ol>
<li><p>前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77 , -57, 6, -24, -14, -117, -4, -60, -90, 28] </p>
</li>
<li><p>现在要求使用赫夫曼编码， 进行解码，又 重新得到原来的字符串”i like like like java do you like a java”</p>
</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> flag  标记是否需要补高位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b     需要转换的字节</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>      转换后的二进制字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//将一个字节变成二进制字符串形式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byteToBinaryString</span><span class="params">(<span class="keyword">boolean</span> flag,<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">       <span class="comment">//先将字节转换成整数</span></span><br><span class="line">       <span class="keyword">int</span> temp=b;</span><br><span class="line">       <span class="comment">//需要补高位</span></span><br><span class="line">       <span class="comment">//如果temp=1，他的二进制为0000 0001，但是Integer.toBinaryString()方法输出会省略前面的0，直接输出 1，但是前面的0我们也是需要的</span></span><br><span class="line">       <span class="comment">//256=》 1 0000 0000 ， 1 =》 0000 0001， 1|256 =》 1 0000 0001 ，后面再截取最后8位，这样就能补齐高位</span></span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           temp =temp | <span class="number">256</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String str = Integer.toBinaryString(temp);</span><br><span class="line">       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">           <span class="comment">//如果补了高位，就截取最后 8 位</span></span><br><span class="line">           <span class="keyword">return</span> str.substring(str.length()-<span class="number">8</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没有补高位就直接返回</span></span><br><span class="line">           <span class="keyword">return</span> str;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> huffmanTable   赫夫曼编码表</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bytes          需要解压的字节数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>               解压后的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//开始解压</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] unzip(Map&lt;Byte,String&gt; huffmanTable,<span class="keyword">byte</span>[] bytes)&#123;</span><br><span class="line">       <span class="comment">//遍历字节数组，将每一个字节转换成二进制字符串，添加到stringBuilder</span></span><br><span class="line">       <span class="comment">//如:1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">       StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果是最后一位，则不需要补高位</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = i==bytes.length-<span class="number">1</span>;</span><br><span class="line">           stringBuilder.append(byteToBinaryString(!flag, bytes[i]));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//根据哈夫曼编码表将二进制字符串解码</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//先转换一下哈夫曼编码表</span></span><br><span class="line">       HashMap&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;Byte,String&gt; table:huffmanTable.entrySet())&#123;</span><br><span class="line">           map.put(table.getValue(),table.getKey());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开始解码</span></span><br><span class="line">       List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 扫描 二进制字符串</span></span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (index&lt;stringBuilder.length())&#123;</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">1</span>;        <span class="comment">//用于计数</span></span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;  <span class="comment">//标记是否计数</span></span><br><span class="line">           String str;         <span class="comment">//用于拼接</span></span><br><span class="line">           Byte value = <span class="keyword">null</span>;         <span class="comment">//用于存放解码后的字节</span></span><br><span class="line">           <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">               str=stringBuilder.substring(index,index+count);</span><br><span class="line">               value=map.get(str);</span><br><span class="line">               <span class="keyword">if</span>(value==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//当前没有找到，继续查找，计数器+1</span></span><br><span class="line">                   count++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//找到，可以结束当前</span></span><br><span class="line">                   flag=<span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//循环结束，表示找到，将value放入list中，并且index指针向后移count次</span></span><br><span class="line">           list.add(value);</span><br><span class="line">           index+=count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将list中的数据全部放入一个字节数组中，返回</span></span><br><span class="line">       <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">           result[i]=list.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩 </p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> srcFile   希望压缩的文件路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dstFile   压缩后文件的路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileZip</span><span class="params">(String srcFile,String dstFile)</span></span>&#123;</span><br><span class="line">      <span class="comment">//文件输入流</span></span><br><span class="line">      InputStream in = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件输出流</span></span><br><span class="line">      OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//文件对象输出流</span></span><br><span class="line">      ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// ===============写入================</span></span><br><span class="line">          in=<span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">          <span class="comment">//用来存放文件数据</span></span><br><span class="line">          <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">          <span class="comment">//开始写入</span></span><br><span class="line">          in.read(bytes);</span><br><span class="line">          <span class="comment">//================压缩================</span></span><br><span class="line">          <span class="keyword">byte</span>[] zip = HuffmanCoding.zip(bytes);</span><br><span class="line">          <span class="comment">//================输出===============</span></span><br><span class="line">          os=<span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">          oos=<span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">          <span class="comment">//将数据写入</span></span><br><span class="line">          oos.writeObject(zip);</span><br><span class="line">          <span class="comment">//还需将赫夫曼编码表写入</span></span><br><span class="line">          oos.writeObject(HuffmanCoding.huffmanTable);</span><br><span class="line">          System.out.println(<span class="string">&quot;压缩成功~~~&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          System.out.println(e.getMessage());</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//关闭流</span></span><br><span class="line">              in.close();</span><br><span class="line">              os.close();</span><br><span class="line">              oos.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">              System.out.println((ex.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> zipFile  需要解压的文件路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile   解压后的文件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileUnzip</span><span class="params">(String zipFile,String srcFile)</span></span>&#123;</span><br><span class="line">       <span class="comment">//文件输入流</span></span><br><span class="line">       InputStream is=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件对象输入流</span></span><br><span class="line">       ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//文件输出流</span></span><br><span class="line">       OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//=================输入==============</span></span><br><span class="line">           is=<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">           ois=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">           <span class="comment">//读取数据</span></span><br><span class="line">           <span class="keyword">byte</span>[] bytes =(<span class="keyword">byte</span>[]) ois.readObject();</span><br><span class="line">           <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">           Map&lt;Byte,String&gt; huffmanCodes=(Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line">           <span class="comment">//=================解压==============</span></span><br><span class="line">           <span class="keyword">byte</span>[] result = HuffmanCoding.unzip(huffmanCodes, bytes);</span><br><span class="line">           <span class="comment">//=================输出==============</span></span><br><span class="line">           os=<span class="keyword">new</span> FileOutputStream(srcFile);</span><br><span class="line">           os.write(result);</span><br><span class="line">           System.out.println(<span class="string">&quot;解压成功~~~&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//关闭流</span></span><br><span class="line">               is.close();</span><br><span class="line">               ois.close();</span><br><span class="line">               os.close();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               System.out.println(e.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//因为是对二进制进行压缩，所以可以压缩视频即图片</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要压缩的文件</span></span><br><span class="line">       String srcFile=<span class="string">&quot;c://test.png&quot;</span>;</span><br><span class="line">        <span class="comment">//压缩后的地址</span></span><br><span class="line">       String dstFile=<span class="string">&quot;c://test.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//解压后的地址</span></span><br><span class="line">       String srcFile2=<span class="string">&quot;c://test2.png&quot;</span>;</span><br><span class="line">       <span class="comment">//压缩</span></span><br><span class="line">       fileZip(srcFile,dstFile);</span><br><span class="line">       <span class="comment">//解压</span></span><br><span class="line">       fileUnzip(dstFile,srcFile2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>赫夫曼树</tag>
        <tag>压缩</tag>
        <tag>解压</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树与平衡二叉树</title>
    <url>/2021/03/17/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树：BST (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。 </p>
<p>特别说明：<a id="more"></a>如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><a href="https://imgtu.com/i/6cOefO"><img src="https://s3.ax1x.com/2021/03/17/6cOefO.png" alt="6cOefO.png"></a></p>
<h3 id="二叉排序树创建和遍历"><a href="#二叉排序树创建和遍历" class="headerlink" title="二叉排序树创建和遍历"></a>二叉排序树创建和遍历</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   Node left;</span><br><span class="line">   Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//小的添加到左边</span></span><br><span class="line">        <span class="keyword">if</span>(node.value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点有左子树，则递归左子树进行添加</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.left=node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.value&gt;<span class="keyword">this</span>.value)&#123; <span class="comment">//大的添加到右边</span></span><br><span class="line">            <span class="comment">//如果当前节点有右子树，则递归右子树进行添加</span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">this</span>.right.add(node);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.right=node;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;添加失败:该节点已存在！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>1.需求先去找到要删除的结点 targetNode </p>
<p>2.找到 targetNode 的 父结点 parent </p>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 </p>
<ol>
<li><p>删除叶子节点  </p>
</li>
<li><p>删除只有一颗子树的节点  </p>
</li>
<li><p>删除有两颗子树的节点. </p>
</li>
</ol>
<h5 id="情况一-删除叶子节点"><a href="#情况一-删除叶子节点" class="headerlink" title="情况一: 删除叶子节点"></a>情况一: 删除叶子节点</h5><p>1.确定 targetNode 是 parent 的左子结点 还是右子结点 </p>
<p>2.根据前面的情况来对应删除 </p>
<p>左子结点 parent.left = null </p>
<p>右子结点 parent.right = null;</p>
<h5 id="情况二-删除只有一颗子树的节点"><a href="#情况二-删除只有一颗子树的节点" class="headerlink" title="情况二: 删除只有一颗子树的节点"></a>情况二: 删除只有一颗子树的节点</h5><p>1.确定 targetNode 的子结点是左子结点还是右子结点 </p>
<p>2.确定targetNode 是 parent 的左子结点还是右子结点</p>
<p>3.根据上面的判断让parent直接指向targetNode 的子节点</p>
<h5 id="情况三-：-删除有两颗子树的节点"><a href="#情况三-：-删除有两颗子树的节点" class="headerlink" title="情况三 ： 删除有两颗子树的节点"></a>情况三 ： 删除有两颗子树的节点</h5><p>1.从 targetNode 的右子树找到最小的结点  (从左子树中找最大值也一样)</p>
<p>2.用一个临时变量temp，将 最小结点的值</p>
<p>3.删除该最小结点 </p>
<p>4.将当前节点的值指向临时变量  ，  targetNode.value = temp</p>
<h4 id="代码实现（前提）"><a href="#代码实现（前提）" class="headerlink" title="代码实现（前提）"></a>代码实现（前提）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line"><span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMaxNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node     当作一棵树的根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>          最小值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//删除当前树中的最大值，且返回该节点的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDeleteMinNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node temp=node;</span><br><span class="line">       <span class="keyword">while</span> (temp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           temp=temp.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除</span></span><br><span class="line">       delete(temp.value);</span><br><span class="line">       <span class="keyword">return</span> temp.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> root.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"> <span class="comment">//查找当前节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果找到就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>(value==<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(value&gt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没找到就返回空</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找当前节点的父节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果value等于当前节点的左子树的值 或 右子树的值  就直接返回</span></span><br><span class="line">       <span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value==value))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果小于，并且当前节点有左子树，就向左递归查找</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; value&lt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; value&gt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">           <span class="comment">//如果大于，并且当前节点有右子树，就向右递归查找</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//没找到就返回空</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代码实现-和兴"><a href="#代码实现-和兴" class="headerlink" title="代码实现 (和兴)"></a>代码实现 (和兴)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//====================BinarySortTree中的代码==============================</span></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前树是空树!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要删除的节点是根节点，并且当前树只有该根节点，直接自我删除即可</span></span><br><span class="line">        <span class="keyword">if</span>(value==root.value &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到要删除的节点</span></span><br><span class="line">        Node target = <span class="keyword">this</span>.search(value);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败:没有value值为:&quot;</span>+value+<span class="string">&quot;的节点&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除节点的父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.searchParent(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况一:当前要删除的节点是叶节点</span></span><br><span class="line">        <span class="keyword">if</span>(target.right==<span class="keyword">null</span> &amp;&amp; target.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断target是parent的左子树还是右子树</span></span><br><span class="line">            <span class="keyword">if</span>(parent.left!=<span class="keyword">null</span> &amp;&amp; parent.left.value== target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.left=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right!=<span class="keyword">null</span> &amp;&amp; parent.right.value==target.value)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                parent.right=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target.right!=<span class="keyword">null</span> &amp;&amp; target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//情况二:删除有两个子树的节点</span></span><br><span class="line">            <span class="comment">//思路:将左子树中的最大值或右子树中的最小值删除，再填充到当前节点</span></span><br><span class="line">            <span class="comment">//获取右子树中的最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = getAndDeleteMinNode(target.right);</span><br><span class="line">            <span class="comment">//将最小值填充到target中</span></span><br><span class="line">            target.value=min;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取左子树中最大的值(两种方法随便选一个即可)</span></span><br><span class="line"><span class="comment">//            int max =getAndDeleteMaxNode(target.left);</span></span><br><span class="line">            <span class="comment">//将最大值填充到target中</span></span><br><span class="line"><span class="comment">//            target.value=max;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况三:删除只有一个子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(target.left!=<span class="keyword">null</span>)&#123;<span class="comment">//删除的节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//删除的节点有右子树</span></span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//target是parent的左子树</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=target.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target是parent的右子树</span></span><br><span class="line">                        parent.right=target.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前节点没有父节点，即根节点</span></span><br><span class="line">                    root=target.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><p>看一个案例(说明二叉排序树可能的问题) </p>
<p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在</p>
<p><a href="https://imgtu.com/i/6cx1xS"><img src="https://s3.ax1x.com/2021/03/17/6cx1xS.png" alt="6cx1xS.png"></a></p>
<ol>
<li><p>左子树全部为空，从形式上看，更像一个单链表. </p>
</li>
<li><p>插入速度没有影响 </p>
</li>
<li><p>查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 </p>
</li>
<li><p>解决方案-平衡二叉树(AVL)</p>
</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 </p>
</li>
<li><p>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 </p>
</li>
<li><p>举例说明, 看看下面哪些 AVL 树</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6cx2I1"><img src="https://s3.ax1x.com/2021/03/17/6cx2I1.png" alt="6cx2I1.png"></a></p>
<h3 id="单旋转-左旋转"><a href="#单旋转-左旋转" class="headerlink" title="单旋转(左旋转)"></a>单旋转(左旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p>
<p><a href="https://imgtu.com/i/6czfTs"><img src="https://s3.ax1x.com/2021/03/17/6czfTs.png" alt="6czfTs.png"></a></p>
<h4 id="代码实现-核心"><a href="#代码实现-核心" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><h6 id="注-下面的代码全是在上面的二叉查找树的基础上完成的"><a href="#注-下面的代码全是在上面的二叉查找树的基础上完成的" class="headerlink" title="注:下面的代码全是在上面的二叉查找树的基础上完成的"></a>注:下面的代码全是在上面的二叉查找树的基础上完成的</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//左旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//复制当前节点</span></span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       <span class="comment">//将新节点的左子树变成当前节点的左子树</span></span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">       <span class="comment">//将新节点的右子树变成当前节点的右子树的左子树</span></span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">       <span class="comment">//将当前节点的右子树的值覆盖当前节点（即将右子树代替当前节点）</span></span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line">       <span class="comment">//将当前节点的左子树变成新节点</span></span><br><span class="line">       <span class="keyword">this</span>.left = newNode;</span><br><span class="line">       <span class="comment">//将当前节点的右子树变成当前节点的右子树的右子树</span></span><br><span class="line">       <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="单旋转-右旋转"><a href="#单旋转-右旋转" class="headerlink" title="单旋转(右旋转)"></a>单旋转(右旋转)</h3><p>给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p>
<p><a href="https://imgtu.com/i/6gSg9x"><img src="https://s3.ax1x.com/2021/03/17/6gSg9x.png" alt="6gSg9x.png"></a></p>
<h4 id="代码实现-核心-1"><a href="#代码实现-核心-1" class="headerlink" title="代码实现(核心)"></a>代码实现(核心)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================</span></span><br><span class="line"><span class="comment">//右旋(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">       newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">       newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">       <span class="keyword">this</span>.right = newNode;</span><br><span class="line">       <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================Node中的代码==============================	</span></span><br><span class="line"><span class="comment">//获取当前树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Math.max(node.left == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left), node.right == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取左子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取右子树的高度(新增)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> getHeight(<span class="keyword">this</span>.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><p>在之前二叉查找树的节点类的新增方法上添加以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">     <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) </span><br><span class="line">         leftRotate();</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">     <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         rightRotate();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。例如: </p>
<p>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.</p>
<p>int[] arr = {2,1,6,5,7,3};   运行原来的代码可以看到，并没有转成 AVL 树</p>
<h5 id="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"><a href="#解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）" class="headerlink" title="解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）"></a>解决思路分析（这里只讲右旋，左旋思路一样，下面代码中有）</h5><p>1.当符合右旋转的条件时 (左子树长)</p>
<p>2.如果它的左子树的右子树高度大于它的左子树的高度</p>
<p>3.先对当前这个结点的左节点进行左旋转</p>
<p>4.再对当前结点进行右旋转的操作即可</p>
<h4 id="改进代码-1"><a href="#改进代码-1" class="headerlink" title="改进代码"></a>改进代码</h4><p>在上面的改进代码中再次改进（有点绕，自己画个图就能理解了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每添加完一个节点就判断一把</span></span><br><span class="line">      <span class="comment">//右子树高度比左子树高度大于1，左旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果右子树的左子树高于右子树，需要先将右子树进行右旋</span></span><br><span class="line">          <span class="keyword">if</span>(right.leftHeight()&gt;right.rightHeight())&#123;</span><br><span class="line">              right.rightRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          leftRotate();</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//左子树高度比右子树高度大于1，右旋(新增)</span></span><br><span class="line">      <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//注意还要双旋转</span></span><br><span class="line">          <span class="comment">//如果左子树的右子树高于左子树，需要先将左子树进行左旋</span></span><br><span class="line">          <span class="keyword">if</span>(left.rightHeight()&gt;left.leftHeight())&#123;</span><br><span class="line">              left.leftRotate();</span><br><span class="line">          &#125;</span><br><span class="line">          rightRotate();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2021/03/19/%E5%9B%BE/</url>
    <content><![CDATA[<p>为什么要有图 </p>
<ol>
<li><p>前面我们学了线性表和树 </p>
</li>
<li><p>线性表局限于一个直接前驱和一个直接后继的关系 </p>
</li>
<li><p>树也只能有一个直接前驱也就是父节点 </p>
</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>当我们需要表示多对多的关系时， 这里我们就用到了图。</li>
</ol>
<h3 id="图的举例说明"><a href="#图的举例说明" class="headerlink" title="图的举例说明"></a>图的举例说明</h3><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图：</p>
<p><a href="https://imgtu.com/i/6feD5q"><img src="https://s4.ax1x.com/2021/03/19/6feD5q.png" alt="6feD5q.png"></a></p>
<h4 id="图的常用概念"><a href="#图的常用概念" class="headerlink" title="图的常用概念"></a>图的常用概念</h4><ol>
<li><p>顶点(vertex) </p>
</li>
<li><p>边(edge) </p>
</li>
<li><p>路径 </p>
</li>
<li><p>无向图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feoPx"><img src="https://s4.ax1x.com/2021/03/19/6feoPx.png" alt="6feoPx.png"></a></p>
<ol start="5">
<li><p>有向图 </p>
</li>
<li><p>带权图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6feHxO"><img src="https://s4.ax1x.com/2021/03/19/6feHxO.png" alt="6feHxO.png"></a></p>
<h3 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h3><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。</p>
<p><a href="https://imgtu.com/i/6fm9Rf"><img src="https://s4.ax1x.com/2021/03/19/6fm9Rf.png" alt="6fm9Rf.png"></a></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ol>
<li><p>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. </p>
</li>
<li><p>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6fmiQS"><img src="https://s4.ax1x.com/2021/03/19/6fmiQS.png" alt="6fmiQS.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放各顶点之间关系的二维数组，权重1表示有链接，0表示无连接(矩阵图)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//存放所有的顶点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeCount;</span><br><span class="line">    <span class="comment">//是否已访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edgeCount=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1      边的一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2      边的另一个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  权重 (这里1表示链接，0表示不连接)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2]=<span class="number">1</span>;</span><br><span class="line">        edges[v2][v1]=<span class="number">1</span>;</span><br><span class="line">        edgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===============其他常用方法==============</span></span><br><span class="line">    <span class="comment">//获取顶点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgesCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edgeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取v1与v2的权重(是否链接)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isClose</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回下标 i 对应的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印edges</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arr=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>&#125;;</span><br><span class="line">    	<span class="comment">//创建图，并添加顶点</span></span><br><span class="line">       Graph graph = <span class="keyword">new</span> Graph(arr.length);</span><br><span class="line">       <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">           graph.addVertex(s);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加边</span></span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       graph.showEdges();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先遍历介绍"><a href="#图的深度优先遍历介绍" class="headerlink" title="图的深度优先遍历介绍"></a>图的深度优先遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 访问策略: </p>
<p>(1)深度优先遍历 </p>
<p>(2)广度优先遍历</p>
<h4 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h4><p>图的深度优先搜索(Depth First Search) 。 </p>
<ol>
<li><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 </p>
</li>
<li><p>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 </p>
</li>
<li><p>显然，深度优先搜索是一个递归的过程</p>
</li>
</ol>
<h5 id="深度优先遍历算法步骤"><a href="#深度优先遍历算法步骤" class="headerlink" title="深度优先遍历算法步骤"></a>深度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v，并标记结点 v 为已访问。</p>
</li>
<li><p>查找结点 v 的第一个邻接结点 w。</p>
</li>
<li><p>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 </p>
</li>
<li><p>若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 </p>
</li>
<li><p>查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 </p>
</li>
</ol>
<h5 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前顶点第一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前顶点当前邻接点的下一个邻接点下标</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=w+<span class="number">1</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(edges[v][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度遍历(DFS)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">       <span class="comment">//没有访问过</span></span><br><span class="line">       <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">           System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">           <span class="comment">//标识已访问</span></span><br><span class="line">           isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取第一个邻接点</span></span><br><span class="line">       <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">       <span class="comment">//如果有邻接点，循环遍历</span></span><br><span class="line">       <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果没有被访问，就访问，并标识</span></span><br><span class="line">           <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">              DFS(w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续访问下一个</span></span><br><span class="line">           w=getNextNeighbor(v,w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//重构深度遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">       isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; vertexList.size();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">               DFS(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历基本思想"><a href="#广度优先遍历基本思想" class="headerlink" title="广度优先遍历基本思想"></a>广度优先遍历基本思想</h4><ol>
<li><p>图的广度优先搜索(Broad First Search) 。</p>
</li>
<li><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 访问这些结点的邻接结点 </p>
</li>
</ol>
<h5 id="广度优先遍历算法步骤"><a href="#广度优先遍历算法步骤" class="headerlink" title="广度优先遍历算法步骤"></a>广度优先遍历算法步骤</h5><ol>
<li><p>访问初始结点 v 并标记结点 v 为已访问。 </p>
</li>
<li><p>结点 v 入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。 </p>
</li>
<li><p>出队列，取得队头结点 u。 </p>
</li>
<li><p>查找结点 u 的第一个邻接结点 w。 </p>
</li>
<li><p>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： </p>
</li>
</ol>
<p>​    6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 </p>
<p>​    6.2 结点 w 入队列 </p>
<p>​    6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度遍历(BFS)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">      <span class="comment">//用LinkedList模拟一个队列，输出一个数据就将它放入队尾</span></span><br><span class="line">      LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">//没有被访问</span></span><br><span class="line">      <span class="keyword">if</span>(!isVisited[v])&#123;</span><br><span class="line">          System.out.print(vertexList.get(v)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">          isVisited[v]=<span class="keyword">true</span>;</span><br><span class="line">          queue.addLast(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//获取队列头</span></span><br><span class="line">          v = (<span class="keyword">int</span>)queue.removeFirst();</span><br><span class="line">          <span class="comment">//获取第一个邻接点</span></span><br><span class="line">          <span class="keyword">int</span> w = getFirstNeighbor(v);</span><br><span class="line">          <span class="comment">//如果有邻接点</span></span><br><span class="line">          <span class="keyword">while</span> (w!=-<span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">                  System.out.print(vertexList.get(w)+<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">                  isVisited[w]=<span class="keyword">true</span>;</span><br><span class="line">                  queue.addLast(w);</span><br><span class="line">              &#125;</span><br><span class="line">              w=getNextNeighbor(v,w);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重构广度遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">      isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexList.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">              BFS(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2021/03/19/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<p>汉诺塔的传说 </p>
<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度<a id="more"></a>一个古老传说的益智玩具。大梵天创造世界的时候做了三根金 刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小 顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p> 假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百 亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 </p>
<h3 id="汉诺塔游戏的演示和思路分析"><a href="#汉诺塔游戏的演示和思路分析" class="headerlink" title="汉诺塔游戏的演示和思路分析:"></a>汉诺塔游戏的演示和思路分析:</h3><p>分治算法解决汉诺塔问题<br>1.如果只有一个盘就直接从a移动到c<br>2.如果个数大&gt;=2,就将盘分成最下面一个盘与上面的所有盘<br>3.将上面的所有盘从a移动到b，最下面一个盘从a移动到c，最后把上面的所有盘从b移动到c，依次递归执行</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num    盘的个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a      柱子 1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b      柱子 2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c      柱子 3</span></span><br><span class="line"><span class="comment">    */</span> 	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">       <span class="comment">//如果只有一个盘</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;盘 1 :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//将上面的所有盘从a移动到b</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">           <span class="comment">//最下面一个盘从a移动到c</span></span><br><span class="line">           System.out.println(<span class="string">&quot;盘 &quot;</span>+num+<span class="string">&quot; :&quot;</span>+a+<span class="string">&quot;=&gt;&quot;</span>+c);</span><br><span class="line">           <span class="comment">//最后把上面的所有盘从b移动到c</span></span><br><span class="line">           hanoi(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//测试汉诺塔</span></span><br><span class="line">       hanoi(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2021/03/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>最小生成树(Minimum Cost Spanning Tree)，简称 MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树</p>
<a id="more"></a>

<h2 id="普里姆（prim）算法"><a href="#普里姆（prim）算法" class="headerlink" title="普里姆（prim）算法"></a>普里姆（prim）算法</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的 连通子图，也就是所谓的极小连通子图</p>
<h3 id="修路问题"><a href="#修路问题" class="headerlink" title="修路问题"></a>修路问题</h3><p><a href="https://imgtu.com/i/6xhH2D"><img src="https://z3.ax1x.com/2021/03/27/6xhH2D.png" alt="6xhH2D.png"></a></p>
<ol>
<li><p>有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通 </p>
</li>
<li><p>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 </p>
</li>
<li><p>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h4><p>有n个顶点，则需要获取n-1条边</p>
<p>每一次获取边一条边的步骤:</p>
<p>1.假如从A开始，将A设为已访问，获取所有已访问与未访问相连的边 如 &lt;A,C&gt;=7   &lt;A,B&gt;=5    &lt;A,G&gt;=2</p>
<p>2.上面三条边中取权值最小的一条边:&lt;A,G&gt;=2,并将G设为已访问</p>
<p>接下来获取第二条边时，A   G  已经是访问过的点了</p>
<p>可以获取 &lt;A,C&gt;=7   &lt;A,B&gt;=5   &lt;G,B&gt;=3   &lt;G,E&gt;=4   &lt;G,F&gt;=6   这5条边，选择最小的一条边: &lt;G,B&gt;=3,并将B设为已访问</p>
<p>循环 n-1次上面的操作</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  需要生产最小数的图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v      从哪个顶点下标开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(Graph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.vertexNum];</span><br><span class="line">        <span class="comment">//标记当前被访问过</span></span><br><span class="line">        isVisited[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记当前生产边的两个点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存放最小值，初始值可以用无穷大代替</span></span><br><span class="line">        <span class="keyword">int</span> minWeight=<span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为普利姆算法最后产生顶点个数x-1条边，每循环一次添加一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt; graph.vertexNum-<span class="number">1</span>;n++)&#123;</span><br><span class="line">            <span class="comment">// i 表示被访问过的顶点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; graph.vertexNum;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示没有被访问过的顶点下标</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph.vertexNum;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVisited[i]==<span class="number">1</span> &amp;&amp; isVisited[j]==<span class="number">0</span> &amp;&amp; graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        <span class="comment">//替换最小值 与顶点</span></span><br><span class="line">                        minWeight=graph.weight[i][j];</span><br><span class="line">                        h1=i;</span><br><span class="line">                        h2=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结束上面两个循环，就生产了一条边</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span>+graph.data[h1]+<span class="string">&quot;,&quot;</span>+graph.data[h2]+<span class="string">&quot;&gt;,&quot;</span>+minWeight);</span><br><span class="line">            <span class="comment">//标记当前点已访问</span></span><br><span class="line">            isVisited[h2]=<span class="number">1</span>;</span><br><span class="line">            minWeight=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexNum  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight     矩阵图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Graph <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum,<span class="keyword">char</span>[] data,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertexNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            graph.data[i]=data[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;</span><br><span class="line">                graph.weight[i][j]=weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> vertexNum;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] data;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexNum = vertexNum;</span><br><span class="line">        <span class="keyword">this</span>.data=<span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">        <span class="keyword">this</span>.weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顶点</span></span><br><span class="line">        <span class="keyword">char</span>[] data=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 矩阵图</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight=&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Graph graph = minTree.createGraph(data.length,data,weight);</span><br><span class="line">        <span class="comment">//生产最小数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最段路:&quot;</span>);</span><br><span class="line">        minTree.prim(graph,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h2><ol>
<li><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 </p>
</li>
<li><p>基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 </p>
</li>
<li><p>具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森 林中不产生回路，直至森林变成一棵树为止</p>
</li>
</ol>
<h3 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h3><p><a href="https://imgtu.com/i/6xoaWV"><img src="https://z3.ax1x.com/2021/03/27/6xoaWV.png" alt="6xoaWV.png"></a></p>
<ol>
<li><p>有北京有新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 </p>
</li>
<li><p>各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 </p>
</li>
<li><p>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p>
</li>
</ol>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>第 1 步：将边加入 R 中。 边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbSmD"><img src="https://z3.ax1x.com/2021/03/27/6xbSmD.png" alt="6xbSmD.png"></a></p>
<p>第 2 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。</p>
<p><a href="https://imgtu.com/i/6xb9TH"><img src="https://z3.ax1x.com/2021/03/27/6xb9TH.png" alt="6xb9TH.png"></a></p>
<p>第 3 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbitA"><img src="https://z3.ax1x.com/2021/03/27/6xbitA.png" alt="6xbitA.png"></a></p>
<p>第 4 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbFfI"><img src="https://z3.ax1x.com/2021/03/27/6xbFfI.png" alt="6xbFfI.png"></a></p>
<p>第 5 步：将边加入 R 中。 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbApt"><img src="https://z3.ax1x.com/2021/03/27/6xbApt.png" alt="6xbApt.png"></a></p>
<p>第 6 步：将边加入 R 中。 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳 过边。将边加入到最小生成树结果 R 中。 </p>
<p><a href="https://imgtu.com/i/6xbE1P"><img src="https://z3.ax1x.com/2021/03/27/6xbE1P.png" alt="6xbE1P.png"></a></p>
<p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt;  &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;     </p>
<h5 id="克鲁斯卡尔算法重点需要解决的以下两个问-题："><a href="#克鲁斯卡尔算法重点需要解决的以下两个问-题：" class="headerlink" title="克鲁斯卡尔算法重点需要解决的以下两个问 题："></a>克鲁斯卡尔算法重点需要解决的以下两个问 题：</h5><h6 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h6><p>对图的所有边按照权值大小进行排序。很好解决，采用排序算法进行排序即可。</p>
<h6 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h6><p>将边添加到最小生成树中时，怎么样判断是否形成了回路。 </p>
<p>记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。 然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123; </span><br><span class="line">    <span class="comment">//用无穷大表示不存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line">    <span class="comment">//所有顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里全部采用复制拷贝的方式初始化，而不是直接赋值，是为了不改变原来传进来vertex，weight的值</span></span><br><span class="line">        <span class="keyword">int</span> len = vertex.length;</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="keyword">this</span>.vertex = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertex[i] = vertex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化矩阵图 与 边的个数</span></span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.weight[i][j] = weight[i][j];</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF &amp;&amp; weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edgeNum /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心算法(生产最小树)</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] kruskal() &#123;</span><br><span class="line">        <span class="comment">//存放最终结果</span></span><br><span class="line">        Edge[] result = <span class="keyword">new</span> Edge[vertex.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存放各个顶点的终点，该数组是不断变化的</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length];</span><br><span class="line">        <span class="comment">//获取所有边</span></span><br><span class="line">        Edge[] edges = getAllEdge();</span><br><span class="line">        <span class="comment">//将边从小到大排序</span></span><br><span class="line">        sort(edges);</span><br><span class="line">        <span class="comment">//遍历排序后的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取边的两个点的下标</span></span><br><span class="line">            <span class="keyword">char</span> v1 = edges[i].from;</span><br><span class="line">            <span class="keyword">int</span> p1 = getIndexOfVertex(v1);</span><br><span class="line">            <span class="keyword">char</span> v2 = edges[i].to;</span><br><span class="line">            <span class="keyword">int</span> p2 = getIndexOfVertex(v2);</span><br><span class="line">            <span class="comment">//然后获取两个点的终点,如果终点的值为0，返回的就是它的自己下标</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p1);</span><br><span class="line">            <span class="keyword">int</span> m =getEnd(ends,p2);</span><br><span class="line">            <span class="comment">//如果两个点的终点不一样就加入到树中,并且标记终点</span></span><br><span class="line">            <span class="keyword">if</span> (n != m) &#123;</span><br><span class="line">                result[index++] = edges[i];</span><br><span class="line">                ends[n] = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============其他补充的重要方法======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 存放每个顶点对应的终点，如果下标是0，则表示终点是自己</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需要查找终点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下标 i 对应的终点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取下标 i 的终点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据顶点获取该顶点所在的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndexOfVertex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex[i] == v) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边排序(从小到大,冒泡)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Edge[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    Edge temp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有边,如果边为INT 或 0（本身）则不显示</span></span><br><span class="line">    <span class="keyword">public</span> Edge[] getAllEdge() &#123;</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> Edge[edgeNum];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != INF) &#123;</span><br><span class="line">                    Edge edge = <span class="keyword">new</span> Edge(vertex[i], vertex[j], weight[i][j]);</span><br><span class="line">                    edges[index++] = edge;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%13d&quot;</span>, weight[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> from;</span><br><span class="line">    <span class="keyword">char</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">char</span> from, <span class="keyword">char</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span> + from + <span class="string">&quot;,&quot;</span></span><br><span class="line">                + to +</span><br><span class="line">                <span class="string">&quot;&gt;=&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span>[][] weight = &#123;</span><br><span class="line">               <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">               <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">               <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">               <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">               <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">               <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">               <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//创建</span></span><br><span class="line">       Kruskal kruskal = <span class="keyword">new</span> Kruskal(vertex, weight);</span><br><span class="line">       System.out.println(<span class="string">&quot;矩阵图为:&quot;</span>);</span><br><span class="line">       kruskal.show();</span><br><span class="line">       <span class="comment">//开始生产最小树</span></span><br><span class="line">       Edge[] result = kruskal.kruskal();</span><br><span class="line">       System.out.println(<span class="string">&quot;最小树为:&quot;</span>);</span><br><span class="line">       System.out.println(Arrays.toString(result));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>prim</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2021/03/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以 起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<p><a href="https://imgtu.com/i/6xz77V"><img src="https://z3.ax1x.com/2021/03/27/6xz77V.png" alt="6xz77V.png"></a></p>
<p>如何计算出 G 到 其它各个点的最短距离?</p>
<a id="more"></a>

<h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><ol>
<li><p>设置出发顶点为 G，顶点集合 V{v1,v2,vi…}，G 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis 集合记录着 G 到图中各顶点的距离(到自身可以看作 0，G 到 vi 距离对应为 di) </p>
</li>
<li><p>从 Dis 中选择值最小且没有访问的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 G 到 vi 即为最短路径</p>
</li>
<li><p>更新 Dis 集合，更新规则为：比较 G 到 V 集合中顶点的距离值，与 G 通过 vi 到 V 集合中顶点的距离值，保留 值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) </p>
</li>
<li><p>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dgraph</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line">    VisitedVertex vv;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 从哪个顶点开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//迪杰斯特拉算法，生产最短路径，结果在vv中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        vv=<span class="keyword">new</span> VisitedVertex(vertex.length,index);</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        vv.update(index,weight);</span><br><span class="line">        <span class="comment">//每循环一次，获取下一个位还没有访问的最小距离的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            index = vv.getNextVertex();</span><br><span class="line">            <span class="comment">//标记该顶点已访问</span></span><br><span class="line">            vv.visited[index]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//根据下一个顶点进行更新</span></span><br><span class="line">            vv.update(index,weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dgraph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showVV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vv.show(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历矩阵图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints:weight)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取具体某个顶点路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        vv.getLoad(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放算法所需要的数组及方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span></span>&#123;</span><br><span class="line">    <span class="comment">//标记是顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">//标记出发点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] dis;</span><br><span class="line">    <span class="comment">//标记到该顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] pre_visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count  顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  从哪个顶点开始出发，寻找最短路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        dis=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        pre_visited=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="comment">//将其他顶点的距离设为最大值</span></span><br><span class="line">        Arrays.fill(dis,<span class="number">65532</span>);</span><br><span class="line">        <span class="comment">//本身的距离设置为0</span></span><br><span class="line">        dis[index]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记本身访问过</span></span><br><span class="line">        visited[index]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//前驱就是本身</span></span><br><span class="line">        pre_visited[index]=index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据index顶点与矩阵图更新VisitedVertex中的各个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="comment">//起点到index的距离加index到j的距离</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//遍历当前顶点的邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;weight[index].length;j++)&#123;</span><br><span class="line">            len=dis[index]+weight[index][j];</span><br><span class="line">            <span class="comment">//如果j点没有被访问，并且len小于起点到j的距离，则替换距离，并标记前驱</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; len&lt;dis[j])&#123;</span><br><span class="line">                dis[j]=len;</span><br><span class="line">                pre_visited[j]=index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取下一个顶点，如果当前顶点没有被访问，并且起点到该点的距离最小，就返回该点下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">65532</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dis.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="number">0</span> &amp;&amp; dis[j]&lt;min)&#123;</span><br><span class="line">                min=dis[j];</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历最短路径(dis)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span>[] vertex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">            System.out.print(vertex[i]+<span class="string">&quot;(&quot;</span>+dis[i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据某一个终点获取具体路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLoad</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pre_visited[end]!=end) &#123;</span><br><span class="line">            System.out.print(end+<span class="string">&quot;&lt;=&quot;</span>);</span><br><span class="line">            end=pre_visited[end];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] weight=<span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//表示该路不存在</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">65532</span>;</span><br><span class="line">        weight[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        weight[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        weight[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        weight[<span class="number">3</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        weight[<span class="number">4</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        weight[<span class="number">5</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        weight[<span class="number">6</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Dgraph graph = <span class="keyword">new</span> Dgraph(vertex, weight);</span><br><span class="line">        <span class="comment">//查看图的矩阵图</span></span><br><span class="line">        graph.show();</span><br><span class="line">        <span class="comment">//生产最短路径(从C开始)</span></span><br><span class="line">        graph.dijkstra(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最短路径:&quot;</span>);</span><br><span class="line">        graph.showVV();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n从C到D的路劲为:&quot;</span>);</span><br><span class="line">        graph.getLoad(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h2><ol>
<li><p>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法 名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 </p>
</li>
<li><p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p>
</li>
<li><p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 </p>
</li>
<li><p>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点 的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每 一个顶点到其他顶点的最短路径。</p>
</li>
</ol>
<h4 id="弗洛伊德-Floyd-算法图解分析"><a href="#弗洛伊德-Floyd-算法图解分析" class="headerlink" title="弗洛伊德(Floyd)算法图解分析"></a>弗洛伊德(Floyd)算法图解分析</h4><p><a href="https://imgtu.com/i/6zpMrR"><img src="https://z3.ax1x.com/2021/03/27/6zpMrR.png" alt="6zpMrR.png"></a></p>
<p>第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为：</p>
<ol>
<li>以 A 顶点作为中间顶点是，B-&gt;A-&gt;C = 12，C-&gt;A-&gt;G = 9 , B-&gt;A-&gt;G = 7 </li>
</ol>
<p>这里只需变换 B-&gt;C   与 C-&gt;G 的中间点，因为B-&gt;A-&gt;G = 7 路线更长，不需要变换</p>
<ol start="2">
<li>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li>
</ol>
<p><a href="https://imgtu.com/i/6zpOy9"><img src="https://z3.ax1x.com/2021/03/27/6zpOy9.png" alt="6zpOy9.png"></a></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fgraph</span></span>&#123;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//矩阵图(距离)</span></span><br><span class="line">    <span class="keyword">int</span>[][] dis;</span><br><span class="line">    <span class="comment">//中间顶点图（前驱）</span></span><br><span class="line">    <span class="keyword">int</span>[][] pre;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fgraph</span><span class="params">(<span class="keyword">char</span>[] vertex,<span class="keyword">int</span>[][] dis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex=vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis=dis;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">            Arrays.fill(pre[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弗洛伊德算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// k 表示中间点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="comment">// i 表示起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                <span class="comment">// j 表示终点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertex.length;j++)&#123;</span><br><span class="line">                    len=dis[i][k]+dis[k][j]; <span class="comment">//表示起点 i 经过中间点 m ，再到终点 j 的距离</span></span><br><span class="line">                    <span class="comment">//如果 len 小于 起点直接到终点的距离，就替换距离与前驱点</span></span><br><span class="line">                    <span class="keyword">if</span>(len&lt;dis[i][j])&#123;</span><br><span class="line">                        dis[i][j]=len;</span><br><span class="line">                        <span class="comment">//替换前驱点(中间点)</span></span><br><span class="line">                        pre[i][j]=pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出pre与dis</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vertex.length;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]]+<span class="string">&quot;\t\t\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vertex.length;i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span>+vertex[k]+<span class="string">&quot;-&gt;&quot;</span>+vertex[i]+<span class="string">&quot;=&quot;</span>+dis[k][i]+<span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">        dis[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">        dis[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">        dis[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        dis[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        dis[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Fgraph graph = <span class="keyword">new</span> Fgraph(vertex,dis);</span><br><span class="line">        System.out.println(<span class="string">&quot;距离图与前驱图:&quot;</span>);</span><br><span class="line">        graph.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n弗洛伊德计算后:&quot;</span>);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/03/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题：有一个背包，容量为 4 磅 ， 现有如下物品</p>
<p><a href="https://imgtu.com/i/6xs1Ag"><img src="https://z3.ax1x.com/2021/03/27/6xs1Ag.png" alt="6xs1Ag.png"></a></p>
<ol>
<li><p>要求达到的目标为装入的背包的<a id="more"></a>总价值最大，并且重量不超出 </p>
</li>
<li><p>要求装入的物品不能重复</p>
</li>
</ol>
<p>这里属于01背包问题，即每件物品只能放一次</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h3><p>算法的主要思想，利用动态规划来解决</p>
<p>1.定义物品的价格： p ，重量 w ，再定义一张表（列表示包能装的重量，行表示每一个物品）</p>
<p>2.遍历每一个物品，如果当前物品重量大于当前背包能装的重量，就采取前一个策列来装物品</p>
<p>3.如果包能装的重量大于或等于当前物品的重量，就需要判断— 上一个策略的价格 与 当前物品价格加剩余空间物品的价格，</p>
<p>哪个大，就把大的转入背包</p>
<p><a href="https://imgtu.com/i/6xsr4J"><img src="https://z3.ax1x.com/2021/03/27/6xsr4J.png" alt="6xsr4J.png"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//吉他，音响，电脑对应的价格</span></span><br><span class="line">        <span class="keyword">int</span>[] p = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包容量</span></span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//物品个数</span></span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="comment">//表（列表示包能装的重量，行表示每一个物品）</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//标记当前物品路径</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//遍历整个表（因为表的大小是n+1，all+1，所以要从1开始遍历，将0出省略）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;        <span class="comment">// i表示第几个物品，j表示第几个重量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果包能装的重量小于当前物品重量，则采取向上的策略</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//包能装的重量大于或等于当前物品的重量，</span></span><br><span class="line">                    <span class="comment">//上一个策略的价格 与 当前物品价格加剩余空间物品的价格</span></span><br><span class="line">                    <span class="comment">//v[i-1][j]表示上一个策略的价格</span></span><br><span class="line">                    <span class="comment">//p[i-1]表示当前物品价格，v[i-1][all-w[i-1]]表示总重量减去当前物品重量在上一个策略中的价格</span></span><br><span class="line"><span class="comment">//                    v[i][j]=Math.max(v[i-1][j],p[i-1]+v[i-1][all-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//注:当加入的path之后，不能像上面一样直接填写价格高的，这里还需分开，如果当前物品加上一个策略剩余物品价格要高，就在path中添加当前物品标记</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j]=p[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][all - w[i - <span class="number">1</span>]];</span><br><span class="line">                        path[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        v[i][j]=v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将添加的物品表示出来</span></span><br><span class="line">        <span class="comment">//反向遍历，如果该物品标记了，就输出，并且将当前背包的重量减去当前物品重量</span></span><br><span class="line">        <span class="keyword">int</span> i=path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加了&quot;</span>+i+<span class="string">&quot;号物品&quot;</span>);</span><br><span class="line">                j-= w[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;填表过程:&quot;</span>);</span><br><span class="line">        show(v);</span><br><span class="line">        System.out.println(<span class="string">&quot;path标记:&quot;</span>);</span><br><span class="line">        show(path);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[][] v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over 。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>马踏棋盘算法</title>
    <url>/2021/03/27/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>马踏棋盘算法也被称为骑士周游问题 </p>
</li>
<li><p>将马随机放在国际象棋的 8×8 棋盘的某个方格中，马按走棋规则(马走日字)进行移动。要求 每个方格只进入一次，走遍棋盘上全部 64 个方格</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/6zFtu4"><img src="https://z3.ax1x.com/2021/03/27/6zFtu4.png" alt="6zFtu4.png"></a></p>
<a id="more"></a>

<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发 现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……</p>
<p>1.假设当前位置可以走，设置当前已访问，并标记步数</p>
<p>1.获取马儿当前位置可以走的所有位置</p>
<p>2.遍历所有位置，如果该位置没走就递归走</p>
<p>3.一旦步数达到了棋盘总数，就标记  finished</p>
<p>3.如果遍历完毕，马儿走的步数没达到棋盘总数，或则没有完成，就表示当前位置走不了，清空当前位置的步数，且标记为未访问</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋盘的总列数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> X ;</span><br><span class="line">   <span class="comment">//棋盘的中行数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> Y;</span><br><span class="line">   <span class="comment">//马儿是否走过的位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">   <span class="comment">//开始走</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> row  当前马儿所在的 行 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> col  当前马儿所在的 列 轴 ，从0开始</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> step  当前的步数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>[][] chessBoard,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">       <span class="comment">//标记当前步数</span></span><br><span class="line">       chessBoard[row][col]=step;</span><br><span class="line">       <span class="comment">//标记当前走过,当前位置在一位数组中表示: 当前行*总列数+当前列</span></span><br><span class="line">       visited[row*X+col]=<span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//获取当前位置可以走的位置</span></span><br><span class="line">       List&lt;Point&gt; nextList = getNext(<span class="keyword">new</span> Point(col, row));</span><br><span class="line">       <span class="comment">//遍历所有的下一步</span></span><br><span class="line">       <span class="keyword">while</span> (!nextList.isEmpty()) &#123;</span><br><span class="line">           Point next = nextList.remove(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//如果下一步没走，就走该位置</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[next.y*X+next.x])&#123;</span><br><span class="line">               go(chessBoard,next.y,next.x,step+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断马儿是否完成了任务</span></span><br><span class="line">       <span class="comment">// 如果上面的循环结束，step没有走到X*Y步，并且还没完成，就将当前位置设置成未访问，并且清空当前位置的步数</span></span><br><span class="line">       <span class="comment">// 如果 step==X*Y ,表示走完，将finished=true; 之后回溯的过程中就不需要清空当前位置的步数了</span></span><br><span class="line">       <span class="keyword">if</span>(step&lt;X*Y &amp;&amp; !finished )&#123;</span><br><span class="line">           chessBoard[row][col]=<span class="number">0</span>;</span><br><span class="line">           visited[row*X+col]=<span class="keyword">false</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           finished=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//获取当前马儿可以走的路线</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point&gt; <span class="title">getNext</span><span class="params">(Point curr)</span></span>&#123;</span><br><span class="line">       List&lt;Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Point p = <span class="keyword">new</span> Point();</span><br><span class="line">       <span class="comment">// 5</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 7</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 0</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 1</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">2</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x+<span class="number">1</span>)&lt;X &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4</span></span><br><span class="line">       <span class="keyword">if</span>((p.x=curr.x-<span class="number">2</span>)&gt;=<span class="number">0</span> &amp;&amp; (p.y=curr.y+<span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> Point(p));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X=<span class="number">6</span>;</span><br><span class="line">        Y=<span class="number">6</span>;</span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span> [][] chessBoard=<span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[X*Y];</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始走</span></span><br><span class="line">        go(chessBoard,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;消耗&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">//输出棋盘</span></span><br><span class="line">        System.out.println(<span class="string">&quot;棋盘为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] ints:chessBoard)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i:ints)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用贪心算法进行优化"><a href="#使用贪心算法进行优化" class="headerlink" title="使用贪心算法进行优化"></a>使用贪心算法进行优化</h4><p>基本思路: 遍历所有下一步可走的位置时，不直接遍历，先对该结果进行排序</p>
<p>排序规则: 当前位置的下一次可走位置次数越大，就排在越前面</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>再上面的遍历nextList的代码上加上  sort(nextList)   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序  point下一次可以走的次数递增排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Point&gt; list)</span></span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取下一步可以走的步数</span></span><br><span class="line">                <span class="keyword">int</span> count1=getNext(o1).size();</span><br><span class="line">                <span class="keyword">int</span> count2=getNext(o2).size();</span><br><span class="line">                <span class="keyword">if</span>(count1-count2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1-count2==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>贪心算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2021/03/27/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配问题：</p>
<ol>
<li><p>有一个字符串 str1= “我是我是怪狗 我是我是怪狗狗”，和一个子串 str2=”我是怪狗狗” </p>
</li>
<li><p>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
</li>
</ol>
<a id="more"></a>

<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><h4 id="实录分析"><a href="#实录分析" class="headerlink" title="实录分析"></a>实录分析</h4><p>并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: </p>
<ol>
<li><p>如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 </p>
</li>
<li><p>如果失配（即 str1[i]! = str2[j]），令 i = i - j + 1，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 </p>
</li>
<li><p>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量 的时间。(不可行!)</p>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violence</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] s1=str1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2=str2.toCharArray();</span><br><span class="line">       <span class="comment">//指向s1的指针</span></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//指向s2的指针</span></span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;s1.length &amp;&amp; j&lt;s2.length)&#123;</span><br><span class="line">           <span class="comment">//如果匹配</span></span><br><span class="line">           <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//不匹配</span></span><br><span class="line">               <span class="comment">//i 回退到之前的位置，并且向前移动一位</span></span><br><span class="line">               i=i-j+<span class="number">1</span>;</span><br><span class="line">               j=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束,</span></span><br><span class="line">       <span class="keyword">if</span>(j==s2.length)&#123;</span><br><span class="line">           <span class="keyword">return</span> i-j;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>介绍《部分匹配表》怎么产生的 </p>
<p>先介绍前缀，后缀是什么</p>
<p><a href="https://imgtu.com/i/6x2JOI"><img src="https://z3.ax1x.com/2021/03/27/6x2JOI.png" alt="6x2JOI.png"></a></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度,例如</p>
<p>”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1；</p>
<p>”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2；</p>
<h5 id="”部分匹配”的实质是"><a href="#”部分匹配”的实质是" class="headerlink" title="”部分匹配”的实质是:"></a>”部分匹配”的实质是:</h5><p>字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么 它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候如果发现 最后一个D不匹配，这时第二个”AB”向前移动 4 位（字符串长度   减去   部分匹配值），就可以来到第一个”AB”的位置。再继续匹配</p>
<p><a href="https://imgtu.com/i/6x2yXn"><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></a></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”</p>
<p><a href="https://imgtu.com/i/6xRQH0"><img src="https://z3.ax1x.com/2021/03/27/6xRQH0.png" alt="6xRQH0.png"></a></p>
<p><a href="https://imgtu.com/i/6xRBE6"><img src="https://z3.ax1x.com/2021/03/27/6xRBE6.png" alt="6xRBE6.png"></a></p>
<p>6.这个时候，如果是暴力算法，就会将继续遍历第三步中 Str1 的下一个字符与str2的第一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这 样就提高了效率）</p>
<p>7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》</p>
<p><img src="https://z3.ax1x.com/2021/03/27/6x2yXn.png" alt="6x2yXn.png"></p>
<p>8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数： </p>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值 </p>
<p>因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p>
<p><a href="https://imgtu.com/i/6xWDLn"><img src="https://z3.ax1x.com/2021/03/27/6xWDLn.png" alt="6xWDLn.png"></a></p>
<p><a href="https://imgtu.com/i/6xWhQJ"><img src="https://z3.ax1x.com/2021/03/27/6xWhQJ.png" alt="6xWhQJ.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str1  所有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str2  需要查找的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> next  str2的部分匹配表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>      需要查找的值的下标，没找到就返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">      <span class="comment">//  i扫描，j扫描str2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ========核心代码===========</span></span><br><span class="line">          <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; str1.charAt(i)!=str2.charAt(j))&#123;</span><br><span class="line">              j=next[j-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果j扫描完毕，就返回下标（因为上面 j++ 了，而 i 没来得及 ++ ，所以后面要 +1 ）</span></span><br><span class="line">          <span class="keyword">if</span>(j==str2.length())&#123;</span><br><span class="line">              <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取一个字符串的部分匹配表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String str)&#123;</span><br><span class="line">      <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">      <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line">      <span class="comment">//第一个数据默认为0（没有前缀与后缀）</span></span><br><span class="line">      next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">          <span class="comment">//如果不匹配，不能直接让len=0，要让len变成匹配表中上一位的匹配值指向的位置</span></span><br><span class="line">          <span class="keyword">while</span>(len&gt;<span class="number">0</span> &amp;&amp; chars[i]!=chars[len])&#123;</span><br><span class="line">              len=next[len-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// i表示当前截取的字符最后一位，如果char[i]==char[len],表示匹配了，匹配值就在上一次的基础上+1,len也要向后移动一位，为了下一次的匹配</span></span><br><span class="line">          <span class="keyword">if</span>(chars[i]==chars[len])&#123;</span><br><span class="line">              len++;</span><br><span class="line">              next[i]=len;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符匹配</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/03/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。<a id="more"></a></p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h4><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>双重for循环，暴力求解</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] ints=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>( (nums[i]+nums[j]) == target)&#123;</span><br><span class="line">                   ints[<span class="number">0</span>]=i;</span><br><span class="line">                   ints[<span class="number">1</span>]=j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ints;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>1.创建一个map集合，key为数组中的值，value为数组当前值的下标</p>
<p>2.循环遍历数组,查询map中是否存在 target 减去 当前值这个key </p>
<p>3.不存在就将当前值为key，下标为value ，存入map中</p>
<p>4.如果存在就直接返回</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>合并有序链表</title>
    <url>/2021/03/28/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<a id="more"></a>

<p><a href="https://imgtu.com/i/cpVCqO"><img src="https://z3.ax1x.com/2021/03/28/cpVCqO.png" alt="cpVCqO.png" style="zoom: 80%;" /></a></p>
<h3 id="思路一-迭代"><a href="#思路一-迭代" class="headerlink" title="思路一:迭代"></a>思路一:迭代</h3><p>1.创建一个头节点head，用来存放结果，curr指向当前插入的位置</p>
<p>2.循环比较 l1.val 与 l2.val , 哪个小就添加到 curr .next ,并后移,直到一个链表全部遍历完毕</p>
<p>3.将另一个链表中剩余的值 直接添加到curr.next</p>
<p>4.返回 head.next</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放返回的结果</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="comment">//遍历两个链表，依次加入到 head中</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next= (l1!=<span class="keyword">null</span>? l1:l2);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-递归"><a href="#思路二-递归" class="headerlink" title="思路二:递归"></a>思路二:递归</h3><p>l1.val 与 l2.val 比较，哪个小就递归该节点的下一个节点与较大的节点，并返回该小的节点</p>
<p>思路都差不多，看代码理解吧~~</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出口，哪个链表先结束就获取另一个链表</span></span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//哪个小就返回哪个，并且再返回前还需将当前较小的节点递归调用获取下一个节点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">           l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="提升"><a href="#提升" class="headerlink" title="提升:"></a>提升:</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="思路一-暴力求解（不推荐）"><a href="#思路一-暴力求解（不推荐）" class="headerlink" title="思路一:暴力求解（不推荐）"></a>思路一:暴力求解（不推荐）</h3><p>遍历数组中所有的链表，全部添加到一个新的链表，再对新链表排序，简单粗暴</p>
<h3 id="思路二-逐一合并"><a href="#思路二-逐一合并" class="headerlink" title="思路二:逐一合并"></a>思路二:逐一合并</h3><p>创建一条新链表，再遍历链表数组，将每一条链表与新链表合并，而合并两条链表再上面已讲解</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//逐一合并</span></span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            res=mergeTwoLists(res,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路三-两两合并-分治思想"><a href="#思路三-两两合并-分治思想" class="headerlink" title="思路三:两两合并(分治思想)"></a>思路三:两两合并(分治思想)</h3><p>根据下标将链表数组分成左右两部分，再递归将左右两部分继续分，直到分不了为止</p>
<p>依次将最小的两链表合并，并返回</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//两两合并,分治思想</span></span><br><span class="line">       <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">           <span class="keyword">return</span> lists[left];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取中间下标</span></span><br><span class="line">       <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//向左递归分</span></span><br><span class="line">       ListNode list1 = merge(lists, left, mid);</span><br><span class="line">       <span class="comment">//向右递归分</span></span><br><span class="line">       ListNode list2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">       <span class="comment">//将上面递归出来的两条链表合并，并返回</span></span><br><span class="line">       <span class="keyword">return</span> mergeTwoLists(list1,list2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="思路四-两两合并-迭代思想"><a href="#思路四-两两合并-迭代思想" class="headerlink" title="思路四:两两合并(迭代思想)"></a>思路四:两两合并(迭代思想)</h3><p>与上面实录差不多，只不过这里没有用递归而已</p>
<p> 将数组中相邻的两个链表进行合并，并依次添加到数组左边，数组大小依次压缩2倍，直到大小为1，并这最后的一个链表返回即可</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两两合并,迭代思想</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标志数组长度，依次 /2</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//如果只剩一个，直接添加就行</span></span><br><span class="line">                <span class="keyword">if</span>(i==k-<span class="number">1</span>)&#123;</span><br><span class="line">                    lists[index++]=lists[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lists[index++]=mergeTwoLists(lists[i],lists[i+<span class="number">1</span>]);<span class="comment">//合并</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压缩后更新数组大小</span></span><br><span class="line">            k=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>分治</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2021/03/28/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<a id="more"></a>

<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cpkusU"><img src="https://z3.ax1x.com/2021/03/28/cpkusU.png" alt="cpkusU.png"></a></p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p><a href="https://imgtu.com/i/cpkQZ4"><img src="https://z3.ax1x.com/2021/03/28/cpkQZ4.png" alt="cpkQZ4.png"></a></p>
<p>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：matrix = [[1]]<br>输出：[[1]]</p>
<h3 id="思路一-暴力求解"><a href="#思路一-暴力求解" class="headerlink" title="思路一:暴力求解"></a>思路一:暴力求解</h3><p>通过一个辅助数组完成</p>
<p>对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：</p>
<p><a href="https://imgtu.com/i/cpk0dH"><img src="https://z3.ax1x.com/2021/03/28/cpk0dH.png" alt="cpk0dH.png"></a></p>
<p>并且，第一行的第 x<em>x</em> 个元素在旋转后恰好是倒数第一列的第 x<em>x</em> 个元素。</p>
<p>对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：</p>
<p><a href="https://imgtu.com/i/cpkrFA"><img src="https://z3.ax1x.com/2021/03/28/cpkrFA.png" alt="cpkrFA.png"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，通过一个辅助数组完成</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                temp[j][temp.length-<span class="number">1</span>-i]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                matrix[i][j]=temp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-自身旋转"><a href="#思路二-自身旋转" class="headerlink" title="思路二: 自身旋转"></a>思路二: 自身旋转</h3><p>采用分层来进行平移的方式，将矩阵的每一层都分开进行旋转，比如5*5的矩阵可以分为3层</p>
<p><a href="https://imgtu.com/i/cpkjw4"><img src="https://z3.ax1x.com/2021/03/28/cpkjw4.png" alt="cpkjw4.png" style="zoom: 50%;" /></a></p>
<p>旋转的时候，每四个矩阵块作为一组进行相应的旋转，将这4个位置的值交换</p>
<p>​    <a href="https://imgtu.com/i/cpAi6K"><img src="https://z3.ax1x.com/2021/03/28/cpAi6K.png" alt="cpAi6K.png" style="zoom:33%;" /></a><img src="https://z3.ax1x.com/2021/03/28/cpA3nS.png" alt="cpA3nS.png" style="zoom:67%;" /></p>
<p>首先不考虑偏移量的时候写出左上角的坐标为(pos1,pos1),右上角的坐标为(pos1,pos2),左下角的坐标为(pos2,pos1),右下角的坐标为(pos2,pos2)。  可以看出，第二次旋转的时候比第一次旋转偏移了一格，这里我们使用add变量来记录矩阵块的偏移量，则能够写出偏移之后对应的坐标</p>
<p>每次计算完一层之后，矩阵向内收缩一层，让 post1++ ，post2– ,条件是  post1&lt;post2</p>
<p><a href="https://imgtu.com/i/cpAfc6"><img src="https://z3.ax1x.com/2021/03/28/cpAfc6.png" alt="cpAfc6.png" style="zoom: 33%;" /></a></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旋转图像，自身旋转</span></span><br><span class="line">        <span class="keyword">int</span> post1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> post2=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//偏移量</span></span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次循环都将旋转最外圈的值</span></span><br><span class="line">        <span class="keyword">while</span> (post1&lt;post2)&#123;</span><br><span class="line">             add=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//开始循环替换 4 个为一组的值</span></span><br><span class="line">            <span class="comment">// post1,post1+len   post1+len,post2   post2,post2-len   post2-len,post1</span></span><br><span class="line">            <span class="keyword">while</span>(add&lt;post2-post1)&#123;</span><br><span class="line">                temp=matrix[post1][post1+add];</span><br><span class="line">                matrix[post1][post1+add]=matrix[post2-add][post1];</span><br><span class="line">                matrix[post2-add][post1]=matrix[post2][post2-add];</span><br><span class="line">                matrix[post2][post2-add]=matrix[post1+add][post2];</span><br><span class="line">                matrix[post1+add][post2]=temp;</span><br><span class="line">                add++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向内缩小</span></span><br><span class="line">            post1++;</span><br><span class="line">            post2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/03/28/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
<h3 id="思路一-递归跳跃-超时"><a href="#思路一-递归跳跃-超时" class="headerlink" title="思路一:递归跳跃(超时)"></a>思路一:递归跳跃(超时)</h3><p>1.判断当前步数有没有超过数组长度，如果超过就返回 true</p>
<p>2.如果没超过就获取当前位置的值，遍历当前位置能跳的所有情况，每次遍历就递归条越</p>
<p>3.如果遍历完毕还没有跳出，就返回false</p>
<p>4.这种方法严重超时，不推荐</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归跳跃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前值可以跳跃的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[n];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jump(nums,n+i))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-直推法"><a href="#思路二-直推法" class="headerlink" title="思路二:直推法"></a>思路二:直推法</h3><p>1.直接遍历当前数组，如果遇到0就停下，从当前0所在的位置向前遍历</p>
<p>2.判断前方是否存在:  (下标 + 值)  &gt;  0所在位置的下标，如果存在则说明这个0是可以跳过的，继续上面的遍历</p>
<p>3.如果不存在，就表示当前0是条不过去的，直接返回false</p>
<p>4.遍历结束，返回true</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果找到0，并且不是最后一个数，就向前遍历</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; i!=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                   <span class="comment">//说明前方有一个值可以跳过当前的0</span></span><br><span class="line">                   <span class="keyword">if</span>(nums[j]+j&gt;i)&#123;</span><br><span class="line">                       flag=<span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没找到可以跳跃的数，就返回 false</span></span><br><span class="line">               <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-覆盖法"><a href="#思路三-覆盖法" class="headerlink" title="思路三:覆盖法"></a>思路三:覆盖法</h3><p>1.用一个值can，表示当前最大可达下标</p>
<p>2.遍历数组，如果当前下标小于或等于最大可达下标，说明可以继续跳越，并且不断更新 can == 》Math.max(can ,  i+nums[i])</p>
<p>3.一旦发现当前下标大于最大可达下标，就返回false</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//表示最大可达的下标</span></span><br><span class="line">       <span class="keyword">int</span> can=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//如果最大可达下标大于当前下标，就不断更新最大可达下标，否则就返回 false</span></span><br><span class="line">           <span class="keyword">if</span>(can&gt;=i)&#123;</span><br><span class="line">               can=Math.max(can,i+nums[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>进阶</p>
<h3 id="跳跃游戏-二"><a href="#跳跃游戏-二" class="headerlink" title="跳跃游戏 二"></a>跳跃游戏 二</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<h3 id="思路一-递归（还是超时）"><a href="#思路一-递归（还是超时）" class="headerlink" title="思路一:递归（还是超时）"></a>思路一:递归（还是超时）</h3><p>遍历每一次跳跃能跳的所有次数, 哪个跳的次数小就返回哪个</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> jump(nums,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">1</span> &lt;&lt; <span class="number">31</span>-<span class="number">1</span>; <span class="comment">//默认最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i&lt;=nums[index]+index;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = jump(nums, i)+<span class="number">1</span>;</span><br><span class="line">            step=Math.min(step,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二-反向查找出发位置"><a href="#思路二-反向查找出发位置" class="headerlink" title="思路二:(反向查找出发位置)"></a>思路二:(反向查找出发位置)</h3><p>从后向前遍历，可获取到达当前下标的所有位置，这时找一个离当前下标最远的位置即可，再更新当前下标为最远位置</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>; <span class="comment">//步数</span></span><br><span class="line">        <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isChange=<span class="keyword">false</span>;<span class="comment">//标记是否可以跳出当前</span></span><br><span class="line">            <span class="comment">//循环遍历，判断最左边是否有值可以跳过当前位置，如果可以跳过就更行 右指针</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+nums[i]&gt;=j)&#123;</span><br><span class="line">                    step++;</span><br><span class="line">                    j=i;</span><br><span class="line">                    isChange=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isChange)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路三-正向查找可到达的最大位置"><a href="#思路三-正向查找可到达的最大位置" class="headerlink" title="思路三:(正向查找可到达的最大位置)"></a>思路三:(正向查找可到达的最大位置)</h3><p>看官网解释方法二，这里我也不是很懂</p>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</a></p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">int</span> maxJump=<span class="number">0</span>;<span class="comment">//当前最大可跳的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//根据当前位置更新最大可达下标</span></span><br><span class="line">            maxJump=Math.max(maxJump,i+nums[i]);</span><br><span class="line">            <span class="comment">//更新边界</span></span><br><span class="line">            <span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">                end=maxJump;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>续。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2021/03/29/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p><a href="https://imgtu.com/i/cPSVeJ"><img src="https://z3.ax1x.com/2021/03/29/cPSVeJ.png" alt="cPSVeJ.png"></a></p>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，<a id="more"></a>在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p>
<h3 id="思路一-动态编程"><a href="#思路一-动态编程" class="headerlink" title="思路一:动态编程"></a>思路一:动态编程</h3><p><a href="https://imgtu.com/i/cPSB6S"><img src="https://z3.ax1x.com/2021/03/29/cPSB6S.png" alt="cPSB6S.png" style="zoom: 67%;" /></a></p>
<p>1.从左向右遍历，获取数组 leftMax , 存放左边最大值</p>
<p>2.从右向左遍历，获取数组 rightMax，存放右边最大值</p>
<p>3.遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差，将差累加起来，最后返回</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//存放左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前数组，获取左右两边最大值中较小的一个，如果大于当前值，就获取他们的差</span></span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span>(min&gt;height[i])&#123;</span><br><span class="line">                num+=(min-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>1.获取数组中的最高值</p>
<p>2.从将最高值看作山顶，最左边向山顶走是大概是递增函数，最右边向山顶走大概是递减函数</p>
<p>3.从左边遍历获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</p>
<p>4.从右边遍历获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=height.length;</span><br><span class="line">        <span class="comment">//获取最高值</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;max)&#123;</span><br><span class="line">                max=height[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从左边获取雨水,函数如果递增就更新左边最大值，如果递减就获取当前值与左边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=leftMax)&#123;</span><br><span class="line">                leftMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(leftMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右边获取雨水，函数如果递减就更新右边最大值，如果递增就获取当前值与右边最大值之间的差</span></span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;=rightMax)&#123;</span><br><span class="line">                rightMax=height[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num+=(rightMax-height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>困难</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和、四数之和</title>
    <url>/2021/03/31/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>三数之和: 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：<a id="more"></a></h4><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = []<br>输出：[]</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><p>输入：nums = [0]<br>输出：[]</p>
<h3 id="方法一-双指针"><a href="#方法一-双指针" class="headerlink" title="方法一(双指针)"></a>方法一(双指针)</h3><h5 id="一二指针不动，第三指针移动"><a href="#一二指针不动，第三指针移动" class="headerlink" title="一二指针不动，第三指针移动"></a>一二指针不动，第三指针移动</h5><p>先对当前数组从小到大排序,这里定义三个指针</p>
<p>让第一个指针从头循环遍历该数组，每一次遍历先让第二指针指向第一指针的下一个位置，再让第二个指针循环遍历数组</p>
<p>第二指针遍历时让第三指针从最后开始走，如果三个指针的值相加大于0，就让第三指针左移，直到等于0，</p>
<p>将结果添加到集合，并最后返回该集合</p>
<h6 id="注意-指针要去重"><a href="#注意-指针要去重" class="headerlink" title="注意: 指针要去重"></a>注意: 指针要去重</h6><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//首先循环第一个指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span> &amp;&amp; nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> third=n-<span class="number">1</span>; <span class="comment">//第三个指针</span></span><br><span class="line">            <span class="keyword">int</span> target= -nums[first];<span class="comment">// 0 减去 头指针的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="comment">//第二个指针去重</span></span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span> &amp;&amp; nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//保证第二指针在第三指针的左边情况下，如果两数相加要大于target，就让第三个指针前移</span></span><br><span class="line">                <span class="keyword">while</span>(second&lt;third &amp;&amp; nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(second==third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;<span class="comment">//条件成立,添加到list中</span></span><br><span class="line">                    List&lt;Integer&gt; add = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    add.add(nums[first]);</span><br><span class="line">                    add.add(nums[second]);</span><br><span class="line">                    add.add(nums[third]);</span><br><span class="line">                    list.add(add);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对上面的方法该进"><a href="#对上面的方法该进" class="headerlink" title="对上面的方法该进"></a>对上面的方法该进</h3><h5 id="一指针不动，二三指针同时移动"><a href="#一指针不动，二三指针同时移动" class="headerlink" title="一指针不动，二三指针同时移动"></a>一指针不动，二三指针同时移动</h5><p>二三指针这里变成左右指针，左指针一定要小于右指针</p>
<p>如果三个数相加小于0，左指针移动，大于0，右指针移动，等于0就将三个数添加到list集合，并同时移动左右指针</p>
<p>最后将集合返回</p>
<h6 id="注意-指针都要去重"><a href="#注意-指针都要去重" class="headerlink" title="注意:指针都要去重"></a>注意:指针都要去重</h6><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">int</span> left= i+<span class="number">1</span>;<span class="comment">//左指针</span></span><br><span class="line">            <span class="keyword">int</span> right=n-<span class="number">1</span>;<span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//添加到list</span></span><br><span class="line">                    list.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//左边去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>] )&#123; left++; &#125;</span><br><span class="line">                    <span class="comment">//右边去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) &#123; right--; &#125;</span><br><span class="line">                    <span class="comment">//指针同移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;  <span class="comment">//如果小了，就左指针移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果大了，就右指针移动</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h6><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：nums = [], target = 0<br>输出：[]</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>方法与三数之和相同，再三数之和的基础上再包一个for循环，看作是第四个数</p>
<p>定义四个指针 a ，b ，c ，d，   </p>
<p>a在最外层，从头遍历数组，b为下一层，从a的下一个数开始遍历数组，c与d为第三层，看作左右指针同时移动。。。。。。(参考两数之和改进后的方法)</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// -2,-1,0,0,1,2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n-<span class="number">3</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; nums[a]==nums[a-<span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]+nums[a+<span class="number">1</span>]+nums[a+<span class="number">2</span>]+nums[a+<span class="number">3</span>]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;n-<span class="number">2</span>;b++)&#123;</span><br><span class="line">                <span class="comment">//去重 b</span></span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span> &amp;&amp; nums[b]==nums[b-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[a]+nums[b]+nums[b+<span class="number">1</span>]+nums[b+<span class="number">2</span>]&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c=b+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> d=n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[a]+nums[b]+nums[c]+nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                        <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[c]==nums[c+<span class="number">1</span>]) &#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (c&lt;d &amp;&amp; nums[d]==nums[d-<span class="number">1</span>]) &#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over。。。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
