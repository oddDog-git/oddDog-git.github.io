<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"odddog-git.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="java虚拟机（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存与垃圾回收">
<meta property="og:url" content="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="hui&#39;s Blog">
<meta property="og:description" content="java虚拟机（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/Ikjg5n.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkjhvT.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkxN1P.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/10/IUJjzT.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IAVsN6.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IAKq2V.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IA8mC9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IVzXXq.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZS2UU.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZAup8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZel80.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZKj7F.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IeEAyD.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I3qt3T.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I3XENR.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8kWMd.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8bZKe.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8cIij.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8xQeO.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGSxWd.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGSTQ1.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGZn4x.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGZg5q.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGyQKK.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGokqA.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGogJK.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IG7uuQ.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGjtij.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGvcB8.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/09/IYgxdf.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/09/IYWCKs.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/09/ItW9X9.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/09/ItqlYd.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/10/IUp6sJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/10/IU91T1.png">
<meta property="article:published_time" content="2021-11-03T00:34:52.000Z">
<meta property="article:modified_time" content="2021-11-13T07:35:24.057Z">
<meta property="article:author" content="怪狗狗">
<meta property="article:tag" content="垃圾回收">
<meta property="article:tag" content="运行时数据区">
<meta property="article:tag" content="类加载子系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg">

<link rel="canonical" href="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM内存与垃圾回收 | hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://oddDog-git" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jerry.jpg">
      <meta itemprop="name" content="怪狗狗">
      <meta itemprop="description" content="跑得又快，长得又帅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hui's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM内存与垃圾回收
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-03 08:34:52" itemprop="dateCreated datePublished" datetime="2021-11-03T08:34:52+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-13 15:35:24" itemprop="dateModified" datetime="2021-11-13T15:35:24+08:00">2021-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>java虚拟机</strong>（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。<a id="more"></a></p>
<p><strong>JVM的位置</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkL3uQ"><img src="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg" alt="IkL3uQ.jpg" style="zoom:50%;" /></a></p>
<p><strong>JVM机构模型</strong></p>
<p>java编译器输入的指令流基本上是一种基于栈的指令集架构，另一种指令集架构是则是基于寄存器的指令集架构。</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计与实现简单，使用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址方式分配</li>
<li>指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>指令集的架构完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令取完成一项操作</li>
<li>指令集以一地址指令、二地址指令和三地址指令为主</li>
</ul>
</li>
</ul>
<p><strong>举例</strong>  ：执行 2+3 操作</p>
<ul>
<li>基于栈的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2  &#x2F;&#x2F;常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3  &#x2F;&#x2F;常量3入栈</span><br><span class="line">istore_2  </span><br><span class="line">iload_1	  </span><br><span class="line">iload_2</span><br><span class="line">iadd	  &#x2F;&#x2F;常量2、3出栈，执行相加</span><br><span class="line">istore_0  &#x2F;&#x2F;结果5入栈</span><br></pre></td></tr></table></figure>
<ul>
<li>基于寄存器的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2  &#x2F;&#x2F;将eax寄存器的值设为1</span><br><span class="line">add eax,3  &#x2F;&#x2F;使eax寄存器的值加3</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong> : 由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令。</p>
<p><strong>JVM总体流程</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ikjg5n"><img src="https://z3.ax1x.com/2021/11/03/Ikjg5n.png" alt="Ikjg5n.png"  /></a></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><ul>
<li><p>类加载子系统<strong>只</strong>负责加载Class文件，class文件的文件开头有特定的文件标识。</p>
</li>
<li><p>加载的类信息存放于放入区中，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量与数字常量（这部分信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkjhvT"><img src="https://z3.ax1x.com/2021/11/03/IkjhvT.png" alt="IkjhvT.png"  /></a></p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkxN1P"><img src="https://z3.ax1x.com/2021/11/03/IkxN1P.jpg" alt="IkxN1P.jpg" style="zoom: 44%;" /></a></p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区中该类的各种数据的访问入口</li>
</ol>
<p><strong>加载 .class文件的方式</strong></p>
<ul>
<li>从本地系统直接加载（常用）</li>
<li>通过网络获取，如 Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，如 动态代理</li>
<li>有其他文件生成，如 JSP应用</li>
<li>从数据库中提取 .class文件</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
<h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><ul>
<li><p>验证（Verify）</p>
<ul>
<li>确保class文件的字节流包含信息的准确性，不危害虚拟机的自身安全</li>
<li>包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IUJjzT"><img src="https://z3.ax1x.com/2021/11/10/IUJjzT.png" alt="IUJjzT.png" style="zoom: 50%;" /></a></p>
</li>
<li><p>准备（Prepare）</p>
<ul>
<li>为类变量分配内存并且设置该类的默认初始值，即零值</li>
<li>这里不包括final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li>
</ul>
</li>
<li><p>解析（Resolve）</p>
<ul>
<li>将常量池的符号引用转换成直接引用，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>事实上，解析操作往往会伴随着初始化之后再执行</li>
</ul>
</li>
</ul>
<h3 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h3><p>初始化阶段就是执行类构造方法 &lt;clinit&gt;() 的过程</p>
<p><strong>clinit方法</strong> : 不需要定义，javac编译器自动收集类中所有 <strong>类变量的赋值动作</strong> 和 <strong>静态代码块中的语句</strong>  按顺序合并而来</p>
<p>若该类有父类，JVM会保证先执行父类中的 &lt;clinit&gt;() 方法</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器，引导类加载器（BootStrap ClassLoader）、自定义类加载器（User-Defined Classloader）</p>
<p>所有派生于抽象类ClassLoader的加载器都划分为自定义类加载器。再程序中常见的类加载器始终只有3个：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IAVsN6"><img src="https://z3.ax1x.com/2021/11/03/IAVsN6.md.png" alt="IAVsN6.md.png" style="zoom:80%;" /></a></p>
<p><strong>启动类加载器（BootStrap ClassLoader）</strong></p>
<ul>
<li>该类加载是由C/C++编写的，嵌套再JVM内部</li>
<li>它用来加载java的核心库，用于提供JVM自身需要的类</li>
<li>出于安全考虑，只加载包名为java、Javax、sun等开头的类</li>
<li>不继承java.lang.ClassLoader，没有父类加载器</li>
<li>加载扩展类加载器和系统类加载器，并指定为他们的父类加载器</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>从JDK的安装目录的jre/lib/ext 下加载类库，如果自定义插件jar文件放入该目录，也会加载。</li>
</ul>
<p><strong>系统类加载器（AppClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载的是程序中默认的类加载器，一般java应用中所有的类是由它来完成加载</li>
<li>通过 ClassLoader.getSystemClassLoader() 可获取到该类加载器</li>
</ul>
<p><strong>用户自定义类加载器</strong></p>
<p>在必要时，我们可以自定义类加载器，来定制类的加载方式，需继承抽象类ClassLoader，实现相关方法。</p>
<p>自定义类加载器作用：</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>放置源码泄露</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>JVM对class文件采用 <strong>按需加载</strong> 方式，加载某个类时采用<strong>双亲委派模式</strong> 。</p>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在父类加载器，则继续向上委托，最终到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类的加载任务，就返回成功，否则子类才会尝试自己去加载</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IAKq2V"><img src="https://z3.ax1x.com/2021/11/03/IAKq2V.png" alt="IAKq2V.png" style="zoom: 80%;" /></a></p>
<p><strong>作用</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，放置核心API被篡改<ul>
<li>如自定义java.lang.String类，而引导类加载器会先加载jdk自带的类，进而报错，这样就保证对java核心的源代码的保护，这也是<strong>沙箱安全机制</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong></p>
<p>在JVM中表示两个class对象是否为同一个类存在的两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader实例对象必须相同</li>
</ul>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证JVM的高效稳定运行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IA8mC9"><img src="https://z3.ax1x.com/2021/11/03/IA8mC9.png" alt="IA8mC9.png" style="zoom: 67%;" /></a></p>
<p>线程独享：程序计算器、栈、本地栈</p>
<p>线程共享：堆、对外内存（永久代或元空间、代码缓存）</p>
<h2 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h2><p>PC寄存器用来存储下一条指令的地址，交给执行引擎读取。</p>
<ul>
<li>它是一块很小的内存空间，是线程私有的，生命周期于线程声明周期一致。</li>
<li>如何时间一个线程只有一个方法在执行，PC计计数器会存储当前线程正在执行的java方法的JVM指令地址，如果正在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成</li>
</ul>
<p><strong>PC寄存器存储字节码指定地址作用</strong></p>
<p>CPU需要不停切换各个线程来执行程序，PC寄存器保存当前线程下执行的位置，JVM的字节码解释器需要通过PC</p>
<p>寄存器的值来明确下一条执行什么样的字节码指令。</p>
<h2 id="虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stack）"></a>虚拟机栈（Java Virtual Machine Stack）</h2><p><strong>虚拟机栈出现的背景</strong>：由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令</p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内确保一个个的栈帧(Stack Frame),对应一次次的方法调用。</p>
<p><strong>生命周期</strong> ：和线程的生命周期一致</p>
<p><strong>作用</strong>：主管java程序的运行，它包方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p><strong>JVM直接堆Java栈的操作只有两个</strong></p>
<ul>
<li>每个方法执行，伴随着<b style='color:red'>进栈</b>（入栈、压栈）</li>
<li>执行结束后<b style='color:red'>出栈</b>操作</li>
</ul>
<p><strong>栈可能出现的异常</strong></p>
<ul>
<li>如果栈固定大小：每个虚拟机栈的容量在线程创建时就能确定下来，如果超过虚拟机栈允许的最大容量，就会抛出StackOverFlowError 异常。</li>
<li>如果栈允许动态扩展：在尝试扩展的时候无法申请到足够的内存，或在创建新的线程时没有足够的内存去创建虚拟机栈，就会抛出 OutOfMemoryError 异常。</li>
</ul>
<p><strong>设置栈内存大小</strong>： <b style='color:red'>-Xss</b>  设置线程的最大栈空间</p>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>每个线程都有直接的栈，栈中的数据都是以<b style="color:red">栈帧（Stack Frame）</b>的格式存在,每个栈帧对应一个方法。</p>
<p><strong>运行原理</strong></p>
<ul>
<li>在同一时间点上，只有一个活动栈帧（当前栈帧），执行引擎运行的所有字节码指令只对当前栈帧经行操作</li>
<li>在当前放法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前栈</li>
<li>不同线程中所包含的栈帧不允许存在相互应用的</li>
<li>方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，当前虚拟机栈会执行出栈操作，将当前栈帧丢弃</li>
<li>使用return指令正常的函数返回、抛出异常返回，都会导致栈帧被弹出</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IVzXXq"><img src="https://z3.ax1x.com/2021/11/04/IVzXXq.jpg" alt="IVzXXq.jpg" style="zoom:50%;" /></a></p>
<p><strong>栈帧的内部结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈 (Operand Stack)</li>
<li>动态链接 (Dynamic Linking)</li>
<li>方法返回地址 (Return Address)</li>
<li>一些附加信息，如对程序调试提供支持的信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZS2UU"><img src="https://z3.ax1x.com/2021/11/04/IZS2UU.jpg" alt="IZS2UU.jpg" style="zoom: 44%;" /></a></p>
<h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><ul>
<li>定义为一个数字数组，用于存储方法参数和定义在方法体内的局部变量，这些数据的类型包括各种<b style="color:red">基本数据类型</b>、<b style="color:red">对象引用(reference)</b></li>
<li>局部变量表是建立在线程的栈上，是线程私有的数据，不存在数据安全问题</li>
<li>局部变量表的容量大小实在编译期间确定下来，并保持在Code属性的<b style="color:red">Maximum local variables</b>数据项中</li>
</ul>
<p><strong>Slot</strong></p>
<ul>
<li>局部变量表中最基本的存储单元是Slot（变量槽），从0开始</li>
<li>32位以内的各种基本数据类型占用一个Slot，64位的数据类型占用两个Slot<ul>
<li>byte、short、char、boolean 在存储前被都转化成 int ，占据一个Slot</li>
<li>long 、double 占据两个Slot</li>
</ul>
</li>
<li>方法被调用时，它的方法参数和方法体内定义的局部变量会<b style="color:red">按顺序被复制</b>到每一个Slot中，通过索引即可访问局部变量表中指定的值</li>
<li>如果当前方法是构造方法或非静态方法，会将 <b style="color:red">this</b> 放在index为0的Slot处</li>
</ul>
<p><strong>Slot的重复利用</strong></p>
<p>如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量很有可能会重复利用过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">	<span class="comment">// 该方法中的局部变量表大小为2: index[0]:this 、index[1]:b</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的b会复用a的槽位</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态变量与局部变量的对比</strong></p>
<ul>
<li>静态变量: 在<b style='color:red'>准备阶段</b>会赋予初始值，在<b style='color:red'>初始化</b>阶段，会赋予我们在代码中定义的值。</li>
<li>局部变量：不存在系统初始化过程，所以一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改代码是错误的，没有赋值，不能使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充</strong></p>
<p>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收。</p>
<h3 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h3><ul>
<li>操作数栈，用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</li>
<li>操作数栈是JVM执行引擎的工作区，其最大深度在编译器就定义好了，保存在Code属性的<b style='color:red'>max_stack</b></li>
<li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈与出栈<ul>
<li>如执行 复制、交换、求和等操作</li>
<li><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZAup8"><img src="https://z3.ax1x.com/2021/11/04/IZAup8.png" alt="IZAup8.png" style="zoom:50%;" /></a></li>
</ul>
</li>
<li>栈中的元素可以是任意的java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>如果被调用的方法带有返回值，其返回值将会压入操作数栈中，并根性PC寄存器中下一条需要执行的字节码指令</li>
</ul>
<p>补充：JVM的<b style='color:red'>解释引擎是基于栈的执行引擎</b>，其中的栈指的就是操作数栈</p>
<h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><p>动态链接（指向运行时常量池的方法引用）：每一个栈帧中内部都包含一个指向<b style='color:blue'>运行时常量池</b>中<b style='color:red'>该栈帧所属的方法引用</b>。</p>
<p>在java源文件被编译到字节码文件中时，所有的变量与方法引用都在为符号引用（Symbolic Reference）保存到class文件的常量池里。当调用其他方法时，就是通过常量池中指向的方法的符号引用来表示。所以<b style='color:red'>动态链接的作用就是为了将这些符号引用转换成调用方法的直接引用</b>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZel80"><img src="https://z3.ax1x.com/2021/11/04/IZel80.png" alt="IZel80.png" style="zoom: 80%;" /></a></p>
<h3 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址(Return Address)"></a>方法返回地址(Return Address)</h3><p>存放调用该方法时pc寄存器的值，用于方法的退出。</p>
<p>一个方法结束，有两种方式:</p>
<ul>
<li><p>正常完成出口</p>
<ul>
<li>执行引擎遇到任意一个返回字节码指令(return)时,会有返回值传递给上层的方法调用者。</li>
</ul>
</li>
<li><p>异常完成出口</p>
<ul>
<li>方法执行过程中遇到异常，并且该异常没有在经行处理，返回地址是要通过<b style='color:red'>异常表</b>来确定，并且没有返回值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZKj7F"><img src="https://z3.ax1x.com/2021/11/04/IZKj7F.png" alt="IZKj7F.png"></a></p>
</li>
</ul>
<p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法中局部变量表、操作数栈，将返回值压入操作数栈中，设置PC寄存器值等，让调用者方法继续执行下去。</p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><strong>符号引用转换为方法的直接引用</strong></p>
<ul>
<li><p>静态链接</p>
<p>当字节码文件被装载到JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变，这种情况下方法的符号引用转换成直接引用的过程为静态链接。</p>
</li>
<li><p>动态链接</p>
<p>如果调用的方法在编译期间无法被确定下来，只能够在程序运行期间将调用方法的符号引用转换为直接引用，这种引用转换过程具备动态性，因此被称之为动态链接。</p>
</li>
</ul>
<p><strong>方法的绑定机制</strong>：绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅仅发生一次。</p>
<ul>
<li>早期绑定<ul>
<li>被调用的目标方法在编译器可知，且运行期间保持不变，因此可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>被调用的方法在编译期间无法被确定下来，只能够在运行期间根据实际的类型绑定相关的方法。</li>
</ul>
</li>
</ul>
<p><strong>虚方法与非虚方法</strong></p>
<p>非虚方法: 编译期间就确定了具体的调用版本，静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</p>
<p>其他的方法都称为虚方法</p>
<p><strong>方法调用指令</strong></p>
<ul>
<li>普通调用指令<ul>
<li><b style='color:blue'>invokestatic</b>：调用静态方法, 解析阶段可确定方法版本</li>
<li><b style='color:blue'>invokespecial</b>：调用&lt;init&gt;方法、私有方法、父类方法, 解析阶段可确定方法版本</li>
<li><b style='color:green'>invokevirtual</b>：调用所有的虚方法（final修饰的除外）</li>
<li><b style='color:green'>invokeinterface</b>：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析处需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固定在虚拟机内部，方法的调用执行不可人为的干预，而invokeinterface指令则支持用户确定方法版本。</p>
<p>invokeinterface实在java7中添加的，为了实现【动态类型语言】支持而做的改进。而java7中并没有提供直接生成invokeinterface指令的方法，直到java8的Lambda表达式的出现，才能够直接生成invokeinterface指令。</p>
<p><strong>动态类型语言和静态类型语言</strong></p>
<ul>
<li>两者的区别在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，满足后者就是动态类型语言</li>
<li>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</li>
</ul>
<p><strong>方法重写的本质</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的实际类型，记作 C</li>
<li>如果在类型 C 找到与常量中相对应的方法，则进行访问</li>
<li>如果没找到，按照继承的关系从下往上依次对 C 的各个父类经行访问</li>
<li>如果始终没找到合适的方法，则抛出 java.lang.AbstractMethodError异常，表示该方法是抽象方法，并且没有没实现。</li>
</ol>
<p>在访问方法时，需要进行访问权限校验，如果没通过，会抛出 java.lang.IllegalAccessError 异常</p>
<p><strong>虚方法表(virtual method table)</strong></p>
<ul>
<li><p>如果在每次动态分派的过程中都要重新在类的方法元数据搜索合适的目标，这样就会影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引的方式来代替查找。</p>
</li>
<li><p>每个类都有一个虚方法表，表中存放着各个虚方法的实际路口。</p>
</li>
<li><p>虚方法表在类的加载的链接阶段被创建并初始化。</p>
</li>
</ul>
<h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IeEAyD"><img src="https://z3.ax1x.com/2021/11/04/IeEAyD.jpg" alt="IeEAyD.jpg" style="zoom: 67%;" /></a></p>
<p><strong>本地方法</strong></p>
<p>一个Native Method就是一个Java调用非Java代码的接口。该方法的实现由非Java语言实现，比如C/C++。</p>
<p>本地接口的作用是融合不同的变成语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><strong>现状</strong> ：目前该方法使用的越来越少，除非是与硬件有关的应用。</p>
<p><strong>本地方法栈概述</strong></p>
<ul>
<li>Java的虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li>
<li>本地方法栈也是线程私有的。</li>
<li>允许被实现固定内存大小，或可动态扩展内存大小（与Java虚拟机栈基本相同）</li>
<li>当某个线程调用有关本地方法时，它就进入了一个全新的且不受虚拟机限制的环境，它与虚拟机有同样的权限。</li>
</ul>
<p><strong>补充</strong></p>
<p>不是所有的虚拟机都支持本地方法；在Hotspot JVM中，直接将本地方法和虚拟机栈合二为一。</p>
<h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p><strong>基本概述</strong></p>
<ul>
<li><p>一个JVM实例只存在一个堆内存，是java内存管理的核心区域。</p>
</li>
<li><p>堆可以处于物理不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
</li>
<li><p>几乎所有的对象实例以及数组都再允运行时分配再堆上，栈帧中仅仅保持对象的引用，该引用指向对象或数组再堆中的位置。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，在垃圾收集的时候才可能会被移除，堆是GC执行垃圾回收的重点。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I3qt3T"><img src="https://z3.ax1x.com/2021/11/08/I3qt3T.png" alt="I3qt3T.png" style="zoom: 80%;" /></a></p>
<p><strong>内存细分</strong></p>
<ul>
<li>Java 7及之前：新生代+老年代+永久代(方法区)<ul>
<li>方法区在堆中</li>
</ul>
</li>
<li>Java8及之后：新生代+老年代+元空间(方法区)<ul>
<li>方法区使用本地内存</li>
</ul>
</li>
</ul>
<h3 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h3><p>堆的大小在JVM启动时就已经设定好了。可通过“-Xmx” 和 “-Xms” 来进行设置</p>
<ul>
<li>-Xms ：表示堆区的起始内存，等价于 -XX:InitialHeapSize，默认 物理电脑内存大小/64</li>
<li>-Xmx :  表示堆区的最大内存，等价于 -XX:MaxHeapSize,  默认 物理电脑内存大小/4</li>
</ul>
<p>一旦堆区的内存大小超过 ”-Xmx“ ,就会抛出 OutOfMemoryError 异常。</p>
<p>通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能。</p>
<h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>堆区可划分为年轻代(YoungGen) 和 老年代(OldGen) ，其中年轻代又可以划分为 Eden空间、Survivor0空间和Surviver1空间（有时也叫做from区、to区）</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I3XENR"><img src="https://z3.ax1x.com/2021/11/08/I3XENR.jpg" alt="I3XENR.jpg" style="zoom: 50%;" /></a></p>
<p><strong>-XX:NewRation</strong>    </p>
<ul>
<li>配置新生代与老年代在堆中的占比</li>
<li>默认 -XX:NewRatio=2 ，新生代占1，老年代占2</li>
</ul>
<p><strong>-XX:SurvivorRatio</strong></p>
<ul>
<li>配置Eden空间和S0与S1空间占比</li>
<li>默认-XX:SurvivorRatio=8，Eden占8，Survivor0占1，Survivor1占1</li>
</ul>
<p><strong>-Xmn</strong></p>
<ul>
<li>设置新生代最大内存大小</li>
</ul>
<p>几乎所有的java对象都是在Eden区被new出来的，而java对象的销毁基本是在新生代进行的。</p>
<p>IBM公司的专门研究表明，新生代 80% 的对象都是”朝夕生死“的。</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>对象分配内存是一件非常严谨与复杂的任务，需要考虑内存如何分配、在哪里分配、内存碎片等问题。</p>
<p><strong>步骤</strong></p>
<ol>
<li>new的对象先放伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序有需要创建对象，GC将对伊甸园区进行垃圾回收(Minor GC) , 将伊甸园区中不再被其他对象所引用的对象进行销毁，再加载的对象放到伊甸园区</li>
<li>然后将伊甸园区的剩余对象移动到幸存者0区，幸存的对象会添加年龄 1</li>
<li>如果再次触发Minor GC，会对伊甸园区和幸存者0区一起GC，把幸存的对象放入幸存者1区，年龄 +1</li>
<li>如果再次Minor GC，会重新放回幸存者0区，接着再是幸存者1区，不断循环</li>
<li>如果对象的年龄为15，就会将该对象放入老年区<ul>
<li>可以设置参数  -XX:MaxTenuringThreshold=15  经行设置</li>
</ul>
</li>
<li>老年去相对清闲，当老年去内存不足时，会触发 Major GC，对老年区经行内存清理</li>
<li>如果老年区执行了 Major GC 后发现依然无法进行对象的保持，就会报 OOM 异常<ul>
<li>java.lang.OutOfmemoryError: Java heap space </li>
</ul>
</li>
</ol>
<p><strong>对不同年龄的对象分配原则</strong></p>
<ul>
<li>优先分配到Eden </li>
<li>大对象(超出Eden最大值)直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中的相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中设置的年龄</li>
</ul>
</li>
</ul>
<p><strong>分代思想</strong></p>
<p>经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象。</p>
<p>如果不分代程序也是可以运行的，所有的对象就在一块。分代的唯一理由就是优化GC新能。</p>
<h3 id="Garbage-Collection（GC）"><a href="#Garbage-Collection（GC）" class="headerlink" title="Garbage Collection（GC）"></a>Garbage Collection（GC）</h3><p>针对HotSpot VM的实现，GC按照区域又分为两大类型：</p>
<p><strong>部分搜集（Partial GC）</strong></p>
<ul>
<li>新生代收集（Minor GC / Young GC）: 只是新生代的垃圾收集</li>
<li>老年代收集（Mojor GC / Old Gc）: 只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC 会有该行为</li>
</ul>
</li>
<li>混合收集（Mixed GC）: 收集整个新生代与部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有该行为</li>
</ul>
</li>
</ul>
<p><strong>整堆收集（Full GC）</strong></p>
<ul>
<li>收集整个java堆和方法区的垃圾收集</li>
</ul>
<p>（提示：有关GC详情，在后面会讲解！）</p>
<h3 id="Thread-Local-Allocation-Buffer（TLAB）"><a href="#Thread-Local-Allocation-Buffer（TLAB）" class="headerlink" title="Thread Local Allocation Buffer（TLAB）"></a>Thread Local Allocation Buffer（TLAB）</h3><p><strong>问题</strong>：堆区是线程共享区域，任何线程都可以访问堆中的共享数据，而对象实例的创建很频繁，所以在并发环境下会不安全。为了避免操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>Eden区为每个线程分配了一个私有的缓存区域（TLAB），使用TLAB可以避免一系列非线程安全问题，同时还能提升内存分配的吞吐量，我们可以将这种分配方式称之为 <b style='color:red'>快速分配策略</b></p>
<p>OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><strong>分配过程</strong></p>
<ul>
<li>JVM将TLAB作为内存分配的首选</li>
<li>一旦对象在TLAB空间分配内存失败，JVM会尝试通过<b style='color:red'>加锁机制</b>确保数据操作的原则性，接着在Eden区分配内存</li>
<li>-XX:UseTLAB , 是否开启TLAB空间</li>
<li>-XX:TLABWasteTargetPercent , 设置TLAB所占用Eden空间的百分比大小，默认 1%</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8kWMd"><img src="https://z3.ax1x.com/2021/11/08/I8kWMd.jpg" alt="I8kWMd.jpg" style="zoom: 50%;" /></a></p>
<h3 id="栈上分配对象"><a href="#栈上分配对象" class="headerlink" title="栈上分配对象"></a>栈上分配对象</h3><p>JVM中，对象是在java堆中分配内存是一个普遍常识。但是有一种特殊情况，那就是<b style='color:red'>如果经过逃逸分析(Escape Analysis) 后发现，应该对象并没有逃逸出方法的话，那就有可能被优化成栈上分配。</b>这样就无需在堆上分配内存，也无需经行GC了，这也是最常见的堆外存储技术。</p>
<p><strong>逃逸分析</strong></p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>如果被外部方法所引用，则认为发生逃逸</li>
</ul>
<p>在JDK 6u23版本后，默认开启逃逸分析</p>
<ul>
<li>-XX:+DoEscapeAnalysis ,显示开启逃逸分析</li>
<li>-XX:+PrintEscapeAnalysis，查看逃逸分析的筛选结果</li>
<li>-server，启动Server模式，在该模式下才可以开启逃逸分析</li>
</ul>
<p><strong>同步省略</strong></p>
<p>JIT编译器可以借助逃逸分析来判断<b style='color:red'>同步块所使用的锁对象是否能够被一个线程访问而没有发布到其他线程。</b>如果没有，JIT编译器在编译这个同步块时会取消对这部分代码的同步。取消同步的过程就叫同步省略，也叫<b style='color:red'>锁消除</b></p>
<p>如以下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        System.out.Println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对obj进行加锁，但obj不会被其他线程访问，所以在JIT编译阶段就会被优化掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="comment">// 取消了锁</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.Println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标量替换</strong></p>
<p><b style='color:red'>标量(Scalar) </b>指一个无法分解成更小的数据的数据。如 java中的基本数据类型</p>
<p><b style='color:red'>聚合量(Aggregate) </b> 可以分解的数据。如java中的对象，可以分成其他聚合量和标量</p>
<p>JIT阶段，如果进过逃逸分析，发现一个对象不会被外界访问，就会进行JIT优化，把该对象拆解成若干个其中包含的若干个成员变量来代替，该过程就是<b style='color:red'>标量替换 </b></p>
<p>-XX:+EliminateAllocations，开启标量替换（默认开启）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123; <span class="comment">// 构造方法省略</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(p.x);</span><br><span class="line">    System.out.println(p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，标量替换后，会变成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对象被替换成两个基本数据类型，这样可以不用创建对象，减少堆内存的占用。</p>
<p><strong>逃逸分析并不成熟</strong></p>
<ul>
<li>有关逃逸分析的论文在1999年就已经发表了，直到JDK1.6才有实现，并且到如今也并不是十分成熟</li>
<li>根本原因在于逃逸分析、标量替换、栈上分配、消除锁也是需要性能消耗的。如果逃逸分析后，所有的对象都逃逸了，那么逃逸分析的过程就白白浪费了。</li>
</ul>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><ul>
<li><p>方法区也java堆一样，是各个线程共享的内存区域。</p>
</li>
<li><p>在JVM启动时就会创建，实际的物理内存空间也是不连续的，可以固定大小或可扩展</p>
</li>
<li><p>方法区决定了系统可以保持多少个类，如果类太多，导致方法区溢出，会抛出异常:</p>
<ul>
<li>java.lang.OutOfmemoryError：Metaspace/PermGen space</li>
</ul>
</li>
</ul>
<p>jdk7及以前，习惯把方法区成为永久代。jdk8开始，使用元空间代替永久代，完全废弃了永久代的概念。</p>
<p>永久代和元空间的最大区别在于: 元空间不在虚拟机设置的内存中，而是使用本地内存。</p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8bZKe"><img src="https://z3.ax1x.com/2021/11/08/I8bZKe.png" alt="I8bZKe.png"></a></p>
<h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><p><strong>jdk7及以前</strong></p>
<ul>
<li>-XX:PermSize，设置永久代初始分配空间，默认 20.75M</li>
<li>-XX:MaxPermSize,设置永久最大可分配空间，32位机器默认64M，64位机器默认82M。</li>
</ul>
<p><strong>jdk8及以后</strong></p>
<ul>
<li>默认值依赖于平台，windows下，-XX:MetaspaceSize=21M，-XX:MaxMetaspaceSize=-1,表示没有限制</li>
<li>MetaspaceSize是元空间的初始大小，就是初始的高水位线，一旦触及这水位线，就会出发Full GC并卸载没有用的类，然后这个高水位线会被重置。新的高水位线的值取决于GC后释放了多少元空间。<ul>
<li>如果释放的空间不足，在不超过MaxMetaspaceSize时，会适当提高</li>
<li>如果释放空间过多，会适当降低该值</li>
</ul>
</li>
<li>初始的高水位线设置过低，就会多出发高水位线的调整，进而出发Full GC。所以建议将 MetaspaceSize 设置位一个相对较高的值。</li>
</ul>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8cIij"><img src="https://z3.ax1x.com/2021/11/08/I8cIij.jpg" alt="I8cIij.jpg"  /></a></p>
<p><strong>类型信息</strong></p>
<p>JVM必须存储类型(class、interface、enum、annotation)的以下信息:</p>
<ul>
<li>该类型的完整有效名</li>
<li>该类型的直接父类完整有效名（interface和Object没有父类）</li>
<li>该类型的修饰符</li>
<li>该类型的直接接口的一个有序列表</li>
</ul>
<p><strong>域(Field)信息</strong></p>
<ul>
<li><p>JVM必须存储类型的域(字段)相关信息: 域名称、域类型、域修饰符</p>
</li>
<li><p>域的声明顺序也会保存下来</p>
</li>
</ul>
<p><strong>方法信息</strong> </p>
<p>JVM必须保存所有方法的以下信息,同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称、方法的返回类型、方法参数的数量和类型、方法的修饰符、方法的字节码、异常表</li>
</ul>
<p><strong>运行时常量池(Runtime Constant Pool)</strong></p>
<ul>
<li>常量池表(Constant Pool Table) 是Class文件的一部分，<b style='color:red'>用于存放编译期生成的各种字面量与符号引用</b>，<b style='color:green'>这部分内容将在类加载后存放到方法区的运行时常量池中</b></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>此时不再是常量池中的符号引用了，这里换位真实地址，所以具备动态性</li>
</ul>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><p><strong>声明</strong>：只有Hotspot才有永久代的概念</p>
<p><strong>变化</strong></p>
<ul>
<li>jdk1.6及以前 : 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 : 有永久代，但已经逐步”去永久代“,字符串常量、静态变量移动到堆中</li>
<li>jdk1.8及以后 : 无永久代，类型保存在本地的元空间，但字符串常量池、静态变量依旧在堆中</li>
</ul>
<p><strong>永久代为什么要被元空间所替换</strong></p>
<ol>
<li>永久代设置空间大小是很难确定的，如果动态加载的类过多，很容易抛出OOM异常。而元空间使用的是本地内存，受本地内存的限制。</li>
<li>对永久代进行调优的很困难的。</li>
</ol>
<p><strong>StringTalbe为什么要调整</strong></p>
<p>因为永久代的回收效率很低，在Full GC的时候才会触发。而Full GC是在老年代、永久代内存不足时才会触发。</p>
<p>导致StringTable的回收效率不高。放到堆里，能够及时回收内存。</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>《Java虚拟机规范》对方法区的约束时非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集，如JDK11时期的ZGC就不支持类卸载。</p>
<p>一般来所方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实时有必要的。</p>
<p><strong>方法区垃圾收集主要回收两部分内容:</strong></p>
<ul>
<li><p>常量池中废弃的常量（比较容易实现，与堆中的回收的对象类似）</p>
<ul>
<li>字面量</li>
<li>符号引用</li>
</ul>
</li>
<li><p>不再使用的类型</p>
<p>需要满足以下三个条件：</p>
<ul>
<li>该类的所有实例已被回收，包括其任何派生子类</li>
<li>该类的类加载器已被回收，该条件除非是经过精心设计的可替换类加载的场景，如OSGI、JSP的重复加载等，否则很难达成</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ul>
<p>满足上述的三个条件，也仅仅是”被允许“回收，而不是和对象一样，没有引用了就必然会回收。</p>
</li>
</ul>
<p>再大量使用反射、动态代理、GCLib等字节码框架的场景，通常需要JVM具备类卸载能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="StringTable相关概念"><a href="#StringTable相关概念" class="headerlink" title="StringTable相关概念"></a>StringTable相关概念</h3><p>字符串常量池(String Pool) ：存放字符串，且不会存储相同内容的字符串。</p>
<p>StringPool是一个固定大小的HashTable，如果放进String Pool的String 非常多，就会造成Hash冲突严重，从而导致链表很长，直接造成调用String.intern时性能下降。</p>
<p><b style='color:blue'>-XX:StringTableSize</b> 参数可设置StirngTable的长度</p>
<ul>
<li>jdk6中StringTable长度是固定的，长度为<b style='color:blue'>1009</b></li>
<li>jdk7中StringTable的长度默认值是<b style='color:blue'>60013</b>,可以手动修改，对设置没有要求</li>
<li>jdk8开始，设置StringTable的长度最小值是<b style='color:blue'>1009</b></li>
</ul>
<p><strong>将字符串放入字符串常量池</strong></p>
<ol>
<li>直接使用双引号声明出来的String ，如 <code>String s = &quot;怪狗狗&quot;;</code></li>
<li>使用Stirng 提供的 <code>intern()</code> 方法</li>
</ol>
<p><strong>字符串拼接</strong></p>
<ul>
<li><p>常量与常量的拼接结果在常量池。原理是编译期(前端编译)优化</p>
</li>
<li><p>如 <code>String s = &quot;a&quot;+&quot;b&quot;</code> 转换成字节码 <code>ldc #2 &lt;ab&gt;</code></p>
</li>
<li><p>只要其中有一个是变量，结果就在堆中。原理是StringBuilder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;a&quot;;</span><br><span class="line">String s2 &#x3D; s1+&quot;b&quot;;</span><br><span class="line"># 上面字符串拼接代码翻译成相应的字节码指令如下:</span><br><span class="line">new 		   #5  创建串池中#5位置的对象，当前对象为StringBuilder，放入操作数栈中</span><br><span class="line">dup 		  	   将栈顶的stringBuilder对象复制一份，并入栈</span><br><span class="line">invokespecial  #6  调用栈顶对象在串池对应#6的方法，这里是&lt;init&gt;构造犯法,消费掉一个栈顶元素</span><br><span class="line">aload_1	 		   将局部变量表位置为1的值入栈，这里是&quot;a&quot;</span><br><span class="line">invokevirtual  #7  调用#7位置处的方法，StringBuilder.append()</span><br><span class="line">idc			   #3  将#3位置处的对象入栈，这里是&quot;b&quot;</span><br><span class="line">invokevirtual  #7  调用#7位置处的方法，StringBuilder.append()</span><br><span class="line">invokevirtual  #8  调用#7位置处的方法，StringBuilder.toString()</span><br><span class="line">astore 	       6   将结果放置局部变量表位置为6处</span><br></pre></td></tr></table></figure></li>
<li><p>*intern()的使用**</p>
</li>
<li><p>将字符串放入常量池，如果串池中有，则不会放入，返回已有的串池中的对象的地址；</p>
</li>
<li><p>如果串池中没有：</p>
<ul>
<li>jdk1.6中，把此<b style='color:blue'>对象复制一份</b>，放入串池，并返回串池中的对象地址</li>
<li>jdk1.7起，把此<b style='color:blue'>对象的引用地址复制一份</b>，放入串池，并返回串池中的引用地址</li>
</ul>
</li>
</ul>
<h2 id="对象详情"><a href="#对象详情" class="headerlink" title="对象详情"></a>对象详情</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><strong>创建对象的方式</strong></p>
<ul>
<li>new</li>
<li>Class的newInstance()</li>
<li>Constructor的newInstance(Xxx)</li>
<li>使用clone()</li>
<li>使用反序列化</li>
<li>第三方库Objenesis</li>
</ul>
<p><strong>创建对象的步骤</strong></p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化</li>
<li>位对象分配内存<ul>
<li>如果内存规整—–指针碰撞</li>
<li>如果内存不规整—–空闲列表分配（JVM需要维护一个列表来记录空闲的内存地址）</li>
</ul>
</li>
<li>处理并发安全问题<ul>
<li>每个线程预先分配一块TLAB</li>
<li>采用CAS配上失败重试保证更新的原子性</li>
</ul>
</li>
<li>初始化分配的空间<ul>
<li>所有属性设置默认值，保证对象实例字段不赋值时可以直接使用</li>
</ul>
</li>
<li>设置对象的对象头</li>
<li>执行init方法经行初始化</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象内部包括三部分：对象头、实例数据、对齐填充</p>
<p><strong>对象头(Header)</strong></p>
<ul>
<li>运行时数据(Mark Work)<ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程的ID</li>
<li>偏向时间戳</li>
<li>如果是数组，还需记录数组长度</li>
</ul>
</li>
<li>指针类型—–指向元数据InstanceKlass，确定该对象所属的类型</li>
</ul>
<p><strong>实例数据(Instance Data)</strong></p>
<ul>
<li>它是真正存储有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的字段）</li>
</ul>
<p><strong>对齐填充(Padding)</strong></p>
<ul>
<li>不是必须的，仅仅起到占位符的作用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8xQeO"><img src="https://z3.ax1x.com/2021/11/08/I8xQeO.jpg" alt="I8xQeO.jpg"></a></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM是通过栈帧上reference访问对象的，主要有两种方式:</p>
<p><strong>方式一：直接指针(HotSpot默认)</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGSxWd"><img src="https://z3.ax1x.com/2021/11/08/IGSxWd.jpg" alt="IGSxWd.jpg" style="zoom:50%;" /></a></p>
<p><strong>方式二：句柄访问</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGSTQ1"><img src="https://z3.ax1x.com/2021/11/08/IGSTQ1.jpg" alt="IGSTQ1.jpg" style="zoom: 50%;" /></a></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>直接内存是在java堆外的、直接指向系统申请的内存区间。</li>
<li>访问直接内存的速度会优于Java堆，出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
<li>由于直接内存在java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小。但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>直接内存大小可以通过MaxDirectMemorySize设置，默认与堆的最大值-Xmx参数一致</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>分配回收成本高</li>
<li>不是JVM内存的回收管理</li>
</ul>
<p><strong>非直接缓冲区</strong>： 读写文件，需要与磁盘交互，需要由用户态切换到内核态。如下图，使用IO需要两份内存存储重复数据，效率低。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGZn4x"><img src="https://z3.ax1x.com/2021/11/08/IGZn4x.png" alt="IGZn4x.png"  /></a></p>
<p><strong>直接缓冲区</strong>：使用NIO时，操作系统划出直接的缓冲区可以被java代码直接访问，只有一份。NIO适合堆大文件的读写操作。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGZg5q"><img src="https://z3.ax1x.com/2021/11/08/IGZg5q.md.png" alt="IGZg5q.md.png"  /></a></p>
<h1 id="执行引擎-Excution-Engine"><a href="#执行引擎-Excution-Engine" class="headerlink" title="执行引擎(Excution Engine)"></a>执行引擎(Excution Engine)</h1><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGyQKK"><img src="https://z3.ax1x.com/2021/11/08/IGyQKK.png" alt="IGyQKK.png"></a></p>
<p>执行引擎是JVM核心的组成部分之一</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，区别是： </p>
<ul>
<li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的</li>
<li><b style='color:red'>虚拟机的执行引擎是由软件自行实现的</b> , 因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</li>
</ul>
<p><strong>执行引擎的作用</strong></p>
<ul>
<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>执行引擎的任务就是<b style='color:red'>将字节码指令解释/编译为对应平台上的本地机器指令</b>, 让Java程序运行起来。换言之，JVM的执行引擎充当了将高级语言翻译成机器语言的译者。</li>
</ul>
<p><strong>工作过程</strong></p>
<ul>
<li>执行引擎执行的字节码指令完全依赖于PC寄存器，每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>方法在执行过程中，执行引擎可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指令定位到目标对象的类型信息。</li>
</ul>
<h2 id="Java代码编译和执行的过程"><a href="#Java代码编译和执行的过程" class="headerlink" title="Java代码编译和执行的过程"></a>Java代码编译和执行的过程</h2><p>大部份的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGokqA"><img src="https://z3.ax1x.com/2021/11/08/IGokqA.jpg" alt="IGokqA.jpg" style="zoom:50%;" /></a></p>
<p><strong>解释器(Interpreter)</strong></p>
<p>当Java虚拟机启动时会根据预定义的规范对<b style='color:red'>字节码采用逐行解释的方式执行</b>,将每条字节码文件中的内容“翻译”成对应平台的本地机器指令执行，启动快，但执行效率低。</p>
<p><strong>JIT编译器(Just In Time Compiler)</strong></p>
<p>虚拟机将源代码直接编译成本地机器平台相关的机器语言，需要一定的执行时间，但编译为本地代码后，执行效率高。</p>
<p><strong>Java是半编译半解释型语言</strong></p>
<p>JDK1.0时代，将Java语言定义为”解释执行”还是比较正确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码时，通常会将解释执行与编译执行二者结合起来</p>
<p><strong>执行引擎基本执行流程</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGogJK"><img src="https://z3.ax1x.com/2021/11/08/IGogJK.jpg" alt="IGogJK.jpg"></a></p>
<p><strong>字节码</strong></p>
<ul>
<li>字节码是一种中间状态的二进制代码，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要是为了实现特定软件的运行与软件环境，与硬件环境无关。</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初中仅仅只是单纯的<b style='color:red'>为了满足Java程序实现跨平台特性</b>,  因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。<a target="_blank" rel="noopener" href="https://imgtu.com/i/IG7uuQ"><img src="https://z3.ax1x.com/2021/11/08/IG7uuQ.jpg" alt="IG7uuQ.jpg" style="zoom: 50%;" /></a></p>
<p>在Java的发展历史里，一共由两套解释执行器，古老的<b style='color:red'>字节码解释器</b>、现在普遍使用的<b style='color:red'>模板解释器</b></p>
<ul>
<li><p>字节码解释器在执行时通过<b style='color:blue'>纯软件代码</b>模拟字节码的执行，效率非常地下</p>
</li>
<li><p>模板解释器将<b style='color:blue'>每一条字节码和一个模板函数相关联</b>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能</p>
<ul>
<li>在HotSpot VM中，解释器主要由Interpreter模板和Code模板构成<ul>
<li>Interpreter模板：实现了解释器的核心功能</li>
<li>Code模板: 用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>解释器在设计和实现上非常简单，出来Java语言外，如Python、Perl、Ruby等也是基于解释器执行的。如今，<b style='color:blue'>基于解释器执行已经被沦落为低效的代名词</b></p>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>现代虚拟机为了提高执行效率，会使用即时编译技术(JIL,Just In Time) 将方法编译成机器码后再执行。</p>
<p>HotSpot MV 采用解释器与即时编译器并存的架构 : </p>
<ul>
<li>当程序启动后,解释器可以马上发挥作用，<b style='color:blue'>省去许多不必要的编译时间</b>，立即执行</li>
<li>随着程序运行时间的推移，编译器逐渐发挥作用，根据热点探测功能，<b style='color:blue'>将有价值的字节码编译为本地机器指令</b>，以换取更高的程序执行效率。</li>
</ul>
<p><strong>热点代码</strong>：一个方法被调用多次方法，或者是一个方法体内部循环次数比较多的循环体。</p>
<p>JIT编译器会将<b style='color:blue'>热点代码</b>直接编译为对应平台的本地机器指令, 由于这种编译方式发生在方法的执行过程中，因此被称之为<b style='color:blue'>栈上替换</b>，或简称为<b style='color:blue'>OSR(On Stack Replacement)编译</b></p>
<p><strong>热点探测功能</strong> ： 判断热点代码</p>
<ul>
<li>目前HotSpot MV 所采用的热点探测方式是<b style='color:blue'>基于计数器的热点探测</b></li>
<li>HotSpot MV为每一个方法都建立2给不同类型的计数器<ul>
<li>方法调用计数器(Invocation Counter) : 统计方法的调用次数</li>
<li>回边计数器(Back Edge Counter): 统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<p><strong>方法调用计数器</strong></p>
<ul>
<li><p>默认阈值在Client模式下是1500次，在Server模式下是10000次，超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>可通过<b style='color:blue'>-XX:CompileThreshold</b>参数来设置</p>
</li>
<li><p>当一个方法被调用时，先检查该方法是否存在被JIT编译过的版本</p>
<ul>
<li>如果存在，则优先使用编译后的本地代码来执行。</li>
<li>如果不存在，将此方的调用计数器值+1，然后判断<b style='color:blue'>方法调用计数器与回边计数器值之和</b>是否超过方法调用计数器的阈值，如果超过阈值，就向即时编译器提交一个该方法的代码编译请求，最后解释执行</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGjtij"><img src="https://z3.ax1x.com/2021/11/08/IGjtij.jpg" alt="IGjtij.jpg" style="zoom: 40%;" /></a></p>
<ul>
<li>热度衰减</li>
</ul>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率。<b style='color:red'>一段时间之内方法调用的次数，当超过一定的时间限度</b>，如果方法调用次数仍然不足它提交给即时编译器，那这个方法的计数器就会被<b style='color:red'>减少一半</b>,这个过程称之为<b style='color:red'>方法调用计数器热度的衰减(Counter Decay)</b>,这段时间称之为<b style='color:red'>半衰周期(Counter Half Life Time)</b></p>
<p>进行热度衰减的动作是在虚拟机经行垃圾收集时顺便进行的。</p>
<p><b style='color:blue'>-XX:UseCounterDecay</b> 参数是关闭/开启热度衰减，默认开启。</p>
<p><b style='color:blue'>-XX:CounterHalfLifeTime</b> 参数设置半衰周期的时间，单位是秒。</p>
<p><strong>回边计数器</strong></p>
<p>统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称之为 “回边”(Back Edge)。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGvcB8"><img src="https://z3.ax1x.com/2021/11/08/IGvcB8.jpg" alt="IGvcB8.jpg" style="zoom:40%;" /></a></p>
<p><strong>HotSpot VM设置程序执行方式</strong></p>
<ul>
<li><b style='color:blue'>-Xint</b> : 完全采用解释器模式执行程序  </li>
<li><b style='color:blue'>-Xcomp </b>: 完全采用即时编译器模式执行程序，如果即时编译出现问题，解释器就会介入执行</li>
<li><b style='color:blue'>-Xmixed</b>: 采用解释器+即时编译器的混合模式共同执行程序  (默认方式)</li>
</ul>
<p><strong>HotSpot VM 中 JIT分类</strong></p>
<p>HotSpot VM内嵌两个JIT编译器，分别为Client Compiler 和 Server Compiler ，一般简称为C1编译器与C2编译器，可使用如下指令指定采用哪种编译器：</p>
<ul>
<li><b style='color:blue'>-clinet</b> : 指定JVM运行在Client模式下，使用C1编译器<ul>
<li>C1编译器对字节码进行<b style='color:red'>简单可靠的优化，耗时短</b>。以达到更快的编译速度。</li>
</ul>
</li>
<li><b style='color:blue'>-server</b>: 指定JVM运行在Server模式下，使用C2编译器<ul>
<li>C2编译器<b style='color:red'>耗时较长的优化，以及激进的优化</b>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<p><strong>C1和C2编译器不同的优化策略</strong></p>
<ul>
<li>C1编译器<ul>
<li>方法内联：将引用的函数代码编译到引用处，这样可以减少栈帧的生成，减少参数传递以及跳转的过程</li>
<li>去虚拟化：对唯一的实习类进行内联</li>
<li>冗余消除：在运行期间把不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2编译器  ： 优化主要是在全局层面，逃逸分析是优化的基础<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于为逃逸的对象分配到栈而不是堆</li>
<li>同步消除：清除同步操作，通常值synchronized</li>
</ul>
</li>
</ul>
<p><strong>分层编译(Tiered Compilation)策略</strong></p>
<ul>
<li>程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，经行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化</li>
<li>在Java7版本后，在-server 模式下会默认开启分层编译策略，有C1与C2相互协同来执行编译任务</li>
</ul>
<h1 id="垃圾回收-Garbage-Collectioin"><a href="#垃圾回收-Garbage-Collectioin" class="headerlink" title="垃圾回收(Garbage Collectioin)"></a>垃圾回收(Garbage Collectioin)</h1><p><strong>垃圾</strong> 是指在<b style='color:red'>运行程序中没有任何指针指向的对象</b>,这个对象就是需要被回收的垃圾</p>
<p>对于高级语言，不断地分配内存空间而不进行回收，内存迟早都会被消耗完。除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。</p>
<p><strong>早期的垃圾回收</strong></p>
<p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员使用new关键字进行内存申请，并使用delete释放该对象所占内存区域。这种方式可以灵活控制内存释放的时间，但是会带来<b style='color:blue'>频繁申请和释放内存的管理负担</b>，容易造成<b style='color:blue'>内存泄漏</b>.</p>
<p><strong>垃圾回收器的作用域</strong>：方法区和堆</p>
<p><strong>从回收次数上看</strong></p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不动Perm区</li>
</ul>
<h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>在GC执行垃圾回收之前，需要先区分处哪些是存活对象，哪些是死亡对象，只有被标记为已死亡的对象，才会被GC执行垃圾回收，释放掉器所占用的内存空间。</p>
<p>当一个对象已经不在别任何的存活对象继续引用时，就可以宣布为已经死亡。</p>
<p>判断对象存活一般有两种方式: <b style='color:red'>引用计数算法（Reference Counting）</b>  和  <b style='color:red'>可达性分析算法</b></p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>对每个对象<b style='color:blue'>保存一个整形的引用计数器属性</b>，用于记录对象被引用的情况</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要引用计数器的值为0 ，就表示对象A不可能在被使用，可进行回收。</li>
</ul>
<p><strong>优点</strong> ：实现简单，垃圾对象便于辨识；判断效率高，回收没有延迟性。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>单独字段存储计算器，增加了<b style='color:blue'>存储空间的开销</b></li>
<li>每次赋值都要更新计数器，伴随着加法和减法操作，增加了<b style='color:blue'>时间开销</b></li>
<li><b style='color:blue'>无法处理循环引用</b>的情况。这是一条致命的缺陷，导致Java垃圾回收器中没有使用这类算法。</li>
</ul>
<p>然而Python语言则支持引用计数器，那么Python是任何解决循环引用？</p>
<ol>
<li>手动解除：在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是python提供的标准库，旨在解决循环引用</li>
</ol>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法不仅实现简单和执行高效，更重要的是可以有效的<b style='color:blue'>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</b>，通常也叫做<b style='color:blue'>追踪性垃圾收集(Tracing Garbage Collection)</b></p>
<p><strong>基本思路</strong></p>
<ul>
<li>以<b style='color:blue'>根对象集合(GC Roots) </b>为起点，按照从上至下的方式<b style='color:blue'>搜索被根对象集合所连接的目标对象是否可达</b></li>
<li>可达性分析后，内存中存活的对象都会被GC Roots 直接或间接连接着，搜索所走过的路径称之为<b style='color:red'>引用链(Reference Chain)</b></li>
<li>如果目标没有别任何引用链相连，则是不可达的，可标记为垃圾对象</li>
</ul>
<p><strong>根对象集合(GC Roots)</strong>   是一组必须活跃的引用，包括以下几类元素:</p>
<ul>
<li>虚拟机栈中引用的对象，如方法中使用的参数、局部变量表</li>
<li>本地方法栈内JNI引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象，如StringTable里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>java虚拟机内部的引用，如基本数据类型对应的Class类型、异常对象、系统类加载器等</li>
</ul>
<p><strong>注意</strong>：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个保证一致性的快照中进行，否则无法保证其准确性。这也是导致GC进行时必须触发”Stop The World”的一个重要原因</p>
<h3 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><ul>
<li>对象终止机制允许开发人员提供<b style='color:blue'>对象被销毁之前定义处理逻辑</b>。</li>
<li>对象被回收前，总会先调用当前对象的<code>finalize()</code>方法，finalize()方法是Object类的方法，允许被重写。</li>
</ul>
<p>永远不要主动调用对象的 <code>finalize()</code> 方法,应该交给垃圾回收机制调用，理由如下:</p>
<ol>
<li>finalize() 可能导致对象复活</li>
<li>finalize() 方法的执行时间是没有保障的，它完全由GC线程决定。</li>
<li>一个糟糕的finalize() 会严重影响GC的性能</li>
</ol>
<p><strong>对象一般处于三种可能的在状态</strong></p>
<ul>
<li>可触及的：从根节点开始，可以达到这个对象</li>
<li>可复活的：对象的引用都被释放，但是对象有可能在finalize() 中复活</li>
<li>不可触及的：不可达且没有重写finalize() ,或对象的finalize() 被调用，并且没有被复活。</li>
</ul>
<p>只有不可触及的对象才会被回收，并且 <b style='color:blue'>finalize()只会被调用一次</b></p>
<h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>当成功区分出垃圾对象后，GC接下来的任务就是执行垃圾回收，释放无用的对象所占用的内存。</p>
<p>目前JVM比较常见的三种垃圾收集算法分别是 <b style='color:red'>标记—清除算法(Mark-Sweep)</b>、<b style='color:red'>复制算法(Copying)</b>、<b style='color:red'>标记—压缩算法(Mark-Compact)</b></p>
<h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>这是一种非常基础和常见的垃圾收集算法。</p>
<p><strong>执行过程</strong></p>
<p>当堆中有效内存被耗尽时，执行STW;<b style='color:blue'>阶段一:</b>标记阶段先标记哪些对象是可达的，<b style='color:blue'>阶段二 :</b>Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IYgxdf"><img src="https://z3.ax1x.com/2021/11/09/IYgxdf.jpg" alt="IYgxdf.jpg" style="zoom: 33%;" /></a></p>
<p><strong>注意: 怎么清除(回收)</strong></p>
<p>这里所谓的清除不是真的置空，而是把需要清理的对象地址保存在空闲列表中。下次有新对象需要加载时，分配相应的大小直接覆盖。</p>
<p><strong>缺点</strong></p>
<ul>
<li>效率不高</li>
<li>进行GC时，需要STW，导致用户体验差</li>
<li>清理了出来的内存是不连续的，容易产生内存碎片，并且需要唯一一个空闲列表</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，然后清除正在使用的内存卡中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IYWCKs"><img src="https://z3.ax1x.com/2021/11/09/IYWCKs.jpg" alt="IYWCKs.jpg" style="zoom:33%;" /></a></p>
<p><strong>优点</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，允许高效</li>
<li>不会出现”碎片”问题</li>
<li>如果系统中的垃圾对象很多，需要复制的存活对象非常少</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要两倍的内存空间</li>
<li>存活对象要移动，所以相应的引用地址也需要改变</li>
</ul>
<p>在新生代，一次通常可以回收70%—90%的内存空间，所以用复制算法堪称完美。</p>
<h4 id="标记—压缩算法"><a href="#标记—压缩算法" class="headerlink" title="标记—压缩算法"></a>标记—压缩算法</h4><p><strong>背景</strong></p>
<p>复制算法的高性能时建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代则相反。因此<b style='color:red'>基于老年代垃圾回收的特性，需要使用其他的算法</b>。</p>
<p>标记-清除算法可以应用在老年代，但是该算法不仅效率低下，而且还会产生内存碎片，所以需要在此基础上进行改进。标记—压缩算法由此诞生</p>
<p><strong>执行过程</strong></p>
<ul>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象。</p>
</li>
<li><p>第二阶段将所有对象压缩到内存的一段，按顺序排放，之后，清理边界外所有的空间</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ItW9X9"><img src="https://z3.ax1x.com/2021/11/09/ItW9X9.jpg" alt="ItW9X9.jpg" style="zoom:33%;" /></a></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行后再进行一次内存碎片整理。因此也可以把它称之为<b style='color:red'>标记—清除—压缩(Mark-Sweep-Compact)算法</b></p>
<p><strong>标记-清除与标记-压缩的区别</strong></p>
<ul>
<li>标记-清除算法是一种<b style='color:blue'>非移动式的回收算法</b>,标记-压缩算法是<b style='color:blue'>移动式的</b></li>
<li>标记的存活对象会被整理，按照内存地址依次排序，这样的话JVM<b style='color:blue'>只需要持有一个内存的起始地址即</b>可，这比维护一个空间列表要少了许多开销</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>消除了标记-清除算法中内存区域分散的缺点</li>
<li>消除了复制算法中，两倍内存的代价</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>效率低</li>
<li>移动对象的同时，如果对象被其他对象引用，还需要调整引用的地址</li>
<li>移动过程需要STW</li>
</ul>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述算法中，再GC过程中，应用软件将处于Stop The World的状态。如果GC时间过长，应用程序将被挂起很久，<b style='color:blue'>将严重影响用户体验或系统的稳定性</b>。为了解决该问题，增量收集(Incremental Collecting)算法诞生了</p>
<p><strong>基本思路</strong></p>
<p>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。</p>
<p><strong>缺点</strong></p>
<p>虽然能减少系统单次达到停顿时间，但是，因为线程切换和上下文切换的消耗，会使得垃圾回收的总体成本上升，<b style='color:blue'>造成系统吞吐量的下降</b></p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，堆空间越大，一次GC所需的时间就越长，STW时间也更长。为了更好的控制GC产生的停顿时间，<b style='color:blue'>将一块大的内存区域分割成多个小块</b>，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间,从而减少一次GC所产生的停顿。</p>
<p>每一个小区间都独立使用，该算法的好处是可以控制停顿的时间。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ItqlYd"><img src="https://z3.ax1x.com/2021/11/09/ItqlYd.png" alt="ItqlYd.png" style="zoom: 67%;" /></a></p>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>通过<code>System.gc()</code> 或 <code>Runtime.getRuntime.gc()</code>的调用，会<b style='color:blue'>显示触发Full GC</b>，对老年代和新生代进行回收。</p>
<p>再一般情况下，垃圾回收是自动进行的，无需手动触发，否则就太过于麻烦了。我们一般在测试代码中才调用System.gc() 方法</p>
<h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><p><strong>内存溢出</strong></p>
<p>没有空闲内存，并且垃圾收集器也无法提供更多内存时，会抛 OutOfMemoryError异常，表示内存溢出</p>
<p>java堆内存不够，原因有二:</p>
<ol>
<li>堆内存设置不够</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集</li>
</ol>
<p>在抛出OutOfMemoryError 之前，通常垃圾收集器都会被触发，其尽所能去清理空间。当然，不是在任何情况下垃圾收集器都会被触发，如出现一个超大对象，超过堆的最大值。</p>
<p><strong>内存泄漏</strong></p>
<p>内存泄漏指 当对象不会再被程序用到了，但是GC有不能回收他们的情况。</p>
<p>尽管内存泄漏不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中可用的内存会逐步蚕食，直至耗尽。</p>
<p>举例:</p>
<ol>
<li><p>单例模式</p>
<p>单例的生命周期和应用程序时一样长的，如果再单例程序中持有对外部对象的引用的话，这个外部对象时不能被回收的</p>
</li>
<li><p>一些提供close的资源未关闭</p>
<p>例如<b style='color:blue'>数据库连接池(dataSource.getConnection())</b>  , <b style='color:blue'>网络连接(socket)</b> ，<b style='color:blue'>io连接</b> 都必须手动close，否则时不能被回收的</p>
</li>
</ol>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p><strong>并发(Concurrent)</strong> ：多个事情在同一时间段内同时发生，在某一时间点只会处理一件事</p>
<p><strong>并行(Parallel)</strong> ：多个事情在同一时间点同时发生，只有在多CPU或多核的情况下才会发生</p>
<p>在垃圾收集器的上下文语境中:</p>
<ul>
<li>串行(Serial)：单线程执行，如果内存不够，暂停程序，执行GC，回收完，再启动程序的线程。</li>
<li>并行(Parallel)：多条垃圾收集线程并行工作，但用户线程仍处于等待状态</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IUp6sJ"><img src="https://z3.ax1x.com/2021/11/10/IUp6sJ.png" alt="IUp6sJ.png" style="zoom: 67%;" /></a></p>
<ul>
<li>并发（Conrurrent）：用户现场与垃圾收集线程同时执行（不一定是并行，可能会交替执行），垃圾回收线程再执行时不会停顿用户的程序<ul>
<li>用户线程继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IU91T1"><img src="https://z3.ax1x.com/2021/11/10/IU91T1.png" alt="IU91T1.png"></a></p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点(Safepoint)</strong></p>
<ul>
<li><p>再程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置被成为”安全点”。</p>
</li>
<li><p>Safe Point 的选择很重要，<b style='color:blue'>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</b>。所以会选择执行时间比较长的指令作为Safe Point ，如方法调用、循环跳转和异常跳转等。</p>
</li>
<li><p>在GC发生时，检查所有线程都跑到安全点的方式：</p>
<ul>
<li>抢先式中断(目前没有虚拟机采用)<ul>
<li>首先中断所有线程，如果还有线程不在安全点，就恢复该线程，让线程跑到安全点。</li>
</ul>
</li>
<li>主动式中断<ul>
<li>设置一个中断标志，各个线程运行到Safe Point时主动轮询这个标志，如果中断标志位真，就将自己进行中断挂起。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>安全区域(Safe Region)</strong></p>
<ul>
<li>当程序“不执行”的时候，如线程处于Sleep状态或Blocked状态，这时线程无法相应JVM的中断请求，”走“到安全点将自己中断挂起。这种情况下，就需要安全区域来解决。</li>
<li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，安全区域可以看做是安全点的扩展。</li>
</ul>
<p><strong>安全区域的实际执行</strong></p>
<ol>
<li>当线程运行到Safe Region时，首先标识已经进入到了Safe Region，如果在这段时间发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查GC是否已完成，如果完成则继续运行，否则线程必须等待直到收到可以离开Safe Region的信号为止</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在JDK1.2之后，java对引用的概念进行了扩展，将引用分为强、软、弱、虚4种，引用强度依次递减。除了强引用外，其他3种引用均可在java.lang.ref包中找到。</p>
<p><strong>强引用（Strong Reference）——不回收</strong></p>
<ul>
<li>默认的引用类型，系统99%以上都是强引用。直接给一个变量赋值操作，该变量就指向对象的一个强引用。</li>
<li>强引用如果是可触及的，垃圾收集器就永远不会收掉强引用的对象，所以强引用是造成java内存泄漏的主要原因之一</li>
<li>强引用可直接访问目标对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个引用都是强引用</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2 = s;</span><br></pre></td></tr></table></figure>
<p><strong>软引用(Soft Reference)——内存不足即回收</strong></p>
<ul>
<li>软引用是用来描述一些还有用的，但非必要的对象。<b style='color:blue'>只被软引用关联着的对象，在系统要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收</b>，如果回收后还是没有足够的内存，才会抛出内存溢出异常。</li>
<li>软引用通常用来实现内存敏感的缓存。如：<b style='color:blue'>高速缓存</b>就用到软引用。如果有空闲内存，就暂时保留缓存，当内存不足时清理掉，这样就保证使用缓存的同时，不会耗尽内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line"><span class="comment">// 创建软引用，指向 obj 指向的对象地址</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>
<p><strong>弱引用(Weak Reference)——发现即回收</strong></p>
<ul>
<li>弱引用来描述那些非必须对象，<b style='color:blue'>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</b>。</li>
<li>由于垃圾收集器的线程优先级很低，因此弱引用也是可以存在比较长的时间，可以用来保存一些可有可无的缓存数据。</li>
<li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过该队列可以跟踪对象的回收情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line"><span class="comment">// 创建弱引用，指向 obj 指向的对象地址</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(obj); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>
<p><strong>虚引用(Phantom Reference)——对象回收跟踪</strong></p>
<ul>
<li>也称”幽灵引用“或”幻影引用“，如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的。随时都会被回收</li>
<li>它不能单独使用，也无法通过虚引用获取。当试图用虚引用的get()方法获取对象时，返回的是null</li>
<li>为一个对象设置虚引用关联的唯一目的在于<b style='color:blue'>跟踪垃圾回收过程</b>。如：在对象被回收时收到一个系统通知</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</li>
<li>虚引用必须和引用队列一起使用，创建虚引用时必须提供一个引用队列作为参数。当GC准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue(); <span class="comment">// 创建引用队列</span></span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj,queue); </span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure>
<h1 id="JVM指令助记符"><a href="#JVM指令助记符" class="headerlink" title="JVM指令助记符"></a>JVM指令助记符</h1><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>
<p>over。。。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老铁们的支持!!!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weChatPay.png" alt="怪狗狗 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/aliPay.jpg" alt="怪狗狗 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"> 垃圾回收</a>
              <a href="/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="tag"> 运行时数据区</a>
              <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" rel="tag"> 类加载子系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/" rel="prev" title="分布式事务-Seata">
      <i class="fa fa-chevron-left"></i> 分布式事务-Seata
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">连接（Linking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88initialization%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">初始化（initialization）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">类加载器的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-Register%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">程序计数器（PC Register）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stack%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟机栈（Java Virtual Machine Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">栈的存储单位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8-Local-Variables"><span class="nav-number">2.2.2.</span> <span class="nav-text">局部变量表(Local Variables)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88-Operand-Stack"><span class="nav-number">2.2.3.</span> <span class="nav-text">操作数栈(Operand Stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-Dynamic-Linking"><span class="nav-number">2.2.4.</span> <span class="nav-text">动态链接(Dynamic Linking)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80-Return-Address"><span class="nav-number">2.2.5.</span> <span class="nav-text">方法返回地址(Return Address)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.6.</span> <span class="nav-text">方法的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%EF%BC%88heap%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">堆（heap）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">设置堆内存大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">2.4.2.</span> <span class="nav-text">新生代与老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.3.</span> <span class="nav-text">对象分配过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-Collection%EF%BC%88GC%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">Garbage Collection（GC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Local-Allocation-Buffer%EF%BC%88TLAB%EF%BC%89"><span class="nav-number">2.4.5.</span> <span class="nav-text">Thread Local Allocation Buffer（TLAB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.6.</span> <span class="nav-text">栈上分配对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">方法区（Method Area）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.5.1.</span> <span class="nav-text">设置方法区大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.2.</span> <span class="nav-text">方法区的内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">2.5.3.</span> <span class="nav-text">方法区的演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">2.5.4.</span> <span class="nav-text">方法区的垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringTable%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.5.</span> <span class="nav-text">StringTable相关概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85"><span class="nav-number">2.6.</span> <span class="nav-text">对象详情</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.6.1.</span> <span class="nav-text">对象的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.6.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.6.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">2.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-Excution-Engine"><span class="nav-number">3.</span> <span class="nav-text">执行引擎(Excution Engine)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">Java代码编译和执行的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">JIT编译器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-Garbage-Collectioin"><span class="nav-number">4.</span> <span class="nav-text">垃圾回收(Garbage Collectioin)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">垃圾回收相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">4.1.1.</span> <span class="nav-text">标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.2.</span> <span class="nav-text">对象的finalization机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-number">4.1.3.</span> <span class="nav-text">清除阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E2%80%94%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">标记—清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E2%80%94%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">标记—压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">增量收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.5.</span> <span class="nav-text">分区算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">4.2.</span> <span class="nav-text">垃圾回收相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc"><span class="nav-number">4.2.1.</span> <span class="nav-text">System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">4.2.2.</span> <span class="nav-text">内存溢出与内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">4.2.3.</span> <span class="nav-text">垃圾回收的并行与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">4.2.4.</span> <span class="nav-text">安全点与安全区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.5.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E6%8C%87%E4%BB%A4%E5%8A%A9%E8%AE%B0%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">JVM指令助记符</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="怪狗狗"
      src="/images/jerry.jpg">
  <p class="site-author-name" itemprop="name">怪狗狗</p>
  <div class="site-description" itemprop="description">跑得又快，长得又帅</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oddDog-git" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oddDog-git" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://1764501567@qq.com/" title="E-Mail → https:&#x2F;&#x2F;1764501567@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://wpa.qq.com/msgrd?v=3&uin=1764501567&site=qq&menu=yes" title="http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;1764501567&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank">加我QQ</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">怪狗狗</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'YVPmrsyUdC4uV9bapDgb8ll6-gzGzoHsz',
      appKey     : 'MUI57EQtRoMQjLvpW68kiNyE',
      placeholder: "快来评论吧！！！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
