<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"odddog-git.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="java虚拟机（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存与垃圾回收">
<meta property="og:url" content="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="hui&#39;s Blog">
<meta property="og:description" content="java虚拟机（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/Ikjg5n.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkjhvT.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IkxN1P.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IAVsN6.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IAKq2V.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/03/IA8mC9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IVzXXq.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZS2UU.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZAup8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZel80.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IZKj7F.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/04/IeEAyD.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I3qt3T.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I3XENR.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8kWMd.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8bZKe.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8cIij.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/I8xQeO.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGSxWd.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGSTQ1.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGZn4x.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/08/IGZg5q.md.png">
<meta property="article:published_time" content="2021-11-03T00:34:52.000Z">
<meta property="article:modified_time" content="2021-11-08T08:54:45.007Z">
<meta property="article:author" content="怪狗狗">
<meta property="article:tag" content="垃圾回收">
<meta property="article:tag" content="运行时数据区">
<meta property="article:tag" content="类加载子系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg">

<link rel="canonical" href="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM内存与垃圾回收 | hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://oddDog-git" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://odddog-git.github.io/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jerry.jpg">
      <meta itemprop="name" content="怪狗狗">
      <meta itemprop="description" content="踏上新征程----go！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hui's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM内存与垃圾回收
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-03 08:34:52" itemprop="dateCreated datePublished" datetime="2021-11-03T08:34:52+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-08 16:54:45" itemprop="dateModified" datetime="2021-11-08T16:54:45+08:00">2021-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/03/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>java虚拟机</strong>（JVM，Java Virtual Machine）是一台执行java字节码的虚拟机计算机，他拥有独立的运行机制。JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。java技术的核心就是java虚拟机,因为所有的java程序都运行在Java虚拟机内部。<a id="more"></a></p>
<p><strong>JVM的位置</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkL3uQ"><img src="https://z3.ax1x.com/2021/11/03/IkL3uQ.jpg" alt="IkL3uQ.jpg" style="zoom:50%;" /></a></p>
<p><strong>JVM机构模型</strong></p>
<p>java编译器输入的指令流基本上是一种基于栈的指令集架构，另一种指令集架构是则是基于寄存器的指令集架构。</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计与实现简单，使用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址方式分配</li>
<li>指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>指令集的架构完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令取完成一项操作</li>
<li>指令集以一地址指令、二地址指令和三地址指令为主</li>
</ul>
</li>
</ul>
<p><strong>举例</strong>  ：执行 2+3 操作</p>
<ul>
<li>基于栈的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2  &#x2F;&#x2F;常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3  &#x2F;&#x2F;常量3入栈</span><br><span class="line">istore_2  </span><br><span class="line">iload_1	  </span><br><span class="line">iload_2</span><br><span class="line">iadd	  &#x2F;&#x2F;常量2、3出栈，执行相加</span><br><span class="line">istore_0  &#x2F;&#x2F;结果5入栈</span><br></pre></td></tr></table></figure>
<ul>
<li>基于寄存器的计算流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2  &#x2F;&#x2F;将eax寄存器的值设为1</span><br><span class="line">add eax,3  &#x2F;&#x2F;使eax寄存器的值加3</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong> : 由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令。</p>
<p><strong>JVM总体流程</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ikjg5n"><img src="https://z3.ax1x.com/2021/11/03/Ikjg5n.png" alt="Ikjg5n.png"></a></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><ul>
<li><p>类加载子系统<strong>只</strong>负责加载Class文件，class文件的文件开头有特定的文件标识。</p>
</li>
<li><p>加载的类信息存放于放入区中，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量与数字常量（这部分信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkjhvT"><img src="https://z3.ax1x.com/2021/11/03/IkjhvT.png" alt="IkjhvT.png"  /></a></p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IkxN1P"><img src="https://z3.ax1x.com/2021/11/03/IkxN1P.jpg" alt="IkxN1P.jpg" style="zoom: 44%;" /></a></p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区中该类的各种数据的访问入口</li>
</ol>
<p><strong>加载 .class文件的方式</strong></p>
<ul>
<li>从本地系统直接加载（常用）</li>
<li>通过网络获取，如 Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，如 动态代理</li>
<li>有其他文件生成，如 JSP应用</li>
<li>从数据库中提取 .class文件</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
<h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><ul>
<li>验证（Verify）<ul>
<li>确保class文件的字节流包含信息的准确性，不危害虚拟机的自身安全</li>
<li>包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
</li>
<li>准备（Prepare）<ul>
<li>为类变量分配内存并且设置该类的默认初始值，即零值</li>
<li>这里不包括final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li>
</ul>
</li>
<li>解析（Resolve）<ul>
<li>将常量池的符号引用转换成直接引用，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>事实上，解析操作往往会伴随着初始化之后再执行</li>
</ul>
</li>
</ul>
<h3 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h3><p>初始化阶段就是执行类构造方法 &lt;clinit&gt;() 的过程</p>
<p><strong>clinit方法</strong> : 不需要定义，javac编译器自动收集类中所有 <strong>类变量的赋值动作</strong> 和 <strong>静态代码块中的语句</strong>  按顺序合并而来</p>
<p>若该类有父类，JVM会保证先执行父类中的 &lt;clinit&gt;() 方法</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器，引导类加载器（BootStrap ClassLoader）、自定义类加载器（User-Defined Classloader）</p>
<p>所有派生于抽象类ClassLoader的加载器都划分为自定义类加载器。再程序中常见的类加载器始终只有3个：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IAVsN6"><img src="https://z3.ax1x.com/2021/11/03/IAVsN6.md.png" alt="IAVsN6.md.png" style="zoom:80%;" /></a></p>
<p><strong>启动类加载器（BootStrap ClassLoader）</strong></p>
<ul>
<li>该类加载是由C/C++编写的，嵌套再JVM内部</li>
<li>它用来加载java的核心库，用于提供JVM自身需要的类</li>
<li>出于安全考虑，只加载包名为java、Javax、sun等开头的类</li>
<li>不继承java.lang.ClassLoader，没有父类加载器</li>
<li>加载扩展类加载器和系统类加载器，并指定为他们的父类加载器</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>从JDK的安装目录的jre/lib/ext 下加载类库，如果自定义插件jar文件放入该目录，也会加载。</li>
</ul>
<p><strong>系统类加载器（AppClassLoader）</strong></p>
<ul>
<li>java语言编写，派生于ClassLoader，父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载的是程序中默认的类加载器，一般java应用中所有的类是由它来完成加载</li>
<li>通过 ClassLoader.getSystemClassLoader() 可获取到该类加载器</li>
</ul>
<p><strong>用户自定义类加载器</strong></p>
<p>在必要时，我们可以自定义类加载器，来定制类的加载方式，需继承抽象类ClassLoader，实现相关方法。</p>
<p>自定义类加载器作用：</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>放置源码泄露</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>JVM对class文件采用 <strong>按需加载</strong> 方式，加载某个类时采用<strong>双亲委派模式</strong> 。</p>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在父类加载器，则继续向上委托，最终到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类的加载任务，就返回成功，否则子类才会尝试自己去加载</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IAKq2V"><img src="https://z3.ax1x.com/2021/11/03/IAKq2V.png" alt="IAKq2V.png" style="zoom: 80%;" /></a></p>
<p><strong>作用</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，放置核心API被篡改<ul>
<li>如自定义java.lang.String类，而引导类加载器会先加载jdk自带的类，进而报错，这样就保证对java核心的源代码的保护，这也是<strong>沙箱安全机制</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong></p>
<p>在JVM中表示两个class对象是否为同一个类存在的两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader实例对象必须相同</li>
</ul>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证JVM的高效稳定运行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IA8mC9"><img src="https://z3.ax1x.com/2021/11/03/IA8mC9.png" alt="IA8mC9.png" style="zoom: 67%;" /></a></p>
<p>线程独享：程序计算器、栈、本地栈</p>
<p>线程共享：堆、对外内存（永久代或元空间、代码缓存）</p>
<h2 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h2><p>PC寄存器用来存储下一条指令的地址，交给执行引擎读取。</p>
<ul>
<li>它是一块很小的内存空间，是线程私有的，生命周期于线程声明周期一致。</li>
<li>如何时间一个线程只有一个方法在执行，PC计计数器会存储当前线程正在执行的java方法的JVM指令地址，如果正在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成</li>
</ul>
<p><strong>PC寄存器存储字节码指定地址作用</strong></p>
<p>CPU需要不停切换各个线程来执行程序，PC寄存器保存当前线程下执行的位置，JVM的字节码解释器需要通过PC</p>
<p>寄存器的值来明确下一条执行什么样的字节码指令。</p>
<h2 id="虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stack）"></a>虚拟机栈（Java Virtual Machine Stack）</h2><p><strong>虚拟机栈出现的背景</strong>：由于跨平台性的设计，java的指令都是根据栈来设计的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要跟多的指令</p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内确保一个个的栈帧(Stack Frame),对应一次次的方法调用。</p>
<p><strong>生命周期</strong> ：和线程的生命周期一致</p>
<p><strong>作用</strong>：主管java程序的运行，它包方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p><strong>JVM直接堆Java栈的操作只有两个</strong></p>
<ul>
<li>每个方法执行，伴随着<b style='color:red'>进栈</b>（入栈、压栈）</li>
<li>执行结束后<b style='color:red'>出栈</b>操作</li>
</ul>
<p><strong>栈可能出现的异常</strong></p>
<ul>
<li>如果栈固定大小：每个虚拟机栈的容量在线程创建时就能确定下来，如果超过虚拟机栈允许的最大容量，就会抛出StackOverFlowError 异常。</li>
<li>如果栈允许动态扩展：在尝试扩展的时候无法申请到足够的内存，或在创建新的线程时没有足够的内存去创建虚拟机栈，就会抛出 OutOfMemoryError 异常。</li>
</ul>
<p><strong>设置栈内存大小</strong>： <b style='color:red'>-Xss</b>  设置线程的最大栈空间</p>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>每个线程都有直接的栈，栈中的数据都是以<b style="color:red">栈帧（Stack Frame）</b>的格式存在,每个栈帧对应一个方法。</p>
<p><strong>运行原理</strong></p>
<ul>
<li>在同一时间点上，只有一个活动栈帧（当前栈帧），执行引擎运行的所有字节码指令只对当前栈帧经行操作</li>
<li>在当前放法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前栈</li>
<li>不同线程中所包含的栈帧不允许存在相互应用的</li>
<li>方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，当前虚拟机栈会执行出栈操作，将当前栈帧丢弃</li>
<li>使用return指令正常的函数返回、抛出异常返回，都会导致栈帧被弹出</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IVzXXq"><img src="https://z3.ax1x.com/2021/11/04/IVzXXq.jpg" alt="IVzXXq.jpg" style="zoom:50%;" /></a></p>
<p><strong>栈帧的内部结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈 (Operand Stack)</li>
<li>动态链接 (Dynamic Linking)</li>
<li>方法返回地址 (Return Address)</li>
<li>一些附加信息，如对程序调试提供支持的信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZS2UU"><img src="https://z3.ax1x.com/2021/11/04/IZS2UU.jpg" alt="IZS2UU.jpg" style="zoom: 44%;" /></a></p>
<h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><ul>
<li>定义为一个数字数组，用于存储方法参数和定义在方法体内的局部变量，这些数据的类型包括各种<b style="color:red">基本数据类型</b>、<b style="color:red">对象引用(reference)</b></li>
<li>局部变量表是建立在线程的栈上，是线程私有的数据，不存在数据安全问题</li>
<li>局部变量表的容量大小实在编译期间确定下来，并保持在Code属性的<b style="color:red">Maximum local variables</b>数据项中</li>
</ul>
<p><strong>Slot</strong></p>
<ul>
<li>局部变量表中最基本的存储单元是Slot（变量槽），从0开始</li>
<li>32位以内的各种基本数据类型占用一个Slot，64位的数据类型占用两个Slot<ul>
<li>byte、short、char、boolean 在存储前被都转化成 int ，占据一个Slot</li>
<li>long 、double 占据两个Slot</li>
</ul>
</li>
<li>方法被调用时，它的方法参数和方法体内定义的局部变量会<b style="color:red">按顺序被复制</b>到每一个Slot中，通过索引即可访问局部变量表中指定的值</li>
<li>如果当前方法是构造方法或非静态方法，会将 <b style="color:red">this</b> 放在index为0的Slot处</li>
</ul>
<p><strong>Slot的重复利用</strong></p>
<p>如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量很有可能会重复利用过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">	<span class="comment">// 该方法中的局部变量表大小为2: index[0]:this 、index[1]:b</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的b会复用a的槽位</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态变量与局部变量的对比</strong></p>
<ul>
<li>静态变量: 在<b style='color:red'>准备阶段</b>会赋予初始值，在<b style='color:red'>初始化</b>阶段，会赋予我们在代码中定义的值。</li>
<li>局部变量：不存在系统初始化过程，所以一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改代码是错误的，没有赋值，不能使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充</strong></p>
<p>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收。</p>
<h3 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h3><ul>
<li>操作数栈，用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</li>
<li>操作数栈是JVM执行引擎的工作区，其最大深度在编译器就定义好了，保存在Code属性的<b style='color:red'>max_stack</b></li>
<li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈与出栈<ul>
<li>如执行 复制、交换、求和等操作</li>
<li><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZAup8"><img src="https://z3.ax1x.com/2021/11/04/IZAup8.png" alt="IZAup8.png" style="zoom:50%;" /></a></li>
</ul>
</li>
<li>栈中的元素可以是任意的java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>如果被调用的方法带有返回值，其返回值将会压入操作数栈中，并根性PC寄存器中下一条需要执行的字节码指令</li>
</ul>
<p>补充：JVM的<b style='color:red'>解释引擎是基于栈的执行引擎</b>，其中的栈指的就是操作数栈</p>
<h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><p>动态链接（指向运行时常量池的方法引用）：每一个栈帧中内部都包含一个指向<b style='color:blue'>运行时常量池</b>中<b style='color:red'>该栈帧所属的方法引用</b>。</p>
<p>在java源文件被编译到字节码文件中时，所有的变量与方法引用都在为符号引用（Symbolic Reference）保存到class文件的常量池里。当调用其他方法时，就是通过常量池中指向的方法的符号引用来表示。所以<b style='color:red'>动态链接的作用就是为了将这些符号引用转换成调用方法的直接引用</b>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZel80"><img src="https://z3.ax1x.com/2021/11/04/IZel80.png" alt="IZel80.png" style="zoom: 80%;" /></a></p>
<h3 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址(Return Address)"></a>方法返回地址(Return Address)</h3><p>存放调用该方法时pc寄存器的值，用于方法的退出。</p>
<p>一个方法结束，有两种方式:</p>
<ul>
<li><p>正常完成出口</p>
<ul>
<li>执行引擎遇到任意一个返回字节码指令(return)时,会有返回值传递给上层的方法调用者。</li>
</ul>
</li>
<li><p>异常完成出口</p>
<ul>
<li>方法执行过程中遇到异常，并且该异常没有在经行处理，返回地址是要通过<b style='color:red'>异常表</b>来确定，并且没有返回值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZKj7F"><img src="https://z3.ax1x.com/2021/11/04/IZKj7F.png" alt="IZKj7F.png"></a></p>
</li>
</ul>
<p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法中局部变量表、操作数栈，将返回值压入操作数栈中，设置PC寄存器值等，让调用者方法继续执行下去。</p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><strong>符号引用转换为方法的直接引用</strong></p>
<ul>
<li><p>静态链接</p>
<p>当字节码文件被装载到JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变，这种情况下方法的符号引用转换成直接引用的过程为静态链接。</p>
</li>
<li><p>动态链接</p>
<p>如果调用的方法在编译期间无法被确定下来，只能够在程序运行期间将调用方法的符号引用转换为直接引用，这种引用转换过程具备动态性，因此被称之为动态链接。</p>
</li>
</ul>
<p><strong>方法的绑定机制</strong>：绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅仅发生一次。</p>
<ul>
<li>早期绑定<ul>
<li>被调用的目标方法在编译器可知，且运行期间保持不变，因此可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>被调用的方法在编译期间无法被确定下来，只能够在运行期间根据实际的类型绑定相关的方法。</li>
</ul>
</li>
</ul>
<p><strong>虚方法与非虚方法</strong></p>
<p>非虚方法: 编译期间就确定了具体的调用版本，静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</p>
<p>其他的方法都称为虚方法</p>
<p><strong>方法调用指令</strong></p>
<ul>
<li>普通调用指令<ul>
<li><b style='color:blue'>invokestatic</b>：调用静态方法, 解析阶段可确定方法版本</li>
<li><b style='color:blue'>invokespecial</b>：调用&lt;init&gt;方法、私有方法、父类方法, 解析阶段可确定方法版本</li>
<li><b style='color:green'>invokevirtual</b>：调用所有的虚方法（final修饰的除外）</li>
<li><b style='color:green'>invokeinterface</b>：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析处需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固定在虚拟机内部，方法的调用执行不可人为的干预，而invokeinterface指令则支持用户确定方法版本。</p>
<p>invokeinterface实在java7中添加的，为了实现【动态类型语言】支持而做的改进。而java7中并没有提供直接生成invokeinterface指令的方法，直到java8的Lambda表达式的出现，才能够直接生成invokeinterface指令。</p>
<p><strong>动态类型语言和静态类型语言</strong></p>
<ul>
<li>两者的区别在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，满足后者就是动态类型语言</li>
<li>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</li>
</ul>
<p><strong>方法重写的本质</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的实际类型，记作 C</li>
<li>如果在类型 C 找到与常量中相对应的方法，则进行访问</li>
<li>如果没找到，按照继承的关系从下往上依次对 C 的各个父类经行访问</li>
<li>如果始终没找到合适的方法，则抛出 java.lang.AbstractMethodError异常，表示该方法是抽象方法，并且没有没实现。</li>
</ol>
<p>在访问方法时，需要进行访问权限校验，如果没通过，会抛出 java.lang.IllegalAccessError 异常</p>
<p><strong>虚方法表(virtual method table)</strong></p>
<ul>
<li><p>如果在每次动态分派的过程中都要重新在类的方法元数据搜索合适的目标，这样就会影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引的方式来代替查找。</p>
</li>
<li><p>每个类都有一个虚方法表，表中存放着各个虚方法的实际路口。</p>
</li>
<li><p>虚方法表在类的加载的链接阶段被创建并初始化。</p>
</li>
</ul>
<h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IeEAyD"><img src="https://z3.ax1x.com/2021/11/04/IeEAyD.jpg" alt="IeEAyD.jpg" style="zoom: 67%;" /></a></p>
<p><strong>本地方法</strong></p>
<p>一个Native Method就是一个Java调用非Java代码的接口。该方法的实现由非Java语言实现，比如C/C++。</p>
<p>本地接口的作用是融合不同的变成语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><strong>现状</strong> ：目前该方法使用的越来越少，除非是与硬件有关的应用。</p>
<p><strong>本地方法栈概述</strong></p>
<ul>
<li>Java的虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li>
<li>本地方法栈也是线程私有的。</li>
<li>允许被实现固定内存大小，或可动态扩展内存大小（与Java虚拟机栈基本相同）</li>
<li>当某个线程调用有关本地方法时，它就进入了一个全新的且不受虚拟机限制的环境，它与虚拟机有同样的权限。</li>
</ul>
<p><strong>补充</strong></p>
<p>不是所有的虚拟机都支持本地方法；在Hotspot JVM中，直接将本地方法和虚拟机栈合二为一。</p>
<h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p><strong>基本概述</strong></p>
<ul>
<li><p>一个JVM实例只存在一个堆内存，是java内存管理的核心区域。</p>
</li>
<li><p>堆可以处于物理不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
</li>
<li><p>几乎所有的对象实例以及数组都再允运行时分配再堆上，栈帧中仅仅保持对象的引用，该引用指向对象或数组再堆中的位置。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，在垃圾收集的时候才可能会被移除，堆是GC执行垃圾回收的重点。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I3qt3T"><img src="https://z3.ax1x.com/2021/11/08/I3qt3T.png" alt="I3qt3T.png" style="zoom: 80%;" /></a></p>
<p><strong>内存细分</strong></p>
<ul>
<li>Java 7及之前：新生代+老年代+永久代(方法区)<ul>
<li>方法区在堆中</li>
</ul>
</li>
<li>Java8及之后：新生代+老年代+元空间(方法区)<ul>
<li>方法区使用本地内存</li>
</ul>
</li>
</ul>
<h3 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h3><p>堆的大小在JVM启动时就已经设定好了。可通过“-Xmx” 和 “-Xms” 来进行设置</p>
<ul>
<li>-Xms ：表示堆区的起始内存，等价于 -XX:InitialHeapSize，默认 物理电脑内存大小/64</li>
<li>-Xmx :  表示堆区的最大内存，等价于 -XX:MaxHeapSize,  默认 物理电脑内存大小/4</li>
</ul>
<p>一旦堆区的内存大小超过 ”-Xmx“ ,就会抛出 OutOfMemoryError 异常。</p>
<p>通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能。</p>
<h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>堆区可划分为年轻代(YoungGen) 和 老年代(OldGen) ，其中年轻代又可以划分为 Eden空间、Survivor0空间和Surviver1空间（有时也叫做from区、to区）</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I3XENR"><img src="https://z3.ax1x.com/2021/11/08/I3XENR.jpg" alt="I3XENR.jpg" style="zoom: 50%;" /></a></p>
<p><strong>-XX:NewRation</strong>    </p>
<ul>
<li>配置新生代与老年代在堆中的占比</li>
<li>默认 -XX:NewRatio=2 ，新生代占1，老年代占2</li>
</ul>
<p><strong>-XX:SurvivorRatio</strong></p>
<ul>
<li>配置Eden空间和S0与S1空间占比</li>
<li>默认-XX:SurvivorRatio=8，Eden占8，Survivor0占1，Survivor1占1</li>
</ul>
<p><strong>-Xmn</strong></p>
<ul>
<li>设置新生代最大内存大小</li>
</ul>
<p>几乎所有的java对象都是在Eden区被new出来的，而java对象的销毁基本是在新生代进行的。</p>
<p>IBM公司的专门研究表明，新生代 80% 的对象都是”朝夕生死“的。</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>对象分配内存是一件非常严谨与复杂的任务，需要考虑内存如何分配、在哪里分配、内存碎片等问题。</p>
<p><strong>步骤</strong></p>
<ol>
<li>new的对象先放伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序有需要创建对象，GC将对伊甸园区进行垃圾回收(Minor GC) , 将伊甸园区中不再被其他对象所引用的对象进行销毁，再加载的对象放到伊甸园区</li>
<li>然后将伊甸园区的剩余对象移动到幸存者0区，幸存的对象会添加年龄 1</li>
<li>如果再次触发Minor GC，会对伊甸园区和幸存者0区一起GC，把幸存的对象放入幸存者1区，年龄 +1</li>
<li>如果再次Minor GC，会重新放回幸存者0区，接着再是幸存者1区，不断循环</li>
<li>如果对象的年龄为15，就会将该对象放入老年区<ul>
<li>可以设置参数  -XX:MaxTenuringThreshold=15  经行设置</li>
</ul>
</li>
<li>老年去相对清闲，当老年去内存不足时，会触发 Major GC，对老年区经行内存清理</li>
<li>如果老年区执行了 Major GC 后发现依然无法进行对象的保持，就会报 OOM 异常<ul>
<li>java.lang.OutOfmemoryError: Java heap space </li>
</ul>
</li>
</ol>
<p><strong>对不同年龄的对象分配原则</strong></p>
<ul>
<li>优先分配到Eden </li>
<li>大对象(超出Eden最大值)直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中的相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中设置的年龄</li>
</ul>
</li>
</ul>
<p><strong>分代思想</strong></p>
<p>经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象。</p>
<p>如果不分代程序也是可以运行的，所有的对象就在一块。分代的唯一理由就是优化GC新能。</p>
<h3 id="Garbage-Collection（GC）"><a href="#Garbage-Collection（GC）" class="headerlink" title="Garbage Collection（GC）"></a>Garbage Collection（GC）</h3><p>针对HotSpot VM的实现，GC按照区域又分为两大类型：</p>
<p><strong>部分搜集（Partial GC）</strong></p>
<ul>
<li>新生代收集（Minor GC / Young GC）: 只是新生代的垃圾收集</li>
<li>老年代收集（Mojor GC / Old Gc）: 只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC 会有该行为</li>
</ul>
</li>
<li>混合收集（Mixed GC）: 收集整个新生代与部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有该行为</li>
</ul>
</li>
</ul>
<p><strong>整堆收集（Full GC）</strong></p>
<ul>
<li>收集整个java堆和方法区的垃圾收集</li>
</ul>
<p>（提示：有关GC详情，在后面会讲解！）</p>
<h3 id="Thread-Local-Allocation-Buffer（TLAB）"><a href="#Thread-Local-Allocation-Buffer（TLAB）" class="headerlink" title="Thread Local Allocation Buffer（TLAB）"></a>Thread Local Allocation Buffer（TLAB）</h3><p><strong>问题</strong>：堆区是线程共享区域，任何线程都可以访问堆中的共享数据，而对象实例的创建很频繁，所以在并发环境下会不安全。为了避免操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>Eden区为每个线程分配了一个私有的缓存区域（TLAB），使用TLAB可以避免一系列非线程安全问题，同时还能提升内存分配的吞吐量，我们可以将这种分配方式称之为 <b style='color:red'>快速分配策略</b></p>
<p>OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><strong>分配过程</strong></p>
<ul>
<li>JVM将TLAB作为内存分配的首选</li>
<li>一旦对象在TLAB空间分配内存失败，JVM会尝试通过<b style='color:red'>加锁机制</b>确保数据操作的原则性，接着在Eden区分配内存</li>
<li>-XX:UseTLAB , 是否开启TLAB空间</li>
<li>-XX:TLABWasteTargetPercent , 设置TLAB所占用Eden空间的百分比大小，默认 1%</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8kWMd"><img src="https://z3.ax1x.com/2021/11/08/I8kWMd.jpg" alt="I8kWMd.jpg" style="zoom: 50%;" /></a></p>
<h3 id="栈上分配对象"><a href="#栈上分配对象" class="headerlink" title="栈上分配对象"></a>栈上分配对象</h3><p>JVM中，对象是在java堆中分配内存是一个普遍常识。但是有一种特殊情况，那就是<b style='color:red'>如果经过逃逸分析(Escape Analysis) 后发现，应该对象并没有逃逸出方法的话，那就有可能被优化成栈上分配。</b>这样就无需在堆上分配内存，也无需经行GC了，这也是最常见的堆外存储技术。</p>
<p><strong>逃逸分析</strong></p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>如果被外部方法所引用，则认为发生逃逸</li>
</ul>
<p>在JDK 6u23版本后，默认开启逃逸分析</p>
<ul>
<li>-XX:+DoEscapeAnalysis ,显示开启逃逸分析</li>
<li>-XX:+PrintEscapeAnalysis，查看逃逸分析的筛选结果</li>
<li>-server，启动Server模式，在该模式下才可以开启逃逸分析</li>
</ul>
<p><strong>同步省略</strong></p>
<p>JIT编译器可以借助逃逸分析来判断<b style='color:red'>同步块所使用的锁对象是否能够被一个线程访问而没有发布到其他线程。</b>如果没有，JIT编译器在编译这个同步块时会取消对这部分代码的同步。取消同步的过程就叫同步省略，也叫<b style='color:red'>锁消除</b></p>
<p>如以下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        System.out.Println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对obj进行加锁，但obj不会被其他线程访问，所以在JIT编译阶段就会被优化掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="comment">// 取消了锁</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.Println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标量替换</strong></p>
<p><b style='color:red'>标量(Scalar) </b>指一个无法分解成更小的数据的数据。如 java中的基本数据类型</p>
<p><b style='color:red'>聚合量(Aggregate) </b> 可以分解的数据。如java中的对象，可以分成其他聚合量和标量</p>
<p>JIT阶段，如果进过逃逸分析，发现一个对象不会被外界访问，就会进行JIT优化，把该对象拆解成若干个其中包含的若干个成员变量来代替，该过程就是<b style='color:red'>标量替换 </b></p>
<p>-XX:+EliminateAllocations，开启标量替换（默认开启）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123; <span class="comment">// 构造方法省略</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(p.x);</span><br><span class="line">    System.out.println(p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，标量替换后，会变成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对象被替换成两个基本数据类型，这样可以不用创建对象，减少堆内存的占用。</p>
<p><strong>逃逸分析并不成熟</strong></p>
<ul>
<li>有关逃逸分析的论文在1999年就已经发表了，直到JDK1.6才有实现，并且到如今也并不是十分成熟</li>
<li>根本原因在于逃逸分析、标量替换、栈上分配、消除锁也是需要性能消耗的。如果逃逸分析后，所有的对象都逃逸了，那么逃逸分析的过程就白白浪费了。</li>
</ul>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><ul>
<li><p>方法区也java堆一样，是各个线程共享的内存区域。</p>
</li>
<li><p>在JVM启动时就会创建，实际的物理内存空间也是不连续的，可以固定大小或可扩展</p>
</li>
<li><p>方法区决定了系统可以保持多少个类，如果类太多，导致方法区溢出，会抛出异常:</p>
<ul>
<li>java.lang.OutOfmemoryError：Metaspace/PermGen space</li>
</ul>
</li>
</ul>
<p>jdk7及以前，习惯把方法区成为永久代。jdk8开始，使用元空间代替永久代，完全废弃了永久代的概念。</p>
<p>永久代和元空间的最大区别在于: 元空间不在虚拟机设置的内存中，而是使用本地内存。</p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8bZKe"><img src="https://z3.ax1x.com/2021/11/08/I8bZKe.png" alt="I8bZKe.png"></a></p>
<h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><p><strong>jdk7及以前</strong></p>
<ul>
<li>-XX:PermSize，设置永久代初始分配空间，默认 20.75M</li>
<li>-XX:MaxPermSize,设置永久最大可分配空间，32位机器默认64M，64位机器默认82M。</li>
</ul>
<p><strong>jdk8及以后</strong></p>
<ul>
<li>默认值依赖于平台，windows下，-XX:MetaspaceSize=21M，-XX:MaxMetaspaceSize=-1,表示没有限制</li>
<li>MetaspaceSize是元空间的初始大小，就是初始的高水位线，一旦触及这水位线，就会出发Full GC并卸载没有用的类，然后这个高水位线会被重置。新的高水位线的值取决于GC后释放了多少元空间。<ul>
<li>如果释放的空间不足，在不超过MaxMetaspaceSize时，会适当提高</li>
<li>如果释放空间过多，会适当降低该值</li>
</ul>
</li>
<li>初始的高水位线设置过低，就会多出发高水位线的调整，进而出发Full GC。所以建议将 MetaspaceSize 设置位一个相对较高的值。</li>
</ul>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8cIij"><img src="https://z3.ax1x.com/2021/11/08/I8cIij.jpg" alt="I8cIij.jpg"  /></a></p>
<p><strong>类型信息</strong></p>
<p>JVM必须存储类型(class、interface、enum、annotation)的以下信息:</p>
<ul>
<li>该类型的完整有效名</li>
<li>该类型的直接父类完整有效名（interface和Object没有父类）</li>
<li>该类型的修饰符</li>
<li>该类型的直接接口的一个有序列表</li>
</ul>
<p><strong>域(Field)信息</strong></p>
<ul>
<li><p>JVM必须存储类型的域(字段)相关信息: 域名称、域类型、域修饰符</p>
</li>
<li><p>域的声明顺序也会保存下来</p>
</li>
</ul>
<p><strong>方法信息</strong> </p>
<p>JVM必须保存所有方法的以下信息,同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称、方法的返回类型、方法参数的数量和类型、方法的修饰符、方法的字节码、异常表</li>
</ul>
<p><strong>运行时常量池(Runtime Constant Pool)</strong></p>
<ul>
<li>常量池表(Constant Pool Table) 是Class文件的一部分，<b style='color:red'>用于存放编译期生成的各种字面量与符号引用</b>，<b style='color:green'>这部分内容将在类加载后存放到方法区的运行时常量池中</b></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>此时不再是常量池中的符号引用了，这里换位真实地址，所以具备动态性</li>
</ul>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><p><strong>声明</strong>：只有Hotspot才有永久代的概念</p>
<p><strong>变化</strong></p>
<ul>
<li>jdk1.6及以前 : 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 : 有永久代，但已经逐步”去永久代“,字符串常量、静态变量移动到堆中</li>
<li>jdk1.8及以后 : 无永久代，类型保存在本地的元空间，但字符串常量池、静态变量依旧在堆中</li>
</ul>
<p><strong>永久代为什么要被元空间所替换</strong></p>
<ol>
<li>永久代设置空间大小是很难确定的，如果动态加载的类过多，很容易抛出OOM异常。而元空间使用的是本地内存，受本地内存的限制。</li>
<li>对永久代进行调优的很困难的。</li>
</ol>
<p><strong>StringTalbe为什么要调整</strong></p>
<p>因为永久代的回收效率很低，在Full GC的时候才会触发。而Full GC是在老年代、永久代内存不足时才会触发。</p>
<p>导致StringTable的回收效率不高。放到堆里，能够及时回收内存。</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>《Java虚拟机规范》对方法区的约束时非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集，如JDK11时期的ZGC就不支持类卸载。</p>
<p>一般来所方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实时有必要的。</p>
<p><strong>方法区垃圾收集主要回收两部分内容:</strong></p>
<ul>
<li><p>常量池中废弃的常量（比较容易实现，与堆中的回收的对象类似）</p>
<ul>
<li>字面量</li>
<li>符号引用</li>
</ul>
</li>
<li><p>不再使用的类型</p>
<p>需要满足以下三个条件：</p>
<ul>
<li>该类的所有实例已被回收，包括其任何派生子类</li>
<li>该类的类加载器已被回收，该条件除非是经过精心设计的可替换类加载的场景，如OSGI、JSP的重复加载等，否则很难达成</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ul>
<p>满足上述的三个条件，也仅仅是”被允许“回收，而不是和对象一样，没有引用了就必然会回收。</p>
</li>
</ul>
<p>再大量使用反射、动态代理、GCLib等字节码框架的场景，通常需要JVM具备类卸载能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="对象详情"><a href="#对象详情" class="headerlink" title="对象详情"></a>对象详情</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><strong>创建对象的方式</strong></p>
<ul>
<li>new</li>
<li>Class的newInstance()</li>
<li>Constructor的newInstance(Xxx)</li>
<li>使用clone()</li>
<li>使用反序列化</li>
<li>第三方库Objenesis</li>
</ul>
<p><strong>创建对象的步骤</strong></p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化</li>
<li>位对象分配内存<ul>
<li>如果内存规整—–指针碰撞</li>
<li>如果内存不规整—–空闲列表分配（JVM需要维护一个列表来记录空闲的内存地址）</li>
</ul>
</li>
<li>处理并发安全问题<ul>
<li>每个线程预先分配一块TLAB</li>
<li>采用CAS配上失败重试保证更新的原子性</li>
</ul>
</li>
<li>初始化分配的空间<ul>
<li>所有属性设置默认值，保证对象实例字段不赋值时可以直接使用</li>
</ul>
</li>
<li>设置对象的对象头</li>
<li>执行init方法经行初始化</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象内部包括三部分：对象头、实例数据、对其填充</p>
<p><strong>对象头(Header)</strong></p>
<ul>
<li>运行时数据(Mark Work)<ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程的ID</li>
<li>偏向时间戳</li>
<li>如果是数组，还需记录数组长度</li>
</ul>
</li>
<li>指针类型—–指向元数据InstanceKlass，确定该对象所属的类型</li>
</ul>
<p><strong>实例数据(Instance Data)</strong></p>
<ul>
<li>它是真正存储有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的字段）</li>
</ul>
<p><strong>对其填充(Padding)</strong></p>
<ul>
<li>不是必须的，仅仅起到占位符的作用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I8xQeO"><img src="https://z3.ax1x.com/2021/11/08/I8xQeO.jpg" alt="I8xQeO.jpg"></a></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM是通过栈帧上reference访问对象的，主要有两种方式:</p>
<p><strong>方式一：直接指针(HotSpot默认)</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGSxWd"><img src="https://z3.ax1x.com/2021/11/08/IGSxWd.jpg" alt="IGSxWd.jpg" style="zoom:50%;" /></a></p>
<p><strong>方式二：句柄访问</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGSTQ1"><img src="https://z3.ax1x.com/2021/11/08/IGSTQ1.jpg" alt="IGSTQ1.jpg" style="zoom: 50%;" /></a></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>直接内存是在java堆外的、直接指向系统申请的内存区间。</li>
<li>访问直接内存的速度会优于Java堆，出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
<li>由于直接内存在java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小。但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>直接内存大小可以通过MaxDirectMemorySize设置，默认与堆的最大值-Xmx参数一致</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>分配回收成本高</li>
<li>不是JVM内存的回收管理</li>
</ul>
<p><strong>非直接缓冲区</strong>： 读写文件，需要与磁盘交互，需要由用户态切换到内核态。如下图，使用IO需要两份内存存储重复数据，效率低。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGZn4x"><img src="https://z3.ax1x.com/2021/11/08/IGZn4x.png" alt="IGZn4x.png"  /></a></p>
<p><strong>直接缓冲区</strong>：使用NIO时，操作系统划出直接的缓冲区可以被java代码直接访问，只有一份。NIO适合堆大文件的读写操作。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IGZg5q"><img src="https://z3.ax1x.com/2021/11/08/IGZg5q.md.png" alt="IGZg5q.md.png"  /></a></p>
<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><p>续。。。</p>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1>
    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老铁们的支持!!!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weChatPay.png" alt="怪狗狗 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/aliPay.jpg" alt="怪狗狗 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"> 垃圾回收</a>
              <a href="/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="tag"> 运行时数据区</a>
              <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" rel="tag"> 类加载子系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/" rel="prev" title="分布式事务-Seata">
      <i class="fa fa-chevron-left"></i> 分布式事务-Seata
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">连接（Linking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88initialization%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">初始化（initialization）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">类加载器的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-Register%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">程序计数器（PC Register）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stack%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟机栈（Java Virtual Machine Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">栈的存储单位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8-Local-Variables"><span class="nav-number">2.2.2.</span> <span class="nav-text">局部变量表(Local Variables)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88-Operand-Stack"><span class="nav-number">2.2.3.</span> <span class="nav-text">操作数栈(Operand Stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-Dynamic-Linking"><span class="nav-number">2.2.4.</span> <span class="nav-text">动态链接(Dynamic Linking)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80-Return-Address"><span class="nav-number">2.2.5.</span> <span class="nav-text">方法返回地址(Return Address)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.6.</span> <span class="nav-text">方法的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%EF%BC%88heap%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">堆（heap）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">设置堆内存大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">2.4.2.</span> <span class="nav-text">新生代与老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.3.</span> <span class="nav-text">对象分配过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-Collection%EF%BC%88GC%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">Garbage Collection（GC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Local-Allocation-Buffer%EF%BC%88TLAB%EF%BC%89"><span class="nav-number">2.4.5.</span> <span class="nav-text">Thread Local Allocation Buffer（TLAB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.6.</span> <span class="nav-text">栈上分配对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">方法区（Method Area）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.5.1.</span> <span class="nav-text">设置方法区大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.2.</span> <span class="nav-text">方法区的内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">2.5.3.</span> <span class="nav-text">方法区的演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">2.5.4.</span> <span class="nav-text">方法区的垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85"><span class="nav-number">2.6.</span> <span class="nav-text">对象详情</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.6.1.</span> <span class="nav-text">对象的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.6.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.6.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">2.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">3.</span> <span class="nav-text">执行引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#StringTable"><span class="nav-number">4.</span> <span class="nav-text">StringTable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">5.</span> <span class="nav-text">垃圾回收</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="怪狗狗"
      src="/images/jerry.jpg">
  <p class="site-author-name" itemprop="name">怪狗狗</p>
  <div class="site-description" itemprop="description">踏上新征程----go！！！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oddDog-git" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oddDog-git" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://1764501567@qq.com/" title="E-Mail → https:&#x2F;&#x2F;1764501567@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://wpa.qq.com/msgrd?v=3&uin=1764501567&site=qq&menu=yes" title="http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;1764501567&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank">加我QQ</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">怪狗狗</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'YVPmrsyUdC4uV9bapDgb8ll6-gzGzoHsz',
      appKey     : 'MUI57EQtRoMQjLvpW68kiNyE',
      placeholder: "快来评论吧！！！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
